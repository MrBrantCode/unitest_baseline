{
  "task_id": "taco_1720",
  "entry_point": "minimum_moves_to_redistribute_problems",
  "mutant_count": 302,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "n = k1 + k2 + k3",
      "mutated_line": "n = k1 + k2 - k3",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 - k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "n = k1 + k2 + k3",
      "mutated_line": "n = (k1 + k2) * k3",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = (k1 + k2) * k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "B = [0] * n",
      "mutated_line": "B = [0] / n",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] / n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "B = [0] * n",
      "mutated_line": "B = [0] + n",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] + n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "B = [0] * n",
      "mutated_line": "B = [0] ** n",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] ** n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "n = k1 + k2 + k3",
      "mutated_line": "n = k1 - k2 + k3",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 - k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "n = k1 + k2 + k3",
      "mutated_line": "n = k1 * k2 + k3",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 * k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "B[i - 1] = 1",
      "mutated_line": "B[i - 1] = 2",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 2\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "B[i - 1] = 1",
      "mutated_line": "B[i - 1] = 0",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 0\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "B[i - 1] = 1",
      "mutated_line": "B[i - 1] = 0",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 0\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "B[i - 1] = 1",
      "mutated_line": "B[i - 1] = -1",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = -1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "B[i - 1] = 2",
      "mutated_line": "B[i - 1] = 3",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 3\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "B[i - 1] = 2",
      "mutated_line": "B[i - 1] = 1",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 1\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "B[i - 1] = 2",
      "mutated_line": "B[i - 1] = 0",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 0\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "B[i - 1] = 2",
      "mutated_line": "B[i - 1] = 1",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 1\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "B[i - 1] = 2",
      "mutated_line": "B[i - 1] = -2",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = -2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "B[i - 1] = 3",
      "mutated_line": "B[i - 1] = 4",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 4\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "B[i - 1] = 3",
      "mutated_line": "B[i - 1] = 2",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 2\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "B[i - 1] = 3",
      "mutated_line": "B[i - 1] = 0",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 0\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "B[i - 1] = 3",
      "mutated_line": "B[i - 1] = 1",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 1\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "B[i - 1] = 3",
      "mutated_line": "B[i - 1] = -3",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = -3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "inf = int(2 * 100000.0 + 3)",
      "mutated_line": "inf = int(2 * 100000.0 - 3)",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 - 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "inf = int(2 * 100000.0 + 3)",
      "mutated_line": "inf = int(2 * 100000.0 * 3)",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 * 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(3):",
      "mutated_line": "for i in range(4):",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(4):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(3):",
      "mutated_line": "for i in range(2):",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(2):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(3):",
      "mutated_line": "for i in range(0):",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(0):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(3):",
      "mutated_line": "for i in range(1):",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(1):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(3):",
      "mutated_line": "for i in range(-3):",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(-3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "stateStorage[n % 2][i] = 0",
      "mutated_line": "stateStorage[n % 2][i] = 1",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 1\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "stateStorage[n % 2][i] = 0",
      "mutated_line": "stateStorage[n % 2][i] = -1",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = -1\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "stateStorage[n % 2][i] = 0",
      "mutated_line": "stateStorage[n % 2][i] = 1",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 1\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "B = [0] * n",
      "mutated_line": "B = [1] * n",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [1] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "B = [0] * n",
      "mutated_line": "B = [-1] * n",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [-1] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "B = [0] * n",
      "mutated_line": "B = [1] * n",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [1] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "B[i - 1] = 1",
      "mutated_line": "B[i + 1] = 1",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i + 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "B[i - 1] = 1",
      "mutated_line": "B[i * 1] = 1",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i * 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "B[i - 1] = 2",
      "mutated_line": "B[i + 1] = 2",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i + 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "B[i - 1] = 2",
      "mutated_line": "B[i * 1] = 2",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i * 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "B[i - 1] = 3",
      "mutated_line": "B[i + 1] = 3",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i + 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "B[i - 1] = 3",
      "mutated_line": "B[i * 1] = 3",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i * 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "inf = int(2 * 100000.0 + 3)",
      "mutated_line": "inf = int(2 / 100000.0 + 3)",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 / 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "inf = int(2 * 100000.0 + 3)",
      "mutated_line": "inf = int(2 + 100000.0 + 3)",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 + 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "inf = int(2 * 100000.0 + 3)",
      "mutated_line": "inf = int(2 ** 100000.0 + 3)",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 ** 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "inf = int(2 * 100000.0 + 3)",
      "mutated_line": "inf = int(2 * 100000.0 + 4)",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 4)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "inf = int(2 * 100000.0 + 3)",
      "mutated_line": "inf = int(2 * 100000.0 + 2)",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 2)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "inf = int(2 * 100000.0 + 3)",
      "mutated_line": "inf = int(2 * 100000.0 + 0)",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 0)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "inf = int(2 * 100000.0 + 3)",
      "mutated_line": "inf = int(2 * 100000.0 + 1)",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 1)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "inf = int(2 * 100000.0 + 3)",
      "mutated_line": "inf = int(2 * 100000.0 + -3)",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + -3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n + 1, -1, -1):",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n + 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n * 1, -1, -1):",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n * 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "UOI",
      "lineno": 19,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 1, +1, -1):",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, +1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "UOI",
      "lineno": 19,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 1, -1, +1):",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, +1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "mutated_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) - min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) - min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "mutated_line": "stateStorage[i % 2][0] = (1 - int(B[i] == 1)) * min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = (1 - int(B[i] == 1)) * min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])",
      "mutated_line": "stateStorage[i % 2][1] = 1 - int(B[i] == 2) - min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) - min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])",
      "mutated_line": "stateStorage[i % 2][1] = (1 - int(B[i] == 2)) * min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = (1 - int(B[i] == 2)) * min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]",
      "mutated_line": "stateStorage[i % 2][2] = 1 - int(B[i] == 3) - stateStorage[(i + 1) % 2][2]",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) - stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]",
      "mutated_line": "stateStorage[i % 2][2] = (1 - int(B[i] == 3)) * stateStorage[(i + 1) % 2][2]",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = (1 - int(B[i] == 3)) * stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "B[i - 1] = 1",
      "mutated_line": "B[i - 2] = 1",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 2] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "B[i - 1] = 1",
      "mutated_line": "B[i - 0] = 1",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 0] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "B[i - 1] = 1",
      "mutated_line": "B[i - 0] = 1",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 0] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "B[i - 1] = 1",
      "mutated_line": "B[i - -1] = 1",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - -1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "B[i - 1] = 2",
      "mutated_line": "B[i - 2] = 2",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 2] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "B[i - 1] = 2",
      "mutated_line": "B[i - 0] = 2",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 0] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "B[i - 1] = 2",
      "mutated_line": "B[i - 0] = 2",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 0] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "B[i - 1] = 2",
      "mutated_line": "B[i - -1] = 2",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - -1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "B[i - 1] = 3",
      "mutated_line": "B[i - 2] = 3",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 2] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "B[i - 1] = 3",
      "mutated_line": "B[i - 0] = 3",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 0] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "B[i - 1] = 3",
      "mutated_line": "B[i - 0] = 3",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 0] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "B[i - 1] = 3",
      "mutated_line": "B[i - -1] = 3",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - -1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "inf = int(2 * 100000.0 + 3)",
      "mutated_line": "inf = int(3 * 100000.0 + 3)",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(3 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "inf = int(2 * 100000.0 + 3)",
      "mutated_line": "inf = int(1 * 100000.0 + 3)",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(1 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "inf = int(2 * 100000.0 + 3)",
      "mutated_line": "inf = int(0 * 100000.0 + 3)",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(0 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "inf = int(2 * 100000.0 + 3)",
      "mutated_line": "inf = int(1 * 100000.0 + 3)",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(1 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "inf = int(2 * 100000.0 + 3)",
      "mutated_line": "inf = int(-2 * 100000.0 + 3)",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(-2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "inf = int(2 * 100000.0 + 3)",
      "mutated_line": "inf = int(2 * 100001.0 + 3)",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100001.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "inf = int(2 * 100000.0 + 3)",
      "mutated_line": "inf = int(2 * 99999.0 + 3)",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 99999.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "inf = int(2 * 100000.0 + 3)",
      "mutated_line": "inf = int(2 * 0 + 3)",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "inf = int(2 * 100000.0 + 3)",
      "mutated_line": "inf = int(2 * 1 + 3)",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 1 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "inf = int(2 * 100000.0 + 3)",
      "mutated_line": "inf = int(2 * -100000.0 + 3)",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * -100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "stateStorage = [[inf for _ in range(3)] for _ in range(2)]",
      "mutated_line": "stateStorage = [[inf for _ in range(3)] for _ in range(3)]",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(3)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "stateStorage = [[inf for _ in range(3)] for _ in range(2)]",
      "mutated_line": "stateStorage = [[inf for _ in range(3)] for _ in range(1)]",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(1)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "stateStorage = [[inf for _ in range(3)] for _ in range(2)]",
      "mutated_line": "stateStorage = [[inf for _ in range(3)] for _ in range(0)]",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(0)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "stateStorage = [[inf for _ in range(3)] for _ in range(2)]",
      "mutated_line": "stateStorage = [[inf for _ in range(3)] for _ in range(1)]",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(1)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "stateStorage = [[inf for _ in range(3)] for _ in range(2)]",
      "mutated_line": "stateStorage = [[inf for _ in range(3)] for _ in range(-2)]",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(-2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "stateStorage[n % 2][i] = 0",
      "mutated_line": "stateStorage[n * 2][i] = 0",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n * 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "stateStorage[n % 2][i] = 0",
      "mutated_line": "stateStorage[n + 2][i] = 0",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n + 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 2, -1, -1):",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 2, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 0, -1, -1):",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 0, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 0, -1, -1):",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 0, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - -1, -1, -1):",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - -1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 1, -2, -1):",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -2, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 1, -0, -1):",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -0, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 1, -0, -1):",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -0, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 1, --1, -1):",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, --1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 1, -1, -2):",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -2):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 1, -1, -0):",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -0):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 1, -1, -0):",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -0):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 1, -1, --1):",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, --1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "mutated_line": "stateStorage[i % 2][1] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][1] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "mutated_line": "stateStorage[i % 2][-1] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][-1] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "mutated_line": "stateStorage[i % 2][1] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][1] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "mutated_line": "stateStorage[i % 2][0] = 1 + int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 + int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "mutated_line": "stateStorage[i % 2][0] = 1 * int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 * int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])",
      "mutated_line": "stateStorage[i % 2][2] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])",
      "mutated_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][0] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])",
      "mutated_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][0] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])",
      "mutated_line": "stateStorage[i % 2][-1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][-1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])",
      "mutated_line": "stateStorage[i % 2][1] = 1 + int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 + int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])",
      "mutated_line": "stateStorage[i % 2][1] = 1 * int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 * int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]",
      "mutated_line": "stateStorage[i % 2][3] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][3] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]",
      "mutated_line": "stateStorage[i % 2][1] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]",
      "mutated_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][0] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]",
      "mutated_line": "stateStorage[i % 2][1] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]",
      "mutated_line": "stateStorage[i % 2][-2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][-2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]",
      "mutated_line": "stateStorage[i % 2][2] = 1 + int(B[i] == 3) + stateStorage[(i + 1) % 2][2]",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 + int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]",
      "mutated_line": "stateStorage[i % 2][2] = 1 * int(B[i] == 3) + stateStorage[(i + 1) % 2][2]",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 * int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])",
      "mutated_line": "return min(stateStorage[0][1], stateStorage[0][1], stateStorage[0][2])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][1], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])",
      "mutated_line": "return min(stateStorage[0][-1], stateStorage[0][1], stateStorage[0][2])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][-1], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])",
      "mutated_line": "return min(stateStorage[0][1], stateStorage[0][1], stateStorage[0][2])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][1], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])",
      "mutated_line": "return min(stateStorage[0][0], stateStorage[0][2], stateStorage[0][2])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][2], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])",
      "mutated_line": "return min(stateStorage[0][0], stateStorage[0][0], stateStorage[0][2])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][0], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])",
      "mutated_line": "return min(stateStorage[0][0], stateStorage[0][0], stateStorage[0][2])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][0], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])",
      "mutated_line": "return min(stateStorage[0][0], stateStorage[0][-1], stateStorage[0][2])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][-1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])",
      "mutated_line": "return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][3])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][3])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])",
      "mutated_line": "return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][1])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][1])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])",
      "mutated_line": "return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][0])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][0])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])",
      "mutated_line": "return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][1])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][1])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])",
      "mutated_line": "return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][-2])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][-2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "stateStorage = [[inf for _ in range(3)] for _ in range(2)]",
      "mutated_line": "stateStorage = [[inf for _ in range(4)] for _ in range(2)]",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(4)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "stateStorage = [[inf for _ in range(3)] for _ in range(2)]",
      "mutated_line": "stateStorage = [[inf for _ in range(2)] for _ in range(2)]",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(2)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "stateStorage = [[inf for _ in range(3)] for _ in range(2)]",
      "mutated_line": "stateStorage = [[inf for _ in range(0)] for _ in range(2)]",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(0)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "stateStorage = [[inf for _ in range(3)] for _ in range(2)]",
      "mutated_line": "stateStorage = [[inf for _ in range(1)] for _ in range(2)]",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(1)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "stateStorage = [[inf for _ in range(3)] for _ in range(2)]",
      "mutated_line": "stateStorage = [[inf for _ in range(-3)] for _ in range(2)]",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(-3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "stateStorage[n % 2][i] = 0",
      "mutated_line": "stateStorage[n % 3][i] = 0",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 3][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "stateStorage[n % 2][i] = 0",
      "mutated_line": "stateStorage[n % 1][i] = 0",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 1][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "stateStorage[n % 2][i] = 0",
      "mutated_line": "stateStorage[n % 0][i] = 0",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 0][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "stateStorage[n % 2][i] = 0",
      "mutated_line": "stateStorage[n % 1][i] = 0",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 1][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "stateStorage[n % 2][i] = 0",
      "mutated_line": "stateStorage[n % -2][i] = 0",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % -2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "mutated_line": "stateStorage[i * 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i * 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "mutated_line": "stateStorage[i + 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i + 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "mutated_line": "stateStorage[i % 2][0] = 2 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 2 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "mutated_line": "stateStorage[i % 2][0] = 0 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 0 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "mutated_line": "stateStorage[i % 2][0] = 0 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 0 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "mutated_line": "stateStorage[i % 2][0] = -1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = -1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])",
      "mutated_line": "stateStorage[i * 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i * 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])",
      "mutated_line": "stateStorage[i + 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i + 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])",
      "mutated_line": "stateStorage[i % 2][1] = 2 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 2 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])",
      "mutated_line": "stateStorage[i % 2][1] = 0 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 0 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])",
      "mutated_line": "stateStorage[i % 2][1] = 0 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 0 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])",
      "mutated_line": "stateStorage[i % 2][1] = -1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = -1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]",
      "mutated_line": "stateStorage[i * 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i * 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]",
      "mutated_line": "stateStorage[i + 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i + 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]",
      "mutated_line": "stateStorage[i % 2][2] = 2 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 2 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]",
      "mutated_line": "stateStorage[i % 2][2] = 0 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 0 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]",
      "mutated_line": "stateStorage[i % 2][2] = 0 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 0 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]",
      "mutated_line": "stateStorage[i % 2][2] = -1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = -1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]",
      "mutated_line": "stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][3]",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][3]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]",
      "mutated_line": "stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][1]",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][1]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]",
      "mutated_line": "stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][0]",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][0]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]",
      "mutated_line": "stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][1]",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][1]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]",
      "mutated_line": "stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][-2]",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][-2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])",
      "mutated_line": "return min(stateStorage[1][0], stateStorage[0][1], stateStorage[0][2])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[1][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])",
      "mutated_line": "return min(stateStorage[-1][0], stateStorage[0][1], stateStorage[0][2])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[-1][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])",
      "mutated_line": "return min(stateStorage[1][0], stateStorage[0][1], stateStorage[0][2])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[1][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])",
      "mutated_line": "return min(stateStorage[0][0], stateStorage[1][1], stateStorage[0][2])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[1][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])",
      "mutated_line": "return min(stateStorage[0][0], stateStorage[-1][1], stateStorage[0][2])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[-1][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])",
      "mutated_line": "return min(stateStorage[0][0], stateStorage[1][1], stateStorage[0][2])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[1][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])",
      "mutated_line": "return min(stateStorage[0][0], stateStorage[0][1], stateStorage[1][2])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[1][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])",
      "mutated_line": "return min(stateStorage[0][0], stateStorage[0][1], stateStorage[-1][2])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[-1][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])",
      "mutated_line": "return min(stateStorage[0][0], stateStorage[0][1], stateStorage[1][2])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[1][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "mutated_line": "stateStorage[i % 3][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 3][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "mutated_line": "stateStorage[i % 1][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 1][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "mutated_line": "stateStorage[i % 0][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 0][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "mutated_line": "stateStorage[i % 1][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 1][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "mutated_line": "stateStorage[i % -2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % -2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "mutated_line": "stateStorage[i % 2][0] = 1 - int(B[i] != 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] != 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "mutated_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "mutated_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][-1], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][-1], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "mutated_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "mutated_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][2])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "mutated_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][2])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "mutated_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][2])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "mutated_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][-1], stateStorage[(i + 1) % 2][2])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][-1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "mutated_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][3])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][3])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "mutated_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][1])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "mutated_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][0])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][0])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "mutated_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][1])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "mutated_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][-2])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][-2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])",
      "mutated_line": "stateStorage[i % 3][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 3][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])",
      "mutated_line": "stateStorage[i % 1][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 1][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])",
      "mutated_line": "stateStorage[i % 0][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 0][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])",
      "mutated_line": "stateStorage[i % 1][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 1][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])",
      "mutated_line": "stateStorage[i % -2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % -2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])",
      "mutated_line": "stateStorage[i % 2][1] = 1 - int(B[i] != 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] != 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])",
      "mutated_line": "stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][3], stateStorage[(i + 1) % 2][1])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][3], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])",
      "mutated_line": "stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][1])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])",
      "mutated_line": "stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])",
      "mutated_line": "stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][1])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])",
      "mutated_line": "stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][-2], stateStorage[(i + 1) % 2][1])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][-2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])",
      "mutated_line": "stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][2])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])",
      "mutated_line": "stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][0])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][0])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])",
      "mutated_line": "stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][0])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][0])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])",
      "mutated_line": "stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][-1])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][-1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]",
      "mutated_line": "stateStorage[i % 3][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 3][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]",
      "mutated_line": "stateStorage[i % 1][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 1][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]",
      "mutated_line": "stateStorage[i % 0][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 0][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]",
      "mutated_line": "stateStorage[i % 1][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 1][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]",
      "mutated_line": "stateStorage[i % -2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % -2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]",
      "mutated_line": "stateStorage[i % 2][2] = 1 - int(B[i] != 3) + stateStorage[(i + 1) % 2][2]",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] != 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]",
      "mutated_line": "stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) * 2][2]",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) * 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]",
      "mutated_line": "stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[i + 1 + 2][2]",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[i + 1 + 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "mutated_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "mutated_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 0) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 0) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "mutated_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 0) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 0) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "mutated_line": "stateStorage[i % 2][0] = 1 - int(B[i] == -1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == -1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "mutated_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) * 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) * 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "mutated_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[i + 1 + 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[i + 1 + 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "mutated_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) * 2][1], stateStorage[(i + 1) % 2][2])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) * 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "mutated_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[i + 1 + 2][1], stateStorage[(i + 1) % 2][2])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[i + 1 + 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "mutated_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) * 2][2])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) * 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "mutated_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[i + 1 + 2][2])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[i + 1 + 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])",
      "mutated_line": "stateStorage[i % 2][1] = 1 - int(B[i] == 3) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 3) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])",
      "mutated_line": "stateStorage[i % 2][1] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])",
      "mutated_line": "stateStorage[i % 2][1] = 1 - int(B[i] == 0) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 0) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])",
      "mutated_line": "stateStorage[i % 2][1] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])",
      "mutated_line": "stateStorage[i % 2][1] = 1 - int(B[i] == -2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == -2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])",
      "mutated_line": "stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) * 2][2], stateStorage[(i + 1) % 2][1])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) * 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])",
      "mutated_line": "stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[i + 1 + 2][2], stateStorage[(i + 1) % 2][1])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[i + 1 + 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])",
      "mutated_line": "stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) * 2][1])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) * 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])",
      "mutated_line": "stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[i + 1 + 2][1])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[i + 1 + 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]",
      "mutated_line": "stateStorage[i % 2][2] = 1 - int(B[i] == 4) + stateStorage[(i + 1) % 2][2]",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 4) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]",
      "mutated_line": "stateStorage[i % 2][2] = 1 - int(B[i] == 2) + stateStorage[(i + 1) % 2][2]",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 2) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]",
      "mutated_line": "stateStorage[i % 2][2] = 1 - int(B[i] == 0) + stateStorage[(i + 1) % 2][2]",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 0) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]",
      "mutated_line": "stateStorage[i % 2][2] = 1 - int(B[i] == 1) + stateStorage[(i + 1) % 2][2]",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 1) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]",
      "mutated_line": "stateStorage[i % 2][2] = 1 - int(B[i] == -3) + stateStorage[(i + 1) % 2][2]",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == -3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]",
      "mutated_line": "stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i - 1) % 2][2]",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i - 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]",
      "mutated_line": "stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[i * 1 % 2][2]",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[i * 1 % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]",
      "mutated_line": "stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 3][2]",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 3][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]",
      "mutated_line": "stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 1][2]",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 1][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]",
      "mutated_line": "stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 0][2]",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 0][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]",
      "mutated_line": "stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 1][2]",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 1][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]",
      "mutated_line": "stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % -2][2]",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % -2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "mutated_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i - 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i - 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "mutated_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[i * 1 % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[i * 1 % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "mutated_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 3][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 3][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "mutated_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 1][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 1][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "mutated_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 0][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 0][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "mutated_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 1][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 1][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "mutated_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % -2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % -2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "mutated_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i - 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i - 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "mutated_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[i * 1 % 2][1], stateStorage[(i + 1) % 2][2])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[i * 1 % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "mutated_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 3][1], stateStorage[(i + 1) % 2][2])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 3][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "mutated_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 1][1], stateStorage[(i + 1) % 2][2])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 1][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "mutated_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 0][1], stateStorage[(i + 1) % 2][2])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 0][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "mutated_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 1][1], stateStorage[(i + 1) % 2][2])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 1][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "mutated_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % -2][1], stateStorage[(i + 1) % 2][2])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % -2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "mutated_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i - 1) % 2][2])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i - 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "mutated_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[i * 1 % 2][2])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[i * 1 % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "mutated_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 3][2])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 3][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "mutated_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 1][2])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 1][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "mutated_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 0][2])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 0][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "mutated_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 1][2])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 1][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "mutated_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % -2][2])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % -2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])",
      "mutated_line": "stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i - 1) % 2][2], stateStorage[(i + 1) % 2][1])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i - 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])",
      "mutated_line": "stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[i * 1 % 2][2], stateStorage[(i + 1) % 2][1])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[i * 1 % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])",
      "mutated_line": "stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 3][2], stateStorage[(i + 1) % 2][1])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 3][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])",
      "mutated_line": "stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 1][2], stateStorage[(i + 1) % 2][1])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 1][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])",
      "mutated_line": "stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 0][2], stateStorage[(i + 1) % 2][1])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 0][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])",
      "mutated_line": "stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 1][2], stateStorage[(i + 1) % 2][1])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 1][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])",
      "mutated_line": "stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % -2][2], stateStorage[(i + 1) % 2][1])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % -2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])",
      "mutated_line": "stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i - 1) % 2][1])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i - 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])",
      "mutated_line": "stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[i * 1 % 2][1])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[i * 1 % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])",
      "mutated_line": "stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 3][1])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 3][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])",
      "mutated_line": "stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 1][1])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 1][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])",
      "mutated_line": "stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 0][1])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 0][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])",
      "mutated_line": "stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 1][1])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 1][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])",
      "mutated_line": "stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % -2][1])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % -2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]",
      "mutated_line": "stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 2) % 2][2]",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 2) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]",
      "mutated_line": "stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 0) % 2][2]",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 0) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]",
      "mutated_line": "stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 0) % 2][2]",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 0) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]",
      "mutated_line": "stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + -1) % 2][2]",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + -1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "mutated_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 2) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 2) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "mutated_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 0) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 0) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "mutated_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 0) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 0) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "mutated_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + -1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + -1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "mutated_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 2) % 2][1], stateStorage[(i + 1) % 2][2])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 2) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "mutated_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 0) % 2][1], stateStorage[(i + 1) % 2][2])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 0) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "mutated_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 0) % 2][1], stateStorage[(i + 1) % 2][2])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 0) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "mutated_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + -1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + -1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "mutated_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 2) % 2][2])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 2) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "mutated_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 0) % 2][2])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 0) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "mutated_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 0) % 2][2])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 0) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])",
      "mutated_line": "stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + -1) % 2][2])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + -1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])",
      "mutated_line": "stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 2) % 2][2], stateStorage[(i + 1) % 2][1])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 2) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])",
      "mutated_line": "stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 0) % 2][2], stateStorage[(i + 1) % 2][1])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 0) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])",
      "mutated_line": "stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 0) % 2][2], stateStorage[(i + 1) % 2][1])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 0) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])",
      "mutated_line": "stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + -1) % 2][2], stateStorage[(i + 1) % 2][1])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + -1) % 2][2], stateStorage[(i + 1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])",
      "mutated_line": "stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 2) % 2][1])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 2) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])",
      "mutated_line": "stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 0) % 2][1])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 0) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])",
      "mutated_line": "stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 0) % 2][1])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 0) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + 1) % 2][1])",
      "mutated_line": "stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + -1) % 2][1])",
      "code": "def minimum_moves_to_redistribute_problems(k1, k2, k3, a1, a2, a3):\n    n = k1 + k2 + k3\n    B = [0] * n\n    for i in a1:\n        B[i - 1] = 1\n    for i in a2:\n        B[i - 1] = 2\n    for i in a3:\n        B[i - 1] = 3\n    inf = int(2 * 100000.0 + 3)\n    stateStorage = [[inf for _ in range(3)] for _ in range(2)]\n    for i in range(3):\n        stateStorage[n % 2][i] = 0\n\n    def fillMatrix(n):\n        for i in range(n - 1, -1, -1):\n            stateStorage[i % 2][0] = 1 - int(B[i] == 1) + min(stateStorage[(i + 1) % 2][0], stateStorage[(i + 1) % 2][1], stateStorage[(i + 1) % 2][2])\n            stateStorage[i % 2][1] = 1 - int(B[i] == 2) + min(stateStorage[(i + 1) % 2][2], stateStorage[(i + -1) % 2][1])\n            stateStorage[i % 2][2] = 1 - int(B[i] == 3) + stateStorage[(i + 1) % 2][2]\n        return min(stateStorage[0][0], stateStorage[0][1], stateStorage[0][2])\n    return fillMatrix(n)"
    }
  ]
}