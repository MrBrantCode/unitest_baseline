{
  "task_id": "taco_17322",
  "entry_point": "convert",
  "mutant_count": 174,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "BASE = 12 * 3600",
      "mutated_line": "BASE = 12 / 3600",
      "code": "from itertools import permutations\nBASE = 12 / 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "BASE = 12 * 3600",
      "mutated_line": "BASE = 12 + 3600",
      "code": "from itertools import permutations\nBASE = 12 + 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "BASE = 12 * 3600",
      "mutated_line": "BASE = 12 ** 3600",
      "code": "from itertools import permutations\nBASE = 12 ** 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "BASE = 12 * 3600",
      "mutated_line": "BASE = 13 * 3600",
      "code": "from itertools import permutations\nBASE = 13 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "BASE = 12 * 3600",
      "mutated_line": "BASE = 11 * 3600",
      "code": "from itertools import permutations\nBASE = 11 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "BASE = 12 * 3600",
      "mutated_line": "BASE = 0 * 3600",
      "code": "from itertools import permutations\nBASE = 0 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "BASE = 12 * 3600",
      "mutated_line": "BASE = 1 * 3600",
      "code": "from itertools import permutations\nBASE = 1 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "BASE = 12 * 3600",
      "mutated_line": "BASE = -12 * 3600",
      "code": "from itertools import permutations\nBASE = -12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "BASE = 12 * 3600",
      "mutated_line": "BASE = 12 * 3601",
      "code": "from itertools import permutations\nBASE = 12 * 3601\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "BASE = 12 * 3600",
      "mutated_line": "BASE = 12 * 3599",
      "code": "from itertools import permutations\nBASE = 12 * 3599\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "BASE = 12 * 3600",
      "mutated_line": "BASE = 12 * 0",
      "code": "from itertools import permutations\nBASE = 12 * 0\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "BASE = 12 * 3600",
      "mutated_line": "BASE = 12 * 1",
      "code": "from itertools import permutations\nBASE = 12 * 1\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "BASE = 12 * 3600",
      "mutated_line": "BASE = 12 * -3600",
      "code": "from itertools import permutations\nBASE = 12 * -3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)",
      "mutated_line": "return '%02d:%02d:%02d' * (v // 3600, v // 60 % 60, v % 60)",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' * (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)",
      "mutated_line": "return '%02d:%02d:%02d' + (v // 3600, v // 60 % 60, v % 60)",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' + (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "res = 13 * 3600",
      "mutated_line": "res = 13 / 3600",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 / 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "res = 13 * 3600",
      "mutated_line": "res = 13 + 3600",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 + 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "res = 13 * 3600",
      "mutated_line": "res = 13 ** 3600",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 ** 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "mi = ma = 0",
      "mutated_line": "mi = ma = 1",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 1\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "mi = ma = 0",
      "mutated_line": "mi = ma = -1",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = -1\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "mi = ma = 0",
      "mutated_line": "mi = ma = 1",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 1\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "C = [0] * n",
      "mutated_line": "C = [0] / n",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] / n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "C = [0] * n",
      "mutated_line": "C = [0] + n",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] + n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "C = [0] * n",
      "mutated_line": "C = [0] ** n",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] ** n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)",
      "mutated_line": "return '' % (v // 3600, v // 60 % 60, v % 60)",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "res = 13 * 3600",
      "mutated_line": "res = 14 * 3600",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 14 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "res = 13 * 3600",
      "mutated_line": "res = 12 * 3600",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 12 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "res = 13 * 3600",
      "mutated_line": "res = 0 * 3600",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 0 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "res = 13 * 3600",
      "mutated_line": "res = 1 * 3600",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 1 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "res = 13 * 3600",
      "mutated_line": "res = -13 * 3600",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = -13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "res = 13 * 3600",
      "mutated_line": "res = 13 * 3601",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3601\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "res = 13 * 3600",
      "mutated_line": "res = 13 * 3599",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3599\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "res = 13 * 3600",
      "mutated_line": "res = 13 * 0",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 0\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "res = 13 * 3600",
      "mutated_line": "res = 13 * 1",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 1\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "res = 13 * 3600",
      "mutated_line": "res = 13 * -3600",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * -3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "if s - r < res:",
      "mutated_line": "if s - r <= res:",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r <= res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "if s - r < res:",
      "mutated_line": "if s - r >= res:",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r >= res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "if s - r < res:",
      "mutated_line": "if s - r != res:",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r != res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)",
      "mutated_line": "return '%02d:%02d:%02d' % (v / 3600, v // 60 % 60, v % 60)",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v / 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)",
      "mutated_line": "return '%02d:%02d:%02d' % (v * 3600, v // 60 % 60, v % 60)",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v * 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)",
      "mutated_line": "return '%02d:%02d:%02d' % (v // 3600, v // 60 * 60, v % 60)",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 * 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)",
      "mutated_line": "return '%02d:%02d:%02d' % (v // 3600, v // 60 + 60, v % 60)",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 + 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)",
      "mutated_line": "return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v * 60)",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v * 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)",
      "mutated_line": "return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v + 60)",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v + 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "C = [0] * n",
      "mutated_line": "C = [1] * n",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [1] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "C = [0] * n",
      "mutated_line": "C = [-1] * n",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [-1] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "C = [0] * n",
      "mutated_line": "C = [1] * n",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [1] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "LCR",
      "lineno": 36,
      "original_line": "while c < l and ts[c] < r:",
      "mutated_line": "while c < l or ts[c] < r:",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l or ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "ASR",
      "lineno": 37,
      "original_line": "c += 1",
      "mutated_line": "c -= 1",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c -= 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if c == l:",
      "mutated_line": "if c != l:",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c != l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "if s - r < res:",
      "mutated_line": "if s + r < res:",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s + r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "if s - r < res:",
      "mutated_line": "if s * r < res:",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s * r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "res = s - r",
      "mutated_line": "res = s + r",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s + r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "res = s - r",
      "mutated_line": "res = s * r",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s * r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "mi = r % BASE",
      "mutated_line": "mi = r * BASE",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r * BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "mi = r % BASE",
      "mutated_line": "mi = r + BASE",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r + BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "ma = s % BASE",
      "mutated_line": "ma = s * BASE",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s * BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "ma = s % BASE",
      "mutated_line": "ma = s + BASE",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s + BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)",
      "mutated_line": "return '%02d:%02d:%02d' % (v // 3601, v // 60 % 60, v % 60)",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3601, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)",
      "mutated_line": "return '%02d:%02d:%02d' % (v // 3599, v // 60 % 60, v % 60)",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3599, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)",
      "mutated_line": "return '%02d:%02d:%02d' % (v // 0, v // 60 % 60, v % 60)",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 0, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)",
      "mutated_line": "return '%02d:%02d:%02d' % (v // 1, v // 60 % 60, v % 60)",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 1, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)",
      "mutated_line": "return '%02d:%02d:%02d' % (v // -3600, v // 60 % 60, v % 60)",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // -3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)",
      "mutated_line": "return '%02d:%02d:%02d' % (v // 3600, v / 60 % 60, v % 60)",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v / 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)",
      "mutated_line": "return '%02d:%02d:%02d' % (v // 3600, v * 60 % 60, v % 60)",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v * 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)",
      "mutated_line": "return '%02d:%02d:%02d' % (v // 3600, v // 60 % 61, v % 60)",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 61, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)",
      "mutated_line": "return '%02d:%02d:%02d' % (v // 3600, v // 60 % 59, v % 60)",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 59, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)",
      "mutated_line": "return '%02d:%02d:%02d' % (v // 3600, v // 60 % 0, v % 60)",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 0, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)",
      "mutated_line": "return '%02d:%02d:%02d' % (v // 3600, v // 60 % 1, v % 60)",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 1, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)",
      "mutated_line": "return '%02d:%02d:%02d' % (v // 3600, v // 60 % -60, v % 60)",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % -60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)",
      "mutated_line": "return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 61)",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 61)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)",
      "mutated_line": "return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 59)",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 59)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)",
      "mutated_line": "return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 0)",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 0)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)",
      "mutated_line": "return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 1)",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 1)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)",
      "mutated_line": "return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % -60)",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % -60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for (a, b, c) in permutations(E, r=3):",
      "mutated_line": "for (a, b, c) in permutations(E, r=4):",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=4):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for (a, b, c) in permutations(E, r=3):",
      "mutated_line": "for (a, b, c) in permutations(E, r=2):",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=2):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for (a, b, c) in permutations(E, r=3):",
      "mutated_line": "for (a, b, c) in permutations(E, r=0):",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=0):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for (a, b, c) in permutations(E, r=3):",
      "mutated_line": "for (a, b, c) in permutations(E, r=1):",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=1):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for (a, b, c) in permutations(E, r=3):",
      "mutated_line": "for (a, b, c) in permutations(E, r=-3):",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=-3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(60):",
      "mutated_line": "for i in range(61):",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(61):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(60):",
      "mutated_line": "for i in range(59):",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(59):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(60):",
      "mutated_line": "for i in range(0):",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(0):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(60):",
      "mutated_line": "for i in range(1):",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(1):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(60):",
      "mutated_line": "for i in range(-60):",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(-60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "h = (a + i) % 60",
      "mutated_line": "h = (a + i) * 60",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) * 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "h = (a + i) % 60",
      "mutated_line": "h = a + i + 60",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = a + i + 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "m = (b + i) % 60",
      "mutated_line": "m = (b + i) * 60",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) * 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "m = (b + i) % 60",
      "mutated_line": "m = b + i + 60",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = b + i + 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "s = (c + i) % 60",
      "mutated_line": "s = (c + i) * 60",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) * 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "s = (c + i) % 60",
      "mutated_line": "s = c + i + 60",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = c + i + 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if m // 12 == h % 5:",
      "mutated_line": "if m // 12 != h % 5:",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 != h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "while c < l and ts[c] < r:",
      "mutated_line": "while c <= l and ts[c] < r:",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c <= l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "while c < l and ts[c] < r:",
      "mutated_line": "while c >= l and ts[c] < r:",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c >= l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "while c < l and ts[c] < r:",
      "mutated_line": "while c != l and ts[c] < r:",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c != l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "while c < l and ts[c] < r:",
      "mutated_line": "while c < l and ts[c] <= r:",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] <= r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "while c < l and ts[c] < r:",
      "mutated_line": "while c < l and ts[c] >= r:",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] >= r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "while c < l and ts[c] < r:",
      "mutated_line": "while c < l and ts[c] != r:",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] != r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "c += 1",
      "mutated_line": "c += 2",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 2\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "c += 1",
      "mutated_line": "c += 0",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 0\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "c += 1",
      "mutated_line": "c += 0",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 0\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "c += 1",
      "mutated_line": "c += -1",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += -1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)",
      "mutated_line": "return '%02d:%02d:%02d' % (v // 3600, v // 61 % 60, v % 60)",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 61 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)",
      "mutated_line": "return '%02d:%02d:%02d' % (v // 3600, v // 59 % 60, v % 60)",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 59 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)",
      "mutated_line": "return '%02d:%02d:%02d' % (v // 3600, v // 0 % 60, v % 60)",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 0 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)",
      "mutated_line": "return '%02d:%02d:%02d' % (v // 3600, v // 1 % 60, v % 60)",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 1 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)",
      "mutated_line": "return '%02d:%02d:%02d' % (v // 3600, v // -60 % 60, v % 60)",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // -60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "h = (a + i) % 60",
      "mutated_line": "h = (a - i) % 60",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a - i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "h = (a + i) % 60",
      "mutated_line": "h = a * i % 60",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = a * i % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "h = (a + i) % 60",
      "mutated_line": "h = (a + i) % 61",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 61\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "h = (a + i) % 60",
      "mutated_line": "h = (a + i) % 59",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 59\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "h = (a + i) % 60",
      "mutated_line": "h = (a + i) % 0",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 0\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "h = (a + i) % 60",
      "mutated_line": "h = (a + i) % 1",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 1\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "h = (a + i) % 60",
      "mutated_line": "h = (a + i) % -60",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % -60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "m = (b + i) % 60",
      "mutated_line": "m = (b - i) % 60",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b - i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "m = (b + i) % 60",
      "mutated_line": "m = b * i % 60",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = b * i % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "m = (b + i) % 60",
      "mutated_line": "m = (b + i) % 61",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 61\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "m = (b + i) % 60",
      "mutated_line": "m = (b + i) % 59",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 59\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "m = (b + i) % 60",
      "mutated_line": "m = (b + i) % 0",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 0\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "m = (b + i) % 60",
      "mutated_line": "m = (b + i) % 1",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 1\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "m = (b + i) % 60",
      "mutated_line": "m = (b + i) % -60",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % -60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "s = (c + i) % 60",
      "mutated_line": "s = (c - i) % 60",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c - i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "s = (c + i) % 60",
      "mutated_line": "s = c * i % 60",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = c * i % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "s = (c + i) % 60",
      "mutated_line": "s = (c + i) % 61",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 61\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "s = (c + i) % 60",
      "mutated_line": "s = (c + i) % 59",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 59\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "s = (c + i) % 60",
      "mutated_line": "s = (c + i) % 0",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 0\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "s = (c + i) % 60",
      "mutated_line": "s = (c + i) % 1",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 1\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "s = (c + i) % 60",
      "mutated_line": "s = (c + i) % -60",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % -60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "if m // 12 == h % 5:",
      "mutated_line": "if m / 12 == h % 5:",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m / 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "if m // 12 == h % 5:",
      "mutated_line": "if m * 12 == h % 5:",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m * 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "if m // 12 == h % 5:",
      "mutated_line": "if m // 12 == h * 5:",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h * 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "if m // 12 == h % 5:",
      "mutated_line": "if m // 12 == h + 5:",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h + 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "v = 3600 * (h // 5) + 60 * m + s",
      "mutated_line": "v = 3600 * (h // 5) + 60 * m - s",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m - s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "v = 3600 * (h // 5) + 60 * m + s",
      "mutated_line": "v = (3600 * (h // 5) + 60 * m) * s",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = (3600 * (h // 5) + 60 * m) * s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "s = max(s, BASE + ts[0])",
      "mutated_line": "s = max(s, BASE - ts[0])",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE - ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "s = max(s, BASE + ts[0])",
      "mutated_line": "s = max(s, BASE * ts[0])",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE * ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if m // 12 == h % 5:",
      "mutated_line": "if m // 13 == h % 5:",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 13 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if m // 12 == h % 5:",
      "mutated_line": "if m // 11 == h % 5:",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 11 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if m // 12 == h % 5:",
      "mutated_line": "if m // 0 == h % 5:",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 0 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if m // 12 == h % 5:",
      "mutated_line": "if m // 1 == h % 5:",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 1 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if m // 12 == h % 5:",
      "mutated_line": "if m // -12 == h % 5:",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // -12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if m // 12 == h % 5:",
      "mutated_line": "if m // 12 == h % 6:",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 6:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if m // 12 == h % 5:",
      "mutated_line": "if m // 12 == h % 4:",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 4:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if m // 12 == h % 5:",
      "mutated_line": "if m // 12 == h % 0:",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 0:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if m // 12 == h % 5:",
      "mutated_line": "if m // 12 == h % 1:",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 1:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if m // 12 == h % 5:",
      "mutated_line": "if m // 12 == h % -5:",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % -5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "v = 3600 * (h // 5) + 60 * m + s",
      "mutated_line": "v = 3600 * (h // 5) - 60 * m + s",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) - 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "v = 3600 * (h // 5) + 60 * m + s",
      "mutated_line": "v = 3600 * (h // 5) * (60 * m) + s",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) * (60 * m) + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "v = 3600 * (h // 5) + 60 * m + s",
      "mutated_line": "v = 3600 / (h // 5) + 60 * m + s",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 / (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "v = 3600 * (h // 5) + 60 * m + s",
      "mutated_line": "v = 3600 + h // 5 + 60 * m + s",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 + h // 5 + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "v = 3600 * (h // 5) + 60 * m + s",
      "mutated_line": "v = 3600 ** (h // 5) + 60 * m + s",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 ** (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "v = 3600 * (h // 5) + 60 * m + s",
      "mutated_line": "v = 3600 * (h // 5) + 60 / m + s",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 / m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "v = 3600 * (h // 5) + 60 * m + s",
      "mutated_line": "v = 3600 * (h // 5) + (60 + m) + s",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + (60 + m) + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "v = 3600 * (h // 5) + 60 * m + s",
      "mutated_line": "v = 3600 * (h // 5) + 60 ** m + s",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 ** m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "s = max(s, BASE + ts[0])",
      "mutated_line": "s = max(s, BASE + ts[1])",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[1])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "s = max(s, BASE + ts[0])",
      "mutated_line": "s = max(s, BASE + ts[-1])",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[-1])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "s = max(s, BASE + ts[0])",
      "mutated_line": "s = max(s, BASE + ts[1])",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[1])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "v = 3600 * (h // 5) + 60 * m + s",
      "mutated_line": "v = 3601 * (h // 5) + 60 * m + s",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3601 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "v = 3600 * (h // 5) + 60 * m + s",
      "mutated_line": "v = 3599 * (h // 5) + 60 * m + s",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3599 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "v = 3600 * (h // 5) + 60 * m + s",
      "mutated_line": "v = 0 * (h // 5) + 60 * m + s",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 0 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "v = 3600 * (h // 5) + 60 * m + s",
      "mutated_line": "v = 1 * (h // 5) + 60 * m + s",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 1 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "v = 3600 * (h // 5) + 60 * m + s",
      "mutated_line": "v = -3600 * (h // 5) + 60 * m + s",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = -3600 * (h // 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "v = 3600 * (h // 5) + 60 * m + s",
      "mutated_line": "v = 3600 * (h / 5) + 60 * m + s",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h / 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "v = 3600 * (h // 5) + 60 * m + s",
      "mutated_line": "v = 3600 * (h * 5) + 60 * m + s",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h * 5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "v = 3600 * (h // 5) + 60 * m + s",
      "mutated_line": "v = 3600 * (h // 5) + 61 * m + s",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 61 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "v = 3600 * (h // 5) + 60 * m + s",
      "mutated_line": "v = 3600 * (h // 5) + 59 * m + s",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 59 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "v = 3600 * (h // 5) + 60 * m + s",
      "mutated_line": "v = 3600 * (h // 5) + 0 * m + s",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 0 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "v = 3600 * (h // 5) + 60 * m + s",
      "mutated_line": "v = 3600 * (h // 5) + 1 * m + s",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + 1 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "v = 3600 * (h // 5) + 60 * m + s",
      "mutated_line": "v = 3600 * (h // 5) + -60 * m + s",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 5) + -60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "v = 3600 * (h // 5) + 60 * m + s",
      "mutated_line": "v = 3600 * (h // 6) + 60 * m + s",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 6) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "v = 3600 * (h // 5) + 60 * m + s",
      "mutated_line": "v = 3600 * (h // 4) + 60 * m + s",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 4) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "v = 3600 * (h // 5) + 60 * m + s",
      "mutated_line": "v = 3600 * (h // 0) + 60 * m + s",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 0) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "v = 3600 * (h // 5) + 60 * m + s",
      "mutated_line": "v = 3600 * (h // 1) + 60 * m + s",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // 1) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "v = 3600 * (h // 5) + 60 * m + s",
      "mutated_line": "v = 3600 * (h // -5) + 60 * m + s",
      "code": "from itertools import permutations\nBASE = 12 * 3600\n\ndef convert(v):\n    return '%02d:%02d:%02d' % (v // 3600, v // 60 % 60, v % 60)\n\ndef find_shortest_time_interval(n, watch_data):\n    R = set()\n    L = []\n    for E in watch_data:\n        ts = set()\n        for (a, b, c) in permutations(E, r=3):\n            for i in range(60):\n                h = (a + i) % 60\n                m = (b + i) % 60\n                s = (c + i) % 60\n                if m // 12 == h % 5:\n                    v = 3600 * (h // -5) + 60 * m + s\n                    ts.add(v)\n                    R.add(v)\n        L.append(sorted(ts))\n    R = sorted(R)\n    res = 13 * 3600\n    mi = ma = 0\n    C = [0] * n\n    for r in R:\n        s = r\n        for i in range(n):\n            c = C[i]\n            ts = L[i]\n            l = len(ts)\n            while c < l and ts[c] < r:\n                c += 1\n            C[i] = c\n            if c == l:\n                s = max(s, BASE + ts[0])\n            else:\n                s = max(s, ts[c])\n        if s - r < res:\n            res = s - r\n            mi = r % BASE\n            ma = s % BASE\n    return (convert(mi), convert(ma))"
    }
  ]
}