{
  "task_id": "taco_2811",
  "entry_point": "generate_candidate_list",
  "mutant_count": 85,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "cp = [-1] * n",
      "mutated_line": "cp = [-1] / n",
      "code": "from collections import deque\n\ndef generate_candidate_list(n, m, relations, preferences):\n    adj = [[] for _ in range(n)]\n    cp = [-1] / n\n    for (p, c) in relations:\n        adj[p - 1].append(c - 1)\n        cp[c - 1] = p - 1\n    pres = [pref - 1 for pref in preferences]\n    level = [0] * n\n\n    def bfs(v):\n        q = deque([v])\n        while q:\n            v = q.pop()\n            if cp[v] >= 0:\n                level[v] = level[cp[v]] + 1\n            for nv in adj[v]:\n                q.append(nv)\n    for i in range(n):\n        if cp[i] == -1:\n            bfs(i)\n    for i in range(n):\n        if level[i] > 0:\n            par = cp[i]\n            if pres[i] != pres[par] and level[pres[i]] <= level[par]:\n                return -1\n    pres = list(set(pres))\n    pres = sorted(pres, key=lambda i: level[i], reverse=True)\n    return (len(pres), [i + 1 for i in pres])"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "cp = [-1] * n",
      "mutated_line": "cp = [-1] + n",
      "code": "from collections import deque\n\ndef generate_candidate_list(n, m, relations, preferences):\n    adj = [[] for _ in range(n)]\n    cp = [-1] + n\n    for (p, c) in relations:\n        adj[p - 1].append(c - 1)\n        cp[c - 1] = p - 1\n    pres = [pref - 1 for pref in preferences]\n    level = [0] * n\n\n    def bfs(v):\n        q = deque([v])\n        while q:\n            v = q.pop()\n            if cp[v] >= 0:\n                level[v] = level[cp[v]] + 1\n            for nv in adj[v]:\n                q.append(nv)\n    for i in range(n):\n        if cp[i] == -1:\n            bfs(i)\n    for i in range(n):\n        if level[i] > 0:\n            par = cp[i]\n            if pres[i] != pres[par] and level[pres[i]] <= level[par]:\n                return -1\n    pres = list(set(pres))\n    pres = sorted(pres, key=lambda i: level[i], reverse=True)\n    return (len(pres), [i + 1 for i in pres])"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "cp = [-1] * n",
      "mutated_line": "cp = [-1] ** n",
      "code": "from collections import deque\n\ndef generate_candidate_list(n, m, relations, preferences):\n    adj = [[] for _ in range(n)]\n    cp = [-1] ** n\n    for (p, c) in relations:\n        adj[p - 1].append(c - 1)\n        cp[c - 1] = p - 1\n    pres = [pref - 1 for pref in preferences]\n    level = [0] * n\n\n    def bfs(v):\n        q = deque([v])\n        while q:\n            v = q.pop()\n            if cp[v] >= 0:\n                level[v] = level[cp[v]] + 1\n            for nv in adj[v]:\n                q.append(nv)\n    for i in range(n):\n        if cp[i] == -1:\n            bfs(i)\n    for i in range(n):\n        if level[i] > 0:\n            par = cp[i]\n            if pres[i] != pres[par] and level[pres[i]] <= level[par]:\n                return -1\n    pres = list(set(pres))\n    pres = sorted(pres, key=lambda i: level[i], reverse=True)\n    return (len(pres), [i + 1 for i in pres])"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "level = [0] * n",
      "mutated_line": "level = [0] / n",
      "code": "from collections import deque\n\ndef generate_candidate_list(n, m, relations, preferences):\n    adj = [[] for _ in range(n)]\n    cp = [-1] * n\n    for (p, c) in relations:\n        adj[p - 1].append(c - 1)\n        cp[c - 1] = p - 1\n    pres = [pref - 1 for pref in preferences]\n    level = [0] / n\n\n    def bfs(v):\n        q = deque([v])\n        while q:\n            v = q.pop()\n            if cp[v] >= 0:\n                level[v] = level[cp[v]] + 1\n            for nv in adj[v]:\n                q.append(nv)\n    for i in range(n):\n        if cp[i] == -1:\n            bfs(i)\n    for i in range(n):\n        if level[i] > 0:\n            par = cp[i]\n            if pres[i] != pres[par] and level[pres[i]] <= level[par]:\n                return -1\n    pres = list(set(pres))\n    pres = sorted(pres, key=lambda i: level[i], reverse=True)\n    return (len(pres), [i + 1 for i in pres])"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "level = [0] * n",
      "mutated_line": "level = [0] + n",
      "code": "from collections import deque\n\ndef generate_candidate_list(n, m, relations, preferences):\n    adj = [[] for _ in range(n)]\n    cp = [-1] * n\n    for (p, c) in relations:\n        adj[p - 1].append(c - 1)\n        cp[c - 1] = p - 1\n    pres = [pref - 1 for pref in preferences]\n    level = [0] + n\n\n    def bfs(v):\n        q = deque([v])\n        while q:\n            v = q.pop()\n            if cp[v] >= 0:\n                level[v] = level[cp[v]] + 1\n            for nv in adj[v]:\n                q.append(nv)\n    for i in range(n):\n        if cp[i] == -1:\n            bfs(i)\n    for i in range(n):\n        if level[i] > 0:\n            par = cp[i]\n            if pres[i] != pres[par] and level[pres[i]] <= level[par]:\n                return -1\n    pres = list(set(pres))\n    pres = sorted(pres, key=lambda i: level[i], reverse=True)\n    return (len(pres), [i + 1 for i in pres])"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "level = [0] * n",
      "mutated_line": "level = [0] ** n",
      "code": "from collections import deque\n\ndef generate_candidate_list(n, m, relations, preferences):\n    adj = [[] for _ in range(n)]\n    cp = [-1] * n\n    for (p, c) in relations:\n        adj[p - 1].append(c - 1)\n        cp[c - 1] = p - 1\n    pres = [pref - 1 for pref in preferences]\n    level = [0] ** n\n\n    def bfs(v):\n        q = deque([v])\n        while q:\n            v = q.pop()\n            if cp[v] >= 0:\n                level[v] = level[cp[v]] + 1\n            for nv in adj[v]:\n                q.append(nv)\n    for i in range(n):\n        if cp[i] == -1:\n            bfs(i)\n    for i in range(n):\n        if level[i] > 0:\n            par = cp[i]\n            if pres[i] != pres[par] and level[pres[i]] <= level[par]:\n                return -1\n    pres = list(set(pres))\n    pres = sorted(pres, key=lambda i: level[i], reverse=True)\n    return (len(pres), [i + 1 for i in pres])"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "cp[c - 1] = p - 1",
      "mutated_line": "cp[c - 1] = p + 1",
      "code": "from collections import deque\n\ndef generate_candidate_list(n, m, relations, preferences):\n    adj = [[] for _ in range(n)]\n    cp = [-1] * n\n    for (p, c) in relations:\n        adj[p - 1].append(c - 1)\n        cp[c - 1] = p + 1\n    pres = [pref - 1 for pref in preferences]\n    level = [0] * n\n\n    def bfs(v):\n        q = deque([v])\n        while q:\n            v = q.pop()\n            if cp[v] >= 0:\n                level[v] = level[cp[v]] + 1\n            for nv in adj[v]:\n                q.append(nv)\n    for i in range(n):\n        if cp[i] == -1:\n            bfs(i)\n    for i in range(n):\n        if level[i] > 0:\n            par = cp[i]\n            if pres[i] != pres[par] and level[pres[i]] <= level[par]:\n                return -1\n    pres = list(set(pres))\n    pres = sorted(pres, key=lambda i: level[i], reverse=True)\n    return (len(pres), [i + 1 for i in pres])"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "cp[c - 1] = p - 1",
      "mutated_line": "cp[c - 1] = p * 1",
      "code": "from collections import deque\n\ndef generate_candidate_list(n, m, relations, preferences):\n    adj = [[] for _ in range(n)]\n    cp = [-1] * n\n    for (p, c) in relations:\n        adj[p - 1].append(c - 1)\n        cp[c - 1] = p * 1\n    pres = [pref - 1 for pref in preferences]\n    level = [0] * n\n\n    def bfs(v):\n        q = deque([v])\n        while q:\n            v = q.pop()\n            if cp[v] >= 0:\n                level[v] = level[cp[v]] + 1\n            for nv in adj[v]:\n                q.append(nv)\n    for i in range(n):\n        if cp[i] == -1:\n            bfs(i)\n    for i in range(n):\n        if level[i] > 0:\n            par = cp[i]\n            if pres[i] != pres[par] and level[pres[i]] <= level[par]:\n                return -1\n    pres = list(set(pres))\n    pres = sorted(pres, key=lambda i: level[i], reverse=True)\n    return (len(pres), [i + 1 for i in pres])"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "pres = [pref - 1 for pref in preferences]",
      "mutated_line": "pres = [pref + 1 for pref in preferences]",
      "code": "from collections import deque\n\ndef generate_candidate_list(n, m, relations, preferences):\n    adj = [[] for _ in range(n)]\n    cp = [-1] * n\n    for (p, c) in relations:\n        adj[p - 1].append(c - 1)\n        cp[c - 1] = p - 1\n    pres = [pref + 1 for pref in preferences]\n    level = [0] * n\n\n    def bfs(v):\n        q = deque([v])\n        while q:\n            v = q.pop()\n            if cp[v] >= 0:\n                level[v] = level[cp[v]] + 1\n            for nv in adj[v]:\n                q.append(nv)\n    for i in range(n):\n        if cp[i] == -1:\n            bfs(i)\n    for i in range(n):\n        if level[i] > 0:\n            par = cp[i]\n            if pres[i] != pres[par] and level[pres[i]] <= level[par]:\n                return -1\n    pres = list(set(pres))\n    pres = sorted(pres, key=lambda i: level[i], reverse=True)\n    return (len(pres), [i + 1 for i in pres])"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "pres = [pref - 1 for pref in preferences]",
      "mutated_line": "pres = [pref * 1 for pref in preferences]",
      "code": "from collections import deque\n\ndef generate_candidate_list(n, m, relations, preferences):\n    adj = [[] for _ in range(n)]\n    cp = [-1] * n\n    for (p, c) in relations:\n        adj[p - 1].append(c - 1)\n        cp[c - 1] = p - 1\n    pres = [pref * 1 for pref in preferences]\n    level = [0] * n\n\n    def bfs(v):\n        q = deque([v])\n        while q:\n            v = q.pop()\n            if cp[v] >= 0:\n                level[v] = level[cp[v]] + 1\n            for nv in adj[v]:\n                q.append(nv)\n    for i in range(n):\n        if cp[i] == -1:\n            bfs(i)\n    for i in range(n):\n        if level[i] > 0:\n            par = cp[i]\n            if pres[i] != pres[par] and level[pres[i]] <= level[par]:\n                return -1\n    pres = list(set(pres))\n    pres = sorted(pres, key=lambda i: level[i], reverse=True)\n    return (len(pres), [i + 1 for i in pres])"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if cp[i] == -1:",
      "mutated_line": "if cp[i] != -1:",
      "code": "from collections import deque\n\ndef generate_candidate_list(n, m, relations, preferences):\n    adj = [[] for _ in range(n)]\n    cp = [-1] * n\n    for (p, c) in relations:\n        adj[p - 1].append(c - 1)\n        cp[c - 1] = p - 1\n    pres = [pref - 1 for pref in preferences]\n    level = [0] * n\n\n    def bfs(v):\n        q = deque([v])\n        while q:\n            v = q.pop()\n            if cp[v] >= 0:\n                level[v] = level[cp[v]] + 1\n            for nv in adj[v]:\n                q.append(nv)\n    for i in range(n):\n        if cp[i] != -1:\n            bfs(i)\n    for i in range(n):\n        if level[i] > 0:\n            par = cp[i]\n            if pres[i] != pres[par] and level[pres[i]] <= level[par]:\n                return -1\n    pres = list(set(pres))\n    pres = sorted(pres, key=lambda i: level[i], reverse=True)\n    return (len(pres), [i + 1 for i in pres])"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if level[i] > 0:",
      "mutated_line": "if level[i] >= 0:",
      "code": "from collections import deque\n\ndef generate_candidate_list(n, m, relations, preferences):\n    adj = [[] for _ in range(n)]\n    cp = [-1] * n\n    for (p, c) in relations:\n        adj[p - 1].append(c - 1)\n        cp[c - 1] = p - 1\n    pres = [pref - 1 for pref in preferences]\n    level = [0] * n\n\n    def bfs(v):\n        q = deque([v])\n        while q:\n            v = q.pop()\n            if cp[v] >= 0:\n                level[v] = level[cp[v]] + 1\n            for nv in adj[v]:\n                q.append(nv)\n    for i in range(n):\n        if cp[i] == -1:\n            bfs(i)\n    for i in range(n):\n        if level[i] >= 0:\n            par = cp[i]\n            if pres[i] != pres[par] and level[pres[i]] <= level[par]:\n                return -1\n    pres = list(set(pres))\n    pres = sorted(pres, key=lambda i: level[i], reverse=True)\n    return (len(pres), [i + 1 for i in pres])"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if level[i] > 0:",
      "mutated_line": "if level[i] <= 0:",
      "code": "from collections import deque\n\ndef generate_candidate_list(n, m, relations, preferences):\n    adj = [[] for _ in range(n)]\n    cp = [-1] * n\n    for (p, c) in relations:\n        adj[p - 1].append(c - 1)\n        cp[c - 1] = p - 1\n    pres = [pref - 1 for pref in preferences]\n    level = [0] * n\n\n    def bfs(v):\n        q = deque([v])\n        while q:\n            v = q.pop()\n            if cp[v] >= 0:\n                level[v] = level[cp[v]] + 1\n            for nv in adj[v]:\n                q.append(nv)\n    for i in range(n):\n        if cp[i] == -1:\n            bfs(i)\n    for i in range(n):\n        if level[i] <= 0:\n            par = cp[i]\n            if pres[i] != pres[par] and level[pres[i]] <= level[par]:\n                return -1\n    pres = list(set(pres))\n    pres = sorted(pres, key=lambda i: level[i], reverse=True)\n    return (len(pres), [i + 1 for i in pres])"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if level[i] > 0:",
      "mutated_line": "if level[i] != 0:",
      "code": "from collections import deque\n\ndef generate_candidate_list(n, m, relations, preferences):\n    adj = [[] for _ in range(n)]\n    cp = [-1] * n\n    for (p, c) in relations:\n        adj[p - 1].append(c - 1)\n        cp[c - 1] = p - 1\n    pres = [pref - 1 for pref in preferences]\n    level = [0] * n\n\n    def bfs(v):\n        q = deque([v])\n        while q:\n            v = q.pop()\n            if cp[v] >= 0:\n                level[v] = level[cp[v]] + 1\n            for nv in adj[v]:\n                q.append(nv)\n    for i in range(n):\n        if cp[i] == -1:\n            bfs(i)\n    for i in range(n):\n        if level[i] != 0:\n            par = cp[i]\n            if pres[i] != pres[par] and level[pres[i]] <= level[par]:\n                return -1\n    pres = list(set(pres))\n    pres = sorted(pres, key=lambda i: level[i], reverse=True)\n    return (len(pres), [i + 1 for i in pres])"
    },
    {
      "operator": "UOI",
      "lineno": 5,
      "original_line": "cp = [-1] * n",
      "mutated_line": "cp = [+1] * n",
      "code": "from collections import deque\n\ndef generate_candidate_list(n, m, relations, preferences):\n    adj = [[] for _ in range(n)]\n    cp = [+1] * n\n    for (p, c) in relations:\n        adj[p - 1].append(c - 1)\n        cp[c - 1] = p - 1\n    pres = [pref - 1 for pref in preferences]\n    level = [0] * n\n\n    def bfs(v):\n        q = deque([v])\n        while q:\n            v = q.pop()\n            if cp[v] >= 0:\n                level[v] = level[cp[v]] + 1\n            for nv in adj[v]:\n                q.append(nv)\n    for i in range(n):\n        if cp[i] == -1:\n            bfs(i)\n    for i in range(n):\n        if level[i] > 0:\n            par = cp[i]\n            if pres[i] != pres[par] and level[pres[i]] <= level[par]:\n                return -1\n    pres = list(set(pres))\n    pres = sorted(pres, key=lambda i: level[i], reverse=True)\n    return (len(pres), [i + 1 for i in pres])"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "adj[p - 1].append(c - 1)",
      "mutated_line": "adj[p - 1].append(c + 1)",
      "code": "from collections import deque\n\ndef generate_candidate_list(n, m, relations, preferences):\n    adj = [[] for _ in range(n)]\n    cp = [-1] * n\n    for (p, c) in relations:\n        adj[p - 1].append(c + 1)\n        cp[c - 1] = p - 1\n    pres = [pref - 1 for pref in preferences]\n    level = [0] * n\n\n    def bfs(v):\n        q = deque([v])\n        while q:\n            v = q.pop()\n            if cp[v] >= 0:\n                level[v] = level[cp[v]] + 1\n            for nv in adj[v]:\n                q.append(nv)\n    for i in range(n):\n        if cp[i] == -1:\n            bfs(i)\n    for i in range(n):\n        if level[i] > 0:\n            par = cp[i]\n            if pres[i] != pres[par] and level[pres[i]] <= level[par]:\n                return -1\n    pres = list(set(pres))\n    pres = sorted(pres, key=lambda i: level[i], reverse=True)\n    return (len(pres), [i + 1 for i in pres])"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "adj[p - 1].append(c - 1)",
      "mutated_line": "adj[p - 1].append(c * 1)",
      "code": "from collections import deque\n\ndef generate_candidate_list(n, m, relations, preferences):\n    adj = [[] for _ in range(n)]\n    cp = [-1] * n\n    for (p, c) in relations:\n        adj[p - 1].append(c * 1)\n        cp[c - 1] = p - 1\n    pres = [pref - 1 for pref in preferences]\n    level = [0] * n\n\n    def bfs(v):\n        q = deque([v])\n        while q:\n            v = q.pop()\n            if cp[v] >= 0:\n                level[v] = level[cp[v]] + 1\n            for nv in adj[v]:\n                q.append(nv)\n    for i in range(n):\n        if cp[i] == -1:\n            bfs(i)\n    for i in range(n):\n        if level[i] > 0:\n            par = cp[i]\n            if pres[i] != pres[par] and level[pres[i]] <= level[par]:\n                return -1\n    pres = list(set(pres))\n    pres = sorted(pres, key=lambda i: level[i], reverse=True)\n    return (len(pres), [i + 1 for i in pres])"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "cp[c - 1] = p - 1",
      "mutated_line": "cp[c + 1] = p - 1",
      "code": "from collections import deque\n\ndef generate_candidate_list(n, m, relations, preferences):\n    adj = [[] for _ in range(n)]\n    cp = [-1] * n\n    for (p, c) in relations:\n        adj[p - 1].append(c - 1)\n        cp[c + 1] = p - 1\n    pres = [pref - 1 for pref in preferences]\n    level = [0] * n\n\n    def bfs(v):\n        q = deque([v])\n        while q:\n            v = q.pop()\n            if cp[v] >= 0:\n                level[v] = level[cp[v]] + 1\n            for nv in adj[v]:\n                q.append(nv)\n    for i in range(n):\n        if cp[i] == -1:\n            bfs(i)\n    for i in range(n):\n        if level[i] > 0:\n            par = cp[i]\n            if pres[i] != pres[par] and level[pres[i]] <= level[par]:\n                return -1\n    pres = list(set(pres))\n    pres = sorted(pres, key=lambda i: level[i], reverse=True)\n    return (len(pres), [i + 1 for i in pres])"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "cp[c - 1] = p - 1",
      "mutated_line": "cp[c * 1] = p - 1",
      "code": "from collections import deque\n\ndef generate_candidate_list(n, m, relations, preferences):\n    adj = [[] for _ in range(n)]\n    cp = [-1] * n\n    for (p, c) in relations:\n        adj[p - 1].append(c - 1)\n        cp[c * 1] = p - 1\n    pres = [pref - 1 for pref in preferences]\n    level = [0] * n\n\n    def bfs(v):\n        q = deque([v])\n        while q:\n            v = q.pop()\n            if cp[v] >= 0:\n                level[v] = level[cp[v]] + 1\n            for nv in adj[v]:\n                q.append(nv)\n    for i in range(n):\n        if cp[i] == -1:\n            bfs(i)\n    for i in range(n):\n        if level[i] > 0:\n            par = cp[i]\n            if pres[i] != pres[par] and level[pres[i]] <= level[par]:\n                return -1\n    pres = list(set(pres))\n    pres = sorted(pres, key=lambda i: level[i], reverse=True)\n    return (len(pres), [i + 1 for i in pres])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "cp[c - 1] = p - 1",
      "mutated_line": "cp[c - 1] = p - 2",
      "code": "from collections import deque\n\ndef generate_candidate_list(n, m, relations, preferences):\n    adj = [[] for _ in range(n)]\n    cp = [-1] * n\n    for (p, c) in relations:\n        adj[p - 1].append(c - 1)\n        cp[c - 1] = p - 2\n    pres = [pref - 1 for pref in preferences]\n    level = [0] * n\n\n    def bfs(v):\n        q = deque([v])\n        while q:\n            v = q.pop()\n            if cp[v] >= 0:\n                level[v] = level[cp[v]] + 1\n            for nv in adj[v]:\n                q.append(nv)\n    for i in range(n):\n        if cp[i] == -1:\n            bfs(i)\n    for i in range(n):\n        if level[i] > 0:\n            par = cp[i]\n            if pres[i] != pres[par] and level[pres[i]] <= level[par]:\n                return -1\n    pres = list(set(pres))\n    pres = sorted(pres, key=lambda i: level[i], reverse=True)\n    return (len(pres), [i + 1 for i in pres])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "cp[c - 1] = p - 1",
      "mutated_line": "cp[c - 1] = p - 0",
      "code": "from collections import deque\n\ndef generate_candidate_list(n, m, relations, preferences):\n    adj = [[] for _ in range(n)]\n    cp = [-1] * n\n    for (p, c) in relations:\n        adj[p - 1].append(c - 1)\n        cp[c - 1] = p - 0\n    pres = [pref - 1 for pref in preferences]\n    level = [0] * n\n\n    def bfs(v):\n        q = deque([v])\n        while q:\n            v = q.pop()\n            if cp[v] >= 0:\n                level[v] = level[cp[v]] + 1\n            for nv in adj[v]:\n                q.append(nv)\n    for i in range(n):\n        if cp[i] == -1:\n            bfs(i)\n    for i in range(n):\n        if level[i] > 0:\n            par = cp[i]\n            if pres[i] != pres[par] and level[pres[i]] <= level[par]:\n                return -1\n    pres = list(set(pres))\n    pres = sorted(pres, key=lambda i: level[i], reverse=True)\n    return (len(pres), [i + 1 for i in pres])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "cp[c - 1] = p - 1",
      "mutated_line": "cp[c - 1] = p - 0",
      "code": "from collections import deque\n\ndef generate_candidate_list(n, m, relations, preferences):\n    adj = [[] for _ in range(n)]\n    cp = [-1] * n\n    for (p, c) in relations:\n        adj[p - 1].append(c - 1)\n        cp[c - 1] = p - 0\n    pres = [pref - 1 for pref in preferences]\n    level = [0] * n\n\n    def bfs(v):\n        q = deque([v])\n        while q:\n            v = q.pop()\n            if cp[v] >= 0:\n                level[v] = level[cp[v]] + 1\n            for nv in adj[v]:\n                q.append(nv)\n    for i in range(n):\n        if cp[i] == -1:\n            bfs(i)\n    for i in range(n):\n        if level[i] > 0:\n            par = cp[i]\n            if pres[i] != pres[par] and level[pres[i]] <= level[par]:\n                return -1\n    pres = list(set(pres))\n    pres = sorted(pres, key=lambda i: level[i], reverse=True)\n    return (len(pres), [i + 1 for i in pres])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "cp[c - 1] = p - 1",
      "mutated_line": "cp[c - 1] = p - -1",
      "code": "from collections import deque\n\ndef generate_candidate_list(n, m, relations, preferences):\n    adj = [[] for _ in range(n)]\n    cp = [-1] * n\n    for (p, c) in relations:\n        adj[p - 1].append(c - 1)\n        cp[c - 1] = p - -1\n    pres = [pref - 1 for pref in preferences]\n    level = [0] * n\n\n    def bfs(v):\n        q = deque([v])\n        while q:\n            v = q.pop()\n            if cp[v] >= 0:\n                level[v] = level[cp[v]] + 1\n            for nv in adj[v]:\n                q.append(nv)\n    for i in range(n):\n        if cp[i] == -1:\n            bfs(i)\n    for i in range(n):\n        if level[i] > 0:\n            par = cp[i]\n            if pres[i] != pres[par] and level[pres[i]] <= level[par]:\n                return -1\n    pres = list(set(pres))\n    pres = sorted(pres, key=lambda i: level[i], reverse=True)\n    return (len(pres), [i + 1 for i in pres])"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "pres = [pref - 1 for pref in preferences]",
      "mutated_line": "pres = [pref - 2 for pref in preferences]",
      "code": "from collections import deque\n\ndef generate_candidate_list(n, m, relations, preferences):\n    adj = [[] for _ in range(n)]\n    cp = [-1] * n\n    for (p, c) in relations:\n        adj[p - 1].append(c - 1)\n        cp[c - 1] = p - 1\n    pres = [pref - 2 for pref in preferences]\n    level = [0] * n\n\n    def bfs(v):\n        q = deque([v])\n        while q:\n            v = q.pop()\n            if cp[v] >= 0:\n                level[v] = level[cp[v]] + 1\n            for nv in adj[v]:\n                q.append(nv)\n    for i in range(n):\n        if cp[i] == -1:\n            bfs(i)\n    for i in range(n):\n        if level[i] > 0:\n            par = cp[i]\n            if pres[i] != pres[par] and level[pres[i]] <= level[par]:\n                return -1\n    pres = list(set(pres))\n    pres = sorted(pres, key=lambda i: level[i], reverse=True)\n    return (len(pres), [i + 1 for i in pres])"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "pres = [pref - 1 for pref in preferences]",
      "mutated_line": "pres = [pref - 0 for pref in preferences]",
      "code": "from collections import deque\n\ndef generate_candidate_list(n, m, relations, preferences):\n    adj = [[] for _ in range(n)]\n    cp = [-1] * n\n    for (p, c) in relations:\n        adj[p - 1].append(c - 1)\n        cp[c - 1] = p - 1\n    pres = [pref - 0 for pref in preferences]\n    level = [0] * n\n\n    def bfs(v):\n        q = deque([v])\n        while q:\n            v = q.pop()\n            if cp[v] >= 0:\n                level[v] = level[cp[v]] + 1\n            for nv in adj[v]:\n                q.append(nv)\n    for i in range(n):\n        if cp[i] == -1:\n            bfs(i)\n    for i in range(n):\n        if level[i] > 0:\n            par = cp[i]\n            if pres[i] != pres[par] and level[pres[i]] <= level[par]:\n                return -1\n    pres = list(set(pres))\n    pres = sorted(pres, key=lambda i: level[i], reverse=True)\n    return (len(pres), [i + 1 for i in pres])"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "pres = [pref - 1 for pref in preferences]",
      "mutated_line": "pres = [pref - 0 for pref in preferences]",
      "code": "from collections import deque\n\ndef generate_candidate_list(n, m, relations, preferences):\n    adj = [[] for _ in range(n)]\n    cp = [-1] * n\n    for (p, c) in relations:\n        adj[p - 1].append(c - 1)\n        cp[c - 1] = p - 1\n    pres = [pref - 0 for pref in preferences]\n    level = [0] * n\n\n    def bfs(v):\n        q = deque([v])\n        while q:\n            v = q.pop()\n            if cp[v] >= 0:\n                level[v] = level[cp[v]] + 1\n            for nv in adj[v]:\n                q.append(nv)\n    for i in range(n):\n        if cp[i] == -1:\n            bfs(i)\n    for i in range(n):\n        if level[i] > 0:\n            par = cp[i]\n            if pres[i] != pres[par] and level[pres[i]] <= level[par]:\n                return -1\n    pres = list(set(pres))\n    pres = sorted(pres, key=lambda i: level[i], reverse=True)\n    return (len(pres), [i + 1 for i in pres])"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "pres = [pref - 1 for pref in preferences]",
      "mutated_line": "pres = [pref - -1 for pref in preferences]",
      "code": "from collections import deque\n\ndef generate_candidate_list(n, m, relations, preferences):\n    adj = [[] for _ in range(n)]\n    cp = [-1] * n\n    for (p, c) in relations:\n        adj[p - 1].append(c - 1)\n        cp[c - 1] = p - 1\n    pres = [pref - -1 for pref in preferences]\n    level = [0] * n\n\n    def bfs(v):\n        q = deque([v])\n        while q:\n            v = q.pop()\n            if cp[v] >= 0:\n                level[v] = level[cp[v]] + 1\n            for nv in adj[v]:\n                q.append(nv)\n    for i in range(n):\n        if cp[i] == -1:\n            bfs(i)\n    for i in range(n):\n        if level[i] > 0:\n            par = cp[i]\n            if pres[i] != pres[par] and level[pres[i]] <= level[par]:\n                return -1\n    pres = list(set(pres))\n    pres = sorted(pres, key=lambda i: level[i], reverse=True)\n    return (len(pres), [i + 1 for i in pres])"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "level = [0] * n",
      "mutated_line": "level = [1] * n",
      "code": "from collections import deque\n\ndef generate_candidate_list(n, m, relations, preferences):\n    adj = [[] for _ in range(n)]\n    cp = [-1] * n\n    for (p, c) in relations:\n        adj[p - 1].append(c - 1)\n        cp[c - 1] = p - 1\n    pres = [pref - 1 for pref in preferences]\n    level = [1] * n\n\n    def bfs(v):\n        q = deque([v])\n        while q:\n            v = q.pop()\n            if cp[v] >= 0:\n                level[v] = level[cp[v]] + 1\n            for nv in adj[v]:\n                q.append(nv)\n    for i in range(n):\n        if cp[i] == -1:\n            bfs(i)\n    for i in range(n):\n        if level[i] > 0:\n            par = cp[i]\n            if pres[i] != pres[par] and level[pres[i]] <= level[par]:\n                return -1\n    pres = list(set(pres))\n    pres = sorted(pres, key=lambda i: level[i], reverse=True)\n    return (len(pres), [i + 1 for i in pres])"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "level = [0] * n",
      "mutated_line": "level = [-1] * n",
      "code": "from collections import deque\n\ndef generate_candidate_list(n, m, relations, preferences):\n    adj = [[] for _ in range(n)]\n    cp = [-1] * n\n    for (p, c) in relations:\n        adj[p - 1].append(c - 1)\n        cp[c - 1] = p - 1\n    pres = [pref - 1 for pref in preferences]\n    level = [-1] * n\n\n    def bfs(v):\n        q = deque([v])\n        while q:\n            v = q.pop()\n            if cp[v] >= 0:\n                level[v] = level[cp[v]] + 1\n            for nv in adj[v]:\n                q.append(nv)\n    for i in range(n):\n        if cp[i] == -1:\n            bfs(i)\n    for i in range(n):\n        if level[i] > 0:\n            par = cp[i]\n            if pres[i] != pres[par] and level[pres[i]] <= level[par]:\n                return -1\n    pres = list(set(pres))\n    pres = sorted(pres, key=lambda i: level[i], reverse=True)\n    return (len(pres), [i + 1 for i in pres])"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "level = [0] * n",
      "mutated_line": "level = [1] * n",
      "code": "from collections import deque\n\ndef generate_candidate_list(n, m, relations, preferences):\n    adj = [[] for _ in range(n)]\n    cp = [-1] * n\n    for (p, c) in relations:\n        adj[p - 1].append(c - 1)\n        cp[c - 1] = p - 1\n    pres = [pref - 1 for pref in preferences]\n    level = [1] * n\n\n    def bfs(v):\n        q = deque([v])\n        while q:\n            v = q.pop()\n            if cp[v] >= 0:\n                level[v] = level[cp[v]] + 1\n            for nv in adj[v]:\n                q.append(nv)\n    for i in range(n):\n        if cp[i] == -1:\n            bfs(i)\n    for i in range(n):\n        if level[i] > 0:\n            par = cp[i]\n            if pres[i] != pres[par] and level[pres[i]] <= level[par]:\n                return -1\n    pres = list(set(pres))\n    pres = sorted(pres, key=lambda i: level[i], reverse=True)\n    return (len(pres), [i + 1 for i in pres])"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if cp[v] >= 0:",
      "mutated_line": "if cp[v] > 0:",
      "code": "from collections import deque\n\ndef generate_candidate_list(n, m, relations, preferences):\n    adj = [[] for _ in range(n)]\n    cp = [-1] * n\n    for (p, c) in relations:\n        adj[p - 1].append(c - 1)\n        cp[c - 1] = p - 1\n    pres = [pref - 1 for pref in preferences]\n    level = [0] * n\n\n    def bfs(v):\n        q = deque([v])\n        while q:\n            v = q.pop()\n            if cp[v] > 0:\n                level[v] = level[cp[v]] + 1\n            for nv in adj[v]:\n                q.append(nv)\n    for i in range(n):\n        if cp[i] == -1:\n            bfs(i)\n    for i in range(n):\n        if level[i] > 0:\n            par = cp[i]\n            if pres[i] != pres[par] and level[pres[i]] <= level[par]:\n                return -1\n    pres = list(set(pres))\n    pres = sorted(pres, key=lambda i: level[i], reverse=True)\n    return (len(pres), [i + 1 for i in pres])"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if cp[v] >= 0:",
      "mutated_line": "if cp[v] < 0:",
      "code": "from collections import deque\n\ndef generate_candidate_list(n, m, relations, preferences):\n    adj = [[] for _ in range(n)]\n    cp = [-1] * n\n    for (p, c) in relations:\n        adj[p - 1].append(c - 1)\n        cp[c - 1] = p - 1\n    pres = [pref - 1 for pref in preferences]\n    level = [0] * n\n\n    def bfs(v):\n        q = deque([v])\n        while q:\n            v = q.pop()\n            if cp[v] < 0:\n                level[v] = level[cp[v]] + 1\n            for nv in adj[v]:\n                q.append(nv)\n    for i in range(n):\n        if cp[i] == -1:\n            bfs(i)\n    for i in range(n):\n        if level[i] > 0:\n            par = cp[i]\n            if pres[i] != pres[par] and level[pres[i]] <= level[par]:\n                return -1\n    pres = list(set(pres))\n    pres = sorted(pres, key=lambda i: level[i], reverse=True)\n    return (len(pres), [i + 1 for i in pres])"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if cp[v] >= 0:",
      "mutated_line": "if cp[v] == 0:",
      "code": "from collections import deque\n\ndef generate_candidate_list(n, m, relations, preferences):\n    adj = [[] for _ in range(n)]\n    cp = [-1] * n\n    for (p, c) in relations:\n        adj[p - 1].append(c - 1)\n        cp[c - 1] = p - 1\n    pres = [pref - 1 for pref in preferences]\n    level = [0] * n\n\n    def bfs(v):\n        q = deque([v])\n        while q:\n            v = q.pop()\n            if cp[v] == 0:\n                level[v] = level[cp[v]] + 1\n            for nv in adj[v]:\n                q.append(nv)\n    for i in range(n):\n        if cp[i] == -1:\n            bfs(i)\n    for i in range(n):\n        if level[i] > 0:\n            par = cp[i]\n            if pres[i] != pres[par] and level[pres[i]] <= level[par]:\n                return -1\n    pres = list(set(pres))\n    pres = sorted(pres, key=lambda i: level[i], reverse=True)\n    return (len(pres), [i + 1 for i in pres])"
    },
    {
      "operator": "UOI",
      "lineno": 24,
      "original_line": "if cp[i] == -1:",
      "mutated_line": "if cp[i] == +1:",
      "code": "from collections import deque\n\ndef generate_candidate_list(n, m, relations, preferences):\n    adj = [[] for _ in range(n)]\n    cp = [-1] * n\n    for (p, c) in relations:\n        adj[p - 1].append(c - 1)\n        cp[c - 1] = p - 1\n    pres = [pref - 1 for pref in preferences]\n    level = [0] * n\n\n    def bfs(v):\n        q = deque([v])\n        while q:\n            v = q.pop()\n            if cp[v] >= 0:\n                level[v] = level[cp[v]] + 1\n            for nv in adj[v]:\n                q.append(nv)\n    for i in range(n):\n        if cp[i] == +1:\n            bfs(i)\n    for i in range(n):\n        if level[i] > 0:\n            par = cp[i]\n            if pres[i] != pres[par] and level[pres[i]] <= level[par]:\n                return -1\n    pres = list(set(pres))\n    pres = sorted(pres, key=lambda i: level[i], reverse=True)\n    return (len(pres), [i + 1 for i in pres])"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if level[i] > 0:",
      "mutated_line": "if level[i] > 1:",
      "code": "from collections import deque\n\ndef generate_candidate_list(n, m, relations, preferences):\n    adj = [[] for _ in range(n)]\n    cp = [-1] * n\n    for (p, c) in relations:\n        adj[p - 1].append(c - 1)\n        cp[c - 1] = p - 1\n    pres = [pref - 1 for pref in preferences]\n    level = [0] * n\n\n    def bfs(v):\n        q = deque([v])\n        while q:\n            v = q.pop()\n            if cp[v] >= 0:\n                level[v] = level[cp[v]] + 1\n            for nv in adj[v]:\n                q.append(nv)\n    for i in range(n):\n        if cp[i] == -1:\n            bfs(i)\n    for i in range(n):\n        if level[i] > 1:\n            par = cp[i]\n            if pres[i] != pres[par] and level[pres[i]] <= level[par]:\n                return -1\n    pres = list(set(pres))\n    pres = sorted(pres, key=lambda i: level[i], reverse=True)\n    return (len(pres), [i + 1 for i in pres])"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if level[i] > 0:",
      "mutated_line": "if level[i] > -1:",
      "code": "from collections import deque\n\ndef generate_candidate_list(n, m, relations, preferences):\n    adj = [[] for _ in range(n)]\n    cp = [-1] * n\n    for (p, c) in relations:\n        adj[p - 1].append(c - 1)\n        cp[c - 1] = p - 1\n    pres = [pref - 1 for pref in preferences]\n    level = [0] * n\n\n    def bfs(v):\n        q = deque([v])\n        while q:\n            v = q.pop()\n            if cp[v] >= 0:\n                level[v] = level[cp[v]] + 1\n            for nv in adj[v]:\n                q.append(nv)\n    for i in range(n):\n        if cp[i] == -1:\n            bfs(i)\n    for i in range(n):\n        if level[i] > -1:\n            par = cp[i]\n            if pres[i] != pres[par] and level[pres[i]] <= level[par]:\n                return -1\n    pres = list(set(pres))\n    pres = sorted(pres, key=lambda i: level[i], reverse=True)\n    return (len(pres), [i + 1 for i in pres])"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if level[i] > 0:",
      "mutated_line": "if level[i] > 1:",
      "code": "from collections import deque\n\ndef generate_candidate_list(n, m, relations, preferences):\n    adj = [[] for _ in range(n)]\n    cp = [-1] * n\n    for (p, c) in relations:\n        adj[p - 1].append(c - 1)\n        cp[c - 1] = p - 1\n    pres = [pref - 1 for pref in preferences]\n    level = [0] * n\n\n    def bfs(v):\n        q = deque([v])\n        while q:\n            v = q.pop()\n            if cp[v] >= 0:\n                level[v] = level[cp[v]] + 1\n            for nv in adj[v]:\n                q.append(nv)\n    for i in range(n):\n        if cp[i] == -1:\n            bfs(i)\n    for i in range(n):\n        if level[i] > 1:\n            par = cp[i]\n            if pres[i] != pres[par] and level[pres[i]] <= level[par]:\n                return -1\n    pres = list(set(pres))\n    pres = sorted(pres, key=lambda i: level[i], reverse=True)\n    return (len(pres), [i + 1 for i in pres])"
    },
    {
      "operator": "LCR",
      "lineno": 30,
      "original_line": "if pres[i] != pres[par] and level[pres[i]] <= level[par]:",
      "mutated_line": "if pres[i] != pres[par] or level[pres[i]] <= level[par]:",
      "code": "from collections import deque\n\ndef generate_candidate_list(n, m, relations, preferences):\n    adj = [[] for _ in range(n)]\n    cp = [-1] * n\n    for (p, c) in relations:\n        adj[p - 1].append(c - 1)\n        cp[c - 1] = p - 1\n    pres = [pref - 1 for pref in preferences]\n    level = [0] * n\n\n    def bfs(v):\n        q = deque([v])\n        while q:\n            v = q.pop()\n            if cp[v] >= 0:\n                level[v] = level[cp[v]] + 1\n            for nv in adj[v]:\n                q.append(nv)\n    for i in range(n):\n        if cp[i] == -1:\n            bfs(i)\n    for i in range(n):\n        if level[i] > 0:\n            par = cp[i]\n            if pres[i] != pres[par] or level[pres[i]] <= level[par]:\n                return -1\n    pres = list(set(pres))\n    pres = sorted(pres, key=lambda i: level[i], reverse=True)\n    return (len(pres), [i + 1 for i in pres])"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "pres = sorted(pres, key=lambda i: level[i], reverse=True)",
      "mutated_line": "pres = sorted(pres, key=lambda i: level[i], reverse=False)",
      "code": "from collections import deque\n\ndef generate_candidate_list(n, m, relations, preferences):\n    adj = [[] for _ in range(n)]\n    cp = [-1] * n\n    for (p, c) in relations:\n        adj[p - 1].append(c - 1)\n        cp[c - 1] = p - 1\n    pres = [pref - 1 for pref in preferences]\n    level = [0] * n\n\n    def bfs(v):\n        q = deque([v])\n        while q:\n            v = q.pop()\n            if cp[v] >= 0:\n                level[v] = level[cp[v]] + 1\n            for nv in adj[v]:\n                q.append(nv)\n    for i in range(n):\n        if cp[i] == -1:\n            bfs(i)\n    for i in range(n):\n        if level[i] > 0:\n            par = cp[i]\n            if pres[i] != pres[par] and level[pres[i]] <= level[par]:\n                return -1\n    pres = list(set(pres))\n    pres = sorted(pres, key=lambda i: level[i], reverse=False)\n    return (len(pres), [i + 1 for i in pres])"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "return len(pres), [i + 1 for i in pres]",
      "mutated_line": "return (len(pres), [i - 1 for i in pres])",
      "code": "from collections import deque\n\ndef generate_candidate_list(n, m, relations, preferences):\n    adj = [[] for _ in range(n)]\n    cp = [-1] * n\n    for (p, c) in relations:\n        adj[p - 1].append(c - 1)\n        cp[c - 1] = p - 1\n    pres = [pref - 1 for pref in preferences]\n    level = [0] * n\n\n    def bfs(v):\n        q = deque([v])\n        while q:\n            v = q.pop()\n            if cp[v] >= 0:\n                level[v] = level[cp[v]] + 1\n            for nv in adj[v]:\n                q.append(nv)\n    for i in range(n):\n        if cp[i] == -1:\n            bfs(i)\n    for i in range(n):\n        if level[i] > 0:\n            par = cp[i]\n            if pres[i] != pres[par] and level[pres[i]] <= level[par]:\n                return -1\n    pres = list(set(pres))\n    pres = sorted(pres, key=lambda i: level[i], reverse=True)\n    return (len(pres), [i - 1 for i in pres])"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "return len(pres), [i + 1 for i in pres]",
      "mutated_line": "return (len(pres), [i * 1 for i in pres])",
      "code": "from collections import deque\n\ndef generate_candidate_list(n, m, relations, preferences):\n    adj = [[] for _ in range(n)]\n    cp = [-1] * n\n    for (p, c) in relations:\n        adj[p - 1].append(c - 1)\n        cp[c - 1] = p - 1\n    pres = [pref - 1 for pref in preferences]\n    level = [0] * n\n\n    def bfs(v):\n        q = deque([v])\n        while q:\n            v = q.pop()\n            if cp[v] >= 0:\n                level[v] = level[cp[v]] + 1\n            for nv in adj[v]:\n                q.append(nv)\n    for i in range(n):\n        if cp[i] == -1:\n            bfs(i)\n    for i in range(n):\n        if level[i] > 0:\n            par = cp[i]\n            if pres[i] != pres[par] and level[pres[i]] <= level[par]:\n                return -1\n    pres = list(set(pres))\n    pres = sorted(pres, key=lambda i: level[i], reverse=True)\n    return (len(pres), [i * 1 for i in pres])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "cp = [-1] * n",
      "mutated_line": "cp = [-2] * n",
      "code": "from collections import deque\n\ndef generate_candidate_list(n, m, relations, preferences):\n    adj = [[] for _ in range(n)]\n    cp = [-2] * n\n    for (p, c) in relations:\n        adj[p - 1].append(c - 1)\n        cp[c - 1] = p - 1\n    pres = [pref - 1 for pref in preferences]\n    level = [0] * n\n\n    def bfs(v):\n        q = deque([v])\n        while q:\n            v = q.pop()\n            if cp[v] >= 0:\n                level[v] = level[cp[v]] + 1\n            for nv in adj[v]:\n                q.append(nv)\n    for i in range(n):\n        if cp[i] == -1:\n            bfs(i)\n    for i in range(n):\n        if level[i] > 0:\n            par = cp[i]\n            if pres[i] != pres[par] and level[pres[i]] <= level[par]:\n                return -1\n    pres = list(set(pres))\n    pres = sorted(pres, key=lambda i: level[i], reverse=True)\n    return (len(pres), [i + 1 for i in pres])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "cp = [-1] * n",
      "mutated_line": "cp = [-0] * n",
      "code": "from collections import deque\n\ndef generate_candidate_list(n, m, relations, preferences):\n    adj = [[] for _ in range(n)]\n    cp = [-0] * n\n    for (p, c) in relations:\n        adj[p - 1].append(c - 1)\n        cp[c - 1] = p - 1\n    pres = [pref - 1 for pref in preferences]\n    level = [0] * n\n\n    def bfs(v):\n        q = deque([v])\n        while q:\n            v = q.pop()\n            if cp[v] >= 0:\n                level[v] = level[cp[v]] + 1\n            for nv in adj[v]:\n                q.append(nv)\n    for i in range(n):\n        if cp[i] == -1:\n            bfs(i)\n    for i in range(n):\n        if level[i] > 0:\n            par = cp[i]\n            if pres[i] != pres[par] and level[pres[i]] <= level[par]:\n                return -1\n    pres = list(set(pres))\n    pres = sorted(pres, key=lambda i: level[i], reverse=True)\n    return (len(pres), [i + 1 for i in pres])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "cp = [-1] * n",
      "mutated_line": "cp = [-0] * n",
      "code": "from collections import deque\n\ndef generate_candidate_list(n, m, relations, preferences):\n    adj = [[] for _ in range(n)]\n    cp = [-0] * n\n    for (p, c) in relations:\n        adj[p - 1].append(c - 1)\n        cp[c - 1] = p - 1\n    pres = [pref - 1 for pref in preferences]\n    level = [0] * n\n\n    def bfs(v):\n        q = deque([v])\n        while q:\n            v = q.pop()\n            if cp[v] >= 0:\n                level[v] = level[cp[v]] + 1\n            for nv in adj[v]:\n                q.append(nv)\n    for i in range(n):\n        if cp[i] == -1:\n            bfs(i)\n    for i in range(n):\n        if level[i] > 0:\n            par = cp[i]\n            if pres[i] != pres[par] and level[pres[i]] <= level[par]:\n                return -1\n    pres = list(set(pres))\n    pres = sorted(pres, key=lambda i: level[i], reverse=True)\n    return (len(pres), [i + 1 for i in pres])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "cp = [-1] * n",
      "mutated_line": "cp = [--1] * n",
      "code": "from collections import deque\n\ndef generate_candidate_list(n, m, relations, preferences):\n    adj = [[] for _ in range(n)]\n    cp = [--1] * n\n    for (p, c) in relations:\n        adj[p - 1].append(c - 1)\n        cp[c - 1] = p - 1\n    pres = [pref - 1 for pref in preferences]\n    level = [0] * n\n\n    def bfs(v):\n        q = deque([v])\n        while q:\n            v = q.pop()\n            if cp[v] >= 0:\n                level[v] = level[cp[v]] + 1\n            for nv in adj[v]:\n                q.append(nv)\n    for i in range(n):\n        if cp[i] == -1:\n            bfs(i)\n    for i in range(n):\n        if level[i] > 0:\n            par = cp[i]\n            if pres[i] != pres[par] and level[pres[i]] <= level[par]:\n                return -1\n    pres = list(set(pres))\n    pres = sorted(pres, key=lambda i: level[i], reverse=True)\n    return (len(pres), [i + 1 for i in pres])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "adj[p - 1].append(c - 1)",
      "mutated_line": "adj[p - 1].append(c - 2)",
      "code": "from collections import deque\n\ndef generate_candidate_list(n, m, relations, preferences):\n    adj = [[] for _ in range(n)]\n    cp = [-1] * n\n    for (p, c) in relations:\n        adj[p - 1].append(c - 2)\n        cp[c - 1] = p - 1\n    pres = [pref - 1 for pref in preferences]\n    level = [0] * n\n\n    def bfs(v):\n        q = deque([v])\n        while q:\n            v = q.pop()\n            if cp[v] >= 0:\n                level[v] = level[cp[v]] + 1\n            for nv in adj[v]:\n                q.append(nv)\n    for i in range(n):\n        if cp[i] == -1:\n            bfs(i)\n    for i in range(n):\n        if level[i] > 0:\n            par = cp[i]\n            if pres[i] != pres[par] and level[pres[i]] <= level[par]:\n                return -1\n    pres = list(set(pres))\n    pres = sorted(pres, key=lambda i: level[i], reverse=True)\n    return (len(pres), [i + 1 for i in pres])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "adj[p - 1].append(c - 1)",
      "mutated_line": "adj[p - 1].append(c - 0)",
      "code": "from collections import deque\n\ndef generate_candidate_list(n, m, relations, preferences):\n    adj = [[] for _ in range(n)]\n    cp = [-1] * n\n    for (p, c) in relations:\n        adj[p - 1].append(c - 0)\n        cp[c - 1] = p - 1\n    pres = [pref - 1 for pref in preferences]\n    level = [0] * n\n\n    def bfs(v):\n        q = deque([v])\n        while q:\n            v = q.pop()\n            if cp[v] >= 0:\n                level[v] = level[cp[v]] + 1\n            for nv in adj[v]:\n                q.append(nv)\n    for i in range(n):\n        if cp[i] == -1:\n            bfs(i)\n    for i in range(n):\n        if level[i] > 0:\n            par = cp[i]\n            if pres[i] != pres[par] and level[pres[i]] <= level[par]:\n                return -1\n    pres = list(set(pres))\n    pres = sorted(pres, key=lambda i: level[i], reverse=True)\n    return (len(pres), [i + 1 for i in pres])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "adj[p - 1].append(c - 1)",
      "mutated_line": "adj[p - 1].append(c - 0)",
      "code": "from collections import deque\n\ndef generate_candidate_list(n, m, relations, preferences):\n    adj = [[] for _ in range(n)]\n    cp = [-1] * n\n    for (p, c) in relations:\n        adj[p - 1].append(c - 0)\n        cp[c - 1] = p - 1\n    pres = [pref - 1 for pref in preferences]\n    level = [0] * n\n\n    def bfs(v):\n        q = deque([v])\n        while q:\n            v = q.pop()\n            if cp[v] >= 0:\n                level[v] = level[cp[v]] + 1\n            for nv in adj[v]:\n                q.append(nv)\n    for i in range(n):\n        if cp[i] == -1:\n            bfs(i)\n    for i in range(n):\n        if level[i] > 0:\n            par = cp[i]\n            if pres[i] != pres[par] and level[pres[i]] <= level[par]:\n                return -1\n    pres = list(set(pres))\n    pres = sorted(pres, key=lambda i: level[i], reverse=True)\n    return (len(pres), [i + 1 for i in pres])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "adj[p - 1].append(c - 1)",
      "mutated_line": "adj[p - 1].append(c - -1)",
      "code": "from collections import deque\n\ndef generate_candidate_list(n, m, relations, preferences):\n    adj = [[] for _ in range(n)]\n    cp = [-1] * n\n    for (p, c) in relations:\n        adj[p - 1].append(c - -1)\n        cp[c - 1] = p - 1\n    pres = [pref - 1 for pref in preferences]\n    level = [0] * n\n\n    def bfs(v):\n        q = deque([v])\n        while q:\n            v = q.pop()\n            if cp[v] >= 0:\n                level[v] = level[cp[v]] + 1\n            for nv in adj[v]:\n                q.append(nv)\n    for i in range(n):\n        if cp[i] == -1:\n            bfs(i)\n    for i in range(n):\n        if level[i] > 0:\n            par = cp[i]\n            if pres[i] != pres[par] and level[pres[i]] <= level[par]:\n                return -1\n    pres = list(set(pres))\n    pres = sorted(pres, key=lambda i: level[i], reverse=True)\n    return (len(pres), [i + 1 for i in pres])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "cp[c - 1] = p - 1",
      "mutated_line": "cp[c - 2] = p - 1",
      "code": "from collections import deque\n\ndef generate_candidate_list(n, m, relations, preferences):\n    adj = [[] for _ in range(n)]\n    cp = [-1] * n\n    for (p, c) in relations:\n        adj[p - 1].append(c - 1)\n        cp[c - 2] = p - 1\n    pres = [pref - 1 for pref in preferences]\n    level = [0] * n\n\n    def bfs(v):\n        q = deque([v])\n        while q:\n            v = q.pop()\n            if cp[v] >= 0:\n                level[v] = level[cp[v]] + 1\n            for nv in adj[v]:\n                q.append(nv)\n    for i in range(n):\n        if cp[i] == -1:\n            bfs(i)\n    for i in range(n):\n        if level[i] > 0:\n            par = cp[i]\n            if pres[i] != pres[par] and level[pres[i]] <= level[par]:\n                return -1\n    pres = list(set(pres))\n    pres = sorted(pres, key=lambda i: level[i], reverse=True)\n    return (len(pres), [i + 1 for i in pres])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "cp[c - 1] = p - 1",
      "mutated_line": "cp[c - 0] = p - 1",
      "code": "from collections import deque\n\ndef generate_candidate_list(n, m, relations, preferences):\n    adj = [[] for _ in range(n)]\n    cp = [-1] * n\n    for (p, c) in relations:\n        adj[p - 1].append(c - 1)\n        cp[c - 0] = p - 1\n    pres = [pref - 1 for pref in preferences]\n    level = [0] * n\n\n    def bfs(v):\n        q = deque([v])\n        while q:\n            v = q.pop()\n            if cp[v] >= 0:\n                level[v] = level[cp[v]] + 1\n            for nv in adj[v]:\n                q.append(nv)\n    for i in range(n):\n        if cp[i] == -1:\n            bfs(i)\n    for i in range(n):\n        if level[i] > 0:\n            par = cp[i]\n            if pres[i] != pres[par] and level[pres[i]] <= level[par]:\n                return -1\n    pres = list(set(pres))\n    pres = sorted(pres, key=lambda i: level[i], reverse=True)\n    return (len(pres), [i + 1 for i in pres])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "cp[c - 1] = p - 1",
      "mutated_line": "cp[c - 0] = p - 1",
      "code": "from collections import deque\n\ndef generate_candidate_list(n, m, relations, preferences):\n    adj = [[] for _ in range(n)]\n    cp = [-1] * n\n    for (p, c) in relations:\n        adj[p - 1].append(c - 1)\n        cp[c - 0] = p - 1\n    pres = [pref - 1 for pref in preferences]\n    level = [0] * n\n\n    def bfs(v):\n        q = deque([v])\n        while q:\n            v = q.pop()\n            if cp[v] >= 0:\n                level[v] = level[cp[v]] + 1\n            for nv in adj[v]:\n                q.append(nv)\n    for i in range(n):\n        if cp[i] == -1:\n            bfs(i)\n    for i in range(n):\n        if level[i] > 0:\n            par = cp[i]\n            if pres[i] != pres[par] and level[pres[i]] <= level[par]:\n                return -1\n    pres = list(set(pres))\n    pres = sorted(pres, key=lambda i: level[i], reverse=True)\n    return (len(pres), [i + 1 for i in pres])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "cp[c - 1] = p - 1",
      "mutated_line": "cp[c - -1] = p - 1",
      "code": "from collections import deque\n\ndef generate_candidate_list(n, m, relations, preferences):\n    adj = [[] for _ in range(n)]\n    cp = [-1] * n\n    for (p, c) in relations:\n        adj[p - 1].append(c - 1)\n        cp[c - -1] = p - 1\n    pres = [pref - 1 for pref in preferences]\n    level = [0] * n\n\n    def bfs(v):\n        q = deque([v])\n        while q:\n            v = q.pop()\n            if cp[v] >= 0:\n                level[v] = level[cp[v]] + 1\n            for nv in adj[v]:\n                q.append(nv)\n    for i in range(n):\n        if cp[i] == -1:\n            bfs(i)\n    for i in range(n):\n        if level[i] > 0:\n            par = cp[i]\n            if pres[i] != pres[par] and level[pres[i]] <= level[par]:\n                return -1\n    pres = list(set(pres))\n    pres = sorted(pres, key=lambda i: level[i], reverse=True)\n    return (len(pres), [i + 1 for i in pres])"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if cp[v] >= 0:",
      "mutated_line": "if cp[v] >= 1:",
      "code": "from collections import deque\n\ndef generate_candidate_list(n, m, relations, preferences):\n    adj = [[] for _ in range(n)]\n    cp = [-1] * n\n    for (p, c) in relations:\n        adj[p - 1].append(c - 1)\n        cp[c - 1] = p - 1\n    pres = [pref - 1 for pref in preferences]\n    level = [0] * n\n\n    def bfs(v):\n        q = deque([v])\n        while q:\n            v = q.pop()\n            if cp[v] >= 1:\n                level[v] = level[cp[v]] + 1\n            for nv in adj[v]:\n                q.append(nv)\n    for i in range(n):\n        if cp[i] == -1:\n            bfs(i)\n    for i in range(n):\n        if level[i] > 0:\n            par = cp[i]\n            if pres[i] != pres[par] and level[pres[i]] <= level[par]:\n                return -1\n    pres = list(set(pres))\n    pres = sorted(pres, key=lambda i: level[i], reverse=True)\n    return (len(pres), [i + 1 for i in pres])"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if cp[v] >= 0:",
      "mutated_line": "if cp[v] >= -1:",
      "code": "from collections import deque\n\ndef generate_candidate_list(n, m, relations, preferences):\n    adj = [[] for _ in range(n)]\n    cp = [-1] * n\n    for (p, c) in relations:\n        adj[p - 1].append(c - 1)\n        cp[c - 1] = p - 1\n    pres = [pref - 1 for pref in preferences]\n    level = [0] * n\n\n    def bfs(v):\n        q = deque([v])\n        while q:\n            v = q.pop()\n            if cp[v] >= -1:\n                level[v] = level[cp[v]] + 1\n            for nv in adj[v]:\n                q.append(nv)\n    for i in range(n):\n        if cp[i] == -1:\n            bfs(i)\n    for i in range(n):\n        if level[i] > 0:\n            par = cp[i]\n            if pres[i] != pres[par] and level[pres[i]] <= level[par]:\n                return -1\n    pres = list(set(pres))\n    pres = sorted(pres, key=lambda i: level[i], reverse=True)\n    return (len(pres), [i + 1 for i in pres])"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if cp[v] >= 0:",
      "mutated_line": "if cp[v] >= 1:",
      "code": "from collections import deque\n\ndef generate_candidate_list(n, m, relations, preferences):\n    adj = [[] for _ in range(n)]\n    cp = [-1] * n\n    for (p, c) in relations:\n        adj[p - 1].append(c - 1)\n        cp[c - 1] = p - 1\n    pres = [pref - 1 for pref in preferences]\n    level = [0] * n\n\n    def bfs(v):\n        q = deque([v])\n        while q:\n            v = q.pop()\n            if cp[v] >= 1:\n                level[v] = level[cp[v]] + 1\n            for nv in adj[v]:\n                q.append(nv)\n    for i in range(n):\n        if cp[i] == -1:\n            bfs(i)\n    for i in range(n):\n        if level[i] > 0:\n            par = cp[i]\n            if pres[i] != pres[par] and level[pres[i]] <= level[par]:\n                return -1\n    pres = list(set(pres))\n    pres = sorted(pres, key=lambda i: level[i], reverse=True)\n    return (len(pres), [i + 1 for i in pres])"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "level[v] = level[cp[v]] + 1",
      "mutated_line": "level[v] = level[cp[v]] - 1",
      "code": "from collections import deque\n\ndef generate_candidate_list(n, m, relations, preferences):\n    adj = [[] for _ in range(n)]\n    cp = [-1] * n\n    for (p, c) in relations:\n        adj[p - 1].append(c - 1)\n        cp[c - 1] = p - 1\n    pres = [pref - 1 for pref in preferences]\n    level = [0] * n\n\n    def bfs(v):\n        q = deque([v])\n        while q:\n            v = q.pop()\n            if cp[v] >= 0:\n                level[v] = level[cp[v]] - 1\n            for nv in adj[v]:\n                q.append(nv)\n    for i in range(n):\n        if cp[i] == -1:\n            bfs(i)\n    for i in range(n):\n        if level[i] > 0:\n            par = cp[i]\n            if pres[i] != pres[par] and level[pres[i]] <= level[par]:\n                return -1\n    pres = list(set(pres))\n    pres = sorted(pres, key=lambda i: level[i], reverse=True)\n    return (len(pres), [i + 1 for i in pres])"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "level[v] = level[cp[v]] + 1",
      "mutated_line": "level[v] = level[cp[v]] * 1",
      "code": "from collections import deque\n\ndef generate_candidate_list(n, m, relations, preferences):\n    adj = [[] for _ in range(n)]\n    cp = [-1] * n\n    for (p, c) in relations:\n        adj[p - 1].append(c - 1)\n        cp[c - 1] = p - 1\n    pres = [pref - 1 for pref in preferences]\n    level = [0] * n\n\n    def bfs(v):\n        q = deque([v])\n        while q:\n            v = q.pop()\n            if cp[v] >= 0:\n                level[v] = level[cp[v]] * 1\n            for nv in adj[v]:\n                q.append(nv)\n    for i in range(n):\n        if cp[i] == -1:\n            bfs(i)\n    for i in range(n):\n        if level[i] > 0:\n            par = cp[i]\n            if pres[i] != pres[par] and level[pres[i]] <= level[par]:\n                return -1\n    pres = list(set(pres))\n    pres = sorted(pres, key=lambda i: level[i], reverse=True)\n    return (len(pres), [i + 1 for i in pres])"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if cp[i] == -1:",
      "mutated_line": "if cp[i] == -2:",
      "code": "from collections import deque\n\ndef generate_candidate_list(n, m, relations, preferences):\n    adj = [[] for _ in range(n)]\n    cp = [-1] * n\n    for (p, c) in relations:\n        adj[p - 1].append(c - 1)\n        cp[c - 1] = p - 1\n    pres = [pref - 1 for pref in preferences]\n    level = [0] * n\n\n    def bfs(v):\n        q = deque([v])\n        while q:\n            v = q.pop()\n            if cp[v] >= 0:\n                level[v] = level[cp[v]] + 1\n            for nv in adj[v]:\n                q.append(nv)\n    for i in range(n):\n        if cp[i] == -2:\n            bfs(i)\n    for i in range(n):\n        if level[i] > 0:\n            par = cp[i]\n            if pres[i] != pres[par] and level[pres[i]] <= level[par]:\n                return -1\n    pres = list(set(pres))\n    pres = sorted(pres, key=lambda i: level[i], reverse=True)\n    return (len(pres), [i + 1 for i in pres])"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if cp[i] == -1:",
      "mutated_line": "if cp[i] == -0:",
      "code": "from collections import deque\n\ndef generate_candidate_list(n, m, relations, preferences):\n    adj = [[] for _ in range(n)]\n    cp = [-1] * n\n    for (p, c) in relations:\n        adj[p - 1].append(c - 1)\n        cp[c - 1] = p - 1\n    pres = [pref - 1 for pref in preferences]\n    level = [0] * n\n\n    def bfs(v):\n        q = deque([v])\n        while q:\n            v = q.pop()\n            if cp[v] >= 0:\n                level[v] = level[cp[v]] + 1\n            for nv in adj[v]:\n                q.append(nv)\n    for i in range(n):\n        if cp[i] == -0:\n            bfs(i)\n    for i in range(n):\n        if level[i] > 0:\n            par = cp[i]\n            if pres[i] != pres[par] and level[pres[i]] <= level[par]:\n                return -1\n    pres = list(set(pres))\n    pres = sorted(pres, key=lambda i: level[i], reverse=True)\n    return (len(pres), [i + 1 for i in pres])"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if cp[i] == -1:",
      "mutated_line": "if cp[i] == -0:",
      "code": "from collections import deque\n\ndef generate_candidate_list(n, m, relations, preferences):\n    adj = [[] for _ in range(n)]\n    cp = [-1] * n\n    for (p, c) in relations:\n        adj[p - 1].append(c - 1)\n        cp[c - 1] = p - 1\n    pres = [pref - 1 for pref in preferences]\n    level = [0] * n\n\n    def bfs(v):\n        q = deque([v])\n        while q:\n            v = q.pop()\n            if cp[v] >= 0:\n                level[v] = level[cp[v]] + 1\n            for nv in adj[v]:\n                q.append(nv)\n    for i in range(n):\n        if cp[i] == -0:\n            bfs(i)\n    for i in range(n):\n        if level[i] > 0:\n            par = cp[i]\n            if pres[i] != pres[par] and level[pres[i]] <= level[par]:\n                return -1\n    pres = list(set(pres))\n    pres = sorted(pres, key=lambda i: level[i], reverse=True)\n    return (len(pres), [i + 1 for i in pres])"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if cp[i] == -1:",
      "mutated_line": "if cp[i] == --1:",
      "code": "from collections import deque\n\ndef generate_candidate_list(n, m, relations, preferences):\n    adj = [[] for _ in range(n)]\n    cp = [-1] * n\n    for (p, c) in relations:\n        adj[p - 1].append(c - 1)\n        cp[c - 1] = p - 1\n    pres = [pref - 1 for pref in preferences]\n    level = [0] * n\n\n    def bfs(v):\n        q = deque([v])\n        while q:\n            v = q.pop()\n            if cp[v] >= 0:\n                level[v] = level[cp[v]] + 1\n            for nv in adj[v]:\n                q.append(nv)\n    for i in range(n):\n        if cp[i] == --1:\n            bfs(i)\n    for i in range(n):\n        if level[i] > 0:\n            par = cp[i]\n            if pres[i] != pres[par] and level[pres[i]] <= level[par]:\n                return -1\n    pres = list(set(pres))\n    pres = sorted(pres, key=lambda i: level[i], reverse=True)\n    return (len(pres), [i + 1 for i in pres])"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if pres[i] != pres[par] and level[pres[i]] <= level[par]:",
      "mutated_line": "if pres[i] == pres[par] and level[pres[i]] <= level[par]:",
      "code": "from collections import deque\n\ndef generate_candidate_list(n, m, relations, preferences):\n    adj = [[] for _ in range(n)]\n    cp = [-1] * n\n    for (p, c) in relations:\n        adj[p - 1].append(c - 1)\n        cp[c - 1] = p - 1\n    pres = [pref - 1 for pref in preferences]\n    level = [0] * n\n\n    def bfs(v):\n        q = deque([v])\n        while q:\n            v = q.pop()\n            if cp[v] >= 0:\n                level[v] = level[cp[v]] + 1\n            for nv in adj[v]:\n                q.append(nv)\n    for i in range(n):\n        if cp[i] == -1:\n            bfs(i)\n    for i in range(n):\n        if level[i] > 0:\n            par = cp[i]\n            if pres[i] == pres[par] and level[pres[i]] <= level[par]:\n                return -1\n    pres = list(set(pres))\n    pres = sorted(pres, key=lambda i: level[i], reverse=True)\n    return (len(pres), [i + 1 for i in pres])"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if pres[i] != pres[par] and level[pres[i]] <= level[par]:",
      "mutated_line": "if pres[i] != pres[par] and level[pres[i]] < level[par]:",
      "code": "from collections import deque\n\ndef generate_candidate_list(n, m, relations, preferences):\n    adj = [[] for _ in range(n)]\n    cp = [-1] * n\n    for (p, c) in relations:\n        adj[p - 1].append(c - 1)\n        cp[c - 1] = p - 1\n    pres = [pref - 1 for pref in preferences]\n    level = [0] * n\n\n    def bfs(v):\n        q = deque([v])\n        while q:\n            v = q.pop()\n            if cp[v] >= 0:\n                level[v] = level[cp[v]] + 1\n            for nv in adj[v]:\n                q.append(nv)\n    for i in range(n):\n        if cp[i] == -1:\n            bfs(i)\n    for i in range(n):\n        if level[i] > 0:\n            par = cp[i]\n            if pres[i] != pres[par] and level[pres[i]] < level[par]:\n                return -1\n    pres = list(set(pres))\n    pres = sorted(pres, key=lambda i: level[i], reverse=True)\n    return (len(pres), [i + 1 for i in pres])"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if pres[i] != pres[par] and level[pres[i]] <= level[par]:",
      "mutated_line": "if pres[i] != pres[par] and level[pres[i]] > level[par]:",
      "code": "from collections import deque\n\ndef generate_candidate_list(n, m, relations, preferences):\n    adj = [[] for _ in range(n)]\n    cp = [-1] * n\n    for (p, c) in relations:\n        adj[p - 1].append(c - 1)\n        cp[c - 1] = p - 1\n    pres = [pref - 1 for pref in preferences]\n    level = [0] * n\n\n    def bfs(v):\n        q = deque([v])\n        while q:\n            v = q.pop()\n            if cp[v] >= 0:\n                level[v] = level[cp[v]] + 1\n            for nv in adj[v]:\n                q.append(nv)\n    for i in range(n):\n        if cp[i] == -1:\n            bfs(i)\n    for i in range(n):\n        if level[i] > 0:\n            par = cp[i]\n            if pres[i] != pres[par] and level[pres[i]] > level[par]:\n                return -1\n    pres = list(set(pres))\n    pres = sorted(pres, key=lambda i: level[i], reverse=True)\n    return (len(pres), [i + 1 for i in pres])"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if pres[i] != pres[par] and level[pres[i]] <= level[par]:",
      "mutated_line": "if pres[i] != pres[par] and level[pres[i]] == level[par]:",
      "code": "from collections import deque\n\ndef generate_candidate_list(n, m, relations, preferences):\n    adj = [[] for _ in range(n)]\n    cp = [-1] * n\n    for (p, c) in relations:\n        adj[p - 1].append(c - 1)\n        cp[c - 1] = p - 1\n    pres = [pref - 1 for pref in preferences]\n    level = [0] * n\n\n    def bfs(v):\n        q = deque([v])\n        while q:\n            v = q.pop()\n            if cp[v] >= 0:\n                level[v] = level[cp[v]] + 1\n            for nv in adj[v]:\n                q.append(nv)\n    for i in range(n):\n        if cp[i] == -1:\n            bfs(i)\n    for i in range(n):\n        if level[i] > 0:\n            par = cp[i]\n            if pres[i] != pres[par] and level[pres[i]] == level[par]:\n                return -1\n    pres = list(set(pres))\n    pres = sorted(pres, key=lambda i: level[i], reverse=True)\n    return (len(pres), [i + 1 for i in pres])"
    },
    {
      "operator": "UOI",
      "lineno": 31,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "from collections import deque\n\ndef generate_candidate_list(n, m, relations, preferences):\n    adj = [[] for _ in range(n)]\n    cp = [-1] * n\n    for (p, c) in relations:\n        adj[p - 1].append(c - 1)\n        cp[c - 1] = p - 1\n    pres = [pref - 1 for pref in preferences]\n    level = [0] * n\n\n    def bfs(v):\n        q = deque([v])\n        while q:\n            v = q.pop()\n            if cp[v] >= 0:\n                level[v] = level[cp[v]] + 1\n            for nv in adj[v]:\n                q.append(nv)\n    for i in range(n):\n        if cp[i] == -1:\n            bfs(i)\n    for i in range(n):\n        if level[i] > 0:\n            par = cp[i]\n            if pres[i] != pres[par] and level[pres[i]] <= level[par]:\n                return +1\n    pres = list(set(pres))\n    pres = sorted(pres, key=lambda i: level[i], reverse=True)\n    return (len(pres), [i + 1 for i in pres])"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return len(pres), [i + 1 for i in pres]",
      "mutated_line": "return (len(pres), [i + 2 for i in pres])",
      "code": "from collections import deque\n\ndef generate_candidate_list(n, m, relations, preferences):\n    adj = [[] for _ in range(n)]\n    cp = [-1] * n\n    for (p, c) in relations:\n        adj[p - 1].append(c - 1)\n        cp[c - 1] = p - 1\n    pres = [pref - 1 for pref in preferences]\n    level = [0] * n\n\n    def bfs(v):\n        q = deque([v])\n        while q:\n            v = q.pop()\n            if cp[v] >= 0:\n                level[v] = level[cp[v]] + 1\n            for nv in adj[v]:\n                q.append(nv)\n    for i in range(n):\n        if cp[i] == -1:\n            bfs(i)\n    for i in range(n):\n        if level[i] > 0:\n            par = cp[i]\n            if pres[i] != pres[par] and level[pres[i]] <= level[par]:\n                return -1\n    pres = list(set(pres))\n    pres = sorted(pres, key=lambda i: level[i], reverse=True)\n    return (len(pres), [i + 2 for i in pres])"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return len(pres), [i + 1 for i in pres]",
      "mutated_line": "return (len(pres), [i + 0 for i in pres])",
      "code": "from collections import deque\n\ndef generate_candidate_list(n, m, relations, preferences):\n    adj = [[] for _ in range(n)]\n    cp = [-1] * n\n    for (p, c) in relations:\n        adj[p - 1].append(c - 1)\n        cp[c - 1] = p - 1\n    pres = [pref - 1 for pref in preferences]\n    level = [0] * n\n\n    def bfs(v):\n        q = deque([v])\n        while q:\n            v = q.pop()\n            if cp[v] >= 0:\n                level[v] = level[cp[v]] + 1\n            for nv in adj[v]:\n                q.append(nv)\n    for i in range(n):\n        if cp[i] == -1:\n            bfs(i)\n    for i in range(n):\n        if level[i] > 0:\n            par = cp[i]\n            if pres[i] != pres[par] and level[pres[i]] <= level[par]:\n                return -1\n    pres = list(set(pres))\n    pres = sorted(pres, key=lambda i: level[i], reverse=True)\n    return (len(pres), [i + 0 for i in pres])"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return len(pres), [i + 1 for i in pres]",
      "mutated_line": "return (len(pres), [i + 0 for i in pres])",
      "code": "from collections import deque\n\ndef generate_candidate_list(n, m, relations, preferences):\n    adj = [[] for _ in range(n)]\n    cp = [-1] * n\n    for (p, c) in relations:\n        adj[p - 1].append(c - 1)\n        cp[c - 1] = p - 1\n    pres = [pref - 1 for pref in preferences]\n    level = [0] * n\n\n    def bfs(v):\n        q = deque([v])\n        while q:\n            v = q.pop()\n            if cp[v] >= 0:\n                level[v] = level[cp[v]] + 1\n            for nv in adj[v]:\n                q.append(nv)\n    for i in range(n):\n        if cp[i] == -1:\n            bfs(i)\n    for i in range(n):\n        if level[i] > 0:\n            par = cp[i]\n            if pres[i] != pres[par] and level[pres[i]] <= level[par]:\n                return -1\n    pres = list(set(pres))\n    pres = sorted(pres, key=lambda i: level[i], reverse=True)\n    return (len(pres), [i + 0 for i in pres])"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return len(pres), [i + 1 for i in pres]",
      "mutated_line": "return (len(pres), [i + -1 for i in pres])",
      "code": "from collections import deque\n\ndef generate_candidate_list(n, m, relations, preferences):\n    adj = [[] for _ in range(n)]\n    cp = [-1] * n\n    for (p, c) in relations:\n        adj[p - 1].append(c - 1)\n        cp[c - 1] = p - 1\n    pres = [pref - 1 for pref in preferences]\n    level = [0] * n\n\n    def bfs(v):\n        q = deque([v])\n        while q:\n            v = q.pop()\n            if cp[v] >= 0:\n                level[v] = level[cp[v]] + 1\n            for nv in adj[v]:\n                q.append(nv)\n    for i in range(n):\n        if cp[i] == -1:\n            bfs(i)\n    for i in range(n):\n        if level[i] > 0:\n            par = cp[i]\n            if pres[i] != pres[par] and level[pres[i]] <= level[par]:\n                return -1\n    pres = list(set(pres))\n    pres = sorted(pres, key=lambda i: level[i], reverse=True)\n    return (len(pres), [i + -1 for i in pres])"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "adj[p - 1].append(c - 1)",
      "mutated_line": "adj[p + 1].append(c - 1)",
      "code": "from collections import deque\n\ndef generate_candidate_list(n, m, relations, preferences):\n    adj = [[] for _ in range(n)]\n    cp = [-1] * n\n    for (p, c) in relations:\n        adj[p + 1].append(c - 1)\n        cp[c - 1] = p - 1\n    pres = [pref - 1 for pref in preferences]\n    level = [0] * n\n\n    def bfs(v):\n        q = deque([v])\n        while q:\n            v = q.pop()\n            if cp[v] >= 0:\n                level[v] = level[cp[v]] + 1\n            for nv in adj[v]:\n                q.append(nv)\n    for i in range(n):\n        if cp[i] == -1:\n            bfs(i)\n    for i in range(n):\n        if level[i] > 0:\n            par = cp[i]\n            if pres[i] != pres[par] and level[pres[i]] <= level[par]:\n                return -1\n    pres = list(set(pres))\n    pres = sorted(pres, key=lambda i: level[i], reverse=True)\n    return (len(pres), [i + 1 for i in pres])"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "adj[p - 1].append(c - 1)",
      "mutated_line": "adj[p * 1].append(c - 1)",
      "code": "from collections import deque\n\ndef generate_candidate_list(n, m, relations, preferences):\n    adj = [[] for _ in range(n)]\n    cp = [-1] * n\n    for (p, c) in relations:\n        adj[p * 1].append(c - 1)\n        cp[c - 1] = p - 1\n    pres = [pref - 1 for pref in preferences]\n    level = [0] * n\n\n    def bfs(v):\n        q = deque([v])\n        while q:\n            v = q.pop()\n            if cp[v] >= 0:\n                level[v] = level[cp[v]] + 1\n            for nv in adj[v]:\n                q.append(nv)\n    for i in range(n):\n        if cp[i] == -1:\n            bfs(i)\n    for i in range(n):\n        if level[i] > 0:\n            par = cp[i]\n            if pres[i] != pres[par] and level[pres[i]] <= level[par]:\n                return -1\n    pres = list(set(pres))\n    pres = sorted(pres, key=lambda i: level[i], reverse=True)\n    return (len(pres), [i + 1 for i in pres])"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "level[v] = level[cp[v]] + 1",
      "mutated_line": "level[v] = level[cp[v]] + 2",
      "code": "from collections import deque\n\ndef generate_candidate_list(n, m, relations, preferences):\n    adj = [[] for _ in range(n)]\n    cp = [-1] * n\n    for (p, c) in relations:\n        adj[p - 1].append(c - 1)\n        cp[c - 1] = p - 1\n    pres = [pref - 1 for pref in preferences]\n    level = [0] * n\n\n    def bfs(v):\n        q = deque([v])\n        while q:\n            v = q.pop()\n            if cp[v] >= 0:\n                level[v] = level[cp[v]] + 2\n            for nv in adj[v]:\n                q.append(nv)\n    for i in range(n):\n        if cp[i] == -1:\n            bfs(i)\n    for i in range(n):\n        if level[i] > 0:\n            par = cp[i]\n            if pres[i] != pres[par] and level[pres[i]] <= level[par]:\n                return -1\n    pres = list(set(pres))\n    pres = sorted(pres, key=lambda i: level[i], reverse=True)\n    return (len(pres), [i + 1 for i in pres])"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "level[v] = level[cp[v]] + 1",
      "mutated_line": "level[v] = level[cp[v]] + 0",
      "code": "from collections import deque\n\ndef generate_candidate_list(n, m, relations, preferences):\n    adj = [[] for _ in range(n)]\n    cp = [-1] * n\n    for (p, c) in relations:\n        adj[p - 1].append(c - 1)\n        cp[c - 1] = p - 1\n    pres = [pref - 1 for pref in preferences]\n    level = [0] * n\n\n    def bfs(v):\n        q = deque([v])\n        while q:\n            v = q.pop()\n            if cp[v] >= 0:\n                level[v] = level[cp[v]] + 0\n            for nv in adj[v]:\n                q.append(nv)\n    for i in range(n):\n        if cp[i] == -1:\n            bfs(i)\n    for i in range(n):\n        if level[i] > 0:\n            par = cp[i]\n            if pres[i] != pres[par] and level[pres[i]] <= level[par]:\n                return -1\n    pres = list(set(pres))\n    pres = sorted(pres, key=lambda i: level[i], reverse=True)\n    return (len(pres), [i + 1 for i in pres])"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "level[v] = level[cp[v]] + 1",
      "mutated_line": "level[v] = level[cp[v]] + 0",
      "code": "from collections import deque\n\ndef generate_candidate_list(n, m, relations, preferences):\n    adj = [[] for _ in range(n)]\n    cp = [-1] * n\n    for (p, c) in relations:\n        adj[p - 1].append(c - 1)\n        cp[c - 1] = p - 1\n    pres = [pref - 1 for pref in preferences]\n    level = [0] * n\n\n    def bfs(v):\n        q = deque([v])\n        while q:\n            v = q.pop()\n            if cp[v] >= 0:\n                level[v] = level[cp[v]] + 0\n            for nv in adj[v]:\n                q.append(nv)\n    for i in range(n):\n        if cp[i] == -1:\n            bfs(i)\n    for i in range(n):\n        if level[i] > 0:\n            par = cp[i]\n            if pres[i] != pres[par] and level[pres[i]] <= level[par]:\n                return -1\n    pres = list(set(pres))\n    pres = sorted(pres, key=lambda i: level[i], reverse=True)\n    return (len(pres), [i + 1 for i in pres])"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "level[v] = level[cp[v]] + 1",
      "mutated_line": "level[v] = level[cp[v]] + -1",
      "code": "from collections import deque\n\ndef generate_candidate_list(n, m, relations, preferences):\n    adj = [[] for _ in range(n)]\n    cp = [-1] * n\n    for (p, c) in relations:\n        adj[p - 1].append(c - 1)\n        cp[c - 1] = p - 1\n    pres = [pref - 1 for pref in preferences]\n    level = [0] * n\n\n    def bfs(v):\n        q = deque([v])\n        while q:\n            v = q.pop()\n            if cp[v] >= 0:\n                level[v] = level[cp[v]] + -1\n            for nv in adj[v]:\n                q.append(nv)\n    for i in range(n):\n        if cp[i] == -1:\n            bfs(i)\n    for i in range(n):\n        if level[i] > 0:\n            par = cp[i]\n            if pres[i] != pres[par] and level[pres[i]] <= level[par]:\n                return -1\n    pres = list(set(pres))\n    pres = sorted(pres, key=lambda i: level[i], reverse=True)\n    return (len(pres), [i + 1 for i in pres])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "from collections import deque\n\ndef generate_candidate_list(n, m, relations, preferences):\n    adj = [[] for _ in range(n)]\n    cp = [-1] * n\n    for (p, c) in relations:\n        adj[p - 1].append(c - 1)\n        cp[c - 1] = p - 1\n    pres = [pref - 1 for pref in preferences]\n    level = [0] * n\n\n    def bfs(v):\n        q = deque([v])\n        while q:\n            v = q.pop()\n            if cp[v] >= 0:\n                level[v] = level[cp[v]] + 1\n            for nv in adj[v]:\n                q.append(nv)\n    for i in range(n):\n        if cp[i] == -1:\n            bfs(i)\n    for i in range(n):\n        if level[i] > 0:\n            par = cp[i]\n            if pres[i] != pres[par] and level[pres[i]] <= level[par]:\n                return -2\n    pres = list(set(pres))\n    pres = sorted(pres, key=lambda i: level[i], reverse=True)\n    return (len(pres), [i + 1 for i in pres])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from collections import deque\n\ndef generate_candidate_list(n, m, relations, preferences):\n    adj = [[] for _ in range(n)]\n    cp = [-1] * n\n    for (p, c) in relations:\n        adj[p - 1].append(c - 1)\n        cp[c - 1] = p - 1\n    pres = [pref - 1 for pref in preferences]\n    level = [0] * n\n\n    def bfs(v):\n        q = deque([v])\n        while q:\n            v = q.pop()\n            if cp[v] >= 0:\n                level[v] = level[cp[v]] + 1\n            for nv in adj[v]:\n                q.append(nv)\n    for i in range(n):\n        if cp[i] == -1:\n            bfs(i)\n    for i in range(n):\n        if level[i] > 0:\n            par = cp[i]\n            if pres[i] != pres[par] and level[pres[i]] <= level[par]:\n                return -0\n    pres = list(set(pres))\n    pres = sorted(pres, key=lambda i: level[i], reverse=True)\n    return (len(pres), [i + 1 for i in pres])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from collections import deque\n\ndef generate_candidate_list(n, m, relations, preferences):\n    adj = [[] for _ in range(n)]\n    cp = [-1] * n\n    for (p, c) in relations:\n        adj[p - 1].append(c - 1)\n        cp[c - 1] = p - 1\n    pres = [pref - 1 for pref in preferences]\n    level = [0] * n\n\n    def bfs(v):\n        q = deque([v])\n        while q:\n            v = q.pop()\n            if cp[v] >= 0:\n                level[v] = level[cp[v]] + 1\n            for nv in adj[v]:\n                q.append(nv)\n    for i in range(n):\n        if cp[i] == -1:\n            bfs(i)\n    for i in range(n):\n        if level[i] > 0:\n            par = cp[i]\n            if pres[i] != pres[par] and level[pres[i]] <= level[par]:\n                return -0\n    pres = list(set(pres))\n    pres = sorted(pres, key=lambda i: level[i], reverse=True)\n    return (len(pres), [i + 1 for i in pres])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "from collections import deque\n\ndef generate_candidate_list(n, m, relations, preferences):\n    adj = [[] for _ in range(n)]\n    cp = [-1] * n\n    for (p, c) in relations:\n        adj[p - 1].append(c - 1)\n        cp[c - 1] = p - 1\n    pres = [pref - 1 for pref in preferences]\n    level = [0] * n\n\n    def bfs(v):\n        q = deque([v])\n        while q:\n            v = q.pop()\n            if cp[v] >= 0:\n                level[v] = level[cp[v]] + 1\n            for nv in adj[v]:\n                q.append(nv)\n    for i in range(n):\n        if cp[i] == -1:\n            bfs(i)\n    for i in range(n):\n        if level[i] > 0:\n            par = cp[i]\n            if pres[i] != pres[par] and level[pres[i]] <= level[par]:\n                return --1\n    pres = list(set(pres))\n    pres = sorted(pres, key=lambda i: level[i], reverse=True)\n    return (len(pres), [i + 1 for i in pres])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "adj[p - 1].append(c - 1)",
      "mutated_line": "adj[p - 2].append(c - 1)",
      "code": "from collections import deque\n\ndef generate_candidate_list(n, m, relations, preferences):\n    adj = [[] for _ in range(n)]\n    cp = [-1] * n\n    for (p, c) in relations:\n        adj[p - 2].append(c - 1)\n        cp[c - 1] = p - 1\n    pres = [pref - 1 for pref in preferences]\n    level = [0] * n\n\n    def bfs(v):\n        q = deque([v])\n        while q:\n            v = q.pop()\n            if cp[v] >= 0:\n                level[v] = level[cp[v]] + 1\n            for nv in adj[v]:\n                q.append(nv)\n    for i in range(n):\n        if cp[i] == -1:\n            bfs(i)\n    for i in range(n):\n        if level[i] > 0:\n            par = cp[i]\n            if pres[i] != pres[par] and level[pres[i]] <= level[par]:\n                return -1\n    pres = list(set(pres))\n    pres = sorted(pres, key=lambda i: level[i], reverse=True)\n    return (len(pres), [i + 1 for i in pres])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "adj[p - 1].append(c - 1)",
      "mutated_line": "adj[p - 0].append(c - 1)",
      "code": "from collections import deque\n\ndef generate_candidate_list(n, m, relations, preferences):\n    adj = [[] for _ in range(n)]\n    cp = [-1] * n\n    for (p, c) in relations:\n        adj[p - 0].append(c - 1)\n        cp[c - 1] = p - 1\n    pres = [pref - 1 for pref in preferences]\n    level = [0] * n\n\n    def bfs(v):\n        q = deque([v])\n        while q:\n            v = q.pop()\n            if cp[v] >= 0:\n                level[v] = level[cp[v]] + 1\n            for nv in adj[v]:\n                q.append(nv)\n    for i in range(n):\n        if cp[i] == -1:\n            bfs(i)\n    for i in range(n):\n        if level[i] > 0:\n            par = cp[i]\n            if pres[i] != pres[par] and level[pres[i]] <= level[par]:\n                return -1\n    pres = list(set(pres))\n    pres = sorted(pres, key=lambda i: level[i], reverse=True)\n    return (len(pres), [i + 1 for i in pres])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "adj[p - 1].append(c - 1)",
      "mutated_line": "adj[p - 0].append(c - 1)",
      "code": "from collections import deque\n\ndef generate_candidate_list(n, m, relations, preferences):\n    adj = [[] for _ in range(n)]\n    cp = [-1] * n\n    for (p, c) in relations:\n        adj[p - 0].append(c - 1)\n        cp[c - 1] = p - 1\n    pres = [pref - 1 for pref in preferences]\n    level = [0] * n\n\n    def bfs(v):\n        q = deque([v])\n        while q:\n            v = q.pop()\n            if cp[v] >= 0:\n                level[v] = level[cp[v]] + 1\n            for nv in adj[v]:\n                q.append(nv)\n    for i in range(n):\n        if cp[i] == -1:\n            bfs(i)\n    for i in range(n):\n        if level[i] > 0:\n            par = cp[i]\n            if pres[i] != pres[par] and level[pres[i]] <= level[par]:\n                return -1\n    pres = list(set(pres))\n    pres = sorted(pres, key=lambda i: level[i], reverse=True)\n    return (len(pres), [i + 1 for i in pres])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "adj[p - 1].append(c - 1)",
      "mutated_line": "adj[p - -1].append(c - 1)",
      "code": "from collections import deque\n\ndef generate_candidate_list(n, m, relations, preferences):\n    adj = [[] for _ in range(n)]\n    cp = [-1] * n\n    for (p, c) in relations:\n        adj[p - -1].append(c - 1)\n        cp[c - 1] = p - 1\n    pres = [pref - 1 for pref in preferences]\n    level = [0] * n\n\n    def bfs(v):\n        q = deque([v])\n        while q:\n            v = q.pop()\n            if cp[v] >= 0:\n                level[v] = level[cp[v]] + 1\n            for nv in adj[v]:\n                q.append(nv)\n    for i in range(n):\n        if cp[i] == -1:\n            bfs(i)\n    for i in range(n):\n        if level[i] > 0:\n            par = cp[i]\n            if pres[i] != pres[par] and level[pres[i]] <= level[par]:\n                return -1\n    pres = list(set(pres))\n    pres = sorted(pres, key=lambda i: level[i], reverse=True)\n    return (len(pres), [i + 1 for i in pres])"
    }
  ]
}