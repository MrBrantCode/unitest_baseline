{
  "task_id": "taco_18680",
  "entry_point": "count_valid_dice_combinations",
  "mutant_count": 318,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "mod = 998244353",
      "mutated_line": "mod = 998244354",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244354\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "mod = 998244353",
      "mutated_line": "mod = 998244352",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244352\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "mod = 998244353",
      "mutated_line": "mod = 0",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 0\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "mod = 998244353",
      "mutated_line": "mod = 1",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 1\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "mod = 998244353",
      "mutated_line": "mod = -998244353",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = -998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if k == 1:",
      "mutated_line": "if k != 1:",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k != 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "ans = [0] * (2 * k + 1)",
      "mutated_line": "ans = [0] / (2 * k + 1)",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] / (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "ans = [0] * (2 * k + 1)",
      "mutated_line": "ans = [0] + (2 * k + 1)",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] + (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "ans = [0] * (2 * k + 1)",
      "mutated_line": "ans = [0] ** (2 * k + 1)",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] ** (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "if n < 0:",
      "mutated_line": "if n <= 0:",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n <= 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "if n < 0:",
      "mutated_line": "if n >= 0:",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n >= 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "if n < 0:",
      "mutated_line": "if n != 0:",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n != 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if n == 0:",
      "mutated_line": "if n != 0:",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n != 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "A = [1, 1]",
      "mutated_line": "A = [2, 1]",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [2, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "A = [1, 1]",
      "mutated_line": "A = [0, 1]",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [0, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "A = [1, 1]",
      "mutated_line": "A = [0, 1]",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [0, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "A = [1, 1]",
      "mutated_line": "A = [-1, 1]",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [-1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "A = [1, 1]",
      "mutated_line": "A = [1, 2]",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 2]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "A = [1, 1]",
      "mutated_line": "A = [1, 0]",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 0]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "A = [1, 1]",
      "mutated_line": "A = [1, 0]",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 0]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "A = [1, 1]",
      "mutated_line": "A = [1, -1]",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, -1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "B = [1, 1]",
      "mutated_line": "B = [2, 1]",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [2, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "B = [1, 1]",
      "mutated_line": "B = [0, 1]",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [0, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "B = [1, 1]",
      "mutated_line": "B = [0, 1]",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [0, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "B = [1, 1]",
      "mutated_line": "B = [-1, 1]",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [-1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "B = [1, 1]",
      "mutated_line": "B = [1, 2]",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 2]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "B = [1, 1]",
      "mutated_line": "B = [1, 0]",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 0]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "B = [1, 1]",
      "mutated_line": "B = [1, 0]",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 0]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "B = [1, 1]",
      "mutated_line": "B = [1, -1]",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, -1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(2, 4005):",
      "mutated_line": "for i in range(3, 4005):",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(3, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(2, 4005):",
      "mutated_line": "for i in range(1, 4005):",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(1, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(2, 4005):",
      "mutated_line": "for i in range(0, 4005):",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(0, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(2, 4005):",
      "mutated_line": "for i in range(1, 4005):",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(1, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(2, 4005):",
      "mutated_line": "for i in range(-2, 4005):",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(-2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(2, 4005):",
      "mutated_line": "for i in range(2, 4006):",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4006):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(2, 4005):",
      "mutated_line": "for i in range(2, 4004):",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4004):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(2, 4005):",
      "mutated_line": "for i in range(2, 0):",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 0):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(2, 4005):",
      "mutated_line": "for i in range(2, 1):",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 1):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(2, 4005):",
      "mutated_line": "for i in range(2, -4005):",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, -4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if k == 1:",
      "mutated_line": "if k == 2:",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 2:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if k == 1:",
      "mutated_line": "if k == 0:",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 0:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if k == 1:",
      "mutated_line": "if k == 0:",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 0:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if k == 1:",
      "mutated_line": "if k == -1:",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == -1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "return [0] * (2 * k - 1)",
      "mutated_line": "return [0] / (2 * k - 1)",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] / (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "return [0] * (2 * k - 1)",
      "mutated_line": "return [0] + (2 * k - 1)",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] + (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "return [0] * (2 * k - 1)",
      "mutated_line": "return [0] ** (2 * k - 1)",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] ** (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "ans = [0] * (2 * k + 1)",
      "mutated_line": "ans = [0] * (2 * k - 1)",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k - 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "ans = [0] * (2 * k + 1)",
      "mutated_line": "ans = [0] * (2 * k * 1)",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k * 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for i in range(2, k + 3):",
      "mutated_line": "for i in range(3, k + 3):",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(3, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for i in range(2, k + 3):",
      "mutated_line": "for i in range(1, k + 3):",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(1, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for i in range(2, k + 3):",
      "mutated_line": "for i in range(0, k + 3):",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(0, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for i in range(2, k + 3):",
      "mutated_line": "for i in range(1, k + 3):",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(1, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for i in range(2, k + 3):",
      "mutated_line": "for i in range(-2, k + 3):",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(-2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "for i in range(2, k + 3):",
      "mutated_line": "for i in range(2, k - 3):",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k - 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "for i in range(2, k + 3):",
      "mutated_line": "for i in range(2, k * 3):",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k * 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if i % 2 == 0:",
      "mutated_line": "if i % 2 != 0:",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 != 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "for i in range(k + 2, 2 * k + 1):",
      "mutated_line": "for i in range(k - 2, 2 * k + 1):",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k - 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "for i in range(k + 2, 2 * k + 1):",
      "mutated_line": "for i in range(k * 2, 2 * k + 1):",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k * 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "for i in range(k + 2, 2 * k + 1):",
      "mutated_line": "for i in range(k + 2, 2 * k - 1):",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k - 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "for i in range(k + 2, 2 * k + 1):",
      "mutated_line": "for i in range(k + 2, 2 * k * 1):",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k * 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if n < 0:",
      "mutated_line": "if n < 1:",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 1:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if n < 0:",
      "mutated_line": "if n < -1:",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < -1:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if n < 0:",
      "mutated_line": "if n < 1:",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 1:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 1\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return -1\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 1\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if n == 0:",
      "mutated_line": "if n == 1:",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 1:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if n == 0:",
      "mutated_line": "if n == -1:",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == -1:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if n == 0:",
      "mutated_line": "if n == 1:",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 1:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if r != 0:",
      "mutated_line": "if r == 0:",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r == 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "elif r < 0:",
      "mutated_line": "elif r <= 0:",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r <= 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "elif r < 0:",
      "mutated_line": "elif r >= 0:",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r >= 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "elif r < 0:",
      "mutated_line": "elif r != 0:",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r != 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "A.append(A[-1] * i % mod)",
      "mutated_line": "A.append(A[-1] * i * mod)",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i * mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "A.append(A[-1] * i % mod)",
      "mutated_line": "A.append(A[-1] * i + mod)",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i + mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "B.append(B[-1] * pow(i, mod - 2, mod) % mod)",
      "mutated_line": "B.append(B[-1] * pow(i, mod - 2, mod) * mod)",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) * mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "B.append(B[-1] * pow(i, mod - 2, mod) % mod)",
      "mutated_line": "B.append(B[-1] * pow(i, mod - 2, mod) + mod)",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) + mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "return [0] * (2 * k - 1)",
      "mutated_line": "return [0] * (2 * k + 1)",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k + 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "return [0] * (2 * k - 1)",
      "mutated_line": "return [0] * (2 * k * 1)",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k * 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "ans = [0] * (2 * k + 1)",
      "mutated_line": "ans = [1] * (2 * k + 1)",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [1] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "ans = [0] * (2 * k + 1)",
      "mutated_line": "ans = [-1] * (2 * k + 1)",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [-1] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "ans = [0] * (2 * k + 1)",
      "mutated_line": "ans = [1] * (2 * k + 1)",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [1] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "ans = [0] * (2 * k + 1)",
      "mutated_line": "ans = [0] * (2 / k + 1)",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 / k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "ans = [0] * (2 * k + 1)",
      "mutated_line": "ans = [0] * (2 + k + 1)",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 + k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "ans = [0] * (2 * k + 1)",
      "mutated_line": "ans = [0] * (2 ** k + 1)",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 ** k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "ans = [0] * (2 * k + 1)",
      "mutated_line": "ans = [0] * (2 * k + 2)",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 2)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "ans = [0] * (2 * k + 1)",
      "mutated_line": "ans = [0] * (2 * k + 0)",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 0)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "ans = [0] * (2 * k + 1)",
      "mutated_line": "ans = [0] * (2 * k + 0)",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 0)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "ans = [0] * (2 * k + 1)",
      "mutated_line": "ans = [0] * (2 * k + -1)",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + -1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for i in range(2, k + 3):",
      "mutated_line": "for i in range(2, k + 4):",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 4):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for i in range(2, k + 3):",
      "mutated_line": "for i in range(2, k + 2):",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 2):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for i in range(2, k + 3):",
      "mutated_line": "for i in range(2, k + 0):",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 0):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for i in range(2, k + 3):",
      "mutated_line": "for i in range(2, k + 1):",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 1):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for i in range(2, k + 3):",
      "mutated_line": "for i in range(2, k + -3):",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + -3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "if i % 2 == 0:",
      "mutated_line": "if i * 2 == 0:",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i * 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "if i % 2 == 0:",
      "mutated_line": "if i + 2 == 0:",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i + 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if i % 2 == 0:",
      "mutated_line": "if i % 2 == 1:",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 1:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if i % 2 == 0:",
      "mutated_line": "if i % 2 == -1:",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == -1:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if i % 2 == 0:",
      "mutated_line": "if i % 2 == 1:",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 1:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "i = i + 1",
      "mutated_line": "i = i - 1",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i - 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "i = i + 1",
      "mutated_line": "i = i * 1",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i * 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for i in range(k + 2, 2 * k + 1):",
      "mutated_line": "for i in range(k + 3, 2 * k + 1):",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 3, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for i in range(k + 2, 2 * k + 1):",
      "mutated_line": "for i in range(k + 1, 2 * k + 1):",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 1, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for i in range(k + 2, 2 * k + 1):",
      "mutated_line": "for i in range(k + 0, 2 * k + 1):",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 0, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for i in range(k + 2, 2 * k + 1):",
      "mutated_line": "for i in range(k + 1, 2 * k + 1):",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 1, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for i in range(k + 2, 2 * k + 1):",
      "mutated_line": "for i in range(k + -2, 2 * k + 1):",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + -2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "for i in range(k + 2, 2 * k + 1):",
      "mutated_line": "for i in range(k + 2, 2 / k + 1):",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 / k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "for i in range(k + 2, 2 * k + 1):",
      "mutated_line": "for i in range(k + 2, 2 + k + 1):",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 + k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "for i in range(k + 2, 2 * k + 1):",
      "mutated_line": "for i in range(k + 2, 2 ** k + 1):",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 ** k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for i in range(k + 2, 2 * k + 1):",
      "mutated_line": "for i in range(k + 2, 2 * k + 2):",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 2):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for i in range(k + 2, 2 * k + 1):",
      "mutated_line": "for i in range(k + 2, 2 * k + 0):",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 0):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for i in range(k + 2, 2 * k + 1):",
      "mutated_line": "for i in range(k + 2, 2 * k + 0):",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 0):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for i in range(k + 2, 2 * k + 1):",
      "mutated_line": "for i in range(k + 2, 2 * k + -1):",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + -1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "ans[i] = ans[2 * k + 2 - i]",
      "mutated_line": "ans[i] = ans[2 * k + 2 + i]",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 + i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "ans[i] = ans[2 * k + 2 - i]",
      "mutated_line": "ans[i] = ans[(2 * k + 2) * i]",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[(2 * k + 2) * i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return ans[2:2 * k + 1]",
      "mutated_line": "return ans[3:2 * k + 1]",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[3:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return ans[2:2 * k + 1]",
      "mutated_line": "return ans[1:2 * k + 1]",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[1:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return ans[2:2 * k + 1]",
      "mutated_line": "return ans[0:2 * k + 1]",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[0:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return ans[2:2 * k + 1]",
      "mutated_line": "return ans[1:2 * k + 1]",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[1:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return ans[2:2 * k + 1]",
      "mutated_line": "return ans[-2:2 * k + 1]",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[-2:2 * k + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "return ans[2:2 * k + 1]",
      "mutated_line": "return ans[2:2 * k - 1]",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "return ans[2:2 * k + 1]",
      "mutated_line": "return ans[2:2 * k * 1]",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k * 1]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if r != 0:",
      "mutated_line": "if r != 1:",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 1:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if r != 0:",
      "mutated_line": "if r != -1:",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != -1:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if r != 0:",
      "mutated_line": "if r != 1:",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 1:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 1\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return -1\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 1\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return 1",
      "mutated_line": "return 2",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 2\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return 1",
      "mutated_line": "return 0",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 0\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return 1",
      "mutated_line": "return 0",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 0\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return 1",
      "mutated_line": "return -1",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return -1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "elif r < 0:",
      "mutated_line": "elif r < 1:",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 1:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "elif r < 0:",
      "mutated_line": "elif r < -1:",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < -1:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "elif r < 0:",
      "mutated_line": "elif r < 1:",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 1:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 1\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return -1\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 1\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "elif r > n:",
      "mutated_line": "elif r >= n:",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r >= n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "elif r > n:",
      "mutated_line": "elif r <= n:",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r <= n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "elif r > n:",
      "mutated_line": "elif r != n:",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r != n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "A.append(A[-1] * i % mod)",
      "mutated_line": "A.append(A[-1] / i % mod)",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] / i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "A.append(A[-1] * i % mod)",
      "mutated_line": "A.append((A[-1] + i) % mod)",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append((A[-1] + i) % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "A.append(A[-1] * i % mod)",
      "mutated_line": "A.append(A[-1] ** i % mod)",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] ** i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "B.append(B[-1] * pow(i, mod - 2, mod) % mod)",
      "mutated_line": "B.append(B[-1] / pow(i, mod - 2, mod) % mod)",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] / pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "B.append(B[-1] * pow(i, mod - 2, mod) % mod)",
      "mutated_line": "B.append((B[-1] + pow(i, mod - 2, mod)) % mod)",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append((B[-1] + pow(i, mod - 2, mod)) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "B.append(B[-1] * pow(i, mod - 2, mod) % mod)",
      "mutated_line": "B.append(B[-1] ** pow(i, mod - 2, mod) % mod)",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] ** pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return [0] * (2 * k - 1)",
      "mutated_line": "return [1] * (2 * k - 1)",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [1] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return [0] * (2 * k - 1)",
      "mutated_line": "return [-1] * (2 * k - 1)",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [-1] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return [0] * (2 * k - 1)",
      "mutated_line": "return [1] * (2 * k - 1)",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [1] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "return [0] * (2 * k - 1)",
      "mutated_line": "return [0] * (2 / k - 1)",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 / k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "return [0] * (2 * k - 1)",
      "mutated_line": "return [0] * (2 + k - 1)",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 + k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "return [0] * (2 * k - 1)",
      "mutated_line": "return [0] * (2 ** k - 1)",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 ** k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return [0] * (2 * k - 1)",
      "mutated_line": "return [0] * (2 * k - 2)",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 2)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return [0] * (2 * k - 1)",
      "mutated_line": "return [0] * (2 * k - 0)",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 0)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return [0] * (2 * k - 1)",
      "mutated_line": "return [0] * (2 * k - 0)",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 0)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return [0] * (2 * k - 1)",
      "mutated_line": "return [0] * (2 * k - -1)",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - -1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "ans = [0] * (2 * k + 1)",
      "mutated_line": "ans = [0] * (3 * k + 1)",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (3 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "ans = [0] * (2 * k + 1)",
      "mutated_line": "ans = [0] * (1 * k + 1)",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (1 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "ans = [0] * (2 * k + 1)",
      "mutated_line": "ans = [0] * (0 * k + 1)",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (0 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "ans = [0] * (2 * k + 1)",
      "mutated_line": "ans = [0] * (1 * k + 1)",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (1 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "ans = [0] * (2 * k + 1)",
      "mutated_line": "ans = [0] * (-2 * k + 1)",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (-2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if i % 2 == 0:",
      "mutated_line": "if i % 3 == 0:",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 3 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if i % 2 == 0:",
      "mutated_line": "if i % 1 == 0:",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 1 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if i % 2 == 0:",
      "mutated_line": "if i % 0 == 0:",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 0 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if i % 2 == 0:",
      "mutated_line": "if i % 1 == 0:",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 1 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if i % 2 == 0:",
      "mutated_line": "if i % -2 == 0:",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % -2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "i = i + 1",
      "mutated_line": "i = i + 2",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 2\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "i = i + 1",
      "mutated_line": "i = i + 0",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 0\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "i = i + 1",
      "mutated_line": "i = i + 0",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 0\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "i = i + 1",
      "mutated_line": "i = i + -1",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + -1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod",
      "mutated_line": "ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) * mod",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) * mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod",
      "mutated_line": "ans[i - 1] = ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod) + mod",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod) + mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "ans[i] = ans[i - 1]",
      "mutated_line": "ans[i] = ans[i + 1]",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i + 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "ans[i] = ans[i - 1]",
      "mutated_line": "ans[i] = ans[i * 1]",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i * 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for i in range(k + 2, 2 * k + 1):",
      "mutated_line": "for i in range(k + 2, 3 * k + 1):",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 3 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for i in range(k + 2, 2 * k + 1):",
      "mutated_line": "for i in range(k + 2, 1 * k + 1):",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 1 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for i in range(k + 2, 2 * k + 1):",
      "mutated_line": "for i in range(k + 2, 0 * k + 1):",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 0 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for i in range(k + 2, 2 * k + 1):",
      "mutated_line": "for i in range(k + 2, 1 * k + 1):",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 1 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for i in range(k + 2, 2 * k + 1):",
      "mutated_line": "for i in range(k + 2, -2 * k + 1):",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, -2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "ans[i] = ans[2 * k + 2 - i]",
      "mutated_line": "ans[i] = ans[2 * k - 2 - i]",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k - 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "ans[i] = ans[2 * k + 2 - i]",
      "mutated_line": "ans[i] = ans[2 * k * 2 - i]",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k * 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "return ans[2:2 * k + 1]",
      "mutated_line": "return ans[2:2 / k + 1]",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 / k + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "return ans[2:2 * k + 1]",
      "mutated_line": "return ans[2:2 + k + 1]",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 + k + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "return ans[2:2 * k + 1]",
      "mutated_line": "return ans[2:2 ** k + 1]",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 ** k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return ans[2:2 * k + 1]",
      "mutated_line": "return ans[2:2 * k + 2]",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 2]"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return ans[2:2 * k + 1]",
      "mutated_line": "return ans[2:2 * k + 0]",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 0]"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return ans[2:2 * k + 1]",
      "mutated_line": "return ans[2:2 * k + 0]",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 0]"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return ans[2:2 * k + 1]",
      "mutated_line": "return ans[2:2 * k + -1]",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + -1]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 1\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return -1\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 1\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "elif r == 0:",
      "mutated_line": "elif r != 0:",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r != 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return [0] * (2 * k - 1)",
      "mutated_line": "return [0] * (3 * k - 1)",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (3 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return [0] * (2 * k - 1)",
      "mutated_line": "return [0] * (1 * k - 1)",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (1 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return [0] * (2 * k - 1)",
      "mutated_line": "return [0] * (0 * k - 1)",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (0 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return [0] * (2 * k - 1)",
      "mutated_line": "return [0] * (1 * k - 1)",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (1 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return [0] * (2 * k - 1)",
      "mutated_line": "return [0] * (-2 * k - 1)",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (-2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "for j in range(min(n + 1, i // 2 + 1)):",
      "mutated_line": "for j in range(min(n - 1, i // 2 + 1)):",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n - 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "for j in range(min(n + 1, i // 2 + 1)):",
      "mutated_line": "for j in range(min(n * 1, i // 2 + 1)):",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n * 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "for j in range(min(n + 1, i // 2 + 1)):",
      "mutated_line": "for j in range(min(n + 1, i // 2 - 1)):",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 - 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "for j in range(min(n + 1, i // 2 + 1)):",
      "mutated_line": "for j in range(min(n + 1, i // 2 * 1)):",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 * 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod",
      "mutated_line": "ans[i + 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i + 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod",
      "mutated_line": "ans[i * 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i * 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod",
      "mutated_line": "ans[i - 1] = (ans[i - 1] - cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] - cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod",
      "mutated_line": "ans[i - 1] = ans[i - 1] * (cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = ans[i - 1] * (cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "ans[i] = ans[i - 1]",
      "mutated_line": "ans[i] = ans[i - 2]",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 2]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "ans[i] = ans[i - 1]",
      "mutated_line": "ans[i] = ans[i - 0]",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 0]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "ans[i] = ans[i - 1]",
      "mutated_line": "ans[i] = ans[i - 0]",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 0]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "ans[i] = ans[i - 1]",
      "mutated_line": "ans[i] = ans[i - -1]",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - -1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "ans[i] = ans[2 * k + 2 - i]",
      "mutated_line": "ans[i] = ans[2 / k + 2 - i]",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 / k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "ans[i] = ans[2 * k + 2 - i]",
      "mutated_line": "ans[i] = ans[2 + k + 2 - i]",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 + k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "ans[i] = ans[2 * k + 2 - i]",
      "mutated_line": "ans[i] = ans[2 ** k + 2 - i]",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 ** k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "ans[i] = ans[2 * k + 2 - i]",
      "mutated_line": "ans[i] = ans[2 * k + 3 - i]",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 3 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "ans[i] = ans[2 * k + 2 - i]",
      "mutated_line": "ans[i] = ans[2 * k + 1 - i]",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 1 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "ans[i] = ans[2 * k + 2 - i]",
      "mutated_line": "ans[i] = ans[2 * k + 0 - i]",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 0 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "ans[i] = ans[2 * k + 2 - i]",
      "mutated_line": "ans[i] = ans[2 * k + 1 - i]",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 1 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "ans[i] = ans[2 * k + 2 - i]",
      "mutated_line": "ans[i] = ans[2 * k + -2 - i]",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + -2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return ans[2:2 * k + 1]",
      "mutated_line": "return ans[2:3 * k + 1]",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:3 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return ans[2:2 * k + 1]",
      "mutated_line": "return ans[2:1 * k + 1]",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:1 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return ans[2:2 * k + 1]",
      "mutated_line": "return ans[2:0 * k + 1]",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:0 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return ans[2:2 * k + 1]",
      "mutated_line": "return ans[2:1 * k + 1]",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:1 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return ans[2:2 * k + 1]",
      "mutated_line": "return ans[2:-2 * k + 1]",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:-2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "elif r == 0:",
      "mutated_line": "elif r == 1:",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 1:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "elif r == 0:",
      "mutated_line": "elif r == -1:",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == -1:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "elif r == 0:",
      "mutated_line": "elif r == 1:",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 1:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return 1",
      "mutated_line": "return 2",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 2\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return 1",
      "mutated_line": "return 0",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 0\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return 1",
      "mutated_line": "return 0",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 0\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return 1",
      "mutated_line": "return -1",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return -1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "elif r == n:",
      "mutated_line": "elif r != n:",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r != n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "UOI",
      "lineno": 25,
      "original_line": "A.append(A[-1] * i % mod)",
      "mutated_line": "A.append(A[+1] * i % mod)",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[+1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "UOI",
      "lineno": 26,
      "original_line": "B.append(B[-1] * pow(i, mod - 2, mod) % mod)",
      "mutated_line": "B.append(B[+1] * pow(i, mod - 2, mod) % mod)",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[+1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "B.append(B[-1] * pow(i, mod - 2, mod) % mod)",
      "mutated_line": "B.append(B[-1] * pow(i, mod + 2, mod) % mod)",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod + 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "B.append(B[-1] * pow(i, mod - 2, mod) % mod)",
      "mutated_line": "B.append(B[-1] * pow(i, mod * 2, mod) % mod)",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod * 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for j in range(min(n + 1, i // 2 + 1)):",
      "mutated_line": "for j in range(min(n + 2, i // 2 + 1)):",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 2, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for j in range(min(n + 1, i // 2 + 1)):",
      "mutated_line": "for j in range(min(n + 0, i // 2 + 1)):",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 0, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for j in range(min(n + 1, i // 2 + 1)):",
      "mutated_line": "for j in range(min(n + 0, i // 2 + 1)):",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 0, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for j in range(min(n + 1, i // 2 + 1)):",
      "mutated_line": "for j in range(min(n + -1, i // 2 + 1)):",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + -1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "for j in range(min(n + 1, i // 2 + 1)):",
      "mutated_line": "for j in range(min(n + 1, i / 2 + 1)):",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i / 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "for j in range(min(n + 1, i // 2 + 1)):",
      "mutated_line": "for j in range(min(n + 1, i * 2 + 1)):",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i * 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for j in range(min(n + 1, i // 2 + 1)):",
      "mutated_line": "for j in range(min(n + 1, i // 2 + 2)):",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 2)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for j in range(min(n + 1, i // 2 + 1)):",
      "mutated_line": "for j in range(min(n + 1, i // 2 + 0)):",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 0)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for j in range(min(n + 1, i // 2 + 1)):",
      "mutated_line": "for j in range(min(n + 1, i // 2 + 0)):",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 0)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for j in range(min(n + 1, i // 2 + 1)):",
      "mutated_line": "for j in range(min(n + 1, i // 2 + -1)):",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + -1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod",
      "mutated_line": "ans[i - 2] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 2] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod",
      "mutated_line": "ans[i - 0] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 0] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod",
      "mutated_line": "ans[i - 0] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 0] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod",
      "mutated_line": "ans[i - -1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - -1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod",
      "mutated_line": "ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) / pow(2, j, mod)) % mod",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) / pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod",
      "mutated_line": "ans[i - 1] = (ans[i - 1] + (cmb(n + k - i, k - i + j) * cmb(i // 2, j) + pow(2, j, mod))) % mod",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + (cmb(n + k - i, k - i + j) * cmb(i // 2, j) + pow(2, j, mod))) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod",
      "mutated_line": "ans[i - 1] = (ans[i - 1] + (cmb(n + k - i, k - i + j) * cmb(i // 2, j)) ** pow(2, j, mod)) % mod",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + (cmb(n + k - i, k - i + j) * cmb(i // 2, j)) ** pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "ans[i] = ans[2 * k + 2 - i]",
      "mutated_line": "ans[i] = ans[3 * k + 2 - i]",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[3 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "ans[i] = ans[2 * k + 2 - i]",
      "mutated_line": "ans[i] = ans[1 * k + 2 - i]",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[1 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "ans[i] = ans[2 * k + 2 - i]",
      "mutated_line": "ans[i] = ans[0 * k + 2 - i]",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[0 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "ans[i] = ans[2 * k + 2 - i]",
      "mutated_line": "ans[i] = ans[1 * k + 2 - i]",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[1 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "ans[i] = ans[2 * k + 2 - i]",
      "mutated_line": "ans[i] = ans[-2 * k + 2 - i]",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[-2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return 1",
      "mutated_line": "return 2",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 2\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return 1",
      "mutated_line": "return 0",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 0\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return 1",
      "mutated_line": "return 0",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 0\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return 1",
      "mutated_line": "return -1",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return -1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "return A[n] * B[r] * B[n - r] % mod",
      "mutated_line": "return A[n] * B[r] * B[n - r] * mod",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] * mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "return A[n] * B[r] * B[n - r] % mod",
      "mutated_line": "return A[n] * B[r] * B[n - r] + mod",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] + mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "A.append(A[-1] * i % mod)",
      "mutated_line": "A.append(A[-2] * i % mod)",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-2] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "A.append(A[-1] * i % mod)",
      "mutated_line": "A.append(A[-0] * i % mod)",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-0] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "A.append(A[-1] * i % mod)",
      "mutated_line": "A.append(A[-0] * i % mod)",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-0] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "A.append(A[-1] * i % mod)",
      "mutated_line": "A.append(A[--1] * i % mod)",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[--1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "B.append(B[-1] * pow(i, mod - 2, mod) % mod)",
      "mutated_line": "B.append(B[-2] * pow(i, mod - 2, mod) % mod)",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-2] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "B.append(B[-1] * pow(i, mod - 2, mod) % mod)",
      "mutated_line": "B.append(B[-0] * pow(i, mod - 2, mod) % mod)",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-0] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "B.append(B[-1] * pow(i, mod - 2, mod) % mod)",
      "mutated_line": "B.append(B[-0] * pow(i, mod - 2, mod) % mod)",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-0] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "B.append(B[-1] * pow(i, mod - 2, mod) % mod)",
      "mutated_line": "B.append(B[--1] * pow(i, mod - 2, mod) % mod)",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[--1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "B.append(B[-1] * pow(i, mod - 2, mod) % mod)",
      "mutated_line": "B.append(B[-1] * pow(i, mod - 3, mod) % mod)",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 3, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "B.append(B[-1] * pow(i, mod - 2, mod) % mod)",
      "mutated_line": "B.append(B[-1] * pow(i, mod - 1, mod) % mod)",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 1, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "B.append(B[-1] * pow(i, mod - 2, mod) % mod)",
      "mutated_line": "B.append(B[-1] * pow(i, mod - 0, mod) % mod)",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 0, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "B.append(B[-1] * pow(i, mod - 2, mod) % mod)",
      "mutated_line": "B.append(B[-1] * pow(i, mod - 1, mod) % mod)",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 1, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "B.append(B[-1] * pow(i, mod - 2, mod) % mod)",
      "mutated_line": "B.append(B[-1] * pow(i, mod - -2, mod) % mod)",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - -2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for j in range(min(n + 1, i // 2 + 1)):",
      "mutated_line": "for j in range(min(n + 1, i // 3 + 1)):",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 3 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for j in range(min(n + 1, i // 2 + 1)):",
      "mutated_line": "for j in range(min(n + 1, i // 1 + 1)):",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 1 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for j in range(min(n + 1, i // 2 + 1)):",
      "mutated_line": "for j in range(min(n + 1, i // 0 + 1)):",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 0 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for j in range(min(n + 1, i // 2 + 1)):",
      "mutated_line": "for j in range(min(n + 1, i // 1 + 1)):",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 1 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for j in range(min(n + 1, i // 2 + 1)):",
      "mutated_line": "for j in range(min(n + 1, i // -2 + 1)):",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // -2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod",
      "mutated_line": "ans[i - 1] = (ans[i + 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i + 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod",
      "mutated_line": "ans[i - 1] = (ans[i * 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i * 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod",
      "mutated_line": "ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) / cmb(i // 2, j) * pow(2, j, mod)) % mod",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) / cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod",
      "mutated_line": "ans[i - 1] = (ans[i - 1] + (cmb(n + k - i, k - i + j) + cmb(i // 2, j)) * pow(2, j, mod)) % mod",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + (cmb(n + k - i, k - i + j) + cmb(i // 2, j)) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod",
      "mutated_line": "ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) ** cmb(i // 2, j) * pow(2, j, mod)) % mod",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) ** cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "return A[n] * B[r] * B[n - r] % mod",
      "mutated_line": "return A[n] * B[r] / B[n - r] % mod",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] / B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "return A[n] * B[r] * B[n - r] % mod",
      "mutated_line": "return (A[n] * B[r] + B[n - r]) % mod",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return (A[n] * B[r] + B[n - r]) % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "return A[n] * B[r] * B[n - r] % mod",
      "mutated_line": "return (A[n] * B[r]) ** B[n - r] % mod",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return (A[n] * B[r]) ** B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod",
      "mutated_line": "ans[i - 1] = (ans[i - 2] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 2] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod",
      "mutated_line": "ans[i - 1] = (ans[i - 0] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 0] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod",
      "mutated_line": "ans[i - 1] = (ans[i - 0] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 0] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod",
      "mutated_line": "ans[i - 1] = (ans[i - -1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - -1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod",
      "mutated_line": "ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(3, j, mod)) % mod",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(3, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod",
      "mutated_line": "ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(1, j, mod)) % mod",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(1, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod",
      "mutated_line": "ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(0, j, mod)) % mod",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(0, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod",
      "mutated_line": "ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(1, j, mod)) % mod",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(1, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod",
      "mutated_line": "ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(-2, j, mod)) % mod",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(-2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "return A[n] * B[r] * B[n - r] % mod",
      "mutated_line": "return A[n] / B[r] * B[n - r] % mod",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] / B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "return A[n] * B[r] * B[n - r] % mod",
      "mutated_line": "return (A[n] + B[r]) * B[n - r] % mod",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return (A[n] + B[r]) * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "return A[n] * B[r] * B[n - r] % mod",
      "mutated_line": "return A[n] ** B[r] * B[n - r] % mod",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] ** B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod",
      "mutated_line": "ans[i - 1] = (ans[i - 1] + cmb(n + k + i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k + i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod",
      "mutated_line": "ans[i - 1] = (ans[i - 1] + cmb((n + k) * i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb((n + k) * i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod",
      "mutated_line": "ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i - j) * cmb(i // 2, j) * pow(2, j, mod)) % mod",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i - j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod",
      "mutated_line": "ans[i - 1] = (ans[i - 1] + cmb(n + k - i, (k - i) * j) * cmb(i // 2, j) * pow(2, j, mod)) % mod",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, (k - i) * j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod",
      "mutated_line": "ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i / 2, j) * pow(2, j, mod)) % mod",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i / 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod",
      "mutated_line": "ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i * 2, j) * pow(2, j, mod)) % mod",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i * 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "return A[n] * B[r] * B[n - r] % mod",
      "mutated_line": "return A[n] * B[r] * B[n + r] % mod",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n + r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "return A[n] * B[r] * B[n - r] % mod",
      "mutated_line": "return A[n] * B[r] * B[n * r] % mod",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n * r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod",
      "mutated_line": "ans[i - 1] = (ans[i - 1] + cmb(n - k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n - k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod",
      "mutated_line": "ans[i - 1] = (ans[i - 1] + cmb(n * k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n * k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod",
      "mutated_line": "ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k + i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k + i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod",
      "mutated_line": "ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k * i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k * i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod",
      "mutated_line": "ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 3, j) * pow(2, j, mod)) % mod",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 3, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod",
      "mutated_line": "ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 1, j) * pow(2, j, mod)) % mod",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 1, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod",
      "mutated_line": "ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 0, j) * pow(2, j, mod)) % mod",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 0, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod",
      "mutated_line": "ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 1, j) * pow(2, j, mod)) % mod",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 1, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // 2, j) * pow(2, j, mod)) % mod",
      "mutated_line": "ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // -2, j) * pow(2, j, mod)) % mod",
      "code": "def count_valid_dice_combinations(k, n):\n\n    def cmb(n, r):\n        if n < 0:\n            return 0\n        if n == 0:\n            if r != 0:\n                return 0\n            else:\n                return 1\n        elif r < 0:\n            return 0\n        elif r > n:\n            return 0\n        elif r == 0:\n            return 1\n        elif r == n:\n            return 1\n        else:\n            return A[n] * B[r] * B[n - r] % mod\n    mod = 998244353\n    A = [1, 1]\n    B = [1, 1]\n    for i in range(2, 4005):\n        A.append(A[-1] * i % mod)\n        B.append(B[-1] * pow(i, mod - 2, mod) % mod)\n    if k == 1:\n        return [0] * (2 * k - 1)\n    ans = [0] * (2 * k + 1)\n    for i in range(2, k + 3):\n        if i % 2 == 0:\n            i = i + 1\n            for j in range(min(n + 1, i // 2 + 1)):\n                ans[i - 1] = (ans[i - 1] + cmb(n + k - i, k - i + j) * cmb(i // -2, j) * pow(2, j, mod)) % mod\n        else:\n            ans[i] = ans[i - 1]\n    for i in range(k + 2, 2 * k + 1):\n        ans[i] = ans[2 * k + 2 - i]\n    return ans[2:2 * k + 1]"
    }
  ]
}