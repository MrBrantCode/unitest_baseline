{
  "task_id": "taco_12872",
  "entry_point": "calculate_visibility_probabilities",
  "mutant_count": 80,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "INF = 10 ** 20",
      "mutated_line": "INF = 10 * 20",
      "code": "from heapq import heappush, heappop\n\ndef calculate_visibility_probabilities(n, m, p, edges, children):\n    INF = 10 * 20\n    graph = [[] for _ in range(n)]\n    for (x, y, w) in edges:\n        graph[x].append((y, w))\n        graph[y].append((x, w))\n    que = []\n    heappush(que, (0, 0))\n    shortest_counter = [[0] * n for _ in range(n)]\n    shortest_counter[0][0] = 1\n    dist = [INF] * n\n    dist[0] = 0\n    path_counter = [0] * n\n    path_counter[0] = 1\n    while que:\n        (total, node) = heappop(que)\n        count = shortest_counter[node]\n        for (to, w) in graph[node]:\n            new_total = total + w\n            new_count = [i for i in count]\n            new_count[to] += path_counter[node]\n            if dist[to] > new_total:\n                dist[to] = new_total\n                shortest_counter[to] = [i for i in new_count]\n                path_counter[to] = path_counter[node]\n                heappush(que, (new_total, to))\n            elif dist[to] == new_total:\n                shortest_counter[to] = [i + j for (i, j) in zip(shortest_counter[to], new_count)]\n                path_counter[to] += path_counter[node]\n    probabilities = []\n    for child in children:\n        probabilities.append(shortest_counter[n - 1][child] / path_counter[n - 1])\n    return probabilities"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "INF = 10 ** 20",
      "mutated_line": "INF = 10 + 20",
      "code": "from heapq import heappush, heappop\n\ndef calculate_visibility_probabilities(n, m, p, edges, children):\n    INF = 10 + 20\n    graph = [[] for _ in range(n)]\n    for (x, y, w) in edges:\n        graph[x].append((y, w))\n        graph[y].append((x, w))\n    que = []\n    heappush(que, (0, 0))\n    shortest_counter = [[0] * n for _ in range(n)]\n    shortest_counter[0][0] = 1\n    dist = [INF] * n\n    dist[0] = 0\n    path_counter = [0] * n\n    path_counter[0] = 1\n    while que:\n        (total, node) = heappop(que)\n        count = shortest_counter[node]\n        for (to, w) in graph[node]:\n            new_total = total + w\n            new_count = [i for i in count]\n            new_count[to] += path_counter[node]\n            if dist[to] > new_total:\n                dist[to] = new_total\n                shortest_counter[to] = [i for i in new_count]\n                path_counter[to] = path_counter[node]\n                heappush(que, (new_total, to))\n            elif dist[to] == new_total:\n                shortest_counter[to] = [i + j for (i, j) in zip(shortest_counter[to], new_count)]\n                path_counter[to] += path_counter[node]\n    probabilities = []\n    for child in children:\n        probabilities.append(shortest_counter[n - 1][child] / path_counter[n - 1])\n    return probabilities"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "shortest_counter[0][0] = 1",
      "mutated_line": "shortest_counter[0][0] = 2",
      "code": "from heapq import heappush, heappop\n\ndef calculate_visibility_probabilities(n, m, p, edges, children):\n    INF = 10 ** 20\n    graph = [[] for _ in range(n)]\n    for (x, y, w) in edges:\n        graph[x].append((y, w))\n        graph[y].append((x, w))\n    que = []\n    heappush(que, (0, 0))\n    shortest_counter = [[0] * n for _ in range(n)]\n    shortest_counter[0][0] = 2\n    dist = [INF] * n\n    dist[0] = 0\n    path_counter = [0] * n\n    path_counter[0] = 1\n    while que:\n        (total, node) = heappop(que)\n        count = shortest_counter[node]\n        for (to, w) in graph[node]:\n            new_total = total + w\n            new_count = [i for i in count]\n            new_count[to] += path_counter[node]\n            if dist[to] > new_total:\n                dist[to] = new_total\n                shortest_counter[to] = [i for i in new_count]\n                path_counter[to] = path_counter[node]\n                heappush(que, (new_total, to))\n            elif dist[to] == new_total:\n                shortest_counter[to] = [i + j for (i, j) in zip(shortest_counter[to], new_count)]\n                path_counter[to] += path_counter[node]\n    probabilities = []\n    for child in children:\n        probabilities.append(shortest_counter[n - 1][child] / path_counter[n - 1])\n    return probabilities"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "shortest_counter[0][0] = 1",
      "mutated_line": "shortest_counter[0][0] = 0",
      "code": "from heapq import heappush, heappop\n\ndef calculate_visibility_probabilities(n, m, p, edges, children):\n    INF = 10 ** 20\n    graph = [[] for _ in range(n)]\n    for (x, y, w) in edges:\n        graph[x].append((y, w))\n        graph[y].append((x, w))\n    que = []\n    heappush(que, (0, 0))\n    shortest_counter = [[0] * n for _ in range(n)]\n    shortest_counter[0][0] = 0\n    dist = [INF] * n\n    dist[0] = 0\n    path_counter = [0] * n\n    path_counter[0] = 1\n    while que:\n        (total, node) = heappop(que)\n        count = shortest_counter[node]\n        for (to, w) in graph[node]:\n            new_total = total + w\n            new_count = [i for i in count]\n            new_count[to] += path_counter[node]\n            if dist[to] > new_total:\n                dist[to] = new_total\n                shortest_counter[to] = [i for i in new_count]\n                path_counter[to] = path_counter[node]\n                heappush(que, (new_total, to))\n            elif dist[to] == new_total:\n                shortest_counter[to] = [i + j for (i, j) in zip(shortest_counter[to], new_count)]\n                path_counter[to] += path_counter[node]\n    probabilities = []\n    for child in children:\n        probabilities.append(shortest_counter[n - 1][child] / path_counter[n - 1])\n    return probabilities"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "shortest_counter[0][0] = 1",
      "mutated_line": "shortest_counter[0][0] = 0",
      "code": "from heapq import heappush, heappop\n\ndef calculate_visibility_probabilities(n, m, p, edges, children):\n    INF = 10 ** 20\n    graph = [[] for _ in range(n)]\n    for (x, y, w) in edges:\n        graph[x].append((y, w))\n        graph[y].append((x, w))\n    que = []\n    heappush(que, (0, 0))\n    shortest_counter = [[0] * n for _ in range(n)]\n    shortest_counter[0][0] = 0\n    dist = [INF] * n\n    dist[0] = 0\n    path_counter = [0] * n\n    path_counter[0] = 1\n    while que:\n        (total, node) = heappop(que)\n        count = shortest_counter[node]\n        for (to, w) in graph[node]:\n            new_total = total + w\n            new_count = [i for i in count]\n            new_count[to] += path_counter[node]\n            if dist[to] > new_total:\n                dist[to] = new_total\n                shortest_counter[to] = [i for i in new_count]\n                path_counter[to] = path_counter[node]\n                heappush(que, (new_total, to))\n            elif dist[to] == new_total:\n                shortest_counter[to] = [i + j for (i, j) in zip(shortest_counter[to], new_count)]\n                path_counter[to] += path_counter[node]\n    probabilities = []\n    for child in children:\n        probabilities.append(shortest_counter[n - 1][child] / path_counter[n - 1])\n    return probabilities"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "shortest_counter[0][0] = 1",
      "mutated_line": "shortest_counter[0][0] = -1",
      "code": "from heapq import heappush, heappop\n\ndef calculate_visibility_probabilities(n, m, p, edges, children):\n    INF = 10 ** 20\n    graph = [[] for _ in range(n)]\n    for (x, y, w) in edges:\n        graph[x].append((y, w))\n        graph[y].append((x, w))\n    que = []\n    heappush(que, (0, 0))\n    shortest_counter = [[0] * n for _ in range(n)]\n    shortest_counter[0][0] = -1\n    dist = [INF] * n\n    dist[0] = 0\n    path_counter = [0] * n\n    path_counter[0] = 1\n    while que:\n        (total, node) = heappop(que)\n        count = shortest_counter[node]\n        for (to, w) in graph[node]:\n            new_total = total + w\n            new_count = [i for i in count]\n            new_count[to] += path_counter[node]\n            if dist[to] > new_total:\n                dist[to] = new_total\n                shortest_counter[to] = [i for i in new_count]\n                path_counter[to] = path_counter[node]\n                heappush(que, (new_total, to))\n            elif dist[to] == new_total:\n                shortest_counter[to] = [i + j for (i, j) in zip(shortest_counter[to], new_count)]\n                path_counter[to] += path_counter[node]\n    probabilities = []\n    for child in children:\n        probabilities.append(shortest_counter[n - 1][child] / path_counter[n - 1])\n    return probabilities"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "dist = [INF] * n",
      "mutated_line": "dist = [INF] / n",
      "code": "from heapq import heappush, heappop\n\ndef calculate_visibility_probabilities(n, m, p, edges, children):\n    INF = 10 ** 20\n    graph = [[] for _ in range(n)]\n    for (x, y, w) in edges:\n        graph[x].append((y, w))\n        graph[y].append((x, w))\n    que = []\n    heappush(que, (0, 0))\n    shortest_counter = [[0] * n for _ in range(n)]\n    shortest_counter[0][0] = 1\n    dist = [INF] / n\n    dist[0] = 0\n    path_counter = [0] * n\n    path_counter[0] = 1\n    while que:\n        (total, node) = heappop(que)\n        count = shortest_counter[node]\n        for (to, w) in graph[node]:\n            new_total = total + w\n            new_count = [i for i in count]\n            new_count[to] += path_counter[node]\n            if dist[to] > new_total:\n                dist[to] = new_total\n                shortest_counter[to] = [i for i in new_count]\n                path_counter[to] = path_counter[node]\n                heappush(que, (new_total, to))\n            elif dist[to] == new_total:\n                shortest_counter[to] = [i + j for (i, j) in zip(shortest_counter[to], new_count)]\n                path_counter[to] += path_counter[node]\n    probabilities = []\n    for child in children:\n        probabilities.append(shortest_counter[n - 1][child] / path_counter[n - 1])\n    return probabilities"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "dist = [INF] * n",
      "mutated_line": "dist = [INF] + n",
      "code": "from heapq import heappush, heappop\n\ndef calculate_visibility_probabilities(n, m, p, edges, children):\n    INF = 10 ** 20\n    graph = [[] for _ in range(n)]\n    for (x, y, w) in edges:\n        graph[x].append((y, w))\n        graph[y].append((x, w))\n    que = []\n    heappush(que, (0, 0))\n    shortest_counter = [[0] * n for _ in range(n)]\n    shortest_counter[0][0] = 1\n    dist = [INF] + n\n    dist[0] = 0\n    path_counter = [0] * n\n    path_counter[0] = 1\n    while que:\n        (total, node) = heappop(que)\n        count = shortest_counter[node]\n        for (to, w) in graph[node]:\n            new_total = total + w\n            new_count = [i for i in count]\n            new_count[to] += path_counter[node]\n            if dist[to] > new_total:\n                dist[to] = new_total\n                shortest_counter[to] = [i for i in new_count]\n                path_counter[to] = path_counter[node]\n                heappush(que, (new_total, to))\n            elif dist[to] == new_total:\n                shortest_counter[to] = [i + j for (i, j) in zip(shortest_counter[to], new_count)]\n                path_counter[to] += path_counter[node]\n    probabilities = []\n    for child in children:\n        probabilities.append(shortest_counter[n - 1][child] / path_counter[n - 1])\n    return probabilities"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "dist = [INF] * n",
      "mutated_line": "dist = [INF] ** n",
      "code": "from heapq import heappush, heappop\n\ndef calculate_visibility_probabilities(n, m, p, edges, children):\n    INF = 10 ** 20\n    graph = [[] for _ in range(n)]\n    for (x, y, w) in edges:\n        graph[x].append((y, w))\n        graph[y].append((x, w))\n    que = []\n    heappush(que, (0, 0))\n    shortest_counter = [[0] * n for _ in range(n)]\n    shortest_counter[0][0] = 1\n    dist = [INF] ** n\n    dist[0] = 0\n    path_counter = [0] * n\n    path_counter[0] = 1\n    while que:\n        (total, node) = heappop(que)\n        count = shortest_counter[node]\n        for (to, w) in graph[node]:\n            new_total = total + w\n            new_count = [i for i in count]\n            new_count[to] += path_counter[node]\n            if dist[to] > new_total:\n                dist[to] = new_total\n                shortest_counter[to] = [i for i in new_count]\n                path_counter[to] = path_counter[node]\n                heappush(que, (new_total, to))\n            elif dist[to] == new_total:\n                shortest_counter[to] = [i + j for (i, j) in zip(shortest_counter[to], new_count)]\n                path_counter[to] += path_counter[node]\n    probabilities = []\n    for child in children:\n        probabilities.append(shortest_counter[n - 1][child] / path_counter[n - 1])\n    return probabilities"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dist[0] = 0",
      "mutated_line": "dist[0] = 1",
      "code": "from heapq import heappush, heappop\n\ndef calculate_visibility_probabilities(n, m, p, edges, children):\n    INF = 10 ** 20\n    graph = [[] for _ in range(n)]\n    for (x, y, w) in edges:\n        graph[x].append((y, w))\n        graph[y].append((x, w))\n    que = []\n    heappush(que, (0, 0))\n    shortest_counter = [[0] * n for _ in range(n)]\n    shortest_counter[0][0] = 1\n    dist = [INF] * n\n    dist[0] = 1\n    path_counter = [0] * n\n    path_counter[0] = 1\n    while que:\n        (total, node) = heappop(que)\n        count = shortest_counter[node]\n        for (to, w) in graph[node]:\n            new_total = total + w\n            new_count = [i for i in count]\n            new_count[to] += path_counter[node]\n            if dist[to] > new_total:\n                dist[to] = new_total\n                shortest_counter[to] = [i for i in new_count]\n                path_counter[to] = path_counter[node]\n                heappush(que, (new_total, to))\n            elif dist[to] == new_total:\n                shortest_counter[to] = [i + j for (i, j) in zip(shortest_counter[to], new_count)]\n                path_counter[to] += path_counter[node]\n    probabilities = []\n    for child in children:\n        probabilities.append(shortest_counter[n - 1][child] / path_counter[n - 1])\n    return probabilities"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dist[0] = 0",
      "mutated_line": "dist[0] = -1",
      "code": "from heapq import heappush, heappop\n\ndef calculate_visibility_probabilities(n, m, p, edges, children):\n    INF = 10 ** 20\n    graph = [[] for _ in range(n)]\n    for (x, y, w) in edges:\n        graph[x].append((y, w))\n        graph[y].append((x, w))\n    que = []\n    heappush(que, (0, 0))\n    shortest_counter = [[0] * n for _ in range(n)]\n    shortest_counter[0][0] = 1\n    dist = [INF] * n\n    dist[0] = -1\n    path_counter = [0] * n\n    path_counter[0] = 1\n    while que:\n        (total, node) = heappop(que)\n        count = shortest_counter[node]\n        for (to, w) in graph[node]:\n            new_total = total + w\n            new_count = [i for i in count]\n            new_count[to] += path_counter[node]\n            if dist[to] > new_total:\n                dist[to] = new_total\n                shortest_counter[to] = [i for i in new_count]\n                path_counter[to] = path_counter[node]\n                heappush(que, (new_total, to))\n            elif dist[to] == new_total:\n                shortest_counter[to] = [i + j for (i, j) in zip(shortest_counter[to], new_count)]\n                path_counter[to] += path_counter[node]\n    probabilities = []\n    for child in children:\n        probabilities.append(shortest_counter[n - 1][child] / path_counter[n - 1])\n    return probabilities"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dist[0] = 0",
      "mutated_line": "dist[0] = 1",
      "code": "from heapq import heappush, heappop\n\ndef calculate_visibility_probabilities(n, m, p, edges, children):\n    INF = 10 ** 20\n    graph = [[] for _ in range(n)]\n    for (x, y, w) in edges:\n        graph[x].append((y, w))\n        graph[y].append((x, w))\n    que = []\n    heappush(que, (0, 0))\n    shortest_counter = [[0] * n for _ in range(n)]\n    shortest_counter[0][0] = 1\n    dist = [INF] * n\n    dist[0] = 1\n    path_counter = [0] * n\n    path_counter[0] = 1\n    while que:\n        (total, node) = heappop(que)\n        count = shortest_counter[node]\n        for (to, w) in graph[node]:\n            new_total = total + w\n            new_count = [i for i in count]\n            new_count[to] += path_counter[node]\n            if dist[to] > new_total:\n                dist[to] = new_total\n                shortest_counter[to] = [i for i in new_count]\n                path_counter[to] = path_counter[node]\n                heappush(que, (new_total, to))\n            elif dist[to] == new_total:\n                shortest_counter[to] = [i + j for (i, j) in zip(shortest_counter[to], new_count)]\n                path_counter[to] += path_counter[node]\n    probabilities = []\n    for child in children:\n        probabilities.append(shortest_counter[n - 1][child] / path_counter[n - 1])\n    return probabilities"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "path_counter = [0] * n",
      "mutated_line": "path_counter = [0] / n",
      "code": "from heapq import heappush, heappop\n\ndef calculate_visibility_probabilities(n, m, p, edges, children):\n    INF = 10 ** 20\n    graph = [[] for _ in range(n)]\n    for (x, y, w) in edges:\n        graph[x].append((y, w))\n        graph[y].append((x, w))\n    que = []\n    heappush(que, (0, 0))\n    shortest_counter = [[0] * n for _ in range(n)]\n    shortest_counter[0][0] = 1\n    dist = [INF] * n\n    dist[0] = 0\n    path_counter = [0] / n\n    path_counter[0] = 1\n    while que:\n        (total, node) = heappop(que)\n        count = shortest_counter[node]\n        for (to, w) in graph[node]:\n            new_total = total + w\n            new_count = [i for i in count]\n            new_count[to] += path_counter[node]\n            if dist[to] > new_total:\n                dist[to] = new_total\n                shortest_counter[to] = [i for i in new_count]\n                path_counter[to] = path_counter[node]\n                heappush(que, (new_total, to))\n            elif dist[to] == new_total:\n                shortest_counter[to] = [i + j for (i, j) in zip(shortest_counter[to], new_count)]\n                path_counter[to] += path_counter[node]\n    probabilities = []\n    for child in children:\n        probabilities.append(shortest_counter[n - 1][child] / path_counter[n - 1])\n    return probabilities"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "path_counter = [0] * n",
      "mutated_line": "path_counter = [0] + n",
      "code": "from heapq import heappush, heappop\n\ndef calculate_visibility_probabilities(n, m, p, edges, children):\n    INF = 10 ** 20\n    graph = [[] for _ in range(n)]\n    for (x, y, w) in edges:\n        graph[x].append((y, w))\n        graph[y].append((x, w))\n    que = []\n    heappush(que, (0, 0))\n    shortest_counter = [[0] * n for _ in range(n)]\n    shortest_counter[0][0] = 1\n    dist = [INF] * n\n    dist[0] = 0\n    path_counter = [0] + n\n    path_counter[0] = 1\n    while que:\n        (total, node) = heappop(que)\n        count = shortest_counter[node]\n        for (to, w) in graph[node]:\n            new_total = total + w\n            new_count = [i for i in count]\n            new_count[to] += path_counter[node]\n            if dist[to] > new_total:\n                dist[to] = new_total\n                shortest_counter[to] = [i for i in new_count]\n                path_counter[to] = path_counter[node]\n                heappush(que, (new_total, to))\n            elif dist[to] == new_total:\n                shortest_counter[to] = [i + j for (i, j) in zip(shortest_counter[to], new_count)]\n                path_counter[to] += path_counter[node]\n    probabilities = []\n    for child in children:\n        probabilities.append(shortest_counter[n - 1][child] / path_counter[n - 1])\n    return probabilities"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "path_counter = [0] * n",
      "mutated_line": "path_counter = [0] ** n",
      "code": "from heapq import heappush, heappop\n\ndef calculate_visibility_probabilities(n, m, p, edges, children):\n    INF = 10 ** 20\n    graph = [[] for _ in range(n)]\n    for (x, y, w) in edges:\n        graph[x].append((y, w))\n        graph[y].append((x, w))\n    que = []\n    heappush(que, (0, 0))\n    shortest_counter = [[0] * n for _ in range(n)]\n    shortest_counter[0][0] = 1\n    dist = [INF] * n\n    dist[0] = 0\n    path_counter = [0] ** n\n    path_counter[0] = 1\n    while que:\n        (total, node) = heappop(que)\n        count = shortest_counter[node]\n        for (to, w) in graph[node]:\n            new_total = total + w\n            new_count = [i for i in count]\n            new_count[to] += path_counter[node]\n            if dist[to] > new_total:\n                dist[to] = new_total\n                shortest_counter[to] = [i for i in new_count]\n                path_counter[to] = path_counter[node]\n                heappush(que, (new_total, to))\n            elif dist[to] == new_total:\n                shortest_counter[to] = [i + j for (i, j) in zip(shortest_counter[to], new_count)]\n                path_counter[to] += path_counter[node]\n    probabilities = []\n    for child in children:\n        probabilities.append(shortest_counter[n - 1][child] / path_counter[n - 1])\n    return probabilities"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "path_counter[0] = 1",
      "mutated_line": "path_counter[0] = 2",
      "code": "from heapq import heappush, heappop\n\ndef calculate_visibility_probabilities(n, m, p, edges, children):\n    INF = 10 ** 20\n    graph = [[] for _ in range(n)]\n    for (x, y, w) in edges:\n        graph[x].append((y, w))\n        graph[y].append((x, w))\n    que = []\n    heappush(que, (0, 0))\n    shortest_counter = [[0] * n for _ in range(n)]\n    shortest_counter[0][0] = 1\n    dist = [INF] * n\n    dist[0] = 0\n    path_counter = [0] * n\n    path_counter[0] = 2\n    while que:\n        (total, node) = heappop(que)\n        count = shortest_counter[node]\n        for (to, w) in graph[node]:\n            new_total = total + w\n            new_count = [i for i in count]\n            new_count[to] += path_counter[node]\n            if dist[to] > new_total:\n                dist[to] = new_total\n                shortest_counter[to] = [i for i in new_count]\n                path_counter[to] = path_counter[node]\n                heappush(que, (new_total, to))\n            elif dist[to] == new_total:\n                shortest_counter[to] = [i + j for (i, j) in zip(shortest_counter[to], new_count)]\n                path_counter[to] += path_counter[node]\n    probabilities = []\n    for child in children:\n        probabilities.append(shortest_counter[n - 1][child] / path_counter[n - 1])\n    return probabilities"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "path_counter[0] = 1",
      "mutated_line": "path_counter[0] = 0",
      "code": "from heapq import heappush, heappop\n\ndef calculate_visibility_probabilities(n, m, p, edges, children):\n    INF = 10 ** 20\n    graph = [[] for _ in range(n)]\n    for (x, y, w) in edges:\n        graph[x].append((y, w))\n        graph[y].append((x, w))\n    que = []\n    heappush(que, (0, 0))\n    shortest_counter = [[0] * n for _ in range(n)]\n    shortest_counter[0][0] = 1\n    dist = [INF] * n\n    dist[0] = 0\n    path_counter = [0] * n\n    path_counter[0] = 0\n    while que:\n        (total, node) = heappop(que)\n        count = shortest_counter[node]\n        for (to, w) in graph[node]:\n            new_total = total + w\n            new_count = [i for i in count]\n            new_count[to] += path_counter[node]\n            if dist[to] > new_total:\n                dist[to] = new_total\n                shortest_counter[to] = [i for i in new_count]\n                path_counter[to] = path_counter[node]\n                heappush(que, (new_total, to))\n            elif dist[to] == new_total:\n                shortest_counter[to] = [i + j for (i, j) in zip(shortest_counter[to], new_count)]\n                path_counter[to] += path_counter[node]\n    probabilities = []\n    for child in children:\n        probabilities.append(shortest_counter[n - 1][child] / path_counter[n - 1])\n    return probabilities"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "path_counter[0] = 1",
      "mutated_line": "path_counter[0] = 0",
      "code": "from heapq import heappush, heappop\n\ndef calculate_visibility_probabilities(n, m, p, edges, children):\n    INF = 10 ** 20\n    graph = [[] for _ in range(n)]\n    for (x, y, w) in edges:\n        graph[x].append((y, w))\n        graph[y].append((x, w))\n    que = []\n    heappush(que, (0, 0))\n    shortest_counter = [[0] * n for _ in range(n)]\n    shortest_counter[0][0] = 1\n    dist = [INF] * n\n    dist[0] = 0\n    path_counter = [0] * n\n    path_counter[0] = 0\n    while que:\n        (total, node) = heappop(que)\n        count = shortest_counter[node]\n        for (to, w) in graph[node]:\n            new_total = total + w\n            new_count = [i for i in count]\n            new_count[to] += path_counter[node]\n            if dist[to] > new_total:\n                dist[to] = new_total\n                shortest_counter[to] = [i for i in new_count]\n                path_counter[to] = path_counter[node]\n                heappush(que, (new_total, to))\n            elif dist[to] == new_total:\n                shortest_counter[to] = [i + j for (i, j) in zip(shortest_counter[to], new_count)]\n                path_counter[to] += path_counter[node]\n    probabilities = []\n    for child in children:\n        probabilities.append(shortest_counter[n - 1][child] / path_counter[n - 1])\n    return probabilities"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "path_counter[0] = 1",
      "mutated_line": "path_counter[0] = -1",
      "code": "from heapq import heappush, heappop\n\ndef calculate_visibility_probabilities(n, m, p, edges, children):\n    INF = 10 ** 20\n    graph = [[] for _ in range(n)]\n    for (x, y, w) in edges:\n        graph[x].append((y, w))\n        graph[y].append((x, w))\n    que = []\n    heappush(que, (0, 0))\n    shortest_counter = [[0] * n for _ in range(n)]\n    shortest_counter[0][0] = 1\n    dist = [INF] * n\n    dist[0] = 0\n    path_counter = [0] * n\n    path_counter[0] = -1\n    while que:\n        (total, node) = heappop(que)\n        count = shortest_counter[node]\n        for (to, w) in graph[node]:\n            new_total = total + w\n            new_count = [i for i in count]\n            new_count[to] += path_counter[node]\n            if dist[to] > new_total:\n                dist[to] = new_total\n                shortest_counter[to] = [i for i in new_count]\n                path_counter[to] = path_counter[node]\n                heappush(que, (new_total, to))\n            elif dist[to] == new_total:\n                shortest_counter[to] = [i + j for (i, j) in zip(shortest_counter[to], new_count)]\n                path_counter[to] += path_counter[node]\n    probabilities = []\n    for child in children:\n        probabilities.append(shortest_counter[n - 1][child] / path_counter[n - 1])\n    return probabilities"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "INF = 10 ** 20",
      "mutated_line": "INF = 11 ** 20",
      "code": "from heapq import heappush, heappop\n\ndef calculate_visibility_probabilities(n, m, p, edges, children):\n    INF = 11 ** 20\n    graph = [[] for _ in range(n)]\n    for (x, y, w) in edges:\n        graph[x].append((y, w))\n        graph[y].append((x, w))\n    que = []\n    heappush(que, (0, 0))\n    shortest_counter = [[0] * n for _ in range(n)]\n    shortest_counter[0][0] = 1\n    dist = [INF] * n\n    dist[0] = 0\n    path_counter = [0] * n\n    path_counter[0] = 1\n    while que:\n        (total, node) = heappop(que)\n        count = shortest_counter[node]\n        for (to, w) in graph[node]:\n            new_total = total + w\n            new_count = [i for i in count]\n            new_count[to] += path_counter[node]\n            if dist[to] > new_total:\n                dist[to] = new_total\n                shortest_counter[to] = [i for i in new_count]\n                path_counter[to] = path_counter[node]\n                heappush(que, (new_total, to))\n            elif dist[to] == new_total:\n                shortest_counter[to] = [i + j for (i, j) in zip(shortest_counter[to], new_count)]\n                path_counter[to] += path_counter[node]\n    probabilities = []\n    for child in children:\n        probabilities.append(shortest_counter[n - 1][child] / path_counter[n - 1])\n    return probabilities"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "INF = 10 ** 20",
      "mutated_line": "INF = 9 ** 20",
      "code": "from heapq import heappush, heappop\n\ndef calculate_visibility_probabilities(n, m, p, edges, children):\n    INF = 9 ** 20\n    graph = [[] for _ in range(n)]\n    for (x, y, w) in edges:\n        graph[x].append((y, w))\n        graph[y].append((x, w))\n    que = []\n    heappush(que, (0, 0))\n    shortest_counter = [[0] * n for _ in range(n)]\n    shortest_counter[0][0] = 1\n    dist = [INF] * n\n    dist[0] = 0\n    path_counter = [0] * n\n    path_counter[0] = 1\n    while que:\n        (total, node) = heappop(que)\n        count = shortest_counter[node]\n        for (to, w) in graph[node]:\n            new_total = total + w\n            new_count = [i for i in count]\n            new_count[to] += path_counter[node]\n            if dist[to] > new_total:\n                dist[to] = new_total\n                shortest_counter[to] = [i for i in new_count]\n                path_counter[to] = path_counter[node]\n                heappush(que, (new_total, to))\n            elif dist[to] == new_total:\n                shortest_counter[to] = [i + j for (i, j) in zip(shortest_counter[to], new_count)]\n                path_counter[to] += path_counter[node]\n    probabilities = []\n    for child in children:\n        probabilities.append(shortest_counter[n - 1][child] / path_counter[n - 1])\n    return probabilities"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "INF = 10 ** 20",
      "mutated_line": "INF = 0 ** 20",
      "code": "from heapq import heappush, heappop\n\ndef calculate_visibility_probabilities(n, m, p, edges, children):\n    INF = 0 ** 20\n    graph = [[] for _ in range(n)]\n    for (x, y, w) in edges:\n        graph[x].append((y, w))\n        graph[y].append((x, w))\n    que = []\n    heappush(que, (0, 0))\n    shortest_counter = [[0] * n for _ in range(n)]\n    shortest_counter[0][0] = 1\n    dist = [INF] * n\n    dist[0] = 0\n    path_counter = [0] * n\n    path_counter[0] = 1\n    while que:\n        (total, node) = heappop(que)\n        count = shortest_counter[node]\n        for (to, w) in graph[node]:\n            new_total = total + w\n            new_count = [i for i in count]\n            new_count[to] += path_counter[node]\n            if dist[to] > new_total:\n                dist[to] = new_total\n                shortest_counter[to] = [i for i in new_count]\n                path_counter[to] = path_counter[node]\n                heappush(que, (new_total, to))\n            elif dist[to] == new_total:\n                shortest_counter[to] = [i + j for (i, j) in zip(shortest_counter[to], new_count)]\n                path_counter[to] += path_counter[node]\n    probabilities = []\n    for child in children:\n        probabilities.append(shortest_counter[n - 1][child] / path_counter[n - 1])\n    return probabilities"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "INF = 10 ** 20",
      "mutated_line": "INF = 1 ** 20",
      "code": "from heapq import heappush, heappop\n\ndef calculate_visibility_probabilities(n, m, p, edges, children):\n    INF = 1 ** 20\n    graph = [[] for _ in range(n)]\n    for (x, y, w) in edges:\n        graph[x].append((y, w))\n        graph[y].append((x, w))\n    que = []\n    heappush(que, (0, 0))\n    shortest_counter = [[0] * n for _ in range(n)]\n    shortest_counter[0][0] = 1\n    dist = [INF] * n\n    dist[0] = 0\n    path_counter = [0] * n\n    path_counter[0] = 1\n    while que:\n        (total, node) = heappop(que)\n        count = shortest_counter[node]\n        for (to, w) in graph[node]:\n            new_total = total + w\n            new_count = [i for i in count]\n            new_count[to] += path_counter[node]\n            if dist[to] > new_total:\n                dist[to] = new_total\n                shortest_counter[to] = [i for i in new_count]\n                path_counter[to] = path_counter[node]\n                heappush(que, (new_total, to))\n            elif dist[to] == new_total:\n                shortest_counter[to] = [i + j for (i, j) in zip(shortest_counter[to], new_count)]\n                path_counter[to] += path_counter[node]\n    probabilities = []\n    for child in children:\n        probabilities.append(shortest_counter[n - 1][child] / path_counter[n - 1])\n    return probabilities"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "INF = 10 ** 20",
      "mutated_line": "INF = -10 ** 20",
      "code": "from heapq import heappush, heappop\n\ndef calculate_visibility_probabilities(n, m, p, edges, children):\n    INF = -10 ** 20\n    graph = [[] for _ in range(n)]\n    for (x, y, w) in edges:\n        graph[x].append((y, w))\n        graph[y].append((x, w))\n    que = []\n    heappush(que, (0, 0))\n    shortest_counter = [[0] * n for _ in range(n)]\n    shortest_counter[0][0] = 1\n    dist = [INF] * n\n    dist[0] = 0\n    path_counter = [0] * n\n    path_counter[0] = 1\n    while que:\n        (total, node) = heappop(que)\n        count = shortest_counter[node]\n        for (to, w) in graph[node]:\n            new_total = total + w\n            new_count = [i for i in count]\n            new_count[to] += path_counter[node]\n            if dist[to] > new_total:\n                dist[to] = new_total\n                shortest_counter[to] = [i for i in new_count]\n                path_counter[to] = path_counter[node]\n                heappush(que, (new_total, to))\n            elif dist[to] == new_total:\n                shortest_counter[to] = [i + j for (i, j) in zip(shortest_counter[to], new_count)]\n                path_counter[to] += path_counter[node]\n    probabilities = []\n    for child in children:\n        probabilities.append(shortest_counter[n - 1][child] / path_counter[n - 1])\n    return probabilities"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "INF = 10 ** 20",
      "mutated_line": "INF = 10 ** 21",
      "code": "from heapq import heappush, heappop\n\ndef calculate_visibility_probabilities(n, m, p, edges, children):\n    INF = 10 ** 21\n    graph = [[] for _ in range(n)]\n    for (x, y, w) in edges:\n        graph[x].append((y, w))\n        graph[y].append((x, w))\n    que = []\n    heappush(que, (0, 0))\n    shortest_counter = [[0] * n for _ in range(n)]\n    shortest_counter[0][0] = 1\n    dist = [INF] * n\n    dist[0] = 0\n    path_counter = [0] * n\n    path_counter[0] = 1\n    while que:\n        (total, node) = heappop(que)\n        count = shortest_counter[node]\n        for (to, w) in graph[node]:\n            new_total = total + w\n            new_count = [i for i in count]\n            new_count[to] += path_counter[node]\n            if dist[to] > new_total:\n                dist[to] = new_total\n                shortest_counter[to] = [i for i in new_count]\n                path_counter[to] = path_counter[node]\n                heappush(que, (new_total, to))\n            elif dist[to] == new_total:\n                shortest_counter[to] = [i + j for (i, j) in zip(shortest_counter[to], new_count)]\n                path_counter[to] += path_counter[node]\n    probabilities = []\n    for child in children:\n        probabilities.append(shortest_counter[n - 1][child] / path_counter[n - 1])\n    return probabilities"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "INF = 10 ** 20",
      "mutated_line": "INF = 10 ** 19",
      "code": "from heapq import heappush, heappop\n\ndef calculate_visibility_probabilities(n, m, p, edges, children):\n    INF = 10 ** 19\n    graph = [[] for _ in range(n)]\n    for (x, y, w) in edges:\n        graph[x].append((y, w))\n        graph[y].append((x, w))\n    que = []\n    heappush(que, (0, 0))\n    shortest_counter = [[0] * n for _ in range(n)]\n    shortest_counter[0][0] = 1\n    dist = [INF] * n\n    dist[0] = 0\n    path_counter = [0] * n\n    path_counter[0] = 1\n    while que:\n        (total, node) = heappop(que)\n        count = shortest_counter[node]\n        for (to, w) in graph[node]:\n            new_total = total + w\n            new_count = [i for i in count]\n            new_count[to] += path_counter[node]\n            if dist[to] > new_total:\n                dist[to] = new_total\n                shortest_counter[to] = [i for i in new_count]\n                path_counter[to] = path_counter[node]\n                heappush(que, (new_total, to))\n            elif dist[to] == new_total:\n                shortest_counter[to] = [i + j for (i, j) in zip(shortest_counter[to], new_count)]\n                path_counter[to] += path_counter[node]\n    probabilities = []\n    for child in children:\n        probabilities.append(shortest_counter[n - 1][child] / path_counter[n - 1])\n    return probabilities"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "INF = 10 ** 20",
      "mutated_line": "INF = 10 ** 0",
      "code": "from heapq import heappush, heappop\n\ndef calculate_visibility_probabilities(n, m, p, edges, children):\n    INF = 10 ** 0\n    graph = [[] for _ in range(n)]\n    for (x, y, w) in edges:\n        graph[x].append((y, w))\n        graph[y].append((x, w))\n    que = []\n    heappush(que, (0, 0))\n    shortest_counter = [[0] * n for _ in range(n)]\n    shortest_counter[0][0] = 1\n    dist = [INF] * n\n    dist[0] = 0\n    path_counter = [0] * n\n    path_counter[0] = 1\n    while que:\n        (total, node) = heappop(que)\n        count = shortest_counter[node]\n        for (to, w) in graph[node]:\n            new_total = total + w\n            new_count = [i for i in count]\n            new_count[to] += path_counter[node]\n            if dist[to] > new_total:\n                dist[to] = new_total\n                shortest_counter[to] = [i for i in new_count]\n                path_counter[to] = path_counter[node]\n                heappush(que, (new_total, to))\n            elif dist[to] == new_total:\n                shortest_counter[to] = [i + j for (i, j) in zip(shortest_counter[to], new_count)]\n                path_counter[to] += path_counter[node]\n    probabilities = []\n    for child in children:\n        probabilities.append(shortest_counter[n - 1][child] / path_counter[n - 1])\n    return probabilities"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "INF = 10 ** 20",
      "mutated_line": "INF = 10 ** 1",
      "code": "from heapq import heappush, heappop\n\ndef calculate_visibility_probabilities(n, m, p, edges, children):\n    INF = 10 ** 1\n    graph = [[] for _ in range(n)]\n    for (x, y, w) in edges:\n        graph[x].append((y, w))\n        graph[y].append((x, w))\n    que = []\n    heappush(que, (0, 0))\n    shortest_counter = [[0] * n for _ in range(n)]\n    shortest_counter[0][0] = 1\n    dist = [INF] * n\n    dist[0] = 0\n    path_counter = [0] * n\n    path_counter[0] = 1\n    while que:\n        (total, node) = heappop(que)\n        count = shortest_counter[node]\n        for (to, w) in graph[node]:\n            new_total = total + w\n            new_count = [i for i in count]\n            new_count[to] += path_counter[node]\n            if dist[to] > new_total:\n                dist[to] = new_total\n                shortest_counter[to] = [i for i in new_count]\n                path_counter[to] = path_counter[node]\n                heappush(que, (new_total, to))\n            elif dist[to] == new_total:\n                shortest_counter[to] = [i + j for (i, j) in zip(shortest_counter[to], new_count)]\n                path_counter[to] += path_counter[node]\n    probabilities = []\n    for child in children:\n        probabilities.append(shortest_counter[n - 1][child] / path_counter[n - 1])\n    return probabilities"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "INF = 10 ** 20",
      "mutated_line": "INF = 10 ** -20",
      "code": "from heapq import heappush, heappop\n\ndef calculate_visibility_probabilities(n, m, p, edges, children):\n    INF = 10 ** -20\n    graph = [[] for _ in range(n)]\n    for (x, y, w) in edges:\n        graph[x].append((y, w))\n        graph[y].append((x, w))\n    que = []\n    heappush(que, (0, 0))\n    shortest_counter = [[0] * n for _ in range(n)]\n    shortest_counter[0][0] = 1\n    dist = [INF] * n\n    dist[0] = 0\n    path_counter = [0] * n\n    path_counter[0] = 1\n    while que:\n        (total, node) = heappop(que)\n        count = shortest_counter[node]\n        for (to, w) in graph[node]:\n            new_total = total + w\n            new_count = [i for i in count]\n            new_count[to] += path_counter[node]\n            if dist[to] > new_total:\n                dist[to] = new_total\n                shortest_counter[to] = [i for i in new_count]\n                path_counter[to] = path_counter[node]\n                heappush(que, (new_total, to))\n            elif dist[to] == new_total:\n                shortest_counter[to] = [i + j for (i, j) in zip(shortest_counter[to], new_count)]\n                path_counter[to] += path_counter[node]\n    probabilities = []\n    for child in children:\n        probabilities.append(shortest_counter[n - 1][child] / path_counter[n - 1])\n    return probabilities"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "shortest_counter = [[0] * n for _ in range(n)]",
      "mutated_line": "shortest_counter = [[0] / n for _ in range(n)]",
      "code": "from heapq import heappush, heappop\n\ndef calculate_visibility_probabilities(n, m, p, edges, children):\n    INF = 10 ** 20\n    graph = [[] for _ in range(n)]\n    for (x, y, w) in edges:\n        graph[x].append((y, w))\n        graph[y].append((x, w))\n    que = []\n    heappush(que, (0, 0))\n    shortest_counter = [[0] / n for _ in range(n)]\n    shortest_counter[0][0] = 1\n    dist = [INF] * n\n    dist[0] = 0\n    path_counter = [0] * n\n    path_counter[0] = 1\n    while que:\n        (total, node) = heappop(que)\n        count = shortest_counter[node]\n        for (to, w) in graph[node]:\n            new_total = total + w\n            new_count = [i for i in count]\n            new_count[to] += path_counter[node]\n            if dist[to] > new_total:\n                dist[to] = new_total\n                shortest_counter[to] = [i for i in new_count]\n                path_counter[to] = path_counter[node]\n                heappush(que, (new_total, to))\n            elif dist[to] == new_total:\n                shortest_counter[to] = [i + j for (i, j) in zip(shortest_counter[to], new_count)]\n                path_counter[to] += path_counter[node]\n    probabilities = []\n    for child in children:\n        probabilities.append(shortest_counter[n - 1][child] / path_counter[n - 1])\n    return probabilities"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "shortest_counter = [[0] * n for _ in range(n)]",
      "mutated_line": "shortest_counter = [[0] + n for _ in range(n)]",
      "code": "from heapq import heappush, heappop\n\ndef calculate_visibility_probabilities(n, m, p, edges, children):\n    INF = 10 ** 20\n    graph = [[] for _ in range(n)]\n    for (x, y, w) in edges:\n        graph[x].append((y, w))\n        graph[y].append((x, w))\n    que = []\n    heappush(que, (0, 0))\n    shortest_counter = [[0] + n for _ in range(n)]\n    shortest_counter[0][0] = 1\n    dist = [INF] * n\n    dist[0] = 0\n    path_counter = [0] * n\n    path_counter[0] = 1\n    while que:\n        (total, node) = heappop(que)\n        count = shortest_counter[node]\n        for (to, w) in graph[node]:\n            new_total = total + w\n            new_count = [i for i in count]\n            new_count[to] += path_counter[node]\n            if dist[to] > new_total:\n                dist[to] = new_total\n                shortest_counter[to] = [i for i in new_count]\n                path_counter[to] = path_counter[node]\n                heappush(que, (new_total, to))\n            elif dist[to] == new_total:\n                shortest_counter[to] = [i + j for (i, j) in zip(shortest_counter[to], new_count)]\n                path_counter[to] += path_counter[node]\n    probabilities = []\n    for child in children:\n        probabilities.append(shortest_counter[n - 1][child] / path_counter[n - 1])\n    return probabilities"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "shortest_counter = [[0] * n for _ in range(n)]",
      "mutated_line": "shortest_counter = [[0] ** n for _ in range(n)]",
      "code": "from heapq import heappush, heappop\n\ndef calculate_visibility_probabilities(n, m, p, edges, children):\n    INF = 10 ** 20\n    graph = [[] for _ in range(n)]\n    for (x, y, w) in edges:\n        graph[x].append((y, w))\n        graph[y].append((x, w))\n    que = []\n    heappush(que, (0, 0))\n    shortest_counter = [[0] ** n for _ in range(n)]\n    shortest_counter[0][0] = 1\n    dist = [INF] * n\n    dist[0] = 0\n    path_counter = [0] * n\n    path_counter[0] = 1\n    while que:\n        (total, node) = heappop(que)\n        count = shortest_counter[node]\n        for (to, w) in graph[node]:\n            new_total = total + w\n            new_count = [i for i in count]\n            new_count[to] += path_counter[node]\n            if dist[to] > new_total:\n                dist[to] = new_total\n                shortest_counter[to] = [i for i in new_count]\n                path_counter[to] = path_counter[node]\n                heappush(que, (new_total, to))\n            elif dist[to] == new_total:\n                shortest_counter[to] = [i + j for (i, j) in zip(shortest_counter[to], new_count)]\n                path_counter[to] += path_counter[node]\n    probabilities = []\n    for child in children:\n        probabilities.append(shortest_counter[n - 1][child] / path_counter[n - 1])\n    return probabilities"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "shortest_counter[0][0] = 1",
      "mutated_line": "shortest_counter[0][1] = 1",
      "code": "from heapq import heappush, heappop\n\ndef calculate_visibility_probabilities(n, m, p, edges, children):\n    INF = 10 ** 20\n    graph = [[] for _ in range(n)]\n    for (x, y, w) in edges:\n        graph[x].append((y, w))\n        graph[y].append((x, w))\n    que = []\n    heappush(que, (0, 0))\n    shortest_counter = [[0] * n for _ in range(n)]\n    shortest_counter[0][1] = 1\n    dist = [INF] * n\n    dist[0] = 0\n    path_counter = [0] * n\n    path_counter[0] = 1\n    while que:\n        (total, node) = heappop(que)\n        count = shortest_counter[node]\n        for (to, w) in graph[node]:\n            new_total = total + w\n            new_count = [i for i in count]\n            new_count[to] += path_counter[node]\n            if dist[to] > new_total:\n                dist[to] = new_total\n                shortest_counter[to] = [i for i in new_count]\n                path_counter[to] = path_counter[node]\n                heappush(que, (new_total, to))\n            elif dist[to] == new_total:\n                shortest_counter[to] = [i + j for (i, j) in zip(shortest_counter[to], new_count)]\n                path_counter[to] += path_counter[node]\n    probabilities = []\n    for child in children:\n        probabilities.append(shortest_counter[n - 1][child] / path_counter[n - 1])\n    return probabilities"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "shortest_counter[0][0] = 1",
      "mutated_line": "shortest_counter[0][-1] = 1",
      "code": "from heapq import heappush, heappop\n\ndef calculate_visibility_probabilities(n, m, p, edges, children):\n    INF = 10 ** 20\n    graph = [[] for _ in range(n)]\n    for (x, y, w) in edges:\n        graph[x].append((y, w))\n        graph[y].append((x, w))\n    que = []\n    heappush(que, (0, 0))\n    shortest_counter = [[0] * n for _ in range(n)]\n    shortest_counter[0][-1] = 1\n    dist = [INF] * n\n    dist[0] = 0\n    path_counter = [0] * n\n    path_counter[0] = 1\n    while que:\n        (total, node) = heappop(que)\n        count = shortest_counter[node]\n        for (to, w) in graph[node]:\n            new_total = total + w\n            new_count = [i for i in count]\n            new_count[to] += path_counter[node]\n            if dist[to] > new_total:\n                dist[to] = new_total\n                shortest_counter[to] = [i for i in new_count]\n                path_counter[to] = path_counter[node]\n                heappush(que, (new_total, to))\n            elif dist[to] == new_total:\n                shortest_counter[to] = [i + j for (i, j) in zip(shortest_counter[to], new_count)]\n                path_counter[to] += path_counter[node]\n    probabilities = []\n    for child in children:\n        probabilities.append(shortest_counter[n - 1][child] / path_counter[n - 1])\n    return probabilities"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "shortest_counter[0][0] = 1",
      "mutated_line": "shortest_counter[0][1] = 1",
      "code": "from heapq import heappush, heappop\n\ndef calculate_visibility_probabilities(n, m, p, edges, children):\n    INF = 10 ** 20\n    graph = [[] for _ in range(n)]\n    for (x, y, w) in edges:\n        graph[x].append((y, w))\n        graph[y].append((x, w))\n    que = []\n    heappush(que, (0, 0))\n    shortest_counter = [[0] * n for _ in range(n)]\n    shortest_counter[0][1] = 1\n    dist = [INF] * n\n    dist[0] = 0\n    path_counter = [0] * n\n    path_counter[0] = 1\n    while que:\n        (total, node) = heappop(que)\n        count = shortest_counter[node]\n        for (to, w) in graph[node]:\n            new_total = total + w\n            new_count = [i for i in count]\n            new_count[to] += path_counter[node]\n            if dist[to] > new_total:\n                dist[to] = new_total\n                shortest_counter[to] = [i for i in new_count]\n                path_counter[to] = path_counter[node]\n                heappush(que, (new_total, to))\n            elif dist[to] == new_total:\n                shortest_counter[to] = [i + j for (i, j) in zip(shortest_counter[to], new_count)]\n                path_counter[to] += path_counter[node]\n    probabilities = []\n    for child in children:\n        probabilities.append(shortest_counter[n - 1][child] / path_counter[n - 1])\n    return probabilities"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dist[0] = 0",
      "mutated_line": "dist[1] = 0",
      "code": "from heapq import heappush, heappop\n\ndef calculate_visibility_probabilities(n, m, p, edges, children):\n    INF = 10 ** 20\n    graph = [[] for _ in range(n)]\n    for (x, y, w) in edges:\n        graph[x].append((y, w))\n        graph[y].append((x, w))\n    que = []\n    heappush(que, (0, 0))\n    shortest_counter = [[0] * n for _ in range(n)]\n    shortest_counter[0][0] = 1\n    dist = [INF] * n\n    dist[1] = 0\n    path_counter = [0] * n\n    path_counter[0] = 1\n    while que:\n        (total, node) = heappop(que)\n        count = shortest_counter[node]\n        for (to, w) in graph[node]:\n            new_total = total + w\n            new_count = [i for i in count]\n            new_count[to] += path_counter[node]\n            if dist[to] > new_total:\n                dist[to] = new_total\n                shortest_counter[to] = [i for i in new_count]\n                path_counter[to] = path_counter[node]\n                heappush(que, (new_total, to))\n            elif dist[to] == new_total:\n                shortest_counter[to] = [i + j for (i, j) in zip(shortest_counter[to], new_count)]\n                path_counter[to] += path_counter[node]\n    probabilities = []\n    for child in children:\n        probabilities.append(shortest_counter[n - 1][child] / path_counter[n - 1])\n    return probabilities"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dist[0] = 0",
      "mutated_line": "dist[-1] = 0",
      "code": "from heapq import heappush, heappop\n\ndef calculate_visibility_probabilities(n, m, p, edges, children):\n    INF = 10 ** 20\n    graph = [[] for _ in range(n)]\n    for (x, y, w) in edges:\n        graph[x].append((y, w))\n        graph[y].append((x, w))\n    que = []\n    heappush(que, (0, 0))\n    shortest_counter = [[0] * n for _ in range(n)]\n    shortest_counter[0][0] = 1\n    dist = [INF] * n\n    dist[-1] = 0\n    path_counter = [0] * n\n    path_counter[0] = 1\n    while que:\n        (total, node) = heappop(que)\n        count = shortest_counter[node]\n        for (to, w) in graph[node]:\n            new_total = total + w\n            new_count = [i for i in count]\n            new_count[to] += path_counter[node]\n            if dist[to] > new_total:\n                dist[to] = new_total\n                shortest_counter[to] = [i for i in new_count]\n                path_counter[to] = path_counter[node]\n                heappush(que, (new_total, to))\n            elif dist[to] == new_total:\n                shortest_counter[to] = [i + j for (i, j) in zip(shortest_counter[to], new_count)]\n                path_counter[to] += path_counter[node]\n    probabilities = []\n    for child in children:\n        probabilities.append(shortest_counter[n - 1][child] / path_counter[n - 1])\n    return probabilities"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dist[0] = 0",
      "mutated_line": "dist[1] = 0",
      "code": "from heapq import heappush, heappop\n\ndef calculate_visibility_probabilities(n, m, p, edges, children):\n    INF = 10 ** 20\n    graph = [[] for _ in range(n)]\n    for (x, y, w) in edges:\n        graph[x].append((y, w))\n        graph[y].append((x, w))\n    que = []\n    heappush(que, (0, 0))\n    shortest_counter = [[0] * n for _ in range(n)]\n    shortest_counter[0][0] = 1\n    dist = [INF] * n\n    dist[1] = 0\n    path_counter = [0] * n\n    path_counter[0] = 1\n    while que:\n        (total, node) = heappop(que)\n        count = shortest_counter[node]\n        for (to, w) in graph[node]:\n            new_total = total + w\n            new_count = [i for i in count]\n            new_count[to] += path_counter[node]\n            if dist[to] > new_total:\n                dist[to] = new_total\n                shortest_counter[to] = [i for i in new_count]\n                path_counter[to] = path_counter[node]\n                heappush(que, (new_total, to))\n            elif dist[to] == new_total:\n                shortest_counter[to] = [i + j for (i, j) in zip(shortest_counter[to], new_count)]\n                path_counter[to] += path_counter[node]\n    probabilities = []\n    for child in children:\n        probabilities.append(shortest_counter[n - 1][child] / path_counter[n - 1])\n    return probabilities"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "path_counter[0] = 1",
      "mutated_line": "path_counter[1] = 1",
      "code": "from heapq import heappush, heappop\n\ndef calculate_visibility_probabilities(n, m, p, edges, children):\n    INF = 10 ** 20\n    graph = [[] for _ in range(n)]\n    for (x, y, w) in edges:\n        graph[x].append((y, w))\n        graph[y].append((x, w))\n    que = []\n    heappush(que, (0, 0))\n    shortest_counter = [[0] * n for _ in range(n)]\n    shortest_counter[0][0] = 1\n    dist = [INF] * n\n    dist[0] = 0\n    path_counter = [0] * n\n    path_counter[1] = 1\n    while que:\n        (total, node) = heappop(que)\n        count = shortest_counter[node]\n        for (to, w) in graph[node]:\n            new_total = total + w\n            new_count = [i for i in count]\n            new_count[to] += path_counter[node]\n            if dist[to] > new_total:\n                dist[to] = new_total\n                shortest_counter[to] = [i for i in new_count]\n                path_counter[to] = path_counter[node]\n                heappush(que, (new_total, to))\n            elif dist[to] == new_total:\n                shortest_counter[to] = [i + j for (i, j) in zip(shortest_counter[to], new_count)]\n                path_counter[to] += path_counter[node]\n    probabilities = []\n    for child in children:\n        probabilities.append(shortest_counter[n - 1][child] / path_counter[n - 1])\n    return probabilities"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "path_counter[0] = 1",
      "mutated_line": "path_counter[-1] = 1",
      "code": "from heapq import heappush, heappop\n\ndef calculate_visibility_probabilities(n, m, p, edges, children):\n    INF = 10 ** 20\n    graph = [[] for _ in range(n)]\n    for (x, y, w) in edges:\n        graph[x].append((y, w))\n        graph[y].append((x, w))\n    que = []\n    heappush(que, (0, 0))\n    shortest_counter = [[0] * n for _ in range(n)]\n    shortest_counter[0][0] = 1\n    dist = [INF] * n\n    dist[0] = 0\n    path_counter = [0] * n\n    path_counter[-1] = 1\n    while que:\n        (total, node) = heappop(que)\n        count = shortest_counter[node]\n        for (to, w) in graph[node]:\n            new_total = total + w\n            new_count = [i for i in count]\n            new_count[to] += path_counter[node]\n            if dist[to] > new_total:\n                dist[to] = new_total\n                shortest_counter[to] = [i for i in new_count]\n                path_counter[to] = path_counter[node]\n                heappush(que, (new_total, to))\n            elif dist[to] == new_total:\n                shortest_counter[to] = [i + j for (i, j) in zip(shortest_counter[to], new_count)]\n                path_counter[to] += path_counter[node]\n    probabilities = []\n    for child in children:\n        probabilities.append(shortest_counter[n - 1][child] / path_counter[n - 1])\n    return probabilities"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "path_counter[0] = 1",
      "mutated_line": "path_counter[1] = 1",
      "code": "from heapq import heappush, heappop\n\ndef calculate_visibility_probabilities(n, m, p, edges, children):\n    INF = 10 ** 20\n    graph = [[] for _ in range(n)]\n    for (x, y, w) in edges:\n        graph[x].append((y, w))\n        graph[y].append((x, w))\n    que = []\n    heappush(que, (0, 0))\n    shortest_counter = [[0] * n for _ in range(n)]\n    shortest_counter[0][0] = 1\n    dist = [INF] * n\n    dist[0] = 0\n    path_counter = [0] * n\n    path_counter[1] = 1\n    while que:\n        (total, node) = heappop(que)\n        count = shortest_counter[node]\n        for (to, w) in graph[node]:\n            new_total = total + w\n            new_count = [i for i in count]\n            new_count[to] += path_counter[node]\n            if dist[to] > new_total:\n                dist[to] = new_total\n                shortest_counter[to] = [i for i in new_count]\n                path_counter[to] = path_counter[node]\n                heappush(que, (new_total, to))\n            elif dist[to] == new_total:\n                shortest_counter[to] = [i + j for (i, j) in zip(shortest_counter[to], new_count)]\n                path_counter[to] += path_counter[node]\n    probabilities = []\n    for child in children:\n        probabilities.append(shortest_counter[n - 1][child] / path_counter[n - 1])\n    return probabilities"
    },
    {
      "operator": "ASR",
      "lineno": 29,
      "original_line": "new_count[to] += path_counter[node]",
      "mutated_line": "new_count[to] -= path_counter[node]",
      "code": "from heapq import heappush, heappop\n\ndef calculate_visibility_probabilities(n, m, p, edges, children):\n    INF = 10 ** 20\n    graph = [[] for _ in range(n)]\n    for (x, y, w) in edges:\n        graph[x].append((y, w))\n        graph[y].append((x, w))\n    que = []\n    heappush(que, (0, 0))\n    shortest_counter = [[0] * n for _ in range(n)]\n    shortest_counter[0][0] = 1\n    dist = [INF] * n\n    dist[0] = 0\n    path_counter = [0] * n\n    path_counter[0] = 1\n    while que:\n        (total, node) = heappop(que)\n        count = shortest_counter[node]\n        for (to, w) in graph[node]:\n            new_total = total + w\n            new_count = [i for i in count]\n            new_count[to] -= path_counter[node]\n            if dist[to] > new_total:\n                dist[to] = new_total\n                shortest_counter[to] = [i for i in new_count]\n                path_counter[to] = path_counter[node]\n                heappush(que, (new_total, to))\n            elif dist[to] == new_total:\n                shortest_counter[to] = [i + j for (i, j) in zip(shortest_counter[to], new_count)]\n                path_counter[to] += path_counter[node]\n    probabilities = []\n    for child in children:\n        probabilities.append(shortest_counter[n - 1][child] / path_counter[n - 1])\n    return probabilities"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "heappush(que, (0, 0))",
      "mutated_line": "heappush(que, (1, 0))",
      "code": "from heapq import heappush, heappop\n\ndef calculate_visibility_probabilities(n, m, p, edges, children):\n    INF = 10 ** 20\n    graph = [[] for _ in range(n)]\n    for (x, y, w) in edges:\n        graph[x].append((y, w))\n        graph[y].append((x, w))\n    que = []\n    heappush(que, (1, 0))\n    shortest_counter = [[0] * n for _ in range(n)]\n    shortest_counter[0][0] = 1\n    dist = [INF] * n\n    dist[0] = 0\n    path_counter = [0] * n\n    path_counter[0] = 1\n    while que:\n        (total, node) = heappop(que)\n        count = shortest_counter[node]\n        for (to, w) in graph[node]:\n            new_total = total + w\n            new_count = [i for i in count]\n            new_count[to] += path_counter[node]\n            if dist[to] > new_total:\n                dist[to] = new_total\n                shortest_counter[to] = [i for i in new_count]\n                path_counter[to] = path_counter[node]\n                heappush(que, (new_total, to))\n            elif dist[to] == new_total:\n                shortest_counter[to] = [i + j for (i, j) in zip(shortest_counter[to], new_count)]\n                path_counter[to] += path_counter[node]\n    probabilities = []\n    for child in children:\n        probabilities.append(shortest_counter[n - 1][child] / path_counter[n - 1])\n    return probabilities"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "heappush(que, (0, 0))",
      "mutated_line": "heappush(que, (-1, 0))",
      "code": "from heapq import heappush, heappop\n\ndef calculate_visibility_probabilities(n, m, p, edges, children):\n    INF = 10 ** 20\n    graph = [[] for _ in range(n)]\n    for (x, y, w) in edges:\n        graph[x].append((y, w))\n        graph[y].append((x, w))\n    que = []\n    heappush(que, (-1, 0))\n    shortest_counter = [[0] * n for _ in range(n)]\n    shortest_counter[0][0] = 1\n    dist = [INF] * n\n    dist[0] = 0\n    path_counter = [0] * n\n    path_counter[0] = 1\n    while que:\n        (total, node) = heappop(que)\n        count = shortest_counter[node]\n        for (to, w) in graph[node]:\n            new_total = total + w\n            new_count = [i for i in count]\n            new_count[to] += path_counter[node]\n            if dist[to] > new_total:\n                dist[to] = new_total\n                shortest_counter[to] = [i for i in new_count]\n                path_counter[to] = path_counter[node]\n                heappush(que, (new_total, to))\n            elif dist[to] == new_total:\n                shortest_counter[to] = [i + j for (i, j) in zip(shortest_counter[to], new_count)]\n                path_counter[to] += path_counter[node]\n    probabilities = []\n    for child in children:\n        probabilities.append(shortest_counter[n - 1][child] / path_counter[n - 1])\n    return probabilities"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "heappush(que, (0, 0))",
      "mutated_line": "heappush(que, (1, 0))",
      "code": "from heapq import heappush, heappop\n\ndef calculate_visibility_probabilities(n, m, p, edges, children):\n    INF = 10 ** 20\n    graph = [[] for _ in range(n)]\n    for (x, y, w) in edges:\n        graph[x].append((y, w))\n        graph[y].append((x, w))\n    que = []\n    heappush(que, (1, 0))\n    shortest_counter = [[0] * n for _ in range(n)]\n    shortest_counter[0][0] = 1\n    dist = [INF] * n\n    dist[0] = 0\n    path_counter = [0] * n\n    path_counter[0] = 1\n    while que:\n        (total, node) = heappop(que)\n        count = shortest_counter[node]\n        for (to, w) in graph[node]:\n            new_total = total + w\n            new_count = [i for i in count]\n            new_count[to] += path_counter[node]\n            if dist[to] > new_total:\n                dist[to] = new_total\n                shortest_counter[to] = [i for i in new_count]\n                path_counter[to] = path_counter[node]\n                heappush(que, (new_total, to))\n            elif dist[to] == new_total:\n                shortest_counter[to] = [i + j for (i, j) in zip(shortest_counter[to], new_count)]\n                path_counter[to] += path_counter[node]\n    probabilities = []\n    for child in children:\n        probabilities.append(shortest_counter[n - 1][child] / path_counter[n - 1])\n    return probabilities"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "heappush(que, (0, 0))",
      "mutated_line": "heappush(que, (0, 1))",
      "code": "from heapq import heappush, heappop\n\ndef calculate_visibility_probabilities(n, m, p, edges, children):\n    INF = 10 ** 20\n    graph = [[] for _ in range(n)]\n    for (x, y, w) in edges:\n        graph[x].append((y, w))\n        graph[y].append((x, w))\n    que = []\n    heappush(que, (0, 1))\n    shortest_counter = [[0] * n for _ in range(n)]\n    shortest_counter[0][0] = 1\n    dist = [INF] * n\n    dist[0] = 0\n    path_counter = [0] * n\n    path_counter[0] = 1\n    while que:\n        (total, node) = heappop(que)\n        count = shortest_counter[node]\n        for (to, w) in graph[node]:\n            new_total = total + w\n            new_count = [i for i in count]\n            new_count[to] += path_counter[node]\n            if dist[to] > new_total:\n                dist[to] = new_total\n                shortest_counter[to] = [i for i in new_count]\n                path_counter[to] = path_counter[node]\n                heappush(que, (new_total, to))\n            elif dist[to] == new_total:\n                shortest_counter[to] = [i + j for (i, j) in zip(shortest_counter[to], new_count)]\n                path_counter[to] += path_counter[node]\n    probabilities = []\n    for child in children:\n        probabilities.append(shortest_counter[n - 1][child] / path_counter[n - 1])\n    return probabilities"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "heappush(que, (0, 0))",
      "mutated_line": "heappush(que, (0, -1))",
      "code": "from heapq import heappush, heappop\n\ndef calculate_visibility_probabilities(n, m, p, edges, children):\n    INF = 10 ** 20\n    graph = [[] for _ in range(n)]\n    for (x, y, w) in edges:\n        graph[x].append((y, w))\n        graph[y].append((x, w))\n    que = []\n    heappush(que, (0, -1))\n    shortest_counter = [[0] * n for _ in range(n)]\n    shortest_counter[0][0] = 1\n    dist = [INF] * n\n    dist[0] = 0\n    path_counter = [0] * n\n    path_counter[0] = 1\n    while que:\n        (total, node) = heappop(que)\n        count = shortest_counter[node]\n        for (to, w) in graph[node]:\n            new_total = total + w\n            new_count = [i for i in count]\n            new_count[to] += path_counter[node]\n            if dist[to] > new_total:\n                dist[to] = new_total\n                shortest_counter[to] = [i for i in new_count]\n                path_counter[to] = path_counter[node]\n                heappush(que, (new_total, to))\n            elif dist[to] == new_total:\n                shortest_counter[to] = [i + j for (i, j) in zip(shortest_counter[to], new_count)]\n                path_counter[to] += path_counter[node]\n    probabilities = []\n    for child in children:\n        probabilities.append(shortest_counter[n - 1][child] / path_counter[n - 1])\n    return probabilities"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "heappush(que, (0, 0))",
      "mutated_line": "heappush(que, (0, 1))",
      "code": "from heapq import heappush, heappop\n\ndef calculate_visibility_probabilities(n, m, p, edges, children):\n    INF = 10 ** 20\n    graph = [[] for _ in range(n)]\n    for (x, y, w) in edges:\n        graph[x].append((y, w))\n        graph[y].append((x, w))\n    que = []\n    heappush(que, (0, 1))\n    shortest_counter = [[0] * n for _ in range(n)]\n    shortest_counter[0][0] = 1\n    dist = [INF] * n\n    dist[0] = 0\n    path_counter = [0] * n\n    path_counter[0] = 1\n    while que:\n        (total, node) = heappop(que)\n        count = shortest_counter[node]\n        for (to, w) in graph[node]:\n            new_total = total + w\n            new_count = [i for i in count]\n            new_count[to] += path_counter[node]\n            if dist[to] > new_total:\n                dist[to] = new_total\n                shortest_counter[to] = [i for i in new_count]\n                path_counter[to] = path_counter[node]\n                heappush(que, (new_total, to))\n            elif dist[to] == new_total:\n                shortest_counter[to] = [i + j for (i, j) in zip(shortest_counter[to], new_count)]\n                path_counter[to] += path_counter[node]\n    probabilities = []\n    for child in children:\n        probabilities.append(shortest_counter[n - 1][child] / path_counter[n - 1])\n    return probabilities"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "shortest_counter[0][0] = 1",
      "mutated_line": "shortest_counter[1][0] = 1",
      "code": "from heapq import heappush, heappop\n\ndef calculate_visibility_probabilities(n, m, p, edges, children):\n    INF = 10 ** 20\n    graph = [[] for _ in range(n)]\n    for (x, y, w) in edges:\n        graph[x].append((y, w))\n        graph[y].append((x, w))\n    que = []\n    heappush(que, (0, 0))\n    shortest_counter = [[0] * n for _ in range(n)]\n    shortest_counter[1][0] = 1\n    dist = [INF] * n\n    dist[0] = 0\n    path_counter = [0] * n\n    path_counter[0] = 1\n    while que:\n        (total, node) = heappop(que)\n        count = shortest_counter[node]\n        for (to, w) in graph[node]:\n            new_total = total + w\n            new_count = [i for i in count]\n            new_count[to] += path_counter[node]\n            if dist[to] > new_total:\n                dist[to] = new_total\n                shortest_counter[to] = [i for i in new_count]\n                path_counter[to] = path_counter[node]\n                heappush(que, (new_total, to))\n            elif dist[to] == new_total:\n                shortest_counter[to] = [i + j for (i, j) in zip(shortest_counter[to], new_count)]\n                path_counter[to] += path_counter[node]\n    probabilities = []\n    for child in children:\n        probabilities.append(shortest_counter[n - 1][child] / path_counter[n - 1])\n    return probabilities"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "shortest_counter[0][0] = 1",
      "mutated_line": "shortest_counter[-1][0] = 1",
      "code": "from heapq import heappush, heappop\n\ndef calculate_visibility_probabilities(n, m, p, edges, children):\n    INF = 10 ** 20\n    graph = [[] for _ in range(n)]\n    for (x, y, w) in edges:\n        graph[x].append((y, w))\n        graph[y].append((x, w))\n    que = []\n    heappush(que, (0, 0))\n    shortest_counter = [[0] * n for _ in range(n)]\n    shortest_counter[-1][0] = 1\n    dist = [INF] * n\n    dist[0] = 0\n    path_counter = [0] * n\n    path_counter[0] = 1\n    while que:\n        (total, node) = heappop(que)\n        count = shortest_counter[node]\n        for (to, w) in graph[node]:\n            new_total = total + w\n            new_count = [i for i in count]\n            new_count[to] += path_counter[node]\n            if dist[to] > new_total:\n                dist[to] = new_total\n                shortest_counter[to] = [i for i in new_count]\n                path_counter[to] = path_counter[node]\n                heappush(que, (new_total, to))\n            elif dist[to] == new_total:\n                shortest_counter[to] = [i + j for (i, j) in zip(shortest_counter[to], new_count)]\n                path_counter[to] += path_counter[node]\n    probabilities = []\n    for child in children:\n        probabilities.append(shortest_counter[n - 1][child] / path_counter[n - 1])\n    return probabilities"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "shortest_counter[0][0] = 1",
      "mutated_line": "shortest_counter[1][0] = 1",
      "code": "from heapq import heappush, heappop\n\ndef calculate_visibility_probabilities(n, m, p, edges, children):\n    INF = 10 ** 20\n    graph = [[] for _ in range(n)]\n    for (x, y, w) in edges:\n        graph[x].append((y, w))\n        graph[y].append((x, w))\n    que = []\n    heappush(que, (0, 0))\n    shortest_counter = [[0] * n for _ in range(n)]\n    shortest_counter[1][0] = 1\n    dist = [INF] * n\n    dist[0] = 0\n    path_counter = [0] * n\n    path_counter[0] = 1\n    while que:\n        (total, node) = heappop(que)\n        count = shortest_counter[node]\n        for (to, w) in graph[node]:\n            new_total = total + w\n            new_count = [i for i in count]\n            new_count[to] += path_counter[node]\n            if dist[to] > new_total:\n                dist[to] = new_total\n                shortest_counter[to] = [i for i in new_count]\n                path_counter[to] = path_counter[node]\n                heappush(que, (new_total, to))\n            elif dist[to] == new_total:\n                shortest_counter[to] = [i + j for (i, j) in zip(shortest_counter[to], new_count)]\n                path_counter[to] += path_counter[node]\n    probabilities = []\n    for child in children:\n        probabilities.append(shortest_counter[n - 1][child] / path_counter[n - 1])\n    return probabilities"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "path_counter = [0] * n",
      "mutated_line": "path_counter = [1] * n",
      "code": "from heapq import heappush, heappop\n\ndef calculate_visibility_probabilities(n, m, p, edges, children):\n    INF = 10 ** 20\n    graph = [[] for _ in range(n)]\n    for (x, y, w) in edges:\n        graph[x].append((y, w))\n        graph[y].append((x, w))\n    que = []\n    heappush(que, (0, 0))\n    shortest_counter = [[0] * n for _ in range(n)]\n    shortest_counter[0][0] = 1\n    dist = [INF] * n\n    dist[0] = 0\n    path_counter = [1] * n\n    path_counter[0] = 1\n    while que:\n        (total, node) = heappop(que)\n        count = shortest_counter[node]\n        for (to, w) in graph[node]:\n            new_total = total + w\n            new_count = [i for i in count]\n            new_count[to] += path_counter[node]\n            if dist[to] > new_total:\n                dist[to] = new_total\n                shortest_counter[to] = [i for i in new_count]\n                path_counter[to] = path_counter[node]\n                heappush(que, (new_total, to))\n            elif dist[to] == new_total:\n                shortest_counter[to] = [i + j for (i, j) in zip(shortest_counter[to], new_count)]\n                path_counter[to] += path_counter[node]\n    probabilities = []\n    for child in children:\n        probabilities.append(shortest_counter[n - 1][child] / path_counter[n - 1])\n    return probabilities"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "path_counter = [0] * n",
      "mutated_line": "path_counter = [-1] * n",
      "code": "from heapq import heappush, heappop\n\ndef calculate_visibility_probabilities(n, m, p, edges, children):\n    INF = 10 ** 20\n    graph = [[] for _ in range(n)]\n    for (x, y, w) in edges:\n        graph[x].append((y, w))\n        graph[y].append((x, w))\n    que = []\n    heappush(que, (0, 0))\n    shortest_counter = [[0] * n for _ in range(n)]\n    shortest_counter[0][0] = 1\n    dist = [INF] * n\n    dist[0] = 0\n    path_counter = [-1] * n\n    path_counter[0] = 1\n    while que:\n        (total, node) = heappop(que)\n        count = shortest_counter[node]\n        for (to, w) in graph[node]:\n            new_total = total + w\n            new_count = [i for i in count]\n            new_count[to] += path_counter[node]\n            if dist[to] > new_total:\n                dist[to] = new_total\n                shortest_counter[to] = [i for i in new_count]\n                path_counter[to] = path_counter[node]\n                heappush(que, (new_total, to))\n            elif dist[to] == new_total:\n                shortest_counter[to] = [i + j for (i, j) in zip(shortest_counter[to], new_count)]\n                path_counter[to] += path_counter[node]\n    probabilities = []\n    for child in children:\n        probabilities.append(shortest_counter[n - 1][child] / path_counter[n - 1])\n    return probabilities"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "path_counter = [0] * n",
      "mutated_line": "path_counter = [1] * n",
      "code": "from heapq import heappush, heappop\n\ndef calculate_visibility_probabilities(n, m, p, edges, children):\n    INF = 10 ** 20\n    graph = [[] for _ in range(n)]\n    for (x, y, w) in edges:\n        graph[x].append((y, w))\n        graph[y].append((x, w))\n    que = []\n    heappush(que, (0, 0))\n    shortest_counter = [[0] * n for _ in range(n)]\n    shortest_counter[0][0] = 1\n    dist = [INF] * n\n    dist[0] = 0\n    path_counter = [1] * n\n    path_counter[0] = 1\n    while que:\n        (total, node) = heappop(que)\n        count = shortest_counter[node]\n        for (to, w) in graph[node]:\n            new_total = total + w\n            new_count = [i for i in count]\n            new_count[to] += path_counter[node]\n            if dist[to] > new_total:\n                dist[to] = new_total\n                shortest_counter[to] = [i for i in new_count]\n                path_counter[to] = path_counter[node]\n                heappush(que, (new_total, to))\n            elif dist[to] == new_total:\n                shortest_counter[to] = [i + j for (i, j) in zip(shortest_counter[to], new_count)]\n                path_counter[to] += path_counter[node]\n    probabilities = []\n    for child in children:\n        probabilities.append(shortest_counter[n - 1][child] / path_counter[n - 1])\n    return probabilities"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "new_total = total + w",
      "mutated_line": "new_total = total - w",
      "code": "from heapq import heappush, heappop\n\ndef calculate_visibility_probabilities(n, m, p, edges, children):\n    INF = 10 ** 20\n    graph = [[] for _ in range(n)]\n    for (x, y, w) in edges:\n        graph[x].append((y, w))\n        graph[y].append((x, w))\n    que = []\n    heappush(que, (0, 0))\n    shortest_counter = [[0] * n for _ in range(n)]\n    shortest_counter[0][0] = 1\n    dist = [INF] * n\n    dist[0] = 0\n    path_counter = [0] * n\n    path_counter[0] = 1\n    while que:\n        (total, node) = heappop(que)\n        count = shortest_counter[node]\n        for (to, w) in graph[node]:\n            new_total = total - w\n            new_count = [i for i in count]\n            new_count[to] += path_counter[node]\n            if dist[to] > new_total:\n                dist[to] = new_total\n                shortest_counter[to] = [i for i in new_count]\n                path_counter[to] = path_counter[node]\n                heappush(que, (new_total, to))\n            elif dist[to] == new_total:\n                shortest_counter[to] = [i + j for (i, j) in zip(shortest_counter[to], new_count)]\n                path_counter[to] += path_counter[node]\n    probabilities = []\n    for child in children:\n        probabilities.append(shortest_counter[n - 1][child] / path_counter[n - 1])\n    return probabilities"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "new_total = total + w",
      "mutated_line": "new_total = total * w",
      "code": "from heapq import heappush, heappop\n\ndef calculate_visibility_probabilities(n, m, p, edges, children):\n    INF = 10 ** 20\n    graph = [[] for _ in range(n)]\n    for (x, y, w) in edges:\n        graph[x].append((y, w))\n        graph[y].append((x, w))\n    que = []\n    heappush(que, (0, 0))\n    shortest_counter = [[0] * n for _ in range(n)]\n    shortest_counter[0][0] = 1\n    dist = [INF] * n\n    dist[0] = 0\n    path_counter = [0] * n\n    path_counter[0] = 1\n    while que:\n        (total, node) = heappop(que)\n        count = shortest_counter[node]\n        for (to, w) in graph[node]:\n            new_total = total * w\n            new_count = [i for i in count]\n            new_count[to] += path_counter[node]\n            if dist[to] > new_total:\n                dist[to] = new_total\n                shortest_counter[to] = [i for i in new_count]\n                path_counter[to] = path_counter[node]\n                heappush(que, (new_total, to))\n            elif dist[to] == new_total:\n                shortest_counter[to] = [i + j for (i, j) in zip(shortest_counter[to], new_count)]\n                path_counter[to] += path_counter[node]\n    probabilities = []\n    for child in children:\n        probabilities.append(shortest_counter[n - 1][child] / path_counter[n - 1])\n    return probabilities"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if dist[to] > new_total:",
      "mutated_line": "if dist[to] >= new_total:",
      "code": "from heapq import heappush, heappop\n\ndef calculate_visibility_probabilities(n, m, p, edges, children):\n    INF = 10 ** 20\n    graph = [[] for _ in range(n)]\n    for (x, y, w) in edges:\n        graph[x].append((y, w))\n        graph[y].append((x, w))\n    que = []\n    heappush(que, (0, 0))\n    shortest_counter = [[0] * n for _ in range(n)]\n    shortest_counter[0][0] = 1\n    dist = [INF] * n\n    dist[0] = 0\n    path_counter = [0] * n\n    path_counter[0] = 1\n    while que:\n        (total, node) = heappop(que)\n        count = shortest_counter[node]\n        for (to, w) in graph[node]:\n            new_total = total + w\n            new_count = [i for i in count]\n            new_count[to] += path_counter[node]\n            if dist[to] >= new_total:\n                dist[to] = new_total\n                shortest_counter[to] = [i for i in new_count]\n                path_counter[to] = path_counter[node]\n                heappush(que, (new_total, to))\n            elif dist[to] == new_total:\n                shortest_counter[to] = [i + j for (i, j) in zip(shortest_counter[to], new_count)]\n                path_counter[to] += path_counter[node]\n    probabilities = []\n    for child in children:\n        probabilities.append(shortest_counter[n - 1][child] / path_counter[n - 1])\n    return probabilities"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if dist[to] > new_total:",
      "mutated_line": "if dist[to] <= new_total:",
      "code": "from heapq import heappush, heappop\n\ndef calculate_visibility_probabilities(n, m, p, edges, children):\n    INF = 10 ** 20\n    graph = [[] for _ in range(n)]\n    for (x, y, w) in edges:\n        graph[x].append((y, w))\n        graph[y].append((x, w))\n    que = []\n    heappush(que, (0, 0))\n    shortest_counter = [[0] * n for _ in range(n)]\n    shortest_counter[0][0] = 1\n    dist = [INF] * n\n    dist[0] = 0\n    path_counter = [0] * n\n    path_counter[0] = 1\n    while que:\n        (total, node) = heappop(que)\n        count = shortest_counter[node]\n        for (to, w) in graph[node]:\n            new_total = total + w\n            new_count = [i for i in count]\n            new_count[to] += path_counter[node]\n            if dist[to] <= new_total:\n                dist[to] = new_total\n                shortest_counter[to] = [i for i in new_count]\n                path_counter[to] = path_counter[node]\n                heappush(que, (new_total, to))\n            elif dist[to] == new_total:\n                shortest_counter[to] = [i + j for (i, j) in zip(shortest_counter[to], new_count)]\n                path_counter[to] += path_counter[node]\n    probabilities = []\n    for child in children:\n        probabilities.append(shortest_counter[n - 1][child] / path_counter[n - 1])\n    return probabilities"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if dist[to] > new_total:",
      "mutated_line": "if dist[to] != new_total:",
      "code": "from heapq import heappush, heappop\n\ndef calculate_visibility_probabilities(n, m, p, edges, children):\n    INF = 10 ** 20\n    graph = [[] for _ in range(n)]\n    for (x, y, w) in edges:\n        graph[x].append((y, w))\n        graph[y].append((x, w))\n    que = []\n    heappush(que, (0, 0))\n    shortest_counter = [[0] * n for _ in range(n)]\n    shortest_counter[0][0] = 1\n    dist = [INF] * n\n    dist[0] = 0\n    path_counter = [0] * n\n    path_counter[0] = 1\n    while que:\n        (total, node) = heappop(que)\n        count = shortest_counter[node]\n        for (to, w) in graph[node]:\n            new_total = total + w\n            new_count = [i for i in count]\n            new_count[to] += path_counter[node]\n            if dist[to] != new_total:\n                dist[to] = new_total\n                shortest_counter[to] = [i for i in new_count]\n                path_counter[to] = path_counter[node]\n                heappush(que, (new_total, to))\n            elif dist[to] == new_total:\n                shortest_counter[to] = [i + j for (i, j) in zip(shortest_counter[to], new_count)]\n                path_counter[to] += path_counter[node]\n    probabilities = []\n    for child in children:\n        probabilities.append(shortest_counter[n - 1][child] / path_counter[n - 1])\n    return probabilities"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "probabilities.append(shortest_counter[n - 1][child] / path_counter[n - 1])",
      "mutated_line": "probabilities.append(shortest_counter[n - 1][child] * path_counter[n - 1])",
      "code": "from heapq import heappush, heappop\n\ndef calculate_visibility_probabilities(n, m, p, edges, children):\n    INF = 10 ** 20\n    graph = [[] for _ in range(n)]\n    for (x, y, w) in edges:\n        graph[x].append((y, w))\n        graph[y].append((x, w))\n    que = []\n    heappush(que, (0, 0))\n    shortest_counter = [[0] * n for _ in range(n)]\n    shortest_counter[0][0] = 1\n    dist = [INF] * n\n    dist[0] = 0\n    path_counter = [0] * n\n    path_counter[0] = 1\n    while que:\n        (total, node) = heappop(que)\n        count = shortest_counter[node]\n        for (to, w) in graph[node]:\n            new_total = total + w\n            new_count = [i for i in count]\n            new_count[to] += path_counter[node]\n            if dist[to] > new_total:\n                dist[to] = new_total\n                shortest_counter[to] = [i for i in new_count]\n                path_counter[to] = path_counter[node]\n                heappush(que, (new_total, to))\n            elif dist[to] == new_total:\n                shortest_counter[to] = [i + j for (i, j) in zip(shortest_counter[to], new_count)]\n                path_counter[to] += path_counter[node]\n    probabilities = []\n    for child in children:\n        probabilities.append(shortest_counter[n - 1][child] * path_counter[n - 1])\n    return probabilities"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "probabilities.append(shortest_counter[n - 1][child] / path_counter[n - 1])",
      "mutated_line": "probabilities.append(shortest_counter[n - 1][child] // path_counter[n - 1])",
      "code": "from heapq import heappush, heappop\n\ndef calculate_visibility_probabilities(n, m, p, edges, children):\n    INF = 10 ** 20\n    graph = [[] for _ in range(n)]\n    for (x, y, w) in edges:\n        graph[x].append((y, w))\n        graph[y].append((x, w))\n    que = []\n    heappush(que, (0, 0))\n    shortest_counter = [[0] * n for _ in range(n)]\n    shortest_counter[0][0] = 1\n    dist = [INF] * n\n    dist[0] = 0\n    path_counter = [0] * n\n    path_counter[0] = 1\n    while que:\n        (total, node) = heappop(que)\n        count = shortest_counter[node]\n        for (to, w) in graph[node]:\n            new_total = total + w\n            new_count = [i for i in count]\n            new_count[to] += path_counter[node]\n            if dist[to] > new_total:\n                dist[to] = new_total\n                shortest_counter[to] = [i for i in new_count]\n                path_counter[to] = path_counter[node]\n                heappush(que, (new_total, to))\n            elif dist[to] == new_total:\n                shortest_counter[to] = [i + j for (i, j) in zip(shortest_counter[to], new_count)]\n                path_counter[to] += path_counter[node]\n    probabilities = []\n    for child in children:\n        probabilities.append(shortest_counter[n - 1][child] // path_counter[n - 1])\n    return probabilities"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "shortest_counter = [[0] * n for _ in range(n)]",
      "mutated_line": "shortest_counter = [[1] * n for _ in range(n)]",
      "code": "from heapq import heappush, heappop\n\ndef calculate_visibility_probabilities(n, m, p, edges, children):\n    INF = 10 ** 20\n    graph = [[] for _ in range(n)]\n    for (x, y, w) in edges:\n        graph[x].append((y, w))\n        graph[y].append((x, w))\n    que = []\n    heappush(que, (0, 0))\n    shortest_counter = [[1] * n for _ in range(n)]\n    shortest_counter[0][0] = 1\n    dist = [INF] * n\n    dist[0] = 0\n    path_counter = [0] * n\n    path_counter[0] = 1\n    while que:\n        (total, node) = heappop(que)\n        count = shortest_counter[node]\n        for (to, w) in graph[node]:\n            new_total = total + w\n            new_count = [i for i in count]\n            new_count[to] += path_counter[node]\n            if dist[to] > new_total:\n                dist[to] = new_total\n                shortest_counter[to] = [i for i in new_count]\n                path_counter[to] = path_counter[node]\n                heappush(que, (new_total, to))\n            elif dist[to] == new_total:\n                shortest_counter[to] = [i + j for (i, j) in zip(shortest_counter[to], new_count)]\n                path_counter[to] += path_counter[node]\n    probabilities = []\n    for child in children:\n        probabilities.append(shortest_counter[n - 1][child] / path_counter[n - 1])\n    return probabilities"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "shortest_counter = [[0] * n for _ in range(n)]",
      "mutated_line": "shortest_counter = [[-1] * n for _ in range(n)]",
      "code": "from heapq import heappush, heappop\n\ndef calculate_visibility_probabilities(n, m, p, edges, children):\n    INF = 10 ** 20\n    graph = [[] for _ in range(n)]\n    for (x, y, w) in edges:\n        graph[x].append((y, w))\n        graph[y].append((x, w))\n    que = []\n    heappush(que, (0, 0))\n    shortest_counter = [[-1] * n for _ in range(n)]\n    shortest_counter[0][0] = 1\n    dist = [INF] * n\n    dist[0] = 0\n    path_counter = [0] * n\n    path_counter[0] = 1\n    while que:\n        (total, node) = heappop(que)\n        count = shortest_counter[node]\n        for (to, w) in graph[node]:\n            new_total = total + w\n            new_count = [i for i in count]\n            new_count[to] += path_counter[node]\n            if dist[to] > new_total:\n                dist[to] = new_total\n                shortest_counter[to] = [i for i in new_count]\n                path_counter[to] = path_counter[node]\n                heappush(que, (new_total, to))\n            elif dist[to] == new_total:\n                shortest_counter[to] = [i + j for (i, j) in zip(shortest_counter[to], new_count)]\n                path_counter[to] += path_counter[node]\n    probabilities = []\n    for child in children:\n        probabilities.append(shortest_counter[n - 1][child] / path_counter[n - 1])\n    return probabilities"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "shortest_counter = [[0] * n for _ in range(n)]",
      "mutated_line": "shortest_counter = [[1] * n for _ in range(n)]",
      "code": "from heapq import heappush, heappop\n\ndef calculate_visibility_probabilities(n, m, p, edges, children):\n    INF = 10 ** 20\n    graph = [[] for _ in range(n)]\n    for (x, y, w) in edges:\n        graph[x].append((y, w))\n        graph[y].append((x, w))\n    que = []\n    heappush(que, (0, 0))\n    shortest_counter = [[1] * n for _ in range(n)]\n    shortest_counter[0][0] = 1\n    dist = [INF] * n\n    dist[0] = 0\n    path_counter = [0] * n\n    path_counter[0] = 1\n    while que:\n        (total, node) = heappop(que)\n        count = shortest_counter[node]\n        for (to, w) in graph[node]:\n            new_total = total + w\n            new_count = [i for i in count]\n            new_count[to] += path_counter[node]\n            if dist[to] > new_total:\n                dist[to] = new_total\n                shortest_counter[to] = [i for i in new_count]\n                path_counter[to] = path_counter[node]\n                heappush(que, (new_total, to))\n            elif dist[to] == new_total:\n                shortest_counter[to] = [i + j for (i, j) in zip(shortest_counter[to], new_count)]\n                path_counter[to] += path_counter[node]\n    probabilities = []\n    for child in children:\n        probabilities.append(shortest_counter[n - 1][child] / path_counter[n - 1])\n    return probabilities"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "elif dist[to] == new_total:",
      "mutated_line": "elif dist[to] != new_total:",
      "code": "from heapq import heappush, heappop\n\ndef calculate_visibility_probabilities(n, m, p, edges, children):\n    INF = 10 ** 20\n    graph = [[] for _ in range(n)]\n    for (x, y, w) in edges:\n        graph[x].append((y, w))\n        graph[y].append((x, w))\n    que = []\n    heappush(que, (0, 0))\n    shortest_counter = [[0] * n for _ in range(n)]\n    shortest_counter[0][0] = 1\n    dist = [INF] * n\n    dist[0] = 0\n    path_counter = [0] * n\n    path_counter[0] = 1\n    while que:\n        (total, node) = heappop(que)\n        count = shortest_counter[node]\n        for (to, w) in graph[node]:\n            new_total = total + w\n            new_count = [i for i in count]\n            new_count[to] += path_counter[node]\n            if dist[to] > new_total:\n                dist[to] = new_total\n                shortest_counter[to] = [i for i in new_count]\n                path_counter[to] = path_counter[node]\n                heappush(que, (new_total, to))\n            elif dist[to] != new_total:\n                shortest_counter[to] = [i + j for (i, j) in zip(shortest_counter[to], new_count)]\n                path_counter[to] += path_counter[node]\n    probabilities = []\n    for child in children:\n        probabilities.append(shortest_counter[n - 1][child] / path_counter[n - 1])\n    return probabilities"
    },
    {
      "operator": "ASR",
      "lineno": 37,
      "original_line": "path_counter[to] += path_counter[node]",
      "mutated_line": "path_counter[to] -= path_counter[node]",
      "code": "from heapq import heappush, heappop\n\ndef calculate_visibility_probabilities(n, m, p, edges, children):\n    INF = 10 ** 20\n    graph = [[] for _ in range(n)]\n    for (x, y, w) in edges:\n        graph[x].append((y, w))\n        graph[y].append((x, w))\n    que = []\n    heappush(que, (0, 0))\n    shortest_counter = [[0] * n for _ in range(n)]\n    shortest_counter[0][0] = 1\n    dist = [INF] * n\n    dist[0] = 0\n    path_counter = [0] * n\n    path_counter[0] = 1\n    while que:\n        (total, node) = heappop(que)\n        count = shortest_counter[node]\n        for (to, w) in graph[node]:\n            new_total = total + w\n            new_count = [i for i in count]\n            new_count[to] += path_counter[node]\n            if dist[to] > new_total:\n                dist[to] = new_total\n                shortest_counter[to] = [i for i in new_count]\n                path_counter[to] = path_counter[node]\n                heappush(que, (new_total, to))\n            elif dist[to] == new_total:\n                shortest_counter[to] = [i + j for (i, j) in zip(shortest_counter[to], new_count)]\n                path_counter[to] -= path_counter[node]\n    probabilities = []\n    for child in children:\n        probabilities.append(shortest_counter[n - 1][child] / path_counter[n - 1])\n    return probabilities"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "probabilities.append(shortest_counter[n - 1][child] / path_counter[n - 1])",
      "mutated_line": "probabilities.append(shortest_counter[n - 1][child] / path_counter[n + 1])",
      "code": "from heapq import heappush, heappop\n\ndef calculate_visibility_probabilities(n, m, p, edges, children):\n    INF = 10 ** 20\n    graph = [[] for _ in range(n)]\n    for (x, y, w) in edges:\n        graph[x].append((y, w))\n        graph[y].append((x, w))\n    que = []\n    heappush(que, (0, 0))\n    shortest_counter = [[0] * n for _ in range(n)]\n    shortest_counter[0][0] = 1\n    dist = [INF] * n\n    dist[0] = 0\n    path_counter = [0] * n\n    path_counter[0] = 1\n    while que:\n        (total, node) = heappop(que)\n        count = shortest_counter[node]\n        for (to, w) in graph[node]:\n            new_total = total + w\n            new_count = [i for i in count]\n            new_count[to] += path_counter[node]\n            if dist[to] > new_total:\n                dist[to] = new_total\n                shortest_counter[to] = [i for i in new_count]\n                path_counter[to] = path_counter[node]\n                heappush(que, (new_total, to))\n            elif dist[to] == new_total:\n                shortest_counter[to] = [i + j for (i, j) in zip(shortest_counter[to], new_count)]\n                path_counter[to] += path_counter[node]\n    probabilities = []\n    for child in children:\n        probabilities.append(shortest_counter[n - 1][child] / path_counter[n + 1])\n    return probabilities"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "probabilities.append(shortest_counter[n - 1][child] / path_counter[n - 1])",
      "mutated_line": "probabilities.append(shortest_counter[n - 1][child] / path_counter[n * 1])",
      "code": "from heapq import heappush, heappop\n\ndef calculate_visibility_probabilities(n, m, p, edges, children):\n    INF = 10 ** 20\n    graph = [[] for _ in range(n)]\n    for (x, y, w) in edges:\n        graph[x].append((y, w))\n        graph[y].append((x, w))\n    que = []\n    heappush(que, (0, 0))\n    shortest_counter = [[0] * n for _ in range(n)]\n    shortest_counter[0][0] = 1\n    dist = [INF] * n\n    dist[0] = 0\n    path_counter = [0] * n\n    path_counter[0] = 1\n    while que:\n        (total, node) = heappop(que)\n        count = shortest_counter[node]\n        for (to, w) in graph[node]:\n            new_total = total + w\n            new_count = [i for i in count]\n            new_count[to] += path_counter[node]\n            if dist[to] > new_total:\n                dist[to] = new_total\n                shortest_counter[to] = [i for i in new_count]\n                path_counter[to] = path_counter[node]\n                heappush(que, (new_total, to))\n            elif dist[to] == new_total:\n                shortest_counter[to] = [i + j for (i, j) in zip(shortest_counter[to], new_count)]\n                path_counter[to] += path_counter[node]\n    probabilities = []\n    for child in children:\n        probabilities.append(shortest_counter[n - 1][child] / path_counter[n * 1])\n    return probabilities"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "shortest_counter[to] = [i + j for (i, j) in zip(shortest_counter[to], new_count)]",
      "mutated_line": "shortest_counter[to] = [i - j for (i, j) in zip(shortest_counter[to], new_count)]",
      "code": "from heapq import heappush, heappop\n\ndef calculate_visibility_probabilities(n, m, p, edges, children):\n    INF = 10 ** 20\n    graph = [[] for _ in range(n)]\n    for (x, y, w) in edges:\n        graph[x].append((y, w))\n        graph[y].append((x, w))\n    que = []\n    heappush(que, (0, 0))\n    shortest_counter = [[0] * n for _ in range(n)]\n    shortest_counter[0][0] = 1\n    dist = [INF] * n\n    dist[0] = 0\n    path_counter = [0] * n\n    path_counter[0] = 1\n    while que:\n        (total, node) = heappop(que)\n        count = shortest_counter[node]\n        for (to, w) in graph[node]:\n            new_total = total + w\n            new_count = [i for i in count]\n            new_count[to] += path_counter[node]\n            if dist[to] > new_total:\n                dist[to] = new_total\n                shortest_counter[to] = [i for i in new_count]\n                path_counter[to] = path_counter[node]\n                heappush(que, (new_total, to))\n            elif dist[to] == new_total:\n                shortest_counter[to] = [i - j for (i, j) in zip(shortest_counter[to], new_count)]\n                path_counter[to] += path_counter[node]\n    probabilities = []\n    for child in children:\n        probabilities.append(shortest_counter[n - 1][child] / path_counter[n - 1])\n    return probabilities"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "shortest_counter[to] = [i + j for (i, j) in zip(shortest_counter[to], new_count)]",
      "mutated_line": "shortest_counter[to] = [i * j for (i, j) in zip(shortest_counter[to], new_count)]",
      "code": "from heapq import heappush, heappop\n\ndef calculate_visibility_probabilities(n, m, p, edges, children):\n    INF = 10 ** 20\n    graph = [[] for _ in range(n)]\n    for (x, y, w) in edges:\n        graph[x].append((y, w))\n        graph[y].append((x, w))\n    que = []\n    heappush(que, (0, 0))\n    shortest_counter = [[0] * n for _ in range(n)]\n    shortest_counter[0][0] = 1\n    dist = [INF] * n\n    dist[0] = 0\n    path_counter = [0] * n\n    path_counter[0] = 1\n    while que:\n        (total, node) = heappop(que)\n        count = shortest_counter[node]\n        for (to, w) in graph[node]:\n            new_total = total + w\n            new_count = [i for i in count]\n            new_count[to] += path_counter[node]\n            if dist[to] > new_total:\n                dist[to] = new_total\n                shortest_counter[to] = [i for i in new_count]\n                path_counter[to] = path_counter[node]\n                heappush(que, (new_total, to))\n            elif dist[to] == new_total:\n                shortest_counter[to] = [i * j for (i, j) in zip(shortest_counter[to], new_count)]\n                path_counter[to] += path_counter[node]\n    probabilities = []\n    for child in children:\n        probabilities.append(shortest_counter[n - 1][child] / path_counter[n - 1])\n    return probabilities"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "probabilities.append(shortest_counter[n - 1][child] / path_counter[n - 1])",
      "mutated_line": "probabilities.append(shortest_counter[n + 1][child] / path_counter[n - 1])",
      "code": "from heapq import heappush, heappop\n\ndef calculate_visibility_probabilities(n, m, p, edges, children):\n    INF = 10 ** 20\n    graph = [[] for _ in range(n)]\n    for (x, y, w) in edges:\n        graph[x].append((y, w))\n        graph[y].append((x, w))\n    que = []\n    heappush(que, (0, 0))\n    shortest_counter = [[0] * n for _ in range(n)]\n    shortest_counter[0][0] = 1\n    dist = [INF] * n\n    dist[0] = 0\n    path_counter = [0] * n\n    path_counter[0] = 1\n    while que:\n        (total, node) = heappop(que)\n        count = shortest_counter[node]\n        for (to, w) in graph[node]:\n            new_total = total + w\n            new_count = [i for i in count]\n            new_count[to] += path_counter[node]\n            if dist[to] > new_total:\n                dist[to] = new_total\n                shortest_counter[to] = [i for i in new_count]\n                path_counter[to] = path_counter[node]\n                heappush(que, (new_total, to))\n            elif dist[to] == new_total:\n                shortest_counter[to] = [i + j for (i, j) in zip(shortest_counter[to], new_count)]\n                path_counter[to] += path_counter[node]\n    probabilities = []\n    for child in children:\n        probabilities.append(shortest_counter[n + 1][child] / path_counter[n - 1])\n    return probabilities"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "probabilities.append(shortest_counter[n - 1][child] / path_counter[n - 1])",
      "mutated_line": "probabilities.append(shortest_counter[n * 1][child] / path_counter[n - 1])",
      "code": "from heapq import heappush, heappop\n\ndef calculate_visibility_probabilities(n, m, p, edges, children):\n    INF = 10 ** 20\n    graph = [[] for _ in range(n)]\n    for (x, y, w) in edges:\n        graph[x].append((y, w))\n        graph[y].append((x, w))\n    que = []\n    heappush(que, (0, 0))\n    shortest_counter = [[0] * n for _ in range(n)]\n    shortest_counter[0][0] = 1\n    dist = [INF] * n\n    dist[0] = 0\n    path_counter = [0] * n\n    path_counter[0] = 1\n    while que:\n        (total, node) = heappop(que)\n        count = shortest_counter[node]\n        for (to, w) in graph[node]:\n            new_total = total + w\n            new_count = [i for i in count]\n            new_count[to] += path_counter[node]\n            if dist[to] > new_total:\n                dist[to] = new_total\n                shortest_counter[to] = [i for i in new_count]\n                path_counter[to] = path_counter[node]\n                heappush(que, (new_total, to))\n            elif dist[to] == new_total:\n                shortest_counter[to] = [i + j for (i, j) in zip(shortest_counter[to], new_count)]\n                path_counter[to] += path_counter[node]\n    probabilities = []\n    for child in children:\n        probabilities.append(shortest_counter[n * 1][child] / path_counter[n - 1])\n    return probabilities"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "probabilities.append(shortest_counter[n - 1][child] / path_counter[n - 1])",
      "mutated_line": "probabilities.append(shortest_counter[n - 1][child] / path_counter[n - 2])",
      "code": "from heapq import heappush, heappop\n\ndef calculate_visibility_probabilities(n, m, p, edges, children):\n    INF = 10 ** 20\n    graph = [[] for _ in range(n)]\n    for (x, y, w) in edges:\n        graph[x].append((y, w))\n        graph[y].append((x, w))\n    que = []\n    heappush(que, (0, 0))\n    shortest_counter = [[0] * n for _ in range(n)]\n    shortest_counter[0][0] = 1\n    dist = [INF] * n\n    dist[0] = 0\n    path_counter = [0] * n\n    path_counter[0] = 1\n    while que:\n        (total, node) = heappop(que)\n        count = shortest_counter[node]\n        for (to, w) in graph[node]:\n            new_total = total + w\n            new_count = [i for i in count]\n            new_count[to] += path_counter[node]\n            if dist[to] > new_total:\n                dist[to] = new_total\n                shortest_counter[to] = [i for i in new_count]\n                path_counter[to] = path_counter[node]\n                heappush(que, (new_total, to))\n            elif dist[to] == new_total:\n                shortest_counter[to] = [i + j for (i, j) in zip(shortest_counter[to], new_count)]\n                path_counter[to] += path_counter[node]\n    probabilities = []\n    for child in children:\n        probabilities.append(shortest_counter[n - 1][child] / path_counter[n - 2])\n    return probabilities"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "probabilities.append(shortest_counter[n - 1][child] / path_counter[n - 1])",
      "mutated_line": "probabilities.append(shortest_counter[n - 1][child] / path_counter[n - 0])",
      "code": "from heapq import heappush, heappop\n\ndef calculate_visibility_probabilities(n, m, p, edges, children):\n    INF = 10 ** 20\n    graph = [[] for _ in range(n)]\n    for (x, y, w) in edges:\n        graph[x].append((y, w))\n        graph[y].append((x, w))\n    que = []\n    heappush(que, (0, 0))\n    shortest_counter = [[0] * n for _ in range(n)]\n    shortest_counter[0][0] = 1\n    dist = [INF] * n\n    dist[0] = 0\n    path_counter = [0] * n\n    path_counter[0] = 1\n    while que:\n        (total, node) = heappop(que)\n        count = shortest_counter[node]\n        for (to, w) in graph[node]:\n            new_total = total + w\n            new_count = [i for i in count]\n            new_count[to] += path_counter[node]\n            if dist[to] > new_total:\n                dist[to] = new_total\n                shortest_counter[to] = [i for i in new_count]\n                path_counter[to] = path_counter[node]\n                heappush(que, (new_total, to))\n            elif dist[to] == new_total:\n                shortest_counter[to] = [i + j for (i, j) in zip(shortest_counter[to], new_count)]\n                path_counter[to] += path_counter[node]\n    probabilities = []\n    for child in children:\n        probabilities.append(shortest_counter[n - 1][child] / path_counter[n - 0])\n    return probabilities"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "probabilities.append(shortest_counter[n - 1][child] / path_counter[n - 1])",
      "mutated_line": "probabilities.append(shortest_counter[n - 1][child] / path_counter[n - 0])",
      "code": "from heapq import heappush, heappop\n\ndef calculate_visibility_probabilities(n, m, p, edges, children):\n    INF = 10 ** 20\n    graph = [[] for _ in range(n)]\n    for (x, y, w) in edges:\n        graph[x].append((y, w))\n        graph[y].append((x, w))\n    que = []\n    heappush(que, (0, 0))\n    shortest_counter = [[0] * n for _ in range(n)]\n    shortest_counter[0][0] = 1\n    dist = [INF] * n\n    dist[0] = 0\n    path_counter = [0] * n\n    path_counter[0] = 1\n    while que:\n        (total, node) = heappop(que)\n        count = shortest_counter[node]\n        for (to, w) in graph[node]:\n            new_total = total + w\n            new_count = [i for i in count]\n            new_count[to] += path_counter[node]\n            if dist[to] > new_total:\n                dist[to] = new_total\n                shortest_counter[to] = [i for i in new_count]\n                path_counter[to] = path_counter[node]\n                heappush(que, (new_total, to))\n            elif dist[to] == new_total:\n                shortest_counter[to] = [i + j for (i, j) in zip(shortest_counter[to], new_count)]\n                path_counter[to] += path_counter[node]\n    probabilities = []\n    for child in children:\n        probabilities.append(shortest_counter[n - 1][child] / path_counter[n - 0])\n    return probabilities"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "probabilities.append(shortest_counter[n - 1][child] / path_counter[n - 1])",
      "mutated_line": "probabilities.append(shortest_counter[n - 1][child] / path_counter[n - -1])",
      "code": "from heapq import heappush, heappop\n\ndef calculate_visibility_probabilities(n, m, p, edges, children):\n    INF = 10 ** 20\n    graph = [[] for _ in range(n)]\n    for (x, y, w) in edges:\n        graph[x].append((y, w))\n        graph[y].append((x, w))\n    que = []\n    heappush(que, (0, 0))\n    shortest_counter = [[0] * n for _ in range(n)]\n    shortest_counter[0][0] = 1\n    dist = [INF] * n\n    dist[0] = 0\n    path_counter = [0] * n\n    path_counter[0] = 1\n    while que:\n        (total, node) = heappop(que)\n        count = shortest_counter[node]\n        for (to, w) in graph[node]:\n            new_total = total + w\n            new_count = [i for i in count]\n            new_count[to] += path_counter[node]\n            if dist[to] > new_total:\n                dist[to] = new_total\n                shortest_counter[to] = [i for i in new_count]\n                path_counter[to] = path_counter[node]\n                heappush(que, (new_total, to))\n            elif dist[to] == new_total:\n                shortest_counter[to] = [i + j for (i, j) in zip(shortest_counter[to], new_count)]\n                path_counter[to] += path_counter[node]\n    probabilities = []\n    for child in children:\n        probabilities.append(shortest_counter[n - 1][child] / path_counter[n - -1])\n    return probabilities"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "probabilities.append(shortest_counter[n - 1][child] / path_counter[n - 1])",
      "mutated_line": "probabilities.append(shortest_counter[n - 2][child] / path_counter[n - 1])",
      "code": "from heapq import heappush, heappop\n\ndef calculate_visibility_probabilities(n, m, p, edges, children):\n    INF = 10 ** 20\n    graph = [[] for _ in range(n)]\n    for (x, y, w) in edges:\n        graph[x].append((y, w))\n        graph[y].append((x, w))\n    que = []\n    heappush(que, (0, 0))\n    shortest_counter = [[0] * n for _ in range(n)]\n    shortest_counter[0][0] = 1\n    dist = [INF] * n\n    dist[0] = 0\n    path_counter = [0] * n\n    path_counter[0] = 1\n    while que:\n        (total, node) = heappop(que)\n        count = shortest_counter[node]\n        for (to, w) in graph[node]:\n            new_total = total + w\n            new_count = [i for i in count]\n            new_count[to] += path_counter[node]\n            if dist[to] > new_total:\n                dist[to] = new_total\n                shortest_counter[to] = [i for i in new_count]\n                path_counter[to] = path_counter[node]\n                heappush(que, (new_total, to))\n            elif dist[to] == new_total:\n                shortest_counter[to] = [i + j for (i, j) in zip(shortest_counter[to], new_count)]\n                path_counter[to] += path_counter[node]\n    probabilities = []\n    for child in children:\n        probabilities.append(shortest_counter[n - 2][child] / path_counter[n - 1])\n    return probabilities"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "probabilities.append(shortest_counter[n - 1][child] / path_counter[n - 1])",
      "mutated_line": "probabilities.append(shortest_counter[n - 0][child] / path_counter[n - 1])",
      "code": "from heapq import heappush, heappop\n\ndef calculate_visibility_probabilities(n, m, p, edges, children):\n    INF = 10 ** 20\n    graph = [[] for _ in range(n)]\n    for (x, y, w) in edges:\n        graph[x].append((y, w))\n        graph[y].append((x, w))\n    que = []\n    heappush(que, (0, 0))\n    shortest_counter = [[0] * n for _ in range(n)]\n    shortest_counter[0][0] = 1\n    dist = [INF] * n\n    dist[0] = 0\n    path_counter = [0] * n\n    path_counter[0] = 1\n    while que:\n        (total, node) = heappop(que)\n        count = shortest_counter[node]\n        for (to, w) in graph[node]:\n            new_total = total + w\n            new_count = [i for i in count]\n            new_count[to] += path_counter[node]\n            if dist[to] > new_total:\n                dist[to] = new_total\n                shortest_counter[to] = [i for i in new_count]\n                path_counter[to] = path_counter[node]\n                heappush(que, (new_total, to))\n            elif dist[to] == new_total:\n                shortest_counter[to] = [i + j for (i, j) in zip(shortest_counter[to], new_count)]\n                path_counter[to] += path_counter[node]\n    probabilities = []\n    for child in children:\n        probabilities.append(shortest_counter[n - 0][child] / path_counter[n - 1])\n    return probabilities"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "probabilities.append(shortest_counter[n - 1][child] / path_counter[n - 1])",
      "mutated_line": "probabilities.append(shortest_counter[n - 0][child] / path_counter[n - 1])",
      "code": "from heapq import heappush, heappop\n\ndef calculate_visibility_probabilities(n, m, p, edges, children):\n    INF = 10 ** 20\n    graph = [[] for _ in range(n)]\n    for (x, y, w) in edges:\n        graph[x].append((y, w))\n        graph[y].append((x, w))\n    que = []\n    heappush(que, (0, 0))\n    shortest_counter = [[0] * n for _ in range(n)]\n    shortest_counter[0][0] = 1\n    dist = [INF] * n\n    dist[0] = 0\n    path_counter = [0] * n\n    path_counter[0] = 1\n    while que:\n        (total, node) = heappop(que)\n        count = shortest_counter[node]\n        for (to, w) in graph[node]:\n            new_total = total + w\n            new_count = [i for i in count]\n            new_count[to] += path_counter[node]\n            if dist[to] > new_total:\n                dist[to] = new_total\n                shortest_counter[to] = [i for i in new_count]\n                path_counter[to] = path_counter[node]\n                heappush(que, (new_total, to))\n            elif dist[to] == new_total:\n                shortest_counter[to] = [i + j for (i, j) in zip(shortest_counter[to], new_count)]\n                path_counter[to] += path_counter[node]\n    probabilities = []\n    for child in children:\n        probabilities.append(shortest_counter[n - 0][child] / path_counter[n - 1])\n    return probabilities"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "probabilities.append(shortest_counter[n - 1][child] / path_counter[n - 1])",
      "mutated_line": "probabilities.append(shortest_counter[n - -1][child] / path_counter[n - 1])",
      "code": "from heapq import heappush, heappop\n\ndef calculate_visibility_probabilities(n, m, p, edges, children):\n    INF = 10 ** 20\n    graph = [[] for _ in range(n)]\n    for (x, y, w) in edges:\n        graph[x].append((y, w))\n        graph[y].append((x, w))\n    que = []\n    heappush(que, (0, 0))\n    shortest_counter = [[0] * n for _ in range(n)]\n    shortest_counter[0][0] = 1\n    dist = [INF] * n\n    dist[0] = 0\n    path_counter = [0] * n\n    path_counter[0] = 1\n    while que:\n        (total, node) = heappop(que)\n        count = shortest_counter[node]\n        for (to, w) in graph[node]:\n            new_total = total + w\n            new_count = [i for i in count]\n            new_count[to] += path_counter[node]\n            if dist[to] > new_total:\n                dist[to] = new_total\n                shortest_counter[to] = [i for i in new_count]\n                path_counter[to] = path_counter[node]\n                heappush(que, (new_total, to))\n            elif dist[to] == new_total:\n                shortest_counter[to] = [i + j for (i, j) in zip(shortest_counter[to], new_count)]\n                path_counter[to] += path_counter[node]\n    probabilities = []\n    for child in children:\n        probabilities.append(shortest_counter[n - -1][child] / path_counter[n - 1])\n    return probabilities"
    }
  ]
}