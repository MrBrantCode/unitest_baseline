{
  "task_id": "taco_3069",
  "entry_point": "minimize_questions",
  "mutant_count": 60,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "mi = 0",
      "mutated_line": "mi = 1",
      "code": "def minimize_questions(features_count, objects):\n    objects_int = [int(obj, 2) for obj in objects]\n    max_object_value = max(objects_int)\n    mi = 1\n    while 2 ** mi <= max_object_value:\n        mi += 1\n    powers_of_2 = [2 ** i for i in range(mi + 1)]\n    fm = {}\n\n    def _minimize_questions(objects_int):\n        key = tuple(objects_int)\n        if key in fm:\n            return fm[key]\n        if len(objects_int) < 2:\n            fm[key] = 0\n            return 0\n        result = float('inf')\n        for power in powers_of_2:\n            part1 = []\n            part2 = []\n            for obj in objects_int:\n                if obj & power:\n                    part1.append(obj)\n                else:\n                    part2.append(obj)\n            if not part1 or not part2:\n                continue\n            r1 = _minimize_questions(part1)\n            r2 = _minimize_questions(part2)\n            result = min(result, max(r1, r2) + 1)\n        fm[key] = result\n        return result\n    return _minimize_questions(objects_int)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "mi = 0",
      "mutated_line": "mi = -1",
      "code": "def minimize_questions(features_count, objects):\n    objects_int = [int(obj, 2) for obj in objects]\n    max_object_value = max(objects_int)\n    mi = -1\n    while 2 ** mi <= max_object_value:\n        mi += 1\n    powers_of_2 = [2 ** i for i in range(mi + 1)]\n    fm = {}\n\n    def _minimize_questions(objects_int):\n        key = tuple(objects_int)\n        if key in fm:\n            return fm[key]\n        if len(objects_int) < 2:\n            fm[key] = 0\n            return 0\n        result = float('inf')\n        for power in powers_of_2:\n            part1 = []\n            part2 = []\n            for obj in objects_int:\n                if obj & power:\n                    part1.append(obj)\n                else:\n                    part2.append(obj)\n            if not part1 or not part2:\n                continue\n            r1 = _minimize_questions(part1)\n            r2 = _minimize_questions(part2)\n            result = min(result, max(r1, r2) + 1)\n        fm[key] = result\n        return result\n    return _minimize_questions(objects_int)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "mi = 0",
      "mutated_line": "mi = 1",
      "code": "def minimize_questions(features_count, objects):\n    objects_int = [int(obj, 2) for obj in objects]\n    max_object_value = max(objects_int)\n    mi = 1\n    while 2 ** mi <= max_object_value:\n        mi += 1\n    powers_of_2 = [2 ** i for i in range(mi + 1)]\n    fm = {}\n\n    def _minimize_questions(objects_int):\n        key = tuple(objects_int)\n        if key in fm:\n            return fm[key]\n        if len(objects_int) < 2:\n            fm[key] = 0\n            return 0\n        result = float('inf')\n        for power in powers_of_2:\n            part1 = []\n            part2 = []\n            for obj in objects_int:\n                if obj & power:\n                    part1.append(obj)\n                else:\n                    part2.append(obj)\n            if not part1 or not part2:\n                continue\n            r1 = _minimize_questions(part1)\n            r2 = _minimize_questions(part2)\n            result = min(result, max(r1, r2) + 1)\n        fm[key] = result\n        return result\n    return _minimize_questions(objects_int)"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "while 2 ** mi <= max_object_value:",
      "mutated_line": "while 2 ** mi < max_object_value:",
      "code": "def minimize_questions(features_count, objects):\n    objects_int = [int(obj, 2) for obj in objects]\n    max_object_value = max(objects_int)\n    mi = 0\n    while 2 ** mi < max_object_value:\n        mi += 1\n    powers_of_2 = [2 ** i for i in range(mi + 1)]\n    fm = {}\n\n    def _minimize_questions(objects_int):\n        key = tuple(objects_int)\n        if key in fm:\n            return fm[key]\n        if len(objects_int) < 2:\n            fm[key] = 0\n            return 0\n        result = float('inf')\n        for power in powers_of_2:\n            part1 = []\n            part2 = []\n            for obj in objects_int:\n                if obj & power:\n                    part1.append(obj)\n                else:\n                    part2.append(obj)\n            if not part1 or not part2:\n                continue\n            r1 = _minimize_questions(part1)\n            r2 = _minimize_questions(part2)\n            result = min(result, max(r1, r2) + 1)\n        fm[key] = result\n        return result\n    return _minimize_questions(objects_int)"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "while 2 ** mi <= max_object_value:",
      "mutated_line": "while 2 ** mi > max_object_value:",
      "code": "def minimize_questions(features_count, objects):\n    objects_int = [int(obj, 2) for obj in objects]\n    max_object_value = max(objects_int)\n    mi = 0\n    while 2 ** mi > max_object_value:\n        mi += 1\n    powers_of_2 = [2 ** i for i in range(mi + 1)]\n    fm = {}\n\n    def _minimize_questions(objects_int):\n        key = tuple(objects_int)\n        if key in fm:\n            return fm[key]\n        if len(objects_int) < 2:\n            fm[key] = 0\n            return 0\n        result = float('inf')\n        for power in powers_of_2:\n            part1 = []\n            part2 = []\n            for obj in objects_int:\n                if obj & power:\n                    part1.append(obj)\n                else:\n                    part2.append(obj)\n            if not part1 or not part2:\n                continue\n            r1 = _minimize_questions(part1)\n            r2 = _minimize_questions(part2)\n            result = min(result, max(r1, r2) + 1)\n        fm[key] = result\n        return result\n    return _minimize_questions(objects_int)"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "while 2 ** mi <= max_object_value:",
      "mutated_line": "while 2 ** mi == max_object_value:",
      "code": "def minimize_questions(features_count, objects):\n    objects_int = [int(obj, 2) for obj in objects]\n    max_object_value = max(objects_int)\n    mi = 0\n    while 2 ** mi == max_object_value:\n        mi += 1\n    powers_of_2 = [2 ** i for i in range(mi + 1)]\n    fm = {}\n\n    def _minimize_questions(objects_int):\n        key = tuple(objects_int)\n        if key in fm:\n            return fm[key]\n        if len(objects_int) < 2:\n            fm[key] = 0\n            return 0\n        result = float('inf')\n        for power in powers_of_2:\n            part1 = []\n            part2 = []\n            for obj in objects_int:\n                if obj & power:\n                    part1.append(obj)\n                else:\n                    part2.append(obj)\n            if not part1 or not part2:\n                continue\n            r1 = _minimize_questions(part1)\n            r2 = _minimize_questions(part2)\n            result = min(result, max(r1, r2) + 1)\n        fm[key] = result\n        return result\n    return _minimize_questions(objects_int)"
    },
    {
      "operator": "ASR",
      "lineno": 11,
      "original_line": "mi += 1",
      "mutated_line": "mi -= 1",
      "code": "def minimize_questions(features_count, objects):\n    objects_int = [int(obj, 2) for obj in objects]\n    max_object_value = max(objects_int)\n    mi = 0\n    while 2 ** mi <= max_object_value:\n        mi -= 1\n    powers_of_2 = [2 ** i for i in range(mi + 1)]\n    fm = {}\n\n    def _minimize_questions(objects_int):\n        key = tuple(objects_int)\n        if key in fm:\n            return fm[key]\n        if len(objects_int) < 2:\n            fm[key] = 0\n            return 0\n        result = float('inf')\n        for power in powers_of_2:\n            part1 = []\n            part2 = []\n            for obj in objects_int:\n                if obj & power:\n                    part1.append(obj)\n                else:\n                    part2.append(obj)\n            if not part1 or not part2:\n                continue\n            r1 = _minimize_questions(part1)\n            r2 = _minimize_questions(part2)\n            result = min(result, max(r1, r2) + 1)\n        fm[key] = result\n        return result\n    return _minimize_questions(objects_int)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "while 2 ** mi <= max_object_value:",
      "mutated_line": "while 2 * mi <= max_object_value:",
      "code": "def minimize_questions(features_count, objects):\n    objects_int = [int(obj, 2) for obj in objects]\n    max_object_value = max(objects_int)\n    mi = 0\n    while 2 * mi <= max_object_value:\n        mi += 1\n    powers_of_2 = [2 ** i for i in range(mi + 1)]\n    fm = {}\n\n    def _minimize_questions(objects_int):\n        key = tuple(objects_int)\n        if key in fm:\n            return fm[key]\n        if len(objects_int) < 2:\n            fm[key] = 0\n            return 0\n        result = float('inf')\n        for power in powers_of_2:\n            part1 = []\n            part2 = []\n            for obj in objects_int:\n                if obj & power:\n                    part1.append(obj)\n                else:\n                    part2.append(obj)\n            if not part1 or not part2:\n                continue\n            r1 = _minimize_questions(part1)\n            r2 = _minimize_questions(part2)\n            result = min(result, max(r1, r2) + 1)\n        fm[key] = result\n        return result\n    return _minimize_questions(objects_int)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "while 2 ** mi <= max_object_value:",
      "mutated_line": "while 2 + mi <= max_object_value:",
      "code": "def minimize_questions(features_count, objects):\n    objects_int = [int(obj, 2) for obj in objects]\n    max_object_value = max(objects_int)\n    mi = 0\n    while 2 + mi <= max_object_value:\n        mi += 1\n    powers_of_2 = [2 ** i for i in range(mi + 1)]\n    fm = {}\n\n    def _minimize_questions(objects_int):\n        key = tuple(objects_int)\n        if key in fm:\n            return fm[key]\n        if len(objects_int) < 2:\n            fm[key] = 0\n            return 0\n        result = float('inf')\n        for power in powers_of_2:\n            part1 = []\n            part2 = []\n            for obj in objects_int:\n                if obj & power:\n                    part1.append(obj)\n                else:\n                    part2.append(obj)\n            if not part1 or not part2:\n                continue\n            r1 = _minimize_questions(part1)\n            r2 = _minimize_questions(part2)\n            result = min(result, max(r1, r2) + 1)\n        fm[key] = result\n        return result\n    return _minimize_questions(objects_int)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "mi += 1",
      "mutated_line": "mi += 2",
      "code": "def minimize_questions(features_count, objects):\n    objects_int = [int(obj, 2) for obj in objects]\n    max_object_value = max(objects_int)\n    mi = 0\n    while 2 ** mi <= max_object_value:\n        mi += 2\n    powers_of_2 = [2 ** i for i in range(mi + 1)]\n    fm = {}\n\n    def _minimize_questions(objects_int):\n        key = tuple(objects_int)\n        if key in fm:\n            return fm[key]\n        if len(objects_int) < 2:\n            fm[key] = 0\n            return 0\n        result = float('inf')\n        for power in powers_of_2:\n            part1 = []\n            part2 = []\n            for obj in objects_int:\n                if obj & power:\n                    part1.append(obj)\n                else:\n                    part2.append(obj)\n            if not part1 or not part2:\n                continue\n            r1 = _minimize_questions(part1)\n            r2 = _minimize_questions(part2)\n            result = min(result, max(r1, r2) + 1)\n        fm[key] = result\n        return result\n    return _minimize_questions(objects_int)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "mi += 1",
      "mutated_line": "mi += 0",
      "code": "def minimize_questions(features_count, objects):\n    objects_int = [int(obj, 2) for obj in objects]\n    max_object_value = max(objects_int)\n    mi = 0\n    while 2 ** mi <= max_object_value:\n        mi += 0\n    powers_of_2 = [2 ** i for i in range(mi + 1)]\n    fm = {}\n\n    def _minimize_questions(objects_int):\n        key = tuple(objects_int)\n        if key in fm:\n            return fm[key]\n        if len(objects_int) < 2:\n            fm[key] = 0\n            return 0\n        result = float('inf')\n        for power in powers_of_2:\n            part1 = []\n            part2 = []\n            for obj in objects_int:\n                if obj & power:\n                    part1.append(obj)\n                else:\n                    part2.append(obj)\n            if not part1 or not part2:\n                continue\n            r1 = _minimize_questions(part1)\n            r2 = _minimize_questions(part2)\n            result = min(result, max(r1, r2) + 1)\n        fm[key] = result\n        return result\n    return _minimize_questions(objects_int)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "mi += 1",
      "mutated_line": "mi += 0",
      "code": "def minimize_questions(features_count, objects):\n    objects_int = [int(obj, 2) for obj in objects]\n    max_object_value = max(objects_int)\n    mi = 0\n    while 2 ** mi <= max_object_value:\n        mi += 0\n    powers_of_2 = [2 ** i for i in range(mi + 1)]\n    fm = {}\n\n    def _minimize_questions(objects_int):\n        key = tuple(objects_int)\n        if key in fm:\n            return fm[key]\n        if len(objects_int) < 2:\n            fm[key] = 0\n            return 0\n        result = float('inf')\n        for power in powers_of_2:\n            part1 = []\n            part2 = []\n            for obj in objects_int:\n                if obj & power:\n                    part1.append(obj)\n                else:\n                    part2.append(obj)\n            if not part1 or not part2:\n                continue\n            r1 = _minimize_questions(part1)\n            r2 = _minimize_questions(part2)\n            result = min(result, max(r1, r2) + 1)\n        fm[key] = result\n        return result\n    return _minimize_questions(objects_int)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "mi += 1",
      "mutated_line": "mi += -1",
      "code": "def minimize_questions(features_count, objects):\n    objects_int = [int(obj, 2) for obj in objects]\n    max_object_value = max(objects_int)\n    mi = 0\n    while 2 ** mi <= max_object_value:\n        mi += -1\n    powers_of_2 = [2 ** i for i in range(mi + 1)]\n    fm = {}\n\n    def _minimize_questions(objects_int):\n        key = tuple(objects_int)\n        if key in fm:\n            return fm[key]\n        if len(objects_int) < 2:\n            fm[key] = 0\n            return 0\n        result = float('inf')\n        for power in powers_of_2:\n            part1 = []\n            part2 = []\n            for obj in objects_int:\n                if obj & power:\n                    part1.append(obj)\n                else:\n                    part2.append(obj)\n            if not part1 or not part2:\n                continue\n            r1 = _minimize_questions(part1)\n            r2 = _minimize_questions(part2)\n            result = min(result, max(r1, r2) + 1)\n        fm[key] = result\n        return result\n    return _minimize_questions(objects_int)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "powers_of_2 = [2 ** i for i in range(mi + 1)]",
      "mutated_line": "powers_of_2 = [2 * i for i in range(mi + 1)]",
      "code": "def minimize_questions(features_count, objects):\n    objects_int = [int(obj, 2) for obj in objects]\n    max_object_value = max(objects_int)\n    mi = 0\n    while 2 ** mi <= max_object_value:\n        mi += 1\n    powers_of_2 = [2 * i for i in range(mi + 1)]\n    fm = {}\n\n    def _minimize_questions(objects_int):\n        key = tuple(objects_int)\n        if key in fm:\n            return fm[key]\n        if len(objects_int) < 2:\n            fm[key] = 0\n            return 0\n        result = float('inf')\n        for power in powers_of_2:\n            part1 = []\n            part2 = []\n            for obj in objects_int:\n                if obj & power:\n                    part1.append(obj)\n                else:\n                    part2.append(obj)\n            if not part1 or not part2:\n                continue\n            r1 = _minimize_questions(part1)\n            r2 = _minimize_questions(part2)\n            result = min(result, max(r1, r2) + 1)\n        fm[key] = result\n        return result\n    return _minimize_questions(objects_int)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "powers_of_2 = [2 ** i for i in range(mi + 1)]",
      "mutated_line": "powers_of_2 = [2 + i for i in range(mi + 1)]",
      "code": "def minimize_questions(features_count, objects):\n    objects_int = [int(obj, 2) for obj in objects]\n    max_object_value = max(objects_int)\n    mi = 0\n    while 2 ** mi <= max_object_value:\n        mi += 1\n    powers_of_2 = [2 + i for i in range(mi + 1)]\n    fm = {}\n\n    def _minimize_questions(objects_int):\n        key = tuple(objects_int)\n        if key in fm:\n            return fm[key]\n        if len(objects_int) < 2:\n            fm[key] = 0\n            return 0\n        result = float('inf')\n        for power in powers_of_2:\n            part1 = []\n            part2 = []\n            for obj in objects_int:\n                if obj & power:\n                    part1.append(obj)\n                else:\n                    part2.append(obj)\n            if not part1 or not part2:\n                continue\n            r1 = _minimize_questions(part1)\n            r2 = _minimize_questions(part2)\n            result = min(result, max(r1, r2) + 1)\n        fm[key] = result\n        return result\n    return _minimize_questions(objects_int)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if key in fm:",
      "mutated_line": "if key not in fm:",
      "code": "def minimize_questions(features_count, objects):\n    objects_int = [int(obj, 2) for obj in objects]\n    max_object_value = max(objects_int)\n    mi = 0\n    while 2 ** mi <= max_object_value:\n        mi += 1\n    powers_of_2 = [2 ** i for i in range(mi + 1)]\n    fm = {}\n\n    def _minimize_questions(objects_int):\n        key = tuple(objects_int)\n        if key not in fm:\n            return fm[key]\n        if len(objects_int) < 2:\n            fm[key] = 0\n            return 0\n        result = float('inf')\n        for power in powers_of_2:\n            part1 = []\n            part2 = []\n            for obj in objects_int:\n                if obj & power:\n                    part1.append(obj)\n                else:\n                    part2.append(obj)\n            if not part1 or not part2:\n                continue\n            r1 = _minimize_questions(part1)\n            r2 = _minimize_questions(part2)\n            result = min(result, max(r1, r2) + 1)\n        fm[key] = result\n        return result\n    return _minimize_questions(objects_int)"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if len(objects_int) < 2:",
      "mutated_line": "if len(objects_int) <= 2:",
      "code": "def minimize_questions(features_count, objects):\n    objects_int = [int(obj, 2) for obj in objects]\n    max_object_value = max(objects_int)\n    mi = 0\n    while 2 ** mi <= max_object_value:\n        mi += 1\n    powers_of_2 = [2 ** i for i in range(mi + 1)]\n    fm = {}\n\n    def _minimize_questions(objects_int):\n        key = tuple(objects_int)\n        if key in fm:\n            return fm[key]\n        if len(objects_int) <= 2:\n            fm[key] = 0\n            return 0\n        result = float('inf')\n        for power in powers_of_2:\n            part1 = []\n            part2 = []\n            for obj in objects_int:\n                if obj & power:\n                    part1.append(obj)\n                else:\n                    part2.append(obj)\n            if not part1 or not part2:\n                continue\n            r1 = _minimize_questions(part1)\n            r2 = _minimize_questions(part2)\n            result = min(result, max(r1, r2) + 1)\n        fm[key] = result\n        return result\n    return _minimize_questions(objects_int)"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if len(objects_int) < 2:",
      "mutated_line": "if len(objects_int) >= 2:",
      "code": "def minimize_questions(features_count, objects):\n    objects_int = [int(obj, 2) for obj in objects]\n    max_object_value = max(objects_int)\n    mi = 0\n    while 2 ** mi <= max_object_value:\n        mi += 1\n    powers_of_2 = [2 ** i for i in range(mi + 1)]\n    fm = {}\n\n    def _minimize_questions(objects_int):\n        key = tuple(objects_int)\n        if key in fm:\n            return fm[key]\n        if len(objects_int) >= 2:\n            fm[key] = 0\n            return 0\n        result = float('inf')\n        for power in powers_of_2:\n            part1 = []\n            part2 = []\n            for obj in objects_int:\n                if obj & power:\n                    part1.append(obj)\n                else:\n                    part2.append(obj)\n            if not part1 or not part2:\n                continue\n            r1 = _minimize_questions(part1)\n            r2 = _minimize_questions(part2)\n            result = min(result, max(r1, r2) + 1)\n        fm[key] = result\n        return result\n    return _minimize_questions(objects_int)"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if len(objects_int) < 2:",
      "mutated_line": "if len(objects_int) != 2:",
      "code": "def minimize_questions(features_count, objects):\n    objects_int = [int(obj, 2) for obj in objects]\n    max_object_value = max(objects_int)\n    mi = 0\n    while 2 ** mi <= max_object_value:\n        mi += 1\n    powers_of_2 = [2 ** i for i in range(mi + 1)]\n    fm = {}\n\n    def _minimize_questions(objects_int):\n        key = tuple(objects_int)\n        if key in fm:\n            return fm[key]\n        if len(objects_int) != 2:\n            fm[key] = 0\n            return 0\n        result = float('inf')\n        for power in powers_of_2:\n            part1 = []\n            part2 = []\n            for obj in objects_int:\n                if obj & power:\n                    part1.append(obj)\n                else:\n                    part2.append(obj)\n            if not part1 or not part2:\n                continue\n            r1 = _minimize_questions(part1)\n            r2 = _minimize_questions(part2)\n            result = min(result, max(r1, r2) + 1)\n        fm[key] = result\n        return result\n    return _minimize_questions(objects_int)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "objects_int = [int(obj, 2) for obj in objects]",
      "mutated_line": "objects_int = [int(obj, 3) for obj in objects]",
      "code": "def minimize_questions(features_count, objects):\n    objects_int = [int(obj, 3) for obj in objects]\n    max_object_value = max(objects_int)\n    mi = 0\n    while 2 ** mi <= max_object_value:\n        mi += 1\n    powers_of_2 = [2 ** i for i in range(mi + 1)]\n    fm = {}\n\n    def _minimize_questions(objects_int):\n        key = tuple(objects_int)\n        if key in fm:\n            return fm[key]\n        if len(objects_int) < 2:\n            fm[key] = 0\n            return 0\n        result = float('inf')\n        for power in powers_of_2:\n            part1 = []\n            part2 = []\n            for obj in objects_int:\n                if obj & power:\n                    part1.append(obj)\n                else:\n                    part2.append(obj)\n            if not part1 or not part2:\n                continue\n            r1 = _minimize_questions(part1)\n            r2 = _minimize_questions(part2)\n            result = min(result, max(r1, r2) + 1)\n        fm[key] = result\n        return result\n    return _minimize_questions(objects_int)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "objects_int = [int(obj, 2) for obj in objects]",
      "mutated_line": "objects_int = [int(obj, 1) for obj in objects]",
      "code": "def minimize_questions(features_count, objects):\n    objects_int = [int(obj, 1) for obj in objects]\n    max_object_value = max(objects_int)\n    mi = 0\n    while 2 ** mi <= max_object_value:\n        mi += 1\n    powers_of_2 = [2 ** i for i in range(mi + 1)]\n    fm = {}\n\n    def _minimize_questions(objects_int):\n        key = tuple(objects_int)\n        if key in fm:\n            return fm[key]\n        if len(objects_int) < 2:\n            fm[key] = 0\n            return 0\n        result = float('inf')\n        for power in powers_of_2:\n            part1 = []\n            part2 = []\n            for obj in objects_int:\n                if obj & power:\n                    part1.append(obj)\n                else:\n                    part2.append(obj)\n            if not part1 or not part2:\n                continue\n            r1 = _minimize_questions(part1)\n            r2 = _minimize_questions(part2)\n            result = min(result, max(r1, r2) + 1)\n        fm[key] = result\n        return result\n    return _minimize_questions(objects_int)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "objects_int = [int(obj, 2) for obj in objects]",
      "mutated_line": "objects_int = [int(obj, 0) for obj in objects]",
      "code": "def minimize_questions(features_count, objects):\n    objects_int = [int(obj, 0) for obj in objects]\n    max_object_value = max(objects_int)\n    mi = 0\n    while 2 ** mi <= max_object_value:\n        mi += 1\n    powers_of_2 = [2 ** i for i in range(mi + 1)]\n    fm = {}\n\n    def _minimize_questions(objects_int):\n        key = tuple(objects_int)\n        if key in fm:\n            return fm[key]\n        if len(objects_int) < 2:\n            fm[key] = 0\n            return 0\n        result = float('inf')\n        for power in powers_of_2:\n            part1 = []\n            part2 = []\n            for obj in objects_int:\n                if obj & power:\n                    part1.append(obj)\n                else:\n                    part2.append(obj)\n            if not part1 or not part2:\n                continue\n            r1 = _minimize_questions(part1)\n            r2 = _minimize_questions(part2)\n            result = min(result, max(r1, r2) + 1)\n        fm[key] = result\n        return result\n    return _minimize_questions(objects_int)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "objects_int = [int(obj, 2) for obj in objects]",
      "mutated_line": "objects_int = [int(obj, 1) for obj in objects]",
      "code": "def minimize_questions(features_count, objects):\n    objects_int = [int(obj, 1) for obj in objects]\n    max_object_value = max(objects_int)\n    mi = 0\n    while 2 ** mi <= max_object_value:\n        mi += 1\n    powers_of_2 = [2 ** i for i in range(mi + 1)]\n    fm = {}\n\n    def _minimize_questions(objects_int):\n        key = tuple(objects_int)\n        if key in fm:\n            return fm[key]\n        if len(objects_int) < 2:\n            fm[key] = 0\n            return 0\n        result = float('inf')\n        for power in powers_of_2:\n            part1 = []\n            part2 = []\n            for obj in objects_int:\n                if obj & power:\n                    part1.append(obj)\n                else:\n                    part2.append(obj)\n            if not part1 or not part2:\n                continue\n            r1 = _minimize_questions(part1)\n            r2 = _minimize_questions(part2)\n            result = min(result, max(r1, r2) + 1)\n        fm[key] = result\n        return result\n    return _minimize_questions(objects_int)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "objects_int = [int(obj, 2) for obj in objects]",
      "mutated_line": "objects_int = [int(obj, -2) for obj in objects]",
      "code": "def minimize_questions(features_count, objects):\n    objects_int = [int(obj, -2) for obj in objects]\n    max_object_value = max(objects_int)\n    mi = 0\n    while 2 ** mi <= max_object_value:\n        mi += 1\n    powers_of_2 = [2 ** i for i in range(mi + 1)]\n    fm = {}\n\n    def _minimize_questions(objects_int):\n        key = tuple(objects_int)\n        if key in fm:\n            return fm[key]\n        if len(objects_int) < 2:\n            fm[key] = 0\n            return 0\n        result = float('inf')\n        for power in powers_of_2:\n            part1 = []\n            part2 = []\n            for obj in objects_int:\n                if obj & power:\n                    part1.append(obj)\n                else:\n                    part2.append(obj)\n            if not part1 or not part2:\n                continue\n            r1 = _minimize_questions(part1)\n            r2 = _minimize_questions(part2)\n            result = min(result, max(r1, r2) + 1)\n        fm[key] = result\n        return result\n    return _minimize_questions(objects_int)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "while 2 ** mi <= max_object_value:",
      "mutated_line": "while 3 ** mi <= max_object_value:",
      "code": "def minimize_questions(features_count, objects):\n    objects_int = [int(obj, 2) for obj in objects]\n    max_object_value = max(objects_int)\n    mi = 0\n    while 3 ** mi <= max_object_value:\n        mi += 1\n    powers_of_2 = [2 ** i for i in range(mi + 1)]\n    fm = {}\n\n    def _minimize_questions(objects_int):\n        key = tuple(objects_int)\n        if key in fm:\n            return fm[key]\n        if len(objects_int) < 2:\n            fm[key] = 0\n            return 0\n        result = float('inf')\n        for power in powers_of_2:\n            part1 = []\n            part2 = []\n            for obj in objects_int:\n                if obj & power:\n                    part1.append(obj)\n                else:\n                    part2.append(obj)\n            if not part1 or not part2:\n                continue\n            r1 = _minimize_questions(part1)\n            r2 = _minimize_questions(part2)\n            result = min(result, max(r1, r2) + 1)\n        fm[key] = result\n        return result\n    return _minimize_questions(objects_int)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "while 2 ** mi <= max_object_value:",
      "mutated_line": "while 1 ** mi <= max_object_value:",
      "code": "def minimize_questions(features_count, objects):\n    objects_int = [int(obj, 2) for obj in objects]\n    max_object_value = max(objects_int)\n    mi = 0\n    while 1 ** mi <= max_object_value:\n        mi += 1\n    powers_of_2 = [2 ** i for i in range(mi + 1)]\n    fm = {}\n\n    def _minimize_questions(objects_int):\n        key = tuple(objects_int)\n        if key in fm:\n            return fm[key]\n        if len(objects_int) < 2:\n            fm[key] = 0\n            return 0\n        result = float('inf')\n        for power in powers_of_2:\n            part1 = []\n            part2 = []\n            for obj in objects_int:\n                if obj & power:\n                    part1.append(obj)\n                else:\n                    part2.append(obj)\n            if not part1 or not part2:\n                continue\n            r1 = _minimize_questions(part1)\n            r2 = _minimize_questions(part2)\n            result = min(result, max(r1, r2) + 1)\n        fm[key] = result\n        return result\n    return _minimize_questions(objects_int)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "while 2 ** mi <= max_object_value:",
      "mutated_line": "while 0 ** mi <= max_object_value:",
      "code": "def minimize_questions(features_count, objects):\n    objects_int = [int(obj, 2) for obj in objects]\n    max_object_value = max(objects_int)\n    mi = 0\n    while 0 ** mi <= max_object_value:\n        mi += 1\n    powers_of_2 = [2 ** i for i in range(mi + 1)]\n    fm = {}\n\n    def _minimize_questions(objects_int):\n        key = tuple(objects_int)\n        if key in fm:\n            return fm[key]\n        if len(objects_int) < 2:\n            fm[key] = 0\n            return 0\n        result = float('inf')\n        for power in powers_of_2:\n            part1 = []\n            part2 = []\n            for obj in objects_int:\n                if obj & power:\n                    part1.append(obj)\n                else:\n                    part2.append(obj)\n            if not part1 or not part2:\n                continue\n            r1 = _minimize_questions(part1)\n            r2 = _minimize_questions(part2)\n            result = min(result, max(r1, r2) + 1)\n        fm[key] = result\n        return result\n    return _minimize_questions(objects_int)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "while 2 ** mi <= max_object_value:",
      "mutated_line": "while 1 ** mi <= max_object_value:",
      "code": "def minimize_questions(features_count, objects):\n    objects_int = [int(obj, 2) for obj in objects]\n    max_object_value = max(objects_int)\n    mi = 0\n    while 1 ** mi <= max_object_value:\n        mi += 1\n    powers_of_2 = [2 ** i for i in range(mi + 1)]\n    fm = {}\n\n    def _minimize_questions(objects_int):\n        key = tuple(objects_int)\n        if key in fm:\n            return fm[key]\n        if len(objects_int) < 2:\n            fm[key] = 0\n            return 0\n        result = float('inf')\n        for power in powers_of_2:\n            part1 = []\n            part2 = []\n            for obj in objects_int:\n                if obj & power:\n                    part1.append(obj)\n                else:\n                    part2.append(obj)\n            if not part1 or not part2:\n                continue\n            r1 = _minimize_questions(part1)\n            r2 = _minimize_questions(part2)\n            result = min(result, max(r1, r2) + 1)\n        fm[key] = result\n        return result\n    return _minimize_questions(objects_int)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "while 2 ** mi <= max_object_value:",
      "mutated_line": "while -2 ** mi <= max_object_value:",
      "code": "def minimize_questions(features_count, objects):\n    objects_int = [int(obj, 2) for obj in objects]\n    max_object_value = max(objects_int)\n    mi = 0\n    while -2 ** mi <= max_object_value:\n        mi += 1\n    powers_of_2 = [2 ** i for i in range(mi + 1)]\n    fm = {}\n\n    def _minimize_questions(objects_int):\n        key = tuple(objects_int)\n        if key in fm:\n            return fm[key]\n        if len(objects_int) < 2:\n            fm[key] = 0\n            return 0\n        result = float('inf')\n        for power in powers_of_2:\n            part1 = []\n            part2 = []\n            for obj in objects_int:\n                if obj & power:\n                    part1.append(obj)\n                else:\n                    part2.append(obj)\n            if not part1 or not part2:\n                continue\n            r1 = _minimize_questions(part1)\n            r2 = _minimize_questions(part2)\n            result = min(result, max(r1, r2) + 1)\n        fm[key] = result\n        return result\n    return _minimize_questions(objects_int)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "powers_of_2 = [2 ** i for i in range(mi + 1)]",
      "mutated_line": "powers_of_2 = [3 ** i for i in range(mi + 1)]",
      "code": "def minimize_questions(features_count, objects):\n    objects_int = [int(obj, 2) for obj in objects]\n    max_object_value = max(objects_int)\n    mi = 0\n    while 2 ** mi <= max_object_value:\n        mi += 1\n    powers_of_2 = [3 ** i for i in range(mi + 1)]\n    fm = {}\n\n    def _minimize_questions(objects_int):\n        key = tuple(objects_int)\n        if key in fm:\n            return fm[key]\n        if len(objects_int) < 2:\n            fm[key] = 0\n            return 0\n        result = float('inf')\n        for power in powers_of_2:\n            part1 = []\n            part2 = []\n            for obj in objects_int:\n                if obj & power:\n                    part1.append(obj)\n                else:\n                    part2.append(obj)\n            if not part1 or not part2:\n                continue\n            r1 = _minimize_questions(part1)\n            r2 = _minimize_questions(part2)\n            result = min(result, max(r1, r2) + 1)\n        fm[key] = result\n        return result\n    return _minimize_questions(objects_int)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "powers_of_2 = [2 ** i for i in range(mi + 1)]",
      "mutated_line": "powers_of_2 = [1 ** i for i in range(mi + 1)]",
      "code": "def minimize_questions(features_count, objects):\n    objects_int = [int(obj, 2) for obj in objects]\n    max_object_value = max(objects_int)\n    mi = 0\n    while 2 ** mi <= max_object_value:\n        mi += 1\n    powers_of_2 = [1 ** i for i in range(mi + 1)]\n    fm = {}\n\n    def _minimize_questions(objects_int):\n        key = tuple(objects_int)\n        if key in fm:\n            return fm[key]\n        if len(objects_int) < 2:\n            fm[key] = 0\n            return 0\n        result = float('inf')\n        for power in powers_of_2:\n            part1 = []\n            part2 = []\n            for obj in objects_int:\n                if obj & power:\n                    part1.append(obj)\n                else:\n                    part2.append(obj)\n            if not part1 or not part2:\n                continue\n            r1 = _minimize_questions(part1)\n            r2 = _minimize_questions(part2)\n            result = min(result, max(r1, r2) + 1)\n        fm[key] = result\n        return result\n    return _minimize_questions(objects_int)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "powers_of_2 = [2 ** i for i in range(mi + 1)]",
      "mutated_line": "powers_of_2 = [0 ** i for i in range(mi + 1)]",
      "code": "def minimize_questions(features_count, objects):\n    objects_int = [int(obj, 2) for obj in objects]\n    max_object_value = max(objects_int)\n    mi = 0\n    while 2 ** mi <= max_object_value:\n        mi += 1\n    powers_of_2 = [0 ** i for i in range(mi + 1)]\n    fm = {}\n\n    def _minimize_questions(objects_int):\n        key = tuple(objects_int)\n        if key in fm:\n            return fm[key]\n        if len(objects_int) < 2:\n            fm[key] = 0\n            return 0\n        result = float('inf')\n        for power in powers_of_2:\n            part1 = []\n            part2 = []\n            for obj in objects_int:\n                if obj & power:\n                    part1.append(obj)\n                else:\n                    part2.append(obj)\n            if not part1 or not part2:\n                continue\n            r1 = _minimize_questions(part1)\n            r2 = _minimize_questions(part2)\n            result = min(result, max(r1, r2) + 1)\n        fm[key] = result\n        return result\n    return _minimize_questions(objects_int)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "powers_of_2 = [2 ** i for i in range(mi + 1)]",
      "mutated_line": "powers_of_2 = [1 ** i for i in range(mi + 1)]",
      "code": "def minimize_questions(features_count, objects):\n    objects_int = [int(obj, 2) for obj in objects]\n    max_object_value = max(objects_int)\n    mi = 0\n    while 2 ** mi <= max_object_value:\n        mi += 1\n    powers_of_2 = [1 ** i for i in range(mi + 1)]\n    fm = {}\n\n    def _minimize_questions(objects_int):\n        key = tuple(objects_int)\n        if key in fm:\n            return fm[key]\n        if len(objects_int) < 2:\n            fm[key] = 0\n            return 0\n        result = float('inf')\n        for power in powers_of_2:\n            part1 = []\n            part2 = []\n            for obj in objects_int:\n                if obj & power:\n                    part1.append(obj)\n                else:\n                    part2.append(obj)\n            if not part1 or not part2:\n                continue\n            r1 = _minimize_questions(part1)\n            r2 = _minimize_questions(part2)\n            result = min(result, max(r1, r2) + 1)\n        fm[key] = result\n        return result\n    return _minimize_questions(objects_int)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "powers_of_2 = [2 ** i for i in range(mi + 1)]",
      "mutated_line": "powers_of_2 = [-2 ** i for i in range(mi + 1)]",
      "code": "def minimize_questions(features_count, objects):\n    objects_int = [int(obj, 2) for obj in objects]\n    max_object_value = max(objects_int)\n    mi = 0\n    while 2 ** mi <= max_object_value:\n        mi += 1\n    powers_of_2 = [-2 ** i for i in range(mi + 1)]\n    fm = {}\n\n    def _minimize_questions(objects_int):\n        key = tuple(objects_int)\n        if key in fm:\n            return fm[key]\n        if len(objects_int) < 2:\n            fm[key] = 0\n            return 0\n        result = float('inf')\n        for power in powers_of_2:\n            part1 = []\n            part2 = []\n            for obj in objects_int:\n                if obj & power:\n                    part1.append(obj)\n                else:\n                    part2.append(obj)\n            if not part1 or not part2:\n                continue\n            r1 = _minimize_questions(part1)\n            r2 = _minimize_questions(part2)\n            result = min(result, max(r1, r2) + 1)\n        fm[key] = result\n        return result\n    return _minimize_questions(objects_int)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if len(objects_int) < 2:",
      "mutated_line": "if len(objects_int) < 3:",
      "code": "def minimize_questions(features_count, objects):\n    objects_int = [int(obj, 2) for obj in objects]\n    max_object_value = max(objects_int)\n    mi = 0\n    while 2 ** mi <= max_object_value:\n        mi += 1\n    powers_of_2 = [2 ** i for i in range(mi + 1)]\n    fm = {}\n\n    def _minimize_questions(objects_int):\n        key = tuple(objects_int)\n        if key in fm:\n            return fm[key]\n        if len(objects_int) < 3:\n            fm[key] = 0\n            return 0\n        result = float('inf')\n        for power in powers_of_2:\n            part1 = []\n            part2 = []\n            for obj in objects_int:\n                if obj & power:\n                    part1.append(obj)\n                else:\n                    part2.append(obj)\n            if not part1 or not part2:\n                continue\n            r1 = _minimize_questions(part1)\n            r2 = _minimize_questions(part2)\n            result = min(result, max(r1, r2) + 1)\n        fm[key] = result\n        return result\n    return _minimize_questions(objects_int)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if len(objects_int) < 2:",
      "mutated_line": "if len(objects_int) < 1:",
      "code": "def minimize_questions(features_count, objects):\n    objects_int = [int(obj, 2) for obj in objects]\n    max_object_value = max(objects_int)\n    mi = 0\n    while 2 ** mi <= max_object_value:\n        mi += 1\n    powers_of_2 = [2 ** i for i in range(mi + 1)]\n    fm = {}\n\n    def _minimize_questions(objects_int):\n        key = tuple(objects_int)\n        if key in fm:\n            return fm[key]\n        if len(objects_int) < 1:\n            fm[key] = 0\n            return 0\n        result = float('inf')\n        for power in powers_of_2:\n            part1 = []\n            part2 = []\n            for obj in objects_int:\n                if obj & power:\n                    part1.append(obj)\n                else:\n                    part2.append(obj)\n            if not part1 or not part2:\n                continue\n            r1 = _minimize_questions(part1)\n            r2 = _minimize_questions(part2)\n            result = min(result, max(r1, r2) + 1)\n        fm[key] = result\n        return result\n    return _minimize_questions(objects_int)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if len(objects_int) < 2:",
      "mutated_line": "if len(objects_int) < 0:",
      "code": "def minimize_questions(features_count, objects):\n    objects_int = [int(obj, 2) for obj in objects]\n    max_object_value = max(objects_int)\n    mi = 0\n    while 2 ** mi <= max_object_value:\n        mi += 1\n    powers_of_2 = [2 ** i for i in range(mi + 1)]\n    fm = {}\n\n    def _minimize_questions(objects_int):\n        key = tuple(objects_int)\n        if key in fm:\n            return fm[key]\n        if len(objects_int) < 0:\n            fm[key] = 0\n            return 0\n        result = float('inf')\n        for power in powers_of_2:\n            part1 = []\n            part2 = []\n            for obj in objects_int:\n                if obj & power:\n                    part1.append(obj)\n                else:\n                    part2.append(obj)\n            if not part1 or not part2:\n                continue\n            r1 = _minimize_questions(part1)\n            r2 = _minimize_questions(part2)\n            result = min(result, max(r1, r2) + 1)\n        fm[key] = result\n        return result\n    return _minimize_questions(objects_int)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if len(objects_int) < 2:",
      "mutated_line": "if len(objects_int) < 1:",
      "code": "def minimize_questions(features_count, objects):\n    objects_int = [int(obj, 2) for obj in objects]\n    max_object_value = max(objects_int)\n    mi = 0\n    while 2 ** mi <= max_object_value:\n        mi += 1\n    powers_of_2 = [2 ** i for i in range(mi + 1)]\n    fm = {}\n\n    def _minimize_questions(objects_int):\n        key = tuple(objects_int)\n        if key in fm:\n            return fm[key]\n        if len(objects_int) < 1:\n            fm[key] = 0\n            return 0\n        result = float('inf')\n        for power in powers_of_2:\n            part1 = []\n            part2 = []\n            for obj in objects_int:\n                if obj & power:\n                    part1.append(obj)\n                else:\n                    part2.append(obj)\n            if not part1 or not part2:\n                continue\n            r1 = _minimize_questions(part1)\n            r2 = _minimize_questions(part2)\n            result = min(result, max(r1, r2) + 1)\n        fm[key] = result\n        return result\n    return _minimize_questions(objects_int)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if len(objects_int) < 2:",
      "mutated_line": "if len(objects_int) < -2:",
      "code": "def minimize_questions(features_count, objects):\n    objects_int = [int(obj, 2) for obj in objects]\n    max_object_value = max(objects_int)\n    mi = 0\n    while 2 ** mi <= max_object_value:\n        mi += 1\n    powers_of_2 = [2 ** i for i in range(mi + 1)]\n    fm = {}\n\n    def _minimize_questions(objects_int):\n        key = tuple(objects_int)\n        if key in fm:\n            return fm[key]\n        if len(objects_int) < -2:\n            fm[key] = 0\n            return 0\n        result = float('inf')\n        for power in powers_of_2:\n            part1 = []\n            part2 = []\n            for obj in objects_int:\n                if obj & power:\n                    part1.append(obj)\n                else:\n                    part2.append(obj)\n            if not part1 or not part2:\n                continue\n            r1 = _minimize_questions(part1)\n            r2 = _minimize_questions(part2)\n            result = min(result, max(r1, r2) + 1)\n        fm[key] = result\n        return result\n    return _minimize_questions(objects_int)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "fm[key] = 0",
      "mutated_line": "fm[key] = 1",
      "code": "def minimize_questions(features_count, objects):\n    objects_int = [int(obj, 2) for obj in objects]\n    max_object_value = max(objects_int)\n    mi = 0\n    while 2 ** mi <= max_object_value:\n        mi += 1\n    powers_of_2 = [2 ** i for i in range(mi + 1)]\n    fm = {}\n\n    def _minimize_questions(objects_int):\n        key = tuple(objects_int)\n        if key in fm:\n            return fm[key]\n        if len(objects_int) < 2:\n            fm[key] = 1\n            return 0\n        result = float('inf')\n        for power in powers_of_2:\n            part1 = []\n            part2 = []\n            for obj in objects_int:\n                if obj & power:\n                    part1.append(obj)\n                else:\n                    part2.append(obj)\n            if not part1 or not part2:\n                continue\n            r1 = _minimize_questions(part1)\n            r2 = _minimize_questions(part2)\n            result = min(result, max(r1, r2) + 1)\n        fm[key] = result\n        return result\n    return _minimize_questions(objects_int)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "fm[key] = 0",
      "mutated_line": "fm[key] = -1",
      "code": "def minimize_questions(features_count, objects):\n    objects_int = [int(obj, 2) for obj in objects]\n    max_object_value = max(objects_int)\n    mi = 0\n    while 2 ** mi <= max_object_value:\n        mi += 1\n    powers_of_2 = [2 ** i for i in range(mi + 1)]\n    fm = {}\n\n    def _minimize_questions(objects_int):\n        key = tuple(objects_int)\n        if key in fm:\n            return fm[key]\n        if len(objects_int) < 2:\n            fm[key] = -1\n            return 0\n        result = float('inf')\n        for power in powers_of_2:\n            part1 = []\n            part2 = []\n            for obj in objects_int:\n                if obj & power:\n                    part1.append(obj)\n                else:\n                    part2.append(obj)\n            if not part1 or not part2:\n                continue\n            r1 = _minimize_questions(part1)\n            r2 = _minimize_questions(part2)\n            result = min(result, max(r1, r2) + 1)\n        fm[key] = result\n        return result\n    return _minimize_questions(objects_int)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "fm[key] = 0",
      "mutated_line": "fm[key] = 1",
      "code": "def minimize_questions(features_count, objects):\n    objects_int = [int(obj, 2) for obj in objects]\n    max_object_value = max(objects_int)\n    mi = 0\n    while 2 ** mi <= max_object_value:\n        mi += 1\n    powers_of_2 = [2 ** i for i in range(mi + 1)]\n    fm = {}\n\n    def _minimize_questions(objects_int):\n        key = tuple(objects_int)\n        if key in fm:\n            return fm[key]\n        if len(objects_int) < 2:\n            fm[key] = 1\n            return 0\n        result = float('inf')\n        for power in powers_of_2:\n            part1 = []\n            part2 = []\n            for obj in objects_int:\n                if obj & power:\n                    part1.append(obj)\n                else:\n                    part2.append(obj)\n            if not part1 or not part2:\n                continue\n            r1 = _minimize_questions(part1)\n            r2 = _minimize_questions(part2)\n            result = min(result, max(r1, r2) + 1)\n        fm[key] = result\n        return result\n    return _minimize_questions(objects_int)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def minimize_questions(features_count, objects):\n    objects_int = [int(obj, 2) for obj in objects]\n    max_object_value = max(objects_int)\n    mi = 0\n    while 2 ** mi <= max_object_value:\n        mi += 1\n    powers_of_2 = [2 ** i for i in range(mi + 1)]\n    fm = {}\n\n    def _minimize_questions(objects_int):\n        key = tuple(objects_int)\n        if key in fm:\n            return fm[key]\n        if len(objects_int) < 2:\n            fm[key] = 0\n            return 1\n        result = float('inf')\n        for power in powers_of_2:\n            part1 = []\n            part2 = []\n            for obj in objects_int:\n                if obj & power:\n                    part1.append(obj)\n                else:\n                    part2.append(obj)\n            if not part1 or not part2:\n                continue\n            r1 = _minimize_questions(part1)\n            r2 = _minimize_questions(part2)\n            result = min(result, max(r1, r2) + 1)\n        fm[key] = result\n        return result\n    return _minimize_questions(objects_int)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "def minimize_questions(features_count, objects):\n    objects_int = [int(obj, 2) for obj in objects]\n    max_object_value = max(objects_int)\n    mi = 0\n    while 2 ** mi <= max_object_value:\n        mi += 1\n    powers_of_2 = [2 ** i for i in range(mi + 1)]\n    fm = {}\n\n    def _minimize_questions(objects_int):\n        key = tuple(objects_int)\n        if key in fm:\n            return fm[key]\n        if len(objects_int) < 2:\n            fm[key] = 0\n            return -1\n        result = float('inf')\n        for power in powers_of_2:\n            part1 = []\n            part2 = []\n            for obj in objects_int:\n                if obj & power:\n                    part1.append(obj)\n                else:\n                    part2.append(obj)\n            if not part1 or not part2:\n                continue\n            r1 = _minimize_questions(part1)\n            r2 = _minimize_questions(part2)\n            result = min(result, max(r1, r2) + 1)\n        fm[key] = result\n        return result\n    return _minimize_questions(objects_int)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def minimize_questions(features_count, objects):\n    objects_int = [int(obj, 2) for obj in objects]\n    max_object_value = max(objects_int)\n    mi = 0\n    while 2 ** mi <= max_object_value:\n        mi += 1\n    powers_of_2 = [2 ** i for i in range(mi + 1)]\n    fm = {}\n\n    def _minimize_questions(objects_int):\n        key = tuple(objects_int)\n        if key in fm:\n            return fm[key]\n        if len(objects_int) < 2:\n            fm[key] = 0\n            return 1\n        result = float('inf')\n        for power in powers_of_2:\n            part1 = []\n            part2 = []\n            for obj in objects_int:\n                if obj & power:\n                    part1.append(obj)\n                else:\n                    part2.append(obj)\n            if not part1 or not part2:\n                continue\n            r1 = _minimize_questions(part1)\n            r2 = _minimize_questions(part2)\n            result = min(result, max(r1, r2) + 1)\n        fm[key] = result\n        return result\n    return _minimize_questions(objects_int)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "result = float('inf')",
      "mutated_line": "result = float('')",
      "code": "def minimize_questions(features_count, objects):\n    objects_int = [int(obj, 2) for obj in objects]\n    max_object_value = max(objects_int)\n    mi = 0\n    while 2 ** mi <= max_object_value:\n        mi += 1\n    powers_of_2 = [2 ** i for i in range(mi + 1)]\n    fm = {}\n\n    def _minimize_questions(objects_int):\n        key = tuple(objects_int)\n        if key in fm:\n            return fm[key]\n        if len(objects_int) < 2:\n            fm[key] = 0\n            return 0\n        result = float('')\n        for power in powers_of_2:\n            part1 = []\n            part2 = []\n            for obj in objects_int:\n                if obj & power:\n                    part1.append(obj)\n                else:\n                    part2.append(obj)\n            if not part1 or not part2:\n                continue\n            r1 = _minimize_questions(part1)\n            r2 = _minimize_questions(part2)\n            result = min(result, max(r1, r2) + 1)\n        fm[key] = result\n        return result\n    return _minimize_questions(objects_int)"
    },
    {
      "operator": "LCR",
      "lineno": 44,
      "original_line": "if not part1 or not part2:",
      "mutated_line": "if not part1 and (not part2):",
      "code": "def minimize_questions(features_count, objects):\n    objects_int = [int(obj, 2) for obj in objects]\n    max_object_value = max(objects_int)\n    mi = 0\n    while 2 ** mi <= max_object_value:\n        mi += 1\n    powers_of_2 = [2 ** i for i in range(mi + 1)]\n    fm = {}\n\n    def _minimize_questions(objects_int):\n        key = tuple(objects_int)\n        if key in fm:\n            return fm[key]\n        if len(objects_int) < 2:\n            fm[key] = 0\n            return 0\n        result = float('inf')\n        for power in powers_of_2:\n            part1 = []\n            part2 = []\n            for obj in objects_int:\n                if obj & power:\n                    part1.append(obj)\n                else:\n                    part2.append(obj)\n            if not part1 and (not part2):\n                continue\n            r1 = _minimize_questions(part1)\n            r2 = _minimize_questions(part2)\n            result = min(result, max(r1, r2) + 1)\n        fm[key] = result\n        return result\n    return _minimize_questions(objects_int)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "powers_of_2 = [2 ** i for i in range(mi + 1)]",
      "mutated_line": "powers_of_2 = [2 ** i for i in range(mi - 1)]",
      "code": "def minimize_questions(features_count, objects):\n    objects_int = [int(obj, 2) for obj in objects]\n    max_object_value = max(objects_int)\n    mi = 0\n    while 2 ** mi <= max_object_value:\n        mi += 1\n    powers_of_2 = [2 ** i for i in range(mi - 1)]\n    fm = {}\n\n    def _minimize_questions(objects_int):\n        key = tuple(objects_int)\n        if key in fm:\n            return fm[key]\n        if len(objects_int) < 2:\n            fm[key] = 0\n            return 0\n        result = float('inf')\n        for power in powers_of_2:\n            part1 = []\n            part2 = []\n            for obj in objects_int:\n                if obj & power:\n                    part1.append(obj)\n                else:\n                    part2.append(obj)\n            if not part1 or not part2:\n                continue\n            r1 = _minimize_questions(part1)\n            r2 = _minimize_questions(part2)\n            result = min(result, max(r1, r2) + 1)\n        fm[key] = result\n        return result\n    return _minimize_questions(objects_int)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "powers_of_2 = [2 ** i for i in range(mi + 1)]",
      "mutated_line": "powers_of_2 = [2 ** i for i in range(mi * 1)]",
      "code": "def minimize_questions(features_count, objects):\n    objects_int = [int(obj, 2) for obj in objects]\n    max_object_value = max(objects_int)\n    mi = 0\n    while 2 ** mi <= max_object_value:\n        mi += 1\n    powers_of_2 = [2 ** i for i in range(mi * 1)]\n    fm = {}\n\n    def _minimize_questions(objects_int):\n        key = tuple(objects_int)\n        if key in fm:\n            return fm[key]\n        if len(objects_int) < 2:\n            fm[key] = 0\n            return 0\n        result = float('inf')\n        for power in powers_of_2:\n            part1 = []\n            part2 = []\n            for obj in objects_int:\n                if obj & power:\n                    part1.append(obj)\n                else:\n                    part2.append(obj)\n            if not part1 or not part2:\n                continue\n            r1 = _minimize_questions(part1)\n            r2 = _minimize_questions(part2)\n            result = min(result, max(r1, r2) + 1)\n        fm[key] = result\n        return result\n    return _minimize_questions(objects_int)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "if obj & power:",
      "mutated_line": "if obj | power:",
      "code": "def minimize_questions(features_count, objects):\n    objects_int = [int(obj, 2) for obj in objects]\n    max_object_value = max(objects_int)\n    mi = 0\n    while 2 ** mi <= max_object_value:\n        mi += 1\n    powers_of_2 = [2 ** i for i in range(mi + 1)]\n    fm = {}\n\n    def _minimize_questions(objects_int):\n        key = tuple(objects_int)\n        if key in fm:\n            return fm[key]\n        if len(objects_int) < 2:\n            fm[key] = 0\n            return 0\n        result = float('inf')\n        for power in powers_of_2:\n            part1 = []\n            part2 = []\n            for obj in objects_int:\n                if obj | power:\n                    part1.append(obj)\n                else:\n                    part2.append(obj)\n            if not part1 or not part2:\n                continue\n            r1 = _minimize_questions(part1)\n            r2 = _minimize_questions(part2)\n            result = min(result, max(r1, r2) + 1)\n        fm[key] = result\n        return result\n    return _minimize_questions(objects_int)"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "result = min(result, max(r1, r2) + 1)",
      "mutated_line": "result = min(result, max(r1, r2) - 1)",
      "code": "def minimize_questions(features_count, objects):\n    objects_int = [int(obj, 2) for obj in objects]\n    max_object_value = max(objects_int)\n    mi = 0\n    while 2 ** mi <= max_object_value:\n        mi += 1\n    powers_of_2 = [2 ** i for i in range(mi + 1)]\n    fm = {}\n\n    def _minimize_questions(objects_int):\n        key = tuple(objects_int)\n        if key in fm:\n            return fm[key]\n        if len(objects_int) < 2:\n            fm[key] = 0\n            return 0\n        result = float('inf')\n        for power in powers_of_2:\n            part1 = []\n            part2 = []\n            for obj in objects_int:\n                if obj & power:\n                    part1.append(obj)\n                else:\n                    part2.append(obj)\n            if not part1 or not part2:\n                continue\n            r1 = _minimize_questions(part1)\n            r2 = _minimize_questions(part2)\n            result = min(result, max(r1, r2) - 1)\n        fm[key] = result\n        return result\n    return _minimize_questions(objects_int)"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "result = min(result, max(r1, r2) + 1)",
      "mutated_line": "result = min(result, max(r1, r2) * 1)",
      "code": "def minimize_questions(features_count, objects):\n    objects_int = [int(obj, 2) for obj in objects]\n    max_object_value = max(objects_int)\n    mi = 0\n    while 2 ** mi <= max_object_value:\n        mi += 1\n    powers_of_2 = [2 ** i for i in range(mi + 1)]\n    fm = {}\n\n    def _minimize_questions(objects_int):\n        key = tuple(objects_int)\n        if key in fm:\n            return fm[key]\n        if len(objects_int) < 2:\n            fm[key] = 0\n            return 0\n        result = float('inf')\n        for power in powers_of_2:\n            part1 = []\n            part2 = []\n            for obj in objects_int:\n                if obj & power:\n                    part1.append(obj)\n                else:\n                    part2.append(obj)\n            if not part1 or not part2:\n                continue\n            r1 = _minimize_questions(part1)\n            r2 = _minimize_questions(part2)\n            result = min(result, max(r1, r2) * 1)\n        fm[key] = result\n        return result\n    return _minimize_questions(objects_int)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "powers_of_2 = [2 ** i for i in range(mi + 1)]",
      "mutated_line": "powers_of_2 = [2 ** i for i in range(mi + 2)]",
      "code": "def minimize_questions(features_count, objects):\n    objects_int = [int(obj, 2) for obj in objects]\n    max_object_value = max(objects_int)\n    mi = 0\n    while 2 ** mi <= max_object_value:\n        mi += 1\n    powers_of_2 = [2 ** i for i in range(mi + 2)]\n    fm = {}\n\n    def _minimize_questions(objects_int):\n        key = tuple(objects_int)\n        if key in fm:\n            return fm[key]\n        if len(objects_int) < 2:\n            fm[key] = 0\n            return 0\n        result = float('inf')\n        for power in powers_of_2:\n            part1 = []\n            part2 = []\n            for obj in objects_int:\n                if obj & power:\n                    part1.append(obj)\n                else:\n                    part2.append(obj)\n            if not part1 or not part2:\n                continue\n            r1 = _minimize_questions(part1)\n            r2 = _minimize_questions(part2)\n            result = min(result, max(r1, r2) + 1)\n        fm[key] = result\n        return result\n    return _minimize_questions(objects_int)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "powers_of_2 = [2 ** i for i in range(mi + 1)]",
      "mutated_line": "powers_of_2 = [2 ** i for i in range(mi + 0)]",
      "code": "def minimize_questions(features_count, objects):\n    objects_int = [int(obj, 2) for obj in objects]\n    max_object_value = max(objects_int)\n    mi = 0\n    while 2 ** mi <= max_object_value:\n        mi += 1\n    powers_of_2 = [2 ** i for i in range(mi + 0)]\n    fm = {}\n\n    def _minimize_questions(objects_int):\n        key = tuple(objects_int)\n        if key in fm:\n            return fm[key]\n        if len(objects_int) < 2:\n            fm[key] = 0\n            return 0\n        result = float('inf')\n        for power in powers_of_2:\n            part1 = []\n            part2 = []\n            for obj in objects_int:\n                if obj & power:\n                    part1.append(obj)\n                else:\n                    part2.append(obj)\n            if not part1 or not part2:\n                continue\n            r1 = _minimize_questions(part1)\n            r2 = _minimize_questions(part2)\n            result = min(result, max(r1, r2) + 1)\n        fm[key] = result\n        return result\n    return _minimize_questions(objects_int)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "powers_of_2 = [2 ** i for i in range(mi + 1)]",
      "mutated_line": "powers_of_2 = [2 ** i for i in range(mi + 0)]",
      "code": "def minimize_questions(features_count, objects):\n    objects_int = [int(obj, 2) for obj in objects]\n    max_object_value = max(objects_int)\n    mi = 0\n    while 2 ** mi <= max_object_value:\n        mi += 1\n    powers_of_2 = [2 ** i for i in range(mi + 0)]\n    fm = {}\n\n    def _minimize_questions(objects_int):\n        key = tuple(objects_int)\n        if key in fm:\n            return fm[key]\n        if len(objects_int) < 2:\n            fm[key] = 0\n            return 0\n        result = float('inf')\n        for power in powers_of_2:\n            part1 = []\n            part2 = []\n            for obj in objects_int:\n                if obj & power:\n                    part1.append(obj)\n                else:\n                    part2.append(obj)\n            if not part1 or not part2:\n                continue\n            r1 = _minimize_questions(part1)\n            r2 = _minimize_questions(part2)\n            result = min(result, max(r1, r2) + 1)\n        fm[key] = result\n        return result\n    return _minimize_questions(objects_int)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "powers_of_2 = [2 ** i for i in range(mi + 1)]",
      "mutated_line": "powers_of_2 = [2 ** i for i in range(mi + -1)]",
      "code": "def minimize_questions(features_count, objects):\n    objects_int = [int(obj, 2) for obj in objects]\n    max_object_value = max(objects_int)\n    mi = 0\n    while 2 ** mi <= max_object_value:\n        mi += 1\n    powers_of_2 = [2 ** i for i in range(mi + -1)]\n    fm = {}\n\n    def _minimize_questions(objects_int):\n        key = tuple(objects_int)\n        if key in fm:\n            return fm[key]\n        if len(objects_int) < 2:\n            fm[key] = 0\n            return 0\n        result = float('inf')\n        for power in powers_of_2:\n            part1 = []\n            part2 = []\n            for obj in objects_int:\n                if obj & power:\n                    part1.append(obj)\n                else:\n                    part2.append(obj)\n            if not part1 or not part2:\n                continue\n            r1 = _minimize_questions(part1)\n            r2 = _minimize_questions(part2)\n            result = min(result, max(r1, r2) + 1)\n        fm[key] = result\n        return result\n    return _minimize_questions(objects_int)"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "result = min(result, max(r1, r2) + 1)",
      "mutated_line": "result = min(result, max(r1, r2) + 2)",
      "code": "def minimize_questions(features_count, objects):\n    objects_int = [int(obj, 2) for obj in objects]\n    max_object_value = max(objects_int)\n    mi = 0\n    while 2 ** mi <= max_object_value:\n        mi += 1\n    powers_of_2 = [2 ** i for i in range(mi + 1)]\n    fm = {}\n\n    def _minimize_questions(objects_int):\n        key = tuple(objects_int)\n        if key in fm:\n            return fm[key]\n        if len(objects_int) < 2:\n            fm[key] = 0\n            return 0\n        result = float('inf')\n        for power in powers_of_2:\n            part1 = []\n            part2 = []\n            for obj in objects_int:\n                if obj & power:\n                    part1.append(obj)\n                else:\n                    part2.append(obj)\n            if not part1 or not part2:\n                continue\n            r1 = _minimize_questions(part1)\n            r2 = _minimize_questions(part2)\n            result = min(result, max(r1, r2) + 2)\n        fm[key] = result\n        return result\n    return _minimize_questions(objects_int)"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "result = min(result, max(r1, r2) + 1)",
      "mutated_line": "result = min(result, max(r1, r2) + 0)",
      "code": "def minimize_questions(features_count, objects):\n    objects_int = [int(obj, 2) for obj in objects]\n    max_object_value = max(objects_int)\n    mi = 0\n    while 2 ** mi <= max_object_value:\n        mi += 1\n    powers_of_2 = [2 ** i for i in range(mi + 1)]\n    fm = {}\n\n    def _minimize_questions(objects_int):\n        key = tuple(objects_int)\n        if key in fm:\n            return fm[key]\n        if len(objects_int) < 2:\n            fm[key] = 0\n            return 0\n        result = float('inf')\n        for power in powers_of_2:\n            part1 = []\n            part2 = []\n            for obj in objects_int:\n                if obj & power:\n                    part1.append(obj)\n                else:\n                    part2.append(obj)\n            if not part1 or not part2:\n                continue\n            r1 = _minimize_questions(part1)\n            r2 = _minimize_questions(part2)\n            result = min(result, max(r1, r2) + 0)\n        fm[key] = result\n        return result\n    return _minimize_questions(objects_int)"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "result = min(result, max(r1, r2) + 1)",
      "mutated_line": "result = min(result, max(r1, r2) + 0)",
      "code": "def minimize_questions(features_count, objects):\n    objects_int = [int(obj, 2) for obj in objects]\n    max_object_value = max(objects_int)\n    mi = 0\n    while 2 ** mi <= max_object_value:\n        mi += 1\n    powers_of_2 = [2 ** i for i in range(mi + 1)]\n    fm = {}\n\n    def _minimize_questions(objects_int):\n        key = tuple(objects_int)\n        if key in fm:\n            return fm[key]\n        if len(objects_int) < 2:\n            fm[key] = 0\n            return 0\n        result = float('inf')\n        for power in powers_of_2:\n            part1 = []\n            part2 = []\n            for obj in objects_int:\n                if obj & power:\n                    part1.append(obj)\n                else:\n                    part2.append(obj)\n            if not part1 or not part2:\n                continue\n            r1 = _minimize_questions(part1)\n            r2 = _minimize_questions(part2)\n            result = min(result, max(r1, r2) + 0)\n        fm[key] = result\n        return result\n    return _minimize_questions(objects_int)"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "result = min(result, max(r1, r2) + 1)",
      "mutated_line": "result = min(result, max(r1, r2) + -1)",
      "code": "def minimize_questions(features_count, objects):\n    objects_int = [int(obj, 2) for obj in objects]\n    max_object_value = max(objects_int)\n    mi = 0\n    while 2 ** mi <= max_object_value:\n        mi += 1\n    powers_of_2 = [2 ** i for i in range(mi + 1)]\n    fm = {}\n\n    def _minimize_questions(objects_int):\n        key = tuple(objects_int)\n        if key in fm:\n            return fm[key]\n        if len(objects_int) < 2:\n            fm[key] = 0\n            return 0\n        result = float('inf')\n        for power in powers_of_2:\n            part1 = []\n            part2 = []\n            for obj in objects_int:\n                if obj & power:\n                    part1.append(obj)\n                else:\n                    part2.append(obj)\n            if not part1 or not part2:\n                continue\n            r1 = _minimize_questions(part1)\n            r2 = _minimize_questions(part2)\n            result = min(result, max(r1, r2) + -1)\n        fm[key] = result\n        return result\n    return _minimize_questions(objects_int)"
    }
  ]
}