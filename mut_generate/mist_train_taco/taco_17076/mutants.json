{
  "task_id": "taco_17076",
  "entry_point": "calculate_team_strength_difference",
  "mutant_count": 82,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mdl = 1000000",
      "mutated_line": "mdl = 1000001",
      "code": "def calculate_team_strength_difference(T, test_cases):\n    mdl = 1000001\n    results = []\n    for case in test_cases:\n        (n, a, b, c, d) = case\n        sqd = {}\n        sqd[d] = 0\n        r = d\n        for e in range(1, n):\n            r = ((a * r + b) * r + c) % mdl\n            try:\n                sqd[r] *= 1\n                break\n            except KeyError:\n                sqd[r] = e\n        if len(sqd) == n:\n            picks = list(sqd.keys())\n        else:\n            inrun = list(sqd.items())\n            inrun.sort(key=lambda x: x[1])\n            nunq = len(sqd)\n            repst = sqd[r]\n            picks = [inrun[e][0] for e in range(0, repst)]\n            reprun = [inrun[e][0] for e in range(repst, nunq)]\n            cyc = (n - len(picks)) // len(reprun)\n            runout = (n - len(picks)) % len(reprun)\n            if 0 == cyc % 2:\n                picks.extend(reprun[:runout])\n            else:\n                picks.extend(reprun[runout:])\n        picks.sort(reverse=True)\n        np = len(picks)\n        sth = sum(picks[0:np:2]) - sum(picks[1:np:2])\n        results.append(abs(sth))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mdl = 1000000",
      "mutated_line": "mdl = 999999",
      "code": "def calculate_team_strength_difference(T, test_cases):\n    mdl = 999999\n    results = []\n    for case in test_cases:\n        (n, a, b, c, d) = case\n        sqd = {}\n        sqd[d] = 0\n        r = d\n        for e in range(1, n):\n            r = ((a * r + b) * r + c) % mdl\n            try:\n                sqd[r] *= 1\n                break\n            except KeyError:\n                sqd[r] = e\n        if len(sqd) == n:\n            picks = list(sqd.keys())\n        else:\n            inrun = list(sqd.items())\n            inrun.sort(key=lambda x: x[1])\n            nunq = len(sqd)\n            repst = sqd[r]\n            picks = [inrun[e][0] for e in range(0, repst)]\n            reprun = [inrun[e][0] for e in range(repst, nunq)]\n            cyc = (n - len(picks)) // len(reprun)\n            runout = (n - len(picks)) % len(reprun)\n            if 0 == cyc % 2:\n                picks.extend(reprun[:runout])\n            else:\n                picks.extend(reprun[runout:])\n        picks.sort(reverse=True)\n        np = len(picks)\n        sth = sum(picks[0:np:2]) - sum(picks[1:np:2])\n        results.append(abs(sth))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mdl = 1000000",
      "mutated_line": "mdl = 0",
      "code": "def calculate_team_strength_difference(T, test_cases):\n    mdl = 0\n    results = []\n    for case in test_cases:\n        (n, a, b, c, d) = case\n        sqd = {}\n        sqd[d] = 0\n        r = d\n        for e in range(1, n):\n            r = ((a * r + b) * r + c) % mdl\n            try:\n                sqd[r] *= 1\n                break\n            except KeyError:\n                sqd[r] = e\n        if len(sqd) == n:\n            picks = list(sqd.keys())\n        else:\n            inrun = list(sqd.items())\n            inrun.sort(key=lambda x: x[1])\n            nunq = len(sqd)\n            repst = sqd[r]\n            picks = [inrun[e][0] for e in range(0, repst)]\n            reprun = [inrun[e][0] for e in range(repst, nunq)]\n            cyc = (n - len(picks)) // len(reprun)\n            runout = (n - len(picks)) % len(reprun)\n            if 0 == cyc % 2:\n                picks.extend(reprun[:runout])\n            else:\n                picks.extend(reprun[runout:])\n        picks.sort(reverse=True)\n        np = len(picks)\n        sth = sum(picks[0:np:2]) - sum(picks[1:np:2])\n        results.append(abs(sth))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mdl = 1000000",
      "mutated_line": "mdl = 1",
      "code": "def calculate_team_strength_difference(T, test_cases):\n    mdl = 1\n    results = []\n    for case in test_cases:\n        (n, a, b, c, d) = case\n        sqd = {}\n        sqd[d] = 0\n        r = d\n        for e in range(1, n):\n            r = ((a * r + b) * r + c) % mdl\n            try:\n                sqd[r] *= 1\n                break\n            except KeyError:\n                sqd[r] = e\n        if len(sqd) == n:\n            picks = list(sqd.keys())\n        else:\n            inrun = list(sqd.items())\n            inrun.sort(key=lambda x: x[1])\n            nunq = len(sqd)\n            repst = sqd[r]\n            picks = [inrun[e][0] for e in range(0, repst)]\n            reprun = [inrun[e][0] for e in range(repst, nunq)]\n            cyc = (n - len(picks)) // len(reprun)\n            runout = (n - len(picks)) % len(reprun)\n            if 0 == cyc % 2:\n                picks.extend(reprun[:runout])\n            else:\n                picks.extend(reprun[runout:])\n        picks.sort(reverse=True)\n        np = len(picks)\n        sth = sum(picks[0:np:2]) - sum(picks[1:np:2])\n        results.append(abs(sth))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mdl = 1000000",
      "mutated_line": "mdl = -1000000",
      "code": "def calculate_team_strength_difference(T, test_cases):\n    mdl = -1000000\n    results = []\n    for case in test_cases:\n        (n, a, b, c, d) = case\n        sqd = {}\n        sqd[d] = 0\n        r = d\n        for e in range(1, n):\n            r = ((a * r + b) * r + c) % mdl\n            try:\n                sqd[r] *= 1\n                break\n            except KeyError:\n                sqd[r] = e\n        if len(sqd) == n:\n            picks = list(sqd.keys())\n        else:\n            inrun = list(sqd.items())\n            inrun.sort(key=lambda x: x[1])\n            nunq = len(sqd)\n            repst = sqd[r]\n            picks = [inrun[e][0] for e in range(0, repst)]\n            reprun = [inrun[e][0] for e in range(repst, nunq)]\n            cyc = (n - len(picks)) // len(reprun)\n            runout = (n - len(picks)) % len(reprun)\n            if 0 == cyc % 2:\n                picks.extend(reprun[:runout])\n            else:\n                picks.extend(reprun[runout:])\n        picks.sort(reverse=True)\n        np = len(picks)\n        sth = sum(picks[0:np:2]) - sum(picks[1:np:2])\n        results.append(abs(sth))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "sqd[d] = 0",
      "mutated_line": "sqd[d] = 1",
      "code": "def calculate_team_strength_difference(T, test_cases):\n    mdl = 1000000\n    results = []\n    for case in test_cases:\n        (n, a, b, c, d) = case\n        sqd = {}\n        sqd[d] = 1\n        r = d\n        for e in range(1, n):\n            r = ((a * r + b) * r + c) % mdl\n            try:\n                sqd[r] *= 1\n                break\n            except KeyError:\n                sqd[r] = e\n        if len(sqd) == n:\n            picks = list(sqd.keys())\n        else:\n            inrun = list(sqd.items())\n            inrun.sort(key=lambda x: x[1])\n            nunq = len(sqd)\n            repst = sqd[r]\n            picks = [inrun[e][0] for e in range(0, repst)]\n            reprun = [inrun[e][0] for e in range(repst, nunq)]\n            cyc = (n - len(picks)) // len(reprun)\n            runout = (n - len(picks)) % len(reprun)\n            if 0 == cyc % 2:\n                picks.extend(reprun[:runout])\n            else:\n                picks.extend(reprun[runout:])\n        picks.sort(reverse=True)\n        np = len(picks)\n        sth = sum(picks[0:np:2]) - sum(picks[1:np:2])\n        results.append(abs(sth))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "sqd[d] = 0",
      "mutated_line": "sqd[d] = -1",
      "code": "def calculate_team_strength_difference(T, test_cases):\n    mdl = 1000000\n    results = []\n    for case in test_cases:\n        (n, a, b, c, d) = case\n        sqd = {}\n        sqd[d] = -1\n        r = d\n        for e in range(1, n):\n            r = ((a * r + b) * r + c) % mdl\n            try:\n                sqd[r] *= 1\n                break\n            except KeyError:\n                sqd[r] = e\n        if len(sqd) == n:\n            picks = list(sqd.keys())\n        else:\n            inrun = list(sqd.items())\n            inrun.sort(key=lambda x: x[1])\n            nunq = len(sqd)\n            repst = sqd[r]\n            picks = [inrun[e][0] for e in range(0, repst)]\n            reprun = [inrun[e][0] for e in range(repst, nunq)]\n            cyc = (n - len(picks)) // len(reprun)\n            runout = (n - len(picks)) % len(reprun)\n            if 0 == cyc % 2:\n                picks.extend(reprun[:runout])\n            else:\n                picks.extend(reprun[runout:])\n        picks.sort(reverse=True)\n        np = len(picks)\n        sth = sum(picks[0:np:2]) - sum(picks[1:np:2])\n        results.append(abs(sth))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "sqd[d] = 0",
      "mutated_line": "sqd[d] = 1",
      "code": "def calculate_team_strength_difference(T, test_cases):\n    mdl = 1000000\n    results = []\n    for case in test_cases:\n        (n, a, b, c, d) = case\n        sqd = {}\n        sqd[d] = 1\n        r = d\n        for e in range(1, n):\n            r = ((a * r + b) * r + c) % mdl\n            try:\n                sqd[r] *= 1\n                break\n            except KeyError:\n                sqd[r] = e\n        if len(sqd) == n:\n            picks = list(sqd.keys())\n        else:\n            inrun = list(sqd.items())\n            inrun.sort(key=lambda x: x[1])\n            nunq = len(sqd)\n            repst = sqd[r]\n            picks = [inrun[e][0] for e in range(0, repst)]\n            reprun = [inrun[e][0] for e in range(repst, nunq)]\n            cyc = (n - len(picks)) // len(reprun)\n            runout = (n - len(picks)) % len(reprun)\n            if 0 == cyc % 2:\n                picks.extend(reprun[:runout])\n            else:\n                picks.extend(reprun[runout:])\n        picks.sort(reverse=True)\n        np = len(picks)\n        sth = sum(picks[0:np:2]) - sum(picks[1:np:2])\n        results.append(abs(sth))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if len(sqd) == n:",
      "mutated_line": "if len(sqd) != n:",
      "code": "def calculate_team_strength_difference(T, test_cases):\n    mdl = 1000000\n    results = []\n    for case in test_cases:\n        (n, a, b, c, d) = case\n        sqd = {}\n        sqd[d] = 0\n        r = d\n        for e in range(1, n):\n            r = ((a * r + b) * r + c) % mdl\n            try:\n                sqd[r] *= 1\n                break\n            except KeyError:\n                sqd[r] = e\n        if len(sqd) != n:\n            picks = list(sqd.keys())\n        else:\n            inrun = list(sqd.items())\n            inrun.sort(key=lambda x: x[1])\n            nunq = len(sqd)\n            repst = sqd[r]\n            picks = [inrun[e][0] for e in range(0, repst)]\n            reprun = [inrun[e][0] for e in range(repst, nunq)]\n            cyc = (n - len(picks)) // len(reprun)\n            runout = (n - len(picks)) % len(reprun)\n            if 0 == cyc % 2:\n                picks.extend(reprun[:runout])\n            else:\n                picks.extend(reprun[runout:])\n        picks.sort(reverse=True)\n        np = len(picks)\n        sth = sum(picks[0:np:2]) - sum(picks[1:np:2])\n        results.append(abs(sth))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "sth = sum(picks[0:np:2]) - sum(picks[1:np:2])",
      "mutated_line": "sth = sum(picks[0:np:2]) + sum(picks[1:np:2])",
      "code": "def calculate_team_strength_difference(T, test_cases):\n    mdl = 1000000\n    results = []\n    for case in test_cases:\n        (n, a, b, c, d) = case\n        sqd = {}\n        sqd[d] = 0\n        r = d\n        for e in range(1, n):\n            r = ((a * r + b) * r + c) % mdl\n            try:\n                sqd[r] *= 1\n                break\n            except KeyError:\n                sqd[r] = e\n        if len(sqd) == n:\n            picks = list(sqd.keys())\n        else:\n            inrun = list(sqd.items())\n            inrun.sort(key=lambda x: x[1])\n            nunq = len(sqd)\n            repst = sqd[r]\n            picks = [inrun[e][0] for e in range(0, repst)]\n            reprun = [inrun[e][0] for e in range(repst, nunq)]\n            cyc = (n - len(picks)) // len(reprun)\n            runout = (n - len(picks)) % len(reprun)\n            if 0 == cyc % 2:\n                picks.extend(reprun[:runout])\n            else:\n                picks.extend(reprun[runout:])\n        picks.sort(reverse=True)\n        np = len(picks)\n        sth = sum(picks[0:np:2]) + sum(picks[1:np:2])\n        results.append(abs(sth))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "sth = sum(picks[0:np:2]) - sum(picks[1:np:2])",
      "mutated_line": "sth = sum(picks[0:np:2]) * sum(picks[1:np:2])",
      "code": "def calculate_team_strength_difference(T, test_cases):\n    mdl = 1000000\n    results = []\n    for case in test_cases:\n        (n, a, b, c, d) = case\n        sqd = {}\n        sqd[d] = 0\n        r = d\n        for e in range(1, n):\n            r = ((a * r + b) * r + c) % mdl\n            try:\n                sqd[r] *= 1\n                break\n            except KeyError:\n                sqd[r] = e\n        if len(sqd) == n:\n            picks = list(sqd.keys())\n        else:\n            inrun = list(sqd.items())\n            inrun.sort(key=lambda x: x[1])\n            nunq = len(sqd)\n            repst = sqd[r]\n            picks = [inrun[e][0] for e in range(0, repst)]\n            reprun = [inrun[e][0] for e in range(repst, nunq)]\n            cyc = (n - len(picks)) // len(reprun)\n            runout = (n - len(picks)) % len(reprun)\n            if 0 == cyc % 2:\n                picks.extend(reprun[:runout])\n            else:\n                picks.extend(reprun[runout:])\n        picks.sort(reverse=True)\n        np = len(picks)\n        sth = sum(picks[0:np:2]) * sum(picks[1:np:2])\n        results.append(abs(sth))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for e in range(1, n):",
      "mutated_line": "for e in range(2, n):",
      "code": "def calculate_team_strength_difference(T, test_cases):\n    mdl = 1000000\n    results = []\n    for case in test_cases:\n        (n, a, b, c, d) = case\n        sqd = {}\n        sqd[d] = 0\n        r = d\n        for e in range(2, n):\n            r = ((a * r + b) * r + c) % mdl\n            try:\n                sqd[r] *= 1\n                break\n            except KeyError:\n                sqd[r] = e\n        if len(sqd) == n:\n            picks = list(sqd.keys())\n        else:\n            inrun = list(sqd.items())\n            inrun.sort(key=lambda x: x[1])\n            nunq = len(sqd)\n            repst = sqd[r]\n            picks = [inrun[e][0] for e in range(0, repst)]\n            reprun = [inrun[e][0] for e in range(repst, nunq)]\n            cyc = (n - len(picks)) // len(reprun)\n            runout = (n - len(picks)) % len(reprun)\n            if 0 == cyc % 2:\n                picks.extend(reprun[:runout])\n            else:\n                picks.extend(reprun[runout:])\n        picks.sort(reverse=True)\n        np = len(picks)\n        sth = sum(picks[0:np:2]) - sum(picks[1:np:2])\n        results.append(abs(sth))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for e in range(1, n):",
      "mutated_line": "for e in range(0, n):",
      "code": "def calculate_team_strength_difference(T, test_cases):\n    mdl = 1000000\n    results = []\n    for case in test_cases:\n        (n, a, b, c, d) = case\n        sqd = {}\n        sqd[d] = 0\n        r = d\n        for e in range(0, n):\n            r = ((a * r + b) * r + c) % mdl\n            try:\n                sqd[r] *= 1\n                break\n            except KeyError:\n                sqd[r] = e\n        if len(sqd) == n:\n            picks = list(sqd.keys())\n        else:\n            inrun = list(sqd.items())\n            inrun.sort(key=lambda x: x[1])\n            nunq = len(sqd)\n            repst = sqd[r]\n            picks = [inrun[e][0] for e in range(0, repst)]\n            reprun = [inrun[e][0] for e in range(repst, nunq)]\n            cyc = (n - len(picks)) // len(reprun)\n            runout = (n - len(picks)) % len(reprun)\n            if 0 == cyc % 2:\n                picks.extend(reprun[:runout])\n            else:\n                picks.extend(reprun[runout:])\n        picks.sort(reverse=True)\n        np = len(picks)\n        sth = sum(picks[0:np:2]) - sum(picks[1:np:2])\n        results.append(abs(sth))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for e in range(1, n):",
      "mutated_line": "for e in range(0, n):",
      "code": "def calculate_team_strength_difference(T, test_cases):\n    mdl = 1000000\n    results = []\n    for case in test_cases:\n        (n, a, b, c, d) = case\n        sqd = {}\n        sqd[d] = 0\n        r = d\n        for e in range(0, n):\n            r = ((a * r + b) * r + c) % mdl\n            try:\n                sqd[r] *= 1\n                break\n            except KeyError:\n                sqd[r] = e\n        if len(sqd) == n:\n            picks = list(sqd.keys())\n        else:\n            inrun = list(sqd.items())\n            inrun.sort(key=lambda x: x[1])\n            nunq = len(sqd)\n            repst = sqd[r]\n            picks = [inrun[e][0] for e in range(0, repst)]\n            reprun = [inrun[e][0] for e in range(repst, nunq)]\n            cyc = (n - len(picks)) // len(reprun)\n            runout = (n - len(picks)) % len(reprun)\n            if 0 == cyc % 2:\n                picks.extend(reprun[:runout])\n            else:\n                picks.extend(reprun[runout:])\n        picks.sort(reverse=True)\n        np = len(picks)\n        sth = sum(picks[0:np:2]) - sum(picks[1:np:2])\n        results.append(abs(sth))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for e in range(1, n):",
      "mutated_line": "for e in range(-1, n):",
      "code": "def calculate_team_strength_difference(T, test_cases):\n    mdl = 1000000\n    results = []\n    for case in test_cases:\n        (n, a, b, c, d) = case\n        sqd = {}\n        sqd[d] = 0\n        r = d\n        for e in range(-1, n):\n            r = ((a * r + b) * r + c) % mdl\n            try:\n                sqd[r] *= 1\n                break\n            except KeyError:\n                sqd[r] = e\n        if len(sqd) == n:\n            picks = list(sqd.keys())\n        else:\n            inrun = list(sqd.items())\n            inrun.sort(key=lambda x: x[1])\n            nunq = len(sqd)\n            repst = sqd[r]\n            picks = [inrun[e][0] for e in range(0, repst)]\n            reprun = [inrun[e][0] for e in range(repst, nunq)]\n            cyc = (n - len(picks)) // len(reprun)\n            runout = (n - len(picks)) % len(reprun)\n            if 0 == cyc % 2:\n                picks.extend(reprun[:runout])\n            else:\n                picks.extend(reprun[runout:])\n        picks.sort(reverse=True)\n        np = len(picks)\n        sth = sum(picks[0:np:2]) - sum(picks[1:np:2])\n        results.append(abs(sth))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "r = ((a * r + b) * r + c) % mdl",
      "mutated_line": "r = ((a * r + b) * r + c) * mdl",
      "code": "def calculate_team_strength_difference(T, test_cases):\n    mdl = 1000000\n    results = []\n    for case in test_cases:\n        (n, a, b, c, d) = case\n        sqd = {}\n        sqd[d] = 0\n        r = d\n        for e in range(1, n):\n            r = ((a * r + b) * r + c) * mdl\n            try:\n                sqd[r] *= 1\n                break\n            except KeyError:\n                sqd[r] = e\n        if len(sqd) == n:\n            picks = list(sqd.keys())\n        else:\n            inrun = list(sqd.items())\n            inrun.sort(key=lambda x: x[1])\n            nunq = len(sqd)\n            repst = sqd[r]\n            picks = [inrun[e][0] for e in range(0, repst)]\n            reprun = [inrun[e][0] for e in range(repst, nunq)]\n            cyc = (n - len(picks)) // len(reprun)\n            runout = (n - len(picks)) % len(reprun)\n            if 0 == cyc % 2:\n                picks.extend(reprun[:runout])\n            else:\n                picks.extend(reprun[runout:])\n        picks.sort(reverse=True)\n        np = len(picks)\n        sth = sum(picks[0:np:2]) - sum(picks[1:np:2])\n        results.append(abs(sth))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "r = ((a * r + b) * r + c) % mdl",
      "mutated_line": "r = (a * r + b) * r + c + mdl",
      "code": "def calculate_team_strength_difference(T, test_cases):\n    mdl = 1000000\n    results = []\n    for case in test_cases:\n        (n, a, b, c, d) = case\n        sqd = {}\n        sqd[d] = 0\n        r = d\n        for e in range(1, n):\n            r = (a * r + b) * r + c + mdl\n            try:\n                sqd[r] *= 1\n                break\n            except KeyError:\n                sqd[r] = e\n        if len(sqd) == n:\n            picks = list(sqd.keys())\n        else:\n            inrun = list(sqd.items())\n            inrun.sort(key=lambda x: x[1])\n            nunq = len(sqd)\n            repst = sqd[r]\n            picks = [inrun[e][0] for e in range(0, repst)]\n            reprun = [inrun[e][0] for e in range(repst, nunq)]\n            cyc = (n - len(picks)) // len(reprun)\n            runout = (n - len(picks)) % len(reprun)\n            if 0 == cyc % 2:\n                picks.extend(reprun[:runout])\n            else:\n                picks.extend(reprun[runout:])\n        picks.sort(reverse=True)\n        np = len(picks)\n        sth = sum(picks[0:np:2]) - sum(picks[1:np:2])\n        results.append(abs(sth))\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 14,
      "original_line": "sqd[r] *= 1",
      "mutated_line": "sqd[r] /= 1",
      "code": "def calculate_team_strength_difference(T, test_cases):\n    mdl = 1000000\n    results = []\n    for case in test_cases:\n        (n, a, b, c, d) = case\n        sqd = {}\n        sqd[d] = 0\n        r = d\n        for e in range(1, n):\n            r = ((a * r + b) * r + c) % mdl\n            try:\n                sqd[r] /= 1\n                break\n            except KeyError:\n                sqd[r] = e\n        if len(sqd) == n:\n            picks = list(sqd.keys())\n        else:\n            inrun = list(sqd.items())\n            inrun.sort(key=lambda x: x[1])\n            nunq = len(sqd)\n            repst = sqd[r]\n            picks = [inrun[e][0] for e in range(0, repst)]\n            reprun = [inrun[e][0] for e in range(repst, nunq)]\n            cyc = (n - len(picks)) // len(reprun)\n            runout = (n - len(picks)) % len(reprun)\n            if 0 == cyc % 2:\n                picks.extend(reprun[:runout])\n            else:\n                picks.extend(reprun[runout:])\n        picks.sort(reverse=True)\n        np = len(picks)\n        sth = sum(picks[0:np:2]) - sum(picks[1:np:2])\n        results.append(abs(sth))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "cyc = (n - len(picks)) // len(reprun)",
      "mutated_line": "cyc = (n - len(picks)) / len(reprun)",
      "code": "def calculate_team_strength_difference(T, test_cases):\n    mdl = 1000000\n    results = []\n    for case in test_cases:\n        (n, a, b, c, d) = case\n        sqd = {}\n        sqd[d] = 0\n        r = d\n        for e in range(1, n):\n            r = ((a * r + b) * r + c) % mdl\n            try:\n                sqd[r] *= 1\n                break\n            except KeyError:\n                sqd[r] = e\n        if len(sqd) == n:\n            picks = list(sqd.keys())\n        else:\n            inrun = list(sqd.items())\n            inrun.sort(key=lambda x: x[1])\n            nunq = len(sqd)\n            repst = sqd[r]\n            picks = [inrun[e][0] for e in range(0, repst)]\n            reprun = [inrun[e][0] for e in range(repst, nunq)]\n            cyc = (n - len(picks)) / len(reprun)\n            runout = (n - len(picks)) % len(reprun)\n            if 0 == cyc % 2:\n                picks.extend(reprun[:runout])\n            else:\n                picks.extend(reprun[runout:])\n        picks.sort(reverse=True)\n        np = len(picks)\n        sth = sum(picks[0:np:2]) - sum(picks[1:np:2])\n        results.append(abs(sth))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "cyc = (n - len(picks)) // len(reprun)",
      "mutated_line": "cyc = (n - len(picks)) * len(reprun)",
      "code": "def calculate_team_strength_difference(T, test_cases):\n    mdl = 1000000\n    results = []\n    for case in test_cases:\n        (n, a, b, c, d) = case\n        sqd = {}\n        sqd[d] = 0\n        r = d\n        for e in range(1, n):\n            r = ((a * r + b) * r + c) % mdl\n            try:\n                sqd[r] *= 1\n                break\n            except KeyError:\n                sqd[r] = e\n        if len(sqd) == n:\n            picks = list(sqd.keys())\n        else:\n            inrun = list(sqd.items())\n            inrun.sort(key=lambda x: x[1])\n            nunq = len(sqd)\n            repst = sqd[r]\n            picks = [inrun[e][0] for e in range(0, repst)]\n            reprun = [inrun[e][0] for e in range(repst, nunq)]\n            cyc = (n - len(picks)) * len(reprun)\n            runout = (n - len(picks)) % len(reprun)\n            if 0 == cyc % 2:\n                picks.extend(reprun[:runout])\n            else:\n                picks.extend(reprun[runout:])\n        picks.sort(reverse=True)\n        np = len(picks)\n        sth = sum(picks[0:np:2]) - sum(picks[1:np:2])\n        results.append(abs(sth))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "runout = (n - len(picks)) % len(reprun)",
      "mutated_line": "runout = (n - len(picks)) * len(reprun)",
      "code": "def calculate_team_strength_difference(T, test_cases):\n    mdl = 1000000\n    results = []\n    for case in test_cases:\n        (n, a, b, c, d) = case\n        sqd = {}\n        sqd[d] = 0\n        r = d\n        for e in range(1, n):\n            r = ((a * r + b) * r + c) % mdl\n            try:\n                sqd[r] *= 1\n                break\n            except KeyError:\n                sqd[r] = e\n        if len(sqd) == n:\n            picks = list(sqd.keys())\n        else:\n            inrun = list(sqd.items())\n            inrun.sort(key=lambda x: x[1])\n            nunq = len(sqd)\n            repst = sqd[r]\n            picks = [inrun[e][0] for e in range(0, repst)]\n            reprun = [inrun[e][0] for e in range(repst, nunq)]\n            cyc = (n - len(picks)) // len(reprun)\n            runout = (n - len(picks)) * len(reprun)\n            if 0 == cyc % 2:\n                picks.extend(reprun[:runout])\n            else:\n                picks.extend(reprun[runout:])\n        picks.sort(reverse=True)\n        np = len(picks)\n        sth = sum(picks[0:np:2]) - sum(picks[1:np:2])\n        results.append(abs(sth))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "runout = (n - len(picks)) % len(reprun)",
      "mutated_line": "runout = n - len(picks) + len(reprun)",
      "code": "def calculate_team_strength_difference(T, test_cases):\n    mdl = 1000000\n    results = []\n    for case in test_cases:\n        (n, a, b, c, d) = case\n        sqd = {}\n        sqd[d] = 0\n        r = d\n        for e in range(1, n):\n            r = ((a * r + b) * r + c) % mdl\n            try:\n                sqd[r] *= 1\n                break\n            except KeyError:\n                sqd[r] = e\n        if len(sqd) == n:\n            picks = list(sqd.keys())\n        else:\n            inrun = list(sqd.items())\n            inrun.sort(key=lambda x: x[1])\n            nunq = len(sqd)\n            repst = sqd[r]\n            picks = [inrun[e][0] for e in range(0, repst)]\n            reprun = [inrun[e][0] for e in range(repst, nunq)]\n            cyc = (n - len(picks)) // len(reprun)\n            runout = n - len(picks) + len(reprun)\n            if 0 == cyc % 2:\n                picks.extend(reprun[:runout])\n            else:\n                picks.extend(reprun[runout:])\n        picks.sort(reverse=True)\n        np = len(picks)\n        sth = sum(picks[0:np:2]) - sum(picks[1:np:2])\n        results.append(abs(sth))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if 0 == cyc % 2:",
      "mutated_line": "if 0 != cyc % 2:",
      "code": "def calculate_team_strength_difference(T, test_cases):\n    mdl = 1000000\n    results = []\n    for case in test_cases:\n        (n, a, b, c, d) = case\n        sqd = {}\n        sqd[d] = 0\n        r = d\n        for e in range(1, n):\n            r = ((a * r + b) * r + c) % mdl\n            try:\n                sqd[r] *= 1\n                break\n            except KeyError:\n                sqd[r] = e\n        if len(sqd) == n:\n            picks = list(sqd.keys())\n        else:\n            inrun = list(sqd.items())\n            inrun.sort(key=lambda x: x[1])\n            nunq = len(sqd)\n            repst = sqd[r]\n            picks = [inrun[e][0] for e in range(0, repst)]\n            reprun = [inrun[e][0] for e in range(repst, nunq)]\n            cyc = (n - len(picks)) // len(reprun)\n            runout = (n - len(picks)) % len(reprun)\n            if 0 != cyc % 2:\n                picks.extend(reprun[:runout])\n            else:\n                picks.extend(reprun[runout:])\n        picks.sort(reverse=True)\n        np = len(picks)\n        sth = sum(picks[0:np:2]) - sum(picks[1:np:2])\n        results.append(abs(sth))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "r = ((a * r + b) * r + c) % mdl",
      "mutated_line": "r = ((a * r + b) * r - c) % mdl",
      "code": "def calculate_team_strength_difference(T, test_cases):\n    mdl = 1000000\n    results = []\n    for case in test_cases:\n        (n, a, b, c, d) = case\n        sqd = {}\n        sqd[d] = 0\n        r = d\n        for e in range(1, n):\n            r = ((a * r + b) * r - c) % mdl\n            try:\n                sqd[r] *= 1\n                break\n            except KeyError:\n                sqd[r] = e\n        if len(sqd) == n:\n            picks = list(sqd.keys())\n        else:\n            inrun = list(sqd.items())\n            inrun.sort(key=lambda x: x[1])\n            nunq = len(sqd)\n            repst = sqd[r]\n            picks = [inrun[e][0] for e in range(0, repst)]\n            reprun = [inrun[e][0] for e in range(repst, nunq)]\n            cyc = (n - len(picks)) // len(reprun)\n            runout = (n - len(picks)) % len(reprun)\n            if 0 == cyc % 2:\n                picks.extend(reprun[:runout])\n            else:\n                picks.extend(reprun[runout:])\n        picks.sort(reverse=True)\n        np = len(picks)\n        sth = sum(picks[0:np:2]) - sum(picks[1:np:2])\n        results.append(abs(sth))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "r = ((a * r + b) * r + c) % mdl",
      "mutated_line": "r = (a * r + b) * r * c % mdl",
      "code": "def calculate_team_strength_difference(T, test_cases):\n    mdl = 1000000\n    results = []\n    for case in test_cases:\n        (n, a, b, c, d) = case\n        sqd = {}\n        sqd[d] = 0\n        r = d\n        for e in range(1, n):\n            r = (a * r + b) * r * c % mdl\n            try:\n                sqd[r] *= 1\n                break\n            except KeyError:\n                sqd[r] = e\n        if len(sqd) == n:\n            picks = list(sqd.keys())\n        else:\n            inrun = list(sqd.items())\n            inrun.sort(key=lambda x: x[1])\n            nunq = len(sqd)\n            repst = sqd[r]\n            picks = [inrun[e][0] for e in range(0, repst)]\n            reprun = [inrun[e][0] for e in range(repst, nunq)]\n            cyc = (n - len(picks)) // len(reprun)\n            runout = (n - len(picks)) % len(reprun)\n            if 0 == cyc % 2:\n                picks.extend(reprun[:runout])\n            else:\n                picks.extend(reprun[runout:])\n        picks.sort(reverse=True)\n        np = len(picks)\n        sth = sum(picks[0:np:2]) - sum(picks[1:np:2])\n        results.append(abs(sth))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "sqd[r] *= 1",
      "mutated_line": "sqd[r] *= 2",
      "code": "def calculate_team_strength_difference(T, test_cases):\n    mdl = 1000000\n    results = []\n    for case in test_cases:\n        (n, a, b, c, d) = case\n        sqd = {}\n        sqd[d] = 0\n        r = d\n        for e in range(1, n):\n            r = ((a * r + b) * r + c) % mdl\n            try:\n                sqd[r] *= 2\n                break\n            except KeyError:\n                sqd[r] = e\n        if len(sqd) == n:\n            picks = list(sqd.keys())\n        else:\n            inrun = list(sqd.items())\n            inrun.sort(key=lambda x: x[1])\n            nunq = len(sqd)\n            repst = sqd[r]\n            picks = [inrun[e][0] for e in range(0, repst)]\n            reprun = [inrun[e][0] for e in range(repst, nunq)]\n            cyc = (n - len(picks)) // len(reprun)\n            runout = (n - len(picks)) % len(reprun)\n            if 0 == cyc % 2:\n                picks.extend(reprun[:runout])\n            else:\n                picks.extend(reprun[runout:])\n        picks.sort(reverse=True)\n        np = len(picks)\n        sth = sum(picks[0:np:2]) - sum(picks[1:np:2])\n        results.append(abs(sth))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "sqd[r] *= 1",
      "mutated_line": "sqd[r] *= 0",
      "code": "def calculate_team_strength_difference(T, test_cases):\n    mdl = 1000000\n    results = []\n    for case in test_cases:\n        (n, a, b, c, d) = case\n        sqd = {}\n        sqd[d] = 0\n        r = d\n        for e in range(1, n):\n            r = ((a * r + b) * r + c) % mdl\n            try:\n                sqd[r] *= 0\n                break\n            except KeyError:\n                sqd[r] = e\n        if len(sqd) == n:\n            picks = list(sqd.keys())\n        else:\n            inrun = list(sqd.items())\n            inrun.sort(key=lambda x: x[1])\n            nunq = len(sqd)\n            repst = sqd[r]\n            picks = [inrun[e][0] for e in range(0, repst)]\n            reprun = [inrun[e][0] for e in range(repst, nunq)]\n            cyc = (n - len(picks)) // len(reprun)\n            runout = (n - len(picks)) % len(reprun)\n            if 0 == cyc % 2:\n                picks.extend(reprun[:runout])\n            else:\n                picks.extend(reprun[runout:])\n        picks.sort(reverse=True)\n        np = len(picks)\n        sth = sum(picks[0:np:2]) - sum(picks[1:np:2])\n        results.append(abs(sth))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "sqd[r] *= 1",
      "mutated_line": "sqd[r] *= 0",
      "code": "def calculate_team_strength_difference(T, test_cases):\n    mdl = 1000000\n    results = []\n    for case in test_cases:\n        (n, a, b, c, d) = case\n        sqd = {}\n        sqd[d] = 0\n        r = d\n        for e in range(1, n):\n            r = ((a * r + b) * r + c) % mdl\n            try:\n                sqd[r] *= 0\n                break\n            except KeyError:\n                sqd[r] = e\n        if len(sqd) == n:\n            picks = list(sqd.keys())\n        else:\n            inrun = list(sqd.items())\n            inrun.sort(key=lambda x: x[1])\n            nunq = len(sqd)\n            repst = sqd[r]\n            picks = [inrun[e][0] for e in range(0, repst)]\n            reprun = [inrun[e][0] for e in range(repst, nunq)]\n            cyc = (n - len(picks)) // len(reprun)\n            runout = (n - len(picks)) % len(reprun)\n            if 0 == cyc % 2:\n                picks.extend(reprun[:runout])\n            else:\n                picks.extend(reprun[runout:])\n        picks.sort(reverse=True)\n        np = len(picks)\n        sth = sum(picks[0:np:2]) - sum(picks[1:np:2])\n        results.append(abs(sth))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "sqd[r] *= 1",
      "mutated_line": "sqd[r] *= -1",
      "code": "def calculate_team_strength_difference(T, test_cases):\n    mdl = 1000000\n    results = []\n    for case in test_cases:\n        (n, a, b, c, d) = case\n        sqd = {}\n        sqd[d] = 0\n        r = d\n        for e in range(1, n):\n            r = ((a * r + b) * r + c) % mdl\n            try:\n                sqd[r] *= -1\n                break\n            except KeyError:\n                sqd[r] = e\n        if len(sqd) == n:\n            picks = list(sqd.keys())\n        else:\n            inrun = list(sqd.items())\n            inrun.sort(key=lambda x: x[1])\n            nunq = len(sqd)\n            repst = sqd[r]\n            picks = [inrun[e][0] for e in range(0, repst)]\n            reprun = [inrun[e][0] for e in range(repst, nunq)]\n            cyc = (n - len(picks)) // len(reprun)\n            runout = (n - len(picks)) % len(reprun)\n            if 0 == cyc % 2:\n                picks.extend(reprun[:runout])\n            else:\n                picks.extend(reprun[runout:])\n        picks.sort(reverse=True)\n        np = len(picks)\n        sth = sum(picks[0:np:2]) - sum(picks[1:np:2])\n        results.append(abs(sth))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "cyc = (n - len(picks)) // len(reprun)",
      "mutated_line": "cyc = (n + len(picks)) // len(reprun)",
      "code": "def calculate_team_strength_difference(T, test_cases):\n    mdl = 1000000\n    results = []\n    for case in test_cases:\n        (n, a, b, c, d) = case\n        sqd = {}\n        sqd[d] = 0\n        r = d\n        for e in range(1, n):\n            r = ((a * r + b) * r + c) % mdl\n            try:\n                sqd[r] *= 1\n                break\n            except KeyError:\n                sqd[r] = e\n        if len(sqd) == n:\n            picks = list(sqd.keys())\n        else:\n            inrun = list(sqd.items())\n            inrun.sort(key=lambda x: x[1])\n            nunq = len(sqd)\n            repst = sqd[r]\n            picks = [inrun[e][0] for e in range(0, repst)]\n            reprun = [inrun[e][0] for e in range(repst, nunq)]\n            cyc = (n + len(picks)) // len(reprun)\n            runout = (n - len(picks)) % len(reprun)\n            if 0 == cyc % 2:\n                picks.extend(reprun[:runout])\n            else:\n                picks.extend(reprun[runout:])\n        picks.sort(reverse=True)\n        np = len(picks)\n        sth = sum(picks[0:np:2]) - sum(picks[1:np:2])\n        results.append(abs(sth))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "cyc = (n - len(picks)) // len(reprun)",
      "mutated_line": "cyc = n * len(picks) // len(reprun)",
      "code": "def calculate_team_strength_difference(T, test_cases):\n    mdl = 1000000\n    results = []\n    for case in test_cases:\n        (n, a, b, c, d) = case\n        sqd = {}\n        sqd[d] = 0\n        r = d\n        for e in range(1, n):\n            r = ((a * r + b) * r + c) % mdl\n            try:\n                sqd[r] *= 1\n                break\n            except KeyError:\n                sqd[r] = e\n        if len(sqd) == n:\n            picks = list(sqd.keys())\n        else:\n            inrun = list(sqd.items())\n            inrun.sort(key=lambda x: x[1])\n            nunq = len(sqd)\n            repst = sqd[r]\n            picks = [inrun[e][0] for e in range(0, repst)]\n            reprun = [inrun[e][0] for e in range(repst, nunq)]\n            cyc = n * len(picks) // len(reprun)\n            runout = (n - len(picks)) % len(reprun)\n            if 0 == cyc % 2:\n                picks.extend(reprun[:runout])\n            else:\n                picks.extend(reprun[runout:])\n        picks.sort(reverse=True)\n        np = len(picks)\n        sth = sum(picks[0:np:2]) - sum(picks[1:np:2])\n        results.append(abs(sth))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "runout = (n - len(picks)) % len(reprun)",
      "mutated_line": "runout = (n + len(picks)) % len(reprun)",
      "code": "def calculate_team_strength_difference(T, test_cases):\n    mdl = 1000000\n    results = []\n    for case in test_cases:\n        (n, a, b, c, d) = case\n        sqd = {}\n        sqd[d] = 0\n        r = d\n        for e in range(1, n):\n            r = ((a * r + b) * r + c) % mdl\n            try:\n                sqd[r] *= 1\n                break\n            except KeyError:\n                sqd[r] = e\n        if len(sqd) == n:\n            picks = list(sqd.keys())\n        else:\n            inrun = list(sqd.items())\n            inrun.sort(key=lambda x: x[1])\n            nunq = len(sqd)\n            repst = sqd[r]\n            picks = [inrun[e][0] for e in range(0, repst)]\n            reprun = [inrun[e][0] for e in range(repst, nunq)]\n            cyc = (n - len(picks)) // len(reprun)\n            runout = (n + len(picks)) % len(reprun)\n            if 0 == cyc % 2:\n                picks.extend(reprun[:runout])\n            else:\n                picks.extend(reprun[runout:])\n        picks.sort(reverse=True)\n        np = len(picks)\n        sth = sum(picks[0:np:2]) - sum(picks[1:np:2])\n        results.append(abs(sth))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "runout = (n - len(picks)) % len(reprun)",
      "mutated_line": "runout = n * len(picks) % len(reprun)",
      "code": "def calculate_team_strength_difference(T, test_cases):\n    mdl = 1000000\n    results = []\n    for case in test_cases:\n        (n, a, b, c, d) = case\n        sqd = {}\n        sqd[d] = 0\n        r = d\n        for e in range(1, n):\n            r = ((a * r + b) * r + c) % mdl\n            try:\n                sqd[r] *= 1\n                break\n            except KeyError:\n                sqd[r] = e\n        if len(sqd) == n:\n            picks = list(sqd.keys())\n        else:\n            inrun = list(sqd.items())\n            inrun.sort(key=lambda x: x[1])\n            nunq = len(sqd)\n            repst = sqd[r]\n            picks = [inrun[e][0] for e in range(0, repst)]\n            reprun = [inrun[e][0] for e in range(repst, nunq)]\n            cyc = (n - len(picks)) // len(reprun)\n            runout = n * len(picks) % len(reprun)\n            if 0 == cyc % 2:\n                picks.extend(reprun[:runout])\n            else:\n                picks.extend(reprun[runout:])\n        picks.sort(reverse=True)\n        np = len(picks)\n        sth = sum(picks[0:np:2]) - sum(picks[1:np:2])\n        results.append(abs(sth))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if 0 == cyc % 2:",
      "mutated_line": "if 1 == cyc % 2:",
      "code": "def calculate_team_strength_difference(T, test_cases):\n    mdl = 1000000\n    results = []\n    for case in test_cases:\n        (n, a, b, c, d) = case\n        sqd = {}\n        sqd[d] = 0\n        r = d\n        for e in range(1, n):\n            r = ((a * r + b) * r + c) % mdl\n            try:\n                sqd[r] *= 1\n                break\n            except KeyError:\n                sqd[r] = e\n        if len(sqd) == n:\n            picks = list(sqd.keys())\n        else:\n            inrun = list(sqd.items())\n            inrun.sort(key=lambda x: x[1])\n            nunq = len(sqd)\n            repst = sqd[r]\n            picks = [inrun[e][0] for e in range(0, repst)]\n            reprun = [inrun[e][0] for e in range(repst, nunq)]\n            cyc = (n - len(picks)) // len(reprun)\n            runout = (n - len(picks)) % len(reprun)\n            if 1 == cyc % 2:\n                picks.extend(reprun[:runout])\n            else:\n                picks.extend(reprun[runout:])\n        picks.sort(reverse=True)\n        np = len(picks)\n        sth = sum(picks[0:np:2]) - sum(picks[1:np:2])\n        results.append(abs(sth))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if 0 == cyc % 2:",
      "mutated_line": "if -1 == cyc % 2:",
      "code": "def calculate_team_strength_difference(T, test_cases):\n    mdl = 1000000\n    results = []\n    for case in test_cases:\n        (n, a, b, c, d) = case\n        sqd = {}\n        sqd[d] = 0\n        r = d\n        for e in range(1, n):\n            r = ((a * r + b) * r + c) % mdl\n            try:\n                sqd[r] *= 1\n                break\n            except KeyError:\n                sqd[r] = e\n        if len(sqd) == n:\n            picks = list(sqd.keys())\n        else:\n            inrun = list(sqd.items())\n            inrun.sort(key=lambda x: x[1])\n            nunq = len(sqd)\n            repst = sqd[r]\n            picks = [inrun[e][0] for e in range(0, repst)]\n            reprun = [inrun[e][0] for e in range(repst, nunq)]\n            cyc = (n - len(picks)) // len(reprun)\n            runout = (n - len(picks)) % len(reprun)\n            if -1 == cyc % 2:\n                picks.extend(reprun[:runout])\n            else:\n                picks.extend(reprun[runout:])\n        picks.sort(reverse=True)\n        np = len(picks)\n        sth = sum(picks[0:np:2]) - sum(picks[1:np:2])\n        results.append(abs(sth))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if 0 == cyc % 2:",
      "mutated_line": "if 1 == cyc % 2:",
      "code": "def calculate_team_strength_difference(T, test_cases):\n    mdl = 1000000\n    results = []\n    for case in test_cases:\n        (n, a, b, c, d) = case\n        sqd = {}\n        sqd[d] = 0\n        r = d\n        for e in range(1, n):\n            r = ((a * r + b) * r + c) % mdl\n            try:\n                sqd[r] *= 1\n                break\n            except KeyError:\n                sqd[r] = e\n        if len(sqd) == n:\n            picks = list(sqd.keys())\n        else:\n            inrun = list(sqd.items())\n            inrun.sort(key=lambda x: x[1])\n            nunq = len(sqd)\n            repst = sqd[r]\n            picks = [inrun[e][0] for e in range(0, repst)]\n            reprun = [inrun[e][0] for e in range(repst, nunq)]\n            cyc = (n - len(picks)) // len(reprun)\n            runout = (n - len(picks)) % len(reprun)\n            if 1 == cyc % 2:\n                picks.extend(reprun[:runout])\n            else:\n                picks.extend(reprun[runout:])\n        picks.sort(reverse=True)\n        np = len(picks)\n        sth = sum(picks[0:np:2]) - sum(picks[1:np:2])\n        results.append(abs(sth))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "if 0 == cyc % 2:",
      "mutated_line": "if 0 == cyc * 2:",
      "code": "def calculate_team_strength_difference(T, test_cases):\n    mdl = 1000000\n    results = []\n    for case in test_cases:\n        (n, a, b, c, d) = case\n        sqd = {}\n        sqd[d] = 0\n        r = d\n        for e in range(1, n):\n            r = ((a * r + b) * r + c) % mdl\n            try:\n                sqd[r] *= 1\n                break\n            except KeyError:\n                sqd[r] = e\n        if len(sqd) == n:\n            picks = list(sqd.keys())\n        else:\n            inrun = list(sqd.items())\n            inrun.sort(key=lambda x: x[1])\n            nunq = len(sqd)\n            repst = sqd[r]\n            picks = [inrun[e][0] for e in range(0, repst)]\n            reprun = [inrun[e][0] for e in range(repst, nunq)]\n            cyc = (n - len(picks)) // len(reprun)\n            runout = (n - len(picks)) % len(reprun)\n            if 0 == cyc * 2:\n                picks.extend(reprun[:runout])\n            else:\n                picks.extend(reprun[runout:])\n        picks.sort(reverse=True)\n        np = len(picks)\n        sth = sum(picks[0:np:2]) - sum(picks[1:np:2])\n        results.append(abs(sth))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "if 0 == cyc % 2:",
      "mutated_line": "if 0 == cyc + 2:",
      "code": "def calculate_team_strength_difference(T, test_cases):\n    mdl = 1000000\n    results = []\n    for case in test_cases:\n        (n, a, b, c, d) = case\n        sqd = {}\n        sqd[d] = 0\n        r = d\n        for e in range(1, n):\n            r = ((a * r + b) * r + c) % mdl\n            try:\n                sqd[r] *= 1\n                break\n            except KeyError:\n                sqd[r] = e\n        if len(sqd) == n:\n            picks = list(sqd.keys())\n        else:\n            inrun = list(sqd.items())\n            inrun.sort(key=lambda x: x[1])\n            nunq = len(sqd)\n            repst = sqd[r]\n            picks = [inrun[e][0] for e in range(0, repst)]\n            reprun = [inrun[e][0] for e in range(repst, nunq)]\n            cyc = (n - len(picks)) // len(reprun)\n            runout = (n - len(picks)) % len(reprun)\n            if 0 == cyc + 2:\n                picks.extend(reprun[:runout])\n            else:\n                picks.extend(reprun[runout:])\n        picks.sort(reverse=True)\n        np = len(picks)\n        sth = sum(picks[0:np:2]) - sum(picks[1:np:2])\n        results.append(abs(sth))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "picks.sort(reverse=True)",
      "mutated_line": "picks.sort(reverse=False)",
      "code": "def calculate_team_strength_difference(T, test_cases):\n    mdl = 1000000\n    results = []\n    for case in test_cases:\n        (n, a, b, c, d) = case\n        sqd = {}\n        sqd[d] = 0\n        r = d\n        for e in range(1, n):\n            r = ((a * r + b) * r + c) % mdl\n            try:\n                sqd[r] *= 1\n                break\n            except KeyError:\n                sqd[r] = e\n        if len(sqd) == n:\n            picks = list(sqd.keys())\n        else:\n            inrun = list(sqd.items())\n            inrun.sort(key=lambda x: x[1])\n            nunq = len(sqd)\n            repst = sqd[r]\n            picks = [inrun[e][0] for e in range(0, repst)]\n            reprun = [inrun[e][0] for e in range(repst, nunq)]\n            cyc = (n - len(picks)) // len(reprun)\n            runout = (n - len(picks)) % len(reprun)\n            if 0 == cyc % 2:\n                picks.extend(reprun[:runout])\n            else:\n                picks.extend(reprun[runout:])\n        picks.sort(reverse=False)\n        np = len(picks)\n        sth = sum(picks[0:np:2]) - sum(picks[1:np:2])\n        results.append(abs(sth))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "r = ((a * r + b) * r + c) % mdl",
      "mutated_line": "r = ((a * r + b) / r + c) % mdl",
      "code": "def calculate_team_strength_difference(T, test_cases):\n    mdl = 1000000\n    results = []\n    for case in test_cases:\n        (n, a, b, c, d) = case\n        sqd = {}\n        sqd[d] = 0\n        r = d\n        for e in range(1, n):\n            r = ((a * r + b) / r + c) % mdl\n            try:\n                sqd[r] *= 1\n                break\n            except KeyError:\n                sqd[r] = e\n        if len(sqd) == n:\n            picks = list(sqd.keys())\n        else:\n            inrun = list(sqd.items())\n            inrun.sort(key=lambda x: x[1])\n            nunq = len(sqd)\n            repst = sqd[r]\n            picks = [inrun[e][0] for e in range(0, repst)]\n            reprun = [inrun[e][0] for e in range(repst, nunq)]\n            cyc = (n - len(picks)) // len(reprun)\n            runout = (n - len(picks)) % len(reprun)\n            if 0 == cyc % 2:\n                picks.extend(reprun[:runout])\n            else:\n                picks.extend(reprun[runout:])\n        picks.sort(reverse=True)\n        np = len(picks)\n        sth = sum(picks[0:np:2]) - sum(picks[1:np:2])\n        results.append(abs(sth))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "r = ((a * r + b) * r + c) % mdl",
      "mutated_line": "r = (a * r + b + r + c) % mdl",
      "code": "def calculate_team_strength_difference(T, test_cases):\n    mdl = 1000000\n    results = []\n    for case in test_cases:\n        (n, a, b, c, d) = case\n        sqd = {}\n        sqd[d] = 0\n        r = d\n        for e in range(1, n):\n            r = (a * r + b + r + c) % mdl\n            try:\n                sqd[r] *= 1\n                break\n            except KeyError:\n                sqd[r] = e\n        if len(sqd) == n:\n            picks = list(sqd.keys())\n        else:\n            inrun = list(sqd.items())\n            inrun.sort(key=lambda x: x[1])\n            nunq = len(sqd)\n            repst = sqd[r]\n            picks = [inrun[e][0] for e in range(0, repst)]\n            reprun = [inrun[e][0] for e in range(repst, nunq)]\n            cyc = (n - len(picks)) // len(reprun)\n            runout = (n - len(picks)) % len(reprun)\n            if 0 == cyc % 2:\n                picks.extend(reprun[:runout])\n            else:\n                picks.extend(reprun[runout:])\n        picks.sort(reverse=True)\n        np = len(picks)\n        sth = sum(picks[0:np:2]) - sum(picks[1:np:2])\n        results.append(abs(sth))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "r = ((a * r + b) * r + c) % mdl",
      "mutated_line": "r = ((a * r + b) ** r + c) % mdl",
      "code": "def calculate_team_strength_difference(T, test_cases):\n    mdl = 1000000\n    results = []\n    for case in test_cases:\n        (n, a, b, c, d) = case\n        sqd = {}\n        sqd[d] = 0\n        r = d\n        for e in range(1, n):\n            r = ((a * r + b) ** r + c) % mdl\n            try:\n                sqd[r] *= 1\n                break\n            except KeyError:\n                sqd[r] = e\n        if len(sqd) == n:\n            picks = list(sqd.keys())\n        else:\n            inrun = list(sqd.items())\n            inrun.sort(key=lambda x: x[1])\n            nunq = len(sqd)\n            repst = sqd[r]\n            picks = [inrun[e][0] for e in range(0, repst)]\n            reprun = [inrun[e][0] for e in range(repst, nunq)]\n            cyc = (n - len(picks)) // len(reprun)\n            runout = (n - len(picks)) % len(reprun)\n            if 0 == cyc % 2:\n                picks.extend(reprun[:runout])\n            else:\n                picks.extend(reprun[runout:])\n        picks.sort(reverse=True)\n        np = len(picks)\n        sth = sum(picks[0:np:2]) - sum(picks[1:np:2])\n        results.append(abs(sth))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "picks = [inrun[e][0] for e in range(0, repst)]",
      "mutated_line": "picks = [inrun[e][1] for e in range(0, repst)]",
      "code": "def calculate_team_strength_difference(T, test_cases):\n    mdl = 1000000\n    results = []\n    for case in test_cases:\n        (n, a, b, c, d) = case\n        sqd = {}\n        sqd[d] = 0\n        r = d\n        for e in range(1, n):\n            r = ((a * r + b) * r + c) % mdl\n            try:\n                sqd[r] *= 1\n                break\n            except KeyError:\n                sqd[r] = e\n        if len(sqd) == n:\n            picks = list(sqd.keys())\n        else:\n            inrun = list(sqd.items())\n            inrun.sort(key=lambda x: x[1])\n            nunq = len(sqd)\n            repst = sqd[r]\n            picks = [inrun[e][1] for e in range(0, repst)]\n            reprun = [inrun[e][0] for e in range(repst, nunq)]\n            cyc = (n - len(picks)) // len(reprun)\n            runout = (n - len(picks)) % len(reprun)\n            if 0 == cyc % 2:\n                picks.extend(reprun[:runout])\n            else:\n                picks.extend(reprun[runout:])\n        picks.sort(reverse=True)\n        np = len(picks)\n        sth = sum(picks[0:np:2]) - sum(picks[1:np:2])\n        results.append(abs(sth))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "picks = [inrun[e][0] for e in range(0, repst)]",
      "mutated_line": "picks = [inrun[e][-1] for e in range(0, repst)]",
      "code": "def calculate_team_strength_difference(T, test_cases):\n    mdl = 1000000\n    results = []\n    for case in test_cases:\n        (n, a, b, c, d) = case\n        sqd = {}\n        sqd[d] = 0\n        r = d\n        for e in range(1, n):\n            r = ((a * r + b) * r + c) % mdl\n            try:\n                sqd[r] *= 1\n                break\n            except KeyError:\n                sqd[r] = e\n        if len(sqd) == n:\n            picks = list(sqd.keys())\n        else:\n            inrun = list(sqd.items())\n            inrun.sort(key=lambda x: x[1])\n            nunq = len(sqd)\n            repst = sqd[r]\n            picks = [inrun[e][-1] for e in range(0, repst)]\n            reprun = [inrun[e][0] for e in range(repst, nunq)]\n            cyc = (n - len(picks)) // len(reprun)\n            runout = (n - len(picks)) % len(reprun)\n            if 0 == cyc % 2:\n                picks.extend(reprun[:runout])\n            else:\n                picks.extend(reprun[runout:])\n        picks.sort(reverse=True)\n        np = len(picks)\n        sth = sum(picks[0:np:2]) - sum(picks[1:np:2])\n        results.append(abs(sth))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "picks = [inrun[e][0] for e in range(0, repst)]",
      "mutated_line": "picks = [inrun[e][1] for e in range(0, repst)]",
      "code": "def calculate_team_strength_difference(T, test_cases):\n    mdl = 1000000\n    results = []\n    for case in test_cases:\n        (n, a, b, c, d) = case\n        sqd = {}\n        sqd[d] = 0\n        r = d\n        for e in range(1, n):\n            r = ((a * r + b) * r + c) % mdl\n            try:\n                sqd[r] *= 1\n                break\n            except KeyError:\n                sqd[r] = e\n        if len(sqd) == n:\n            picks = list(sqd.keys())\n        else:\n            inrun = list(sqd.items())\n            inrun.sort(key=lambda x: x[1])\n            nunq = len(sqd)\n            repst = sqd[r]\n            picks = [inrun[e][1] for e in range(0, repst)]\n            reprun = [inrun[e][0] for e in range(repst, nunq)]\n            cyc = (n - len(picks)) // len(reprun)\n            runout = (n - len(picks)) % len(reprun)\n            if 0 == cyc % 2:\n                picks.extend(reprun[:runout])\n            else:\n                picks.extend(reprun[runout:])\n        picks.sort(reverse=True)\n        np = len(picks)\n        sth = sum(picks[0:np:2]) - sum(picks[1:np:2])\n        results.append(abs(sth))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "reprun = [inrun[e][0] for e in range(repst, nunq)]",
      "mutated_line": "reprun = [inrun[e][1] for e in range(repst, nunq)]",
      "code": "def calculate_team_strength_difference(T, test_cases):\n    mdl = 1000000\n    results = []\n    for case in test_cases:\n        (n, a, b, c, d) = case\n        sqd = {}\n        sqd[d] = 0\n        r = d\n        for e in range(1, n):\n            r = ((a * r + b) * r + c) % mdl\n            try:\n                sqd[r] *= 1\n                break\n            except KeyError:\n                sqd[r] = e\n        if len(sqd) == n:\n            picks = list(sqd.keys())\n        else:\n            inrun = list(sqd.items())\n            inrun.sort(key=lambda x: x[1])\n            nunq = len(sqd)\n            repst = sqd[r]\n            picks = [inrun[e][0] for e in range(0, repst)]\n            reprun = [inrun[e][1] for e in range(repst, nunq)]\n            cyc = (n - len(picks)) // len(reprun)\n            runout = (n - len(picks)) % len(reprun)\n            if 0 == cyc % 2:\n                picks.extend(reprun[:runout])\n            else:\n                picks.extend(reprun[runout:])\n        picks.sort(reverse=True)\n        np = len(picks)\n        sth = sum(picks[0:np:2]) - sum(picks[1:np:2])\n        results.append(abs(sth))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "reprun = [inrun[e][0] for e in range(repst, nunq)]",
      "mutated_line": "reprun = [inrun[e][-1] for e in range(repst, nunq)]",
      "code": "def calculate_team_strength_difference(T, test_cases):\n    mdl = 1000000\n    results = []\n    for case in test_cases:\n        (n, a, b, c, d) = case\n        sqd = {}\n        sqd[d] = 0\n        r = d\n        for e in range(1, n):\n            r = ((a * r + b) * r + c) % mdl\n            try:\n                sqd[r] *= 1\n                break\n            except KeyError:\n                sqd[r] = e\n        if len(sqd) == n:\n            picks = list(sqd.keys())\n        else:\n            inrun = list(sqd.items())\n            inrun.sort(key=lambda x: x[1])\n            nunq = len(sqd)\n            repst = sqd[r]\n            picks = [inrun[e][0] for e in range(0, repst)]\n            reprun = [inrun[e][-1] for e in range(repst, nunq)]\n            cyc = (n - len(picks)) // len(reprun)\n            runout = (n - len(picks)) % len(reprun)\n            if 0 == cyc % 2:\n                picks.extend(reprun[:runout])\n            else:\n                picks.extend(reprun[runout:])\n        picks.sort(reverse=True)\n        np = len(picks)\n        sth = sum(picks[0:np:2]) - sum(picks[1:np:2])\n        results.append(abs(sth))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "reprun = [inrun[e][0] for e in range(repst, nunq)]",
      "mutated_line": "reprun = [inrun[e][1] for e in range(repst, nunq)]",
      "code": "def calculate_team_strength_difference(T, test_cases):\n    mdl = 1000000\n    results = []\n    for case in test_cases:\n        (n, a, b, c, d) = case\n        sqd = {}\n        sqd[d] = 0\n        r = d\n        for e in range(1, n):\n            r = ((a * r + b) * r + c) % mdl\n            try:\n                sqd[r] *= 1\n                break\n            except KeyError:\n                sqd[r] = e\n        if len(sqd) == n:\n            picks = list(sqd.keys())\n        else:\n            inrun = list(sqd.items())\n            inrun.sort(key=lambda x: x[1])\n            nunq = len(sqd)\n            repst = sqd[r]\n            picks = [inrun[e][0] for e in range(0, repst)]\n            reprun = [inrun[e][1] for e in range(repst, nunq)]\n            cyc = (n - len(picks)) // len(reprun)\n            runout = (n - len(picks)) % len(reprun)\n            if 0 == cyc % 2:\n                picks.extend(reprun[:runout])\n            else:\n                picks.extend(reprun[runout:])\n        picks.sort(reverse=True)\n        np = len(picks)\n        sth = sum(picks[0:np:2]) - sum(picks[1:np:2])\n        results.append(abs(sth))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if 0 == cyc % 2:",
      "mutated_line": "if 0 == cyc % 3:",
      "code": "def calculate_team_strength_difference(T, test_cases):\n    mdl = 1000000\n    results = []\n    for case in test_cases:\n        (n, a, b, c, d) = case\n        sqd = {}\n        sqd[d] = 0\n        r = d\n        for e in range(1, n):\n            r = ((a * r + b) * r + c) % mdl\n            try:\n                sqd[r] *= 1\n                break\n            except KeyError:\n                sqd[r] = e\n        if len(sqd) == n:\n            picks = list(sqd.keys())\n        else:\n            inrun = list(sqd.items())\n            inrun.sort(key=lambda x: x[1])\n            nunq = len(sqd)\n            repst = sqd[r]\n            picks = [inrun[e][0] for e in range(0, repst)]\n            reprun = [inrun[e][0] for e in range(repst, nunq)]\n            cyc = (n - len(picks)) // len(reprun)\n            runout = (n - len(picks)) % len(reprun)\n            if 0 == cyc % 3:\n                picks.extend(reprun[:runout])\n            else:\n                picks.extend(reprun[runout:])\n        picks.sort(reverse=True)\n        np = len(picks)\n        sth = sum(picks[0:np:2]) - sum(picks[1:np:2])\n        results.append(abs(sth))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if 0 == cyc % 2:",
      "mutated_line": "if 0 == cyc % 1:",
      "code": "def calculate_team_strength_difference(T, test_cases):\n    mdl = 1000000\n    results = []\n    for case in test_cases:\n        (n, a, b, c, d) = case\n        sqd = {}\n        sqd[d] = 0\n        r = d\n        for e in range(1, n):\n            r = ((a * r + b) * r + c) % mdl\n            try:\n                sqd[r] *= 1\n                break\n            except KeyError:\n                sqd[r] = e\n        if len(sqd) == n:\n            picks = list(sqd.keys())\n        else:\n            inrun = list(sqd.items())\n            inrun.sort(key=lambda x: x[1])\n            nunq = len(sqd)\n            repst = sqd[r]\n            picks = [inrun[e][0] for e in range(0, repst)]\n            reprun = [inrun[e][0] for e in range(repst, nunq)]\n            cyc = (n - len(picks)) // len(reprun)\n            runout = (n - len(picks)) % len(reprun)\n            if 0 == cyc % 1:\n                picks.extend(reprun[:runout])\n            else:\n                picks.extend(reprun[runout:])\n        picks.sort(reverse=True)\n        np = len(picks)\n        sth = sum(picks[0:np:2]) - sum(picks[1:np:2])\n        results.append(abs(sth))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if 0 == cyc % 2:",
      "mutated_line": "if 0 == cyc % 0:",
      "code": "def calculate_team_strength_difference(T, test_cases):\n    mdl = 1000000\n    results = []\n    for case in test_cases:\n        (n, a, b, c, d) = case\n        sqd = {}\n        sqd[d] = 0\n        r = d\n        for e in range(1, n):\n            r = ((a * r + b) * r + c) % mdl\n            try:\n                sqd[r] *= 1\n                break\n            except KeyError:\n                sqd[r] = e\n        if len(sqd) == n:\n            picks = list(sqd.keys())\n        else:\n            inrun = list(sqd.items())\n            inrun.sort(key=lambda x: x[1])\n            nunq = len(sqd)\n            repst = sqd[r]\n            picks = [inrun[e][0] for e in range(0, repst)]\n            reprun = [inrun[e][0] for e in range(repst, nunq)]\n            cyc = (n - len(picks)) // len(reprun)\n            runout = (n - len(picks)) % len(reprun)\n            if 0 == cyc % 0:\n                picks.extend(reprun[:runout])\n            else:\n                picks.extend(reprun[runout:])\n        picks.sort(reverse=True)\n        np = len(picks)\n        sth = sum(picks[0:np:2]) - sum(picks[1:np:2])\n        results.append(abs(sth))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if 0 == cyc % 2:",
      "mutated_line": "if 0 == cyc % 1:",
      "code": "def calculate_team_strength_difference(T, test_cases):\n    mdl = 1000000\n    results = []\n    for case in test_cases:\n        (n, a, b, c, d) = case\n        sqd = {}\n        sqd[d] = 0\n        r = d\n        for e in range(1, n):\n            r = ((a * r + b) * r + c) % mdl\n            try:\n                sqd[r] *= 1\n                break\n            except KeyError:\n                sqd[r] = e\n        if len(sqd) == n:\n            picks = list(sqd.keys())\n        else:\n            inrun = list(sqd.items())\n            inrun.sort(key=lambda x: x[1])\n            nunq = len(sqd)\n            repst = sqd[r]\n            picks = [inrun[e][0] for e in range(0, repst)]\n            reprun = [inrun[e][0] for e in range(repst, nunq)]\n            cyc = (n - len(picks)) // len(reprun)\n            runout = (n - len(picks)) % len(reprun)\n            if 0 == cyc % 1:\n                picks.extend(reprun[:runout])\n            else:\n                picks.extend(reprun[runout:])\n        picks.sort(reverse=True)\n        np = len(picks)\n        sth = sum(picks[0:np:2]) - sum(picks[1:np:2])\n        results.append(abs(sth))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if 0 == cyc % 2:",
      "mutated_line": "if 0 == cyc % -2:",
      "code": "def calculate_team_strength_difference(T, test_cases):\n    mdl = 1000000\n    results = []\n    for case in test_cases:\n        (n, a, b, c, d) = case\n        sqd = {}\n        sqd[d] = 0\n        r = d\n        for e in range(1, n):\n            r = ((a * r + b) * r + c) % mdl\n            try:\n                sqd[r] *= 1\n                break\n            except KeyError:\n                sqd[r] = e\n        if len(sqd) == n:\n            picks = list(sqd.keys())\n        else:\n            inrun = list(sqd.items())\n            inrun.sort(key=lambda x: x[1])\n            nunq = len(sqd)\n            repst = sqd[r]\n            picks = [inrun[e][0] for e in range(0, repst)]\n            reprun = [inrun[e][0] for e in range(repst, nunq)]\n            cyc = (n - len(picks)) // len(reprun)\n            runout = (n - len(picks)) % len(reprun)\n            if 0 == cyc % -2:\n                picks.extend(reprun[:runout])\n            else:\n                picks.extend(reprun[runout:])\n        picks.sort(reverse=True)\n        np = len(picks)\n        sth = sum(picks[0:np:2]) - sum(picks[1:np:2])\n        results.append(abs(sth))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "r = ((a * r + b) * r + c) % mdl",
      "mutated_line": "r = ((a * r - b) * r + c) % mdl",
      "code": "def calculate_team_strength_difference(T, test_cases):\n    mdl = 1000000\n    results = []\n    for case in test_cases:\n        (n, a, b, c, d) = case\n        sqd = {}\n        sqd[d] = 0\n        r = d\n        for e in range(1, n):\n            r = ((a * r - b) * r + c) % mdl\n            try:\n                sqd[r] *= 1\n                break\n            except KeyError:\n                sqd[r] = e\n        if len(sqd) == n:\n            picks = list(sqd.keys())\n        else:\n            inrun = list(sqd.items())\n            inrun.sort(key=lambda x: x[1])\n            nunq = len(sqd)\n            repst = sqd[r]\n            picks = [inrun[e][0] for e in range(0, repst)]\n            reprun = [inrun[e][0] for e in range(repst, nunq)]\n            cyc = (n - len(picks)) // len(reprun)\n            runout = (n - len(picks)) % len(reprun)\n            if 0 == cyc % 2:\n                picks.extend(reprun[:runout])\n            else:\n                picks.extend(reprun[runout:])\n        picks.sort(reverse=True)\n        np = len(picks)\n        sth = sum(picks[0:np:2]) - sum(picks[1:np:2])\n        results.append(abs(sth))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "r = ((a * r + b) * r + c) % mdl",
      "mutated_line": "r = (a * r * b * r + c) % mdl",
      "code": "def calculate_team_strength_difference(T, test_cases):\n    mdl = 1000000\n    results = []\n    for case in test_cases:\n        (n, a, b, c, d) = case\n        sqd = {}\n        sqd[d] = 0\n        r = d\n        for e in range(1, n):\n            r = (a * r * b * r + c) % mdl\n            try:\n                sqd[r] *= 1\n                break\n            except KeyError:\n                sqd[r] = e\n        if len(sqd) == n:\n            picks = list(sqd.keys())\n        else:\n            inrun = list(sqd.items())\n            inrun.sort(key=lambda x: x[1])\n            nunq = len(sqd)\n            repst = sqd[r]\n            picks = [inrun[e][0] for e in range(0, repst)]\n            reprun = [inrun[e][0] for e in range(repst, nunq)]\n            cyc = (n - len(picks)) // len(reprun)\n            runout = (n - len(picks)) % len(reprun)\n            if 0 == cyc % 2:\n                picks.extend(reprun[:runout])\n            else:\n                picks.extend(reprun[runout:])\n        picks.sort(reverse=True)\n        np = len(picks)\n        sth = sum(picks[0:np:2]) - sum(picks[1:np:2])\n        results.append(abs(sth))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "picks = [inrun[e][0] for e in range(0, repst)]",
      "mutated_line": "picks = [inrun[e][0] for e in range(1, repst)]",
      "code": "def calculate_team_strength_difference(T, test_cases):\n    mdl = 1000000\n    results = []\n    for case in test_cases:\n        (n, a, b, c, d) = case\n        sqd = {}\n        sqd[d] = 0\n        r = d\n        for e in range(1, n):\n            r = ((a * r + b) * r + c) % mdl\n            try:\n                sqd[r] *= 1\n                break\n            except KeyError:\n                sqd[r] = e\n        if len(sqd) == n:\n            picks = list(sqd.keys())\n        else:\n            inrun = list(sqd.items())\n            inrun.sort(key=lambda x: x[1])\n            nunq = len(sqd)\n            repst = sqd[r]\n            picks = [inrun[e][0] for e in range(1, repst)]\n            reprun = [inrun[e][0] for e in range(repst, nunq)]\n            cyc = (n - len(picks)) // len(reprun)\n            runout = (n - len(picks)) % len(reprun)\n            if 0 == cyc % 2:\n                picks.extend(reprun[:runout])\n            else:\n                picks.extend(reprun[runout:])\n        picks.sort(reverse=True)\n        np = len(picks)\n        sth = sum(picks[0:np:2]) - sum(picks[1:np:2])\n        results.append(abs(sth))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "picks = [inrun[e][0] for e in range(0, repst)]",
      "mutated_line": "picks = [inrun[e][0] for e in range(-1, repst)]",
      "code": "def calculate_team_strength_difference(T, test_cases):\n    mdl = 1000000\n    results = []\n    for case in test_cases:\n        (n, a, b, c, d) = case\n        sqd = {}\n        sqd[d] = 0\n        r = d\n        for e in range(1, n):\n            r = ((a * r + b) * r + c) % mdl\n            try:\n                sqd[r] *= 1\n                break\n            except KeyError:\n                sqd[r] = e\n        if len(sqd) == n:\n            picks = list(sqd.keys())\n        else:\n            inrun = list(sqd.items())\n            inrun.sort(key=lambda x: x[1])\n            nunq = len(sqd)\n            repst = sqd[r]\n            picks = [inrun[e][0] for e in range(-1, repst)]\n            reprun = [inrun[e][0] for e in range(repst, nunq)]\n            cyc = (n - len(picks)) // len(reprun)\n            runout = (n - len(picks)) % len(reprun)\n            if 0 == cyc % 2:\n                picks.extend(reprun[:runout])\n            else:\n                picks.extend(reprun[runout:])\n        picks.sort(reverse=True)\n        np = len(picks)\n        sth = sum(picks[0:np:2]) - sum(picks[1:np:2])\n        results.append(abs(sth))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "picks = [inrun[e][0] for e in range(0, repst)]",
      "mutated_line": "picks = [inrun[e][0] for e in range(1, repst)]",
      "code": "def calculate_team_strength_difference(T, test_cases):\n    mdl = 1000000\n    results = []\n    for case in test_cases:\n        (n, a, b, c, d) = case\n        sqd = {}\n        sqd[d] = 0\n        r = d\n        for e in range(1, n):\n            r = ((a * r + b) * r + c) % mdl\n            try:\n                sqd[r] *= 1\n                break\n            except KeyError:\n                sqd[r] = e\n        if len(sqd) == n:\n            picks = list(sqd.keys())\n        else:\n            inrun = list(sqd.items())\n            inrun.sort(key=lambda x: x[1])\n            nunq = len(sqd)\n            repst = sqd[r]\n            picks = [inrun[e][0] for e in range(1, repst)]\n            reprun = [inrun[e][0] for e in range(repst, nunq)]\n            cyc = (n - len(picks)) // len(reprun)\n            runout = (n - len(picks)) % len(reprun)\n            if 0 == cyc % 2:\n                picks.extend(reprun[:runout])\n            else:\n                picks.extend(reprun[runout:])\n        picks.sort(reverse=True)\n        np = len(picks)\n        sth = sum(picks[0:np:2]) - sum(picks[1:np:2])\n        results.append(abs(sth))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "sth = sum(picks[0:np:2]) - sum(picks[1:np:2])",
      "mutated_line": "sth = sum(picks[1:np:2]) - sum(picks[1:np:2])",
      "code": "def calculate_team_strength_difference(T, test_cases):\n    mdl = 1000000\n    results = []\n    for case in test_cases:\n        (n, a, b, c, d) = case\n        sqd = {}\n        sqd[d] = 0\n        r = d\n        for e in range(1, n):\n            r = ((a * r + b) * r + c) % mdl\n            try:\n                sqd[r] *= 1\n                break\n            except KeyError:\n                sqd[r] = e\n        if len(sqd) == n:\n            picks = list(sqd.keys())\n        else:\n            inrun = list(sqd.items())\n            inrun.sort(key=lambda x: x[1])\n            nunq = len(sqd)\n            repst = sqd[r]\n            picks = [inrun[e][0] for e in range(0, repst)]\n            reprun = [inrun[e][0] for e in range(repst, nunq)]\n            cyc = (n - len(picks)) // len(reprun)\n            runout = (n - len(picks)) % len(reprun)\n            if 0 == cyc % 2:\n                picks.extend(reprun[:runout])\n            else:\n                picks.extend(reprun[runout:])\n        picks.sort(reverse=True)\n        np = len(picks)\n        sth = sum(picks[1:np:2]) - sum(picks[1:np:2])\n        results.append(abs(sth))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "sth = sum(picks[0:np:2]) - sum(picks[1:np:2])",
      "mutated_line": "sth = sum(picks[-1:np:2]) - sum(picks[1:np:2])",
      "code": "def calculate_team_strength_difference(T, test_cases):\n    mdl = 1000000\n    results = []\n    for case in test_cases:\n        (n, a, b, c, d) = case\n        sqd = {}\n        sqd[d] = 0\n        r = d\n        for e in range(1, n):\n            r = ((a * r + b) * r + c) % mdl\n            try:\n                sqd[r] *= 1\n                break\n            except KeyError:\n                sqd[r] = e\n        if len(sqd) == n:\n            picks = list(sqd.keys())\n        else:\n            inrun = list(sqd.items())\n            inrun.sort(key=lambda x: x[1])\n            nunq = len(sqd)\n            repst = sqd[r]\n            picks = [inrun[e][0] for e in range(0, repst)]\n            reprun = [inrun[e][0] for e in range(repst, nunq)]\n            cyc = (n - len(picks)) // len(reprun)\n            runout = (n - len(picks)) % len(reprun)\n            if 0 == cyc % 2:\n                picks.extend(reprun[:runout])\n            else:\n                picks.extend(reprun[runout:])\n        picks.sort(reverse=True)\n        np = len(picks)\n        sth = sum(picks[-1:np:2]) - sum(picks[1:np:2])\n        results.append(abs(sth))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "sth = sum(picks[0:np:2]) - sum(picks[1:np:2])",
      "mutated_line": "sth = sum(picks[1:np:2]) - sum(picks[1:np:2])",
      "code": "def calculate_team_strength_difference(T, test_cases):\n    mdl = 1000000\n    results = []\n    for case in test_cases:\n        (n, a, b, c, d) = case\n        sqd = {}\n        sqd[d] = 0\n        r = d\n        for e in range(1, n):\n            r = ((a * r + b) * r + c) % mdl\n            try:\n                sqd[r] *= 1\n                break\n            except KeyError:\n                sqd[r] = e\n        if len(sqd) == n:\n            picks = list(sqd.keys())\n        else:\n            inrun = list(sqd.items())\n            inrun.sort(key=lambda x: x[1])\n            nunq = len(sqd)\n            repst = sqd[r]\n            picks = [inrun[e][0] for e in range(0, repst)]\n            reprun = [inrun[e][0] for e in range(repst, nunq)]\n            cyc = (n - len(picks)) // len(reprun)\n            runout = (n - len(picks)) % len(reprun)\n            if 0 == cyc % 2:\n                picks.extend(reprun[:runout])\n            else:\n                picks.extend(reprun[runout:])\n        picks.sort(reverse=True)\n        np = len(picks)\n        sth = sum(picks[1:np:2]) - sum(picks[1:np:2])\n        results.append(abs(sth))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "sth = sum(picks[0:np:2]) - sum(picks[1:np:2])",
      "mutated_line": "sth = sum(picks[0:np:3]) - sum(picks[1:np:2])",
      "code": "def calculate_team_strength_difference(T, test_cases):\n    mdl = 1000000\n    results = []\n    for case in test_cases:\n        (n, a, b, c, d) = case\n        sqd = {}\n        sqd[d] = 0\n        r = d\n        for e in range(1, n):\n            r = ((a * r + b) * r + c) % mdl\n            try:\n                sqd[r] *= 1\n                break\n            except KeyError:\n                sqd[r] = e\n        if len(sqd) == n:\n            picks = list(sqd.keys())\n        else:\n            inrun = list(sqd.items())\n            inrun.sort(key=lambda x: x[1])\n            nunq = len(sqd)\n            repst = sqd[r]\n            picks = [inrun[e][0] for e in range(0, repst)]\n            reprun = [inrun[e][0] for e in range(repst, nunq)]\n            cyc = (n - len(picks)) // len(reprun)\n            runout = (n - len(picks)) % len(reprun)\n            if 0 == cyc % 2:\n                picks.extend(reprun[:runout])\n            else:\n                picks.extend(reprun[runout:])\n        picks.sort(reverse=True)\n        np = len(picks)\n        sth = sum(picks[0:np:3]) - sum(picks[1:np:2])\n        results.append(abs(sth))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "sth = sum(picks[0:np:2]) - sum(picks[1:np:2])",
      "mutated_line": "sth = sum(picks[0:np:1]) - sum(picks[1:np:2])",
      "code": "def calculate_team_strength_difference(T, test_cases):\n    mdl = 1000000\n    results = []\n    for case in test_cases:\n        (n, a, b, c, d) = case\n        sqd = {}\n        sqd[d] = 0\n        r = d\n        for e in range(1, n):\n            r = ((a * r + b) * r + c) % mdl\n            try:\n                sqd[r] *= 1\n                break\n            except KeyError:\n                sqd[r] = e\n        if len(sqd) == n:\n            picks = list(sqd.keys())\n        else:\n            inrun = list(sqd.items())\n            inrun.sort(key=lambda x: x[1])\n            nunq = len(sqd)\n            repst = sqd[r]\n            picks = [inrun[e][0] for e in range(0, repst)]\n            reprun = [inrun[e][0] for e in range(repst, nunq)]\n            cyc = (n - len(picks)) // len(reprun)\n            runout = (n - len(picks)) % len(reprun)\n            if 0 == cyc % 2:\n                picks.extend(reprun[:runout])\n            else:\n                picks.extend(reprun[runout:])\n        picks.sort(reverse=True)\n        np = len(picks)\n        sth = sum(picks[0:np:1]) - sum(picks[1:np:2])\n        results.append(abs(sth))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "sth = sum(picks[0:np:2]) - sum(picks[1:np:2])",
      "mutated_line": "sth = sum(picks[0:np:0]) - sum(picks[1:np:2])",
      "code": "def calculate_team_strength_difference(T, test_cases):\n    mdl = 1000000\n    results = []\n    for case in test_cases:\n        (n, a, b, c, d) = case\n        sqd = {}\n        sqd[d] = 0\n        r = d\n        for e in range(1, n):\n            r = ((a * r + b) * r + c) % mdl\n            try:\n                sqd[r] *= 1\n                break\n            except KeyError:\n                sqd[r] = e\n        if len(sqd) == n:\n            picks = list(sqd.keys())\n        else:\n            inrun = list(sqd.items())\n            inrun.sort(key=lambda x: x[1])\n            nunq = len(sqd)\n            repst = sqd[r]\n            picks = [inrun[e][0] for e in range(0, repst)]\n            reprun = [inrun[e][0] for e in range(repst, nunq)]\n            cyc = (n - len(picks)) // len(reprun)\n            runout = (n - len(picks)) % len(reprun)\n            if 0 == cyc % 2:\n                picks.extend(reprun[:runout])\n            else:\n                picks.extend(reprun[runout:])\n        picks.sort(reverse=True)\n        np = len(picks)\n        sth = sum(picks[0:np:0]) - sum(picks[1:np:2])\n        results.append(abs(sth))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "sth = sum(picks[0:np:2]) - sum(picks[1:np:2])",
      "mutated_line": "sth = sum(picks[0:np:1]) - sum(picks[1:np:2])",
      "code": "def calculate_team_strength_difference(T, test_cases):\n    mdl = 1000000\n    results = []\n    for case in test_cases:\n        (n, a, b, c, d) = case\n        sqd = {}\n        sqd[d] = 0\n        r = d\n        for e in range(1, n):\n            r = ((a * r + b) * r + c) % mdl\n            try:\n                sqd[r] *= 1\n                break\n            except KeyError:\n                sqd[r] = e\n        if len(sqd) == n:\n            picks = list(sqd.keys())\n        else:\n            inrun = list(sqd.items())\n            inrun.sort(key=lambda x: x[1])\n            nunq = len(sqd)\n            repst = sqd[r]\n            picks = [inrun[e][0] for e in range(0, repst)]\n            reprun = [inrun[e][0] for e in range(repst, nunq)]\n            cyc = (n - len(picks)) // len(reprun)\n            runout = (n - len(picks)) % len(reprun)\n            if 0 == cyc % 2:\n                picks.extend(reprun[:runout])\n            else:\n                picks.extend(reprun[runout:])\n        picks.sort(reverse=True)\n        np = len(picks)\n        sth = sum(picks[0:np:1]) - sum(picks[1:np:2])\n        results.append(abs(sth))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "sth = sum(picks[0:np:2]) - sum(picks[1:np:2])",
      "mutated_line": "sth = sum(picks[0:np:-2]) - sum(picks[1:np:2])",
      "code": "def calculate_team_strength_difference(T, test_cases):\n    mdl = 1000000\n    results = []\n    for case in test_cases:\n        (n, a, b, c, d) = case\n        sqd = {}\n        sqd[d] = 0\n        r = d\n        for e in range(1, n):\n            r = ((a * r + b) * r + c) % mdl\n            try:\n                sqd[r] *= 1\n                break\n            except KeyError:\n                sqd[r] = e\n        if len(sqd) == n:\n            picks = list(sqd.keys())\n        else:\n            inrun = list(sqd.items())\n            inrun.sort(key=lambda x: x[1])\n            nunq = len(sqd)\n            repst = sqd[r]\n            picks = [inrun[e][0] for e in range(0, repst)]\n            reprun = [inrun[e][0] for e in range(repst, nunq)]\n            cyc = (n - len(picks)) // len(reprun)\n            runout = (n - len(picks)) % len(reprun)\n            if 0 == cyc % 2:\n                picks.extend(reprun[:runout])\n            else:\n                picks.extend(reprun[runout:])\n        picks.sort(reverse=True)\n        np = len(picks)\n        sth = sum(picks[0:np:-2]) - sum(picks[1:np:2])\n        results.append(abs(sth))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "sth = sum(picks[0:np:2]) - sum(picks[1:np:2])",
      "mutated_line": "sth = sum(picks[0:np:2]) - sum(picks[2:np:2])",
      "code": "def calculate_team_strength_difference(T, test_cases):\n    mdl = 1000000\n    results = []\n    for case in test_cases:\n        (n, a, b, c, d) = case\n        sqd = {}\n        sqd[d] = 0\n        r = d\n        for e in range(1, n):\n            r = ((a * r + b) * r + c) % mdl\n            try:\n                sqd[r] *= 1\n                break\n            except KeyError:\n                sqd[r] = e\n        if len(sqd) == n:\n            picks = list(sqd.keys())\n        else:\n            inrun = list(sqd.items())\n            inrun.sort(key=lambda x: x[1])\n            nunq = len(sqd)\n            repst = sqd[r]\n            picks = [inrun[e][0] for e in range(0, repst)]\n            reprun = [inrun[e][0] for e in range(repst, nunq)]\n            cyc = (n - len(picks)) // len(reprun)\n            runout = (n - len(picks)) % len(reprun)\n            if 0 == cyc % 2:\n                picks.extend(reprun[:runout])\n            else:\n                picks.extend(reprun[runout:])\n        picks.sort(reverse=True)\n        np = len(picks)\n        sth = sum(picks[0:np:2]) - sum(picks[2:np:2])\n        results.append(abs(sth))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "sth = sum(picks[0:np:2]) - sum(picks[1:np:2])",
      "mutated_line": "sth = sum(picks[0:np:2]) - sum(picks[0:np:2])",
      "code": "def calculate_team_strength_difference(T, test_cases):\n    mdl = 1000000\n    results = []\n    for case in test_cases:\n        (n, a, b, c, d) = case\n        sqd = {}\n        sqd[d] = 0\n        r = d\n        for e in range(1, n):\n            r = ((a * r + b) * r + c) % mdl\n            try:\n                sqd[r] *= 1\n                break\n            except KeyError:\n                sqd[r] = e\n        if len(sqd) == n:\n            picks = list(sqd.keys())\n        else:\n            inrun = list(sqd.items())\n            inrun.sort(key=lambda x: x[1])\n            nunq = len(sqd)\n            repst = sqd[r]\n            picks = [inrun[e][0] for e in range(0, repst)]\n            reprun = [inrun[e][0] for e in range(repst, nunq)]\n            cyc = (n - len(picks)) // len(reprun)\n            runout = (n - len(picks)) % len(reprun)\n            if 0 == cyc % 2:\n                picks.extend(reprun[:runout])\n            else:\n                picks.extend(reprun[runout:])\n        picks.sort(reverse=True)\n        np = len(picks)\n        sth = sum(picks[0:np:2]) - sum(picks[0:np:2])\n        results.append(abs(sth))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "sth = sum(picks[0:np:2]) - sum(picks[1:np:2])",
      "mutated_line": "sth = sum(picks[0:np:2]) - sum(picks[0:np:2])",
      "code": "def calculate_team_strength_difference(T, test_cases):\n    mdl = 1000000\n    results = []\n    for case in test_cases:\n        (n, a, b, c, d) = case\n        sqd = {}\n        sqd[d] = 0\n        r = d\n        for e in range(1, n):\n            r = ((a * r + b) * r + c) % mdl\n            try:\n                sqd[r] *= 1\n                break\n            except KeyError:\n                sqd[r] = e\n        if len(sqd) == n:\n            picks = list(sqd.keys())\n        else:\n            inrun = list(sqd.items())\n            inrun.sort(key=lambda x: x[1])\n            nunq = len(sqd)\n            repst = sqd[r]\n            picks = [inrun[e][0] for e in range(0, repst)]\n            reprun = [inrun[e][0] for e in range(repst, nunq)]\n            cyc = (n - len(picks)) // len(reprun)\n            runout = (n - len(picks)) % len(reprun)\n            if 0 == cyc % 2:\n                picks.extend(reprun[:runout])\n            else:\n                picks.extend(reprun[runout:])\n        picks.sort(reverse=True)\n        np = len(picks)\n        sth = sum(picks[0:np:2]) - sum(picks[0:np:2])\n        results.append(abs(sth))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "sth = sum(picks[0:np:2]) - sum(picks[1:np:2])",
      "mutated_line": "sth = sum(picks[0:np:2]) - sum(picks[-1:np:2])",
      "code": "def calculate_team_strength_difference(T, test_cases):\n    mdl = 1000000\n    results = []\n    for case in test_cases:\n        (n, a, b, c, d) = case\n        sqd = {}\n        sqd[d] = 0\n        r = d\n        for e in range(1, n):\n            r = ((a * r + b) * r + c) % mdl\n            try:\n                sqd[r] *= 1\n                break\n            except KeyError:\n                sqd[r] = e\n        if len(sqd) == n:\n            picks = list(sqd.keys())\n        else:\n            inrun = list(sqd.items())\n            inrun.sort(key=lambda x: x[1])\n            nunq = len(sqd)\n            repst = sqd[r]\n            picks = [inrun[e][0] for e in range(0, repst)]\n            reprun = [inrun[e][0] for e in range(repst, nunq)]\n            cyc = (n - len(picks)) // len(reprun)\n            runout = (n - len(picks)) % len(reprun)\n            if 0 == cyc % 2:\n                picks.extend(reprun[:runout])\n            else:\n                picks.extend(reprun[runout:])\n        picks.sort(reverse=True)\n        np = len(picks)\n        sth = sum(picks[0:np:2]) - sum(picks[-1:np:2])\n        results.append(abs(sth))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "sth = sum(picks[0:np:2]) - sum(picks[1:np:2])",
      "mutated_line": "sth = sum(picks[0:np:2]) - sum(picks[1:np:3])",
      "code": "def calculate_team_strength_difference(T, test_cases):\n    mdl = 1000000\n    results = []\n    for case in test_cases:\n        (n, a, b, c, d) = case\n        sqd = {}\n        sqd[d] = 0\n        r = d\n        for e in range(1, n):\n            r = ((a * r + b) * r + c) % mdl\n            try:\n                sqd[r] *= 1\n                break\n            except KeyError:\n                sqd[r] = e\n        if len(sqd) == n:\n            picks = list(sqd.keys())\n        else:\n            inrun = list(sqd.items())\n            inrun.sort(key=lambda x: x[1])\n            nunq = len(sqd)\n            repst = sqd[r]\n            picks = [inrun[e][0] for e in range(0, repst)]\n            reprun = [inrun[e][0] for e in range(repst, nunq)]\n            cyc = (n - len(picks)) // len(reprun)\n            runout = (n - len(picks)) % len(reprun)\n            if 0 == cyc % 2:\n                picks.extend(reprun[:runout])\n            else:\n                picks.extend(reprun[runout:])\n        picks.sort(reverse=True)\n        np = len(picks)\n        sth = sum(picks[0:np:2]) - sum(picks[1:np:3])\n        results.append(abs(sth))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "sth = sum(picks[0:np:2]) - sum(picks[1:np:2])",
      "mutated_line": "sth = sum(picks[0:np:2]) - sum(picks[1:np:1])",
      "code": "def calculate_team_strength_difference(T, test_cases):\n    mdl = 1000000\n    results = []\n    for case in test_cases:\n        (n, a, b, c, d) = case\n        sqd = {}\n        sqd[d] = 0\n        r = d\n        for e in range(1, n):\n            r = ((a * r + b) * r + c) % mdl\n            try:\n                sqd[r] *= 1\n                break\n            except KeyError:\n                sqd[r] = e\n        if len(sqd) == n:\n            picks = list(sqd.keys())\n        else:\n            inrun = list(sqd.items())\n            inrun.sort(key=lambda x: x[1])\n            nunq = len(sqd)\n            repst = sqd[r]\n            picks = [inrun[e][0] for e in range(0, repst)]\n            reprun = [inrun[e][0] for e in range(repst, nunq)]\n            cyc = (n - len(picks)) // len(reprun)\n            runout = (n - len(picks)) % len(reprun)\n            if 0 == cyc % 2:\n                picks.extend(reprun[:runout])\n            else:\n                picks.extend(reprun[runout:])\n        picks.sort(reverse=True)\n        np = len(picks)\n        sth = sum(picks[0:np:2]) - sum(picks[1:np:1])\n        results.append(abs(sth))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "sth = sum(picks[0:np:2]) - sum(picks[1:np:2])",
      "mutated_line": "sth = sum(picks[0:np:2]) - sum(picks[1:np:0])",
      "code": "def calculate_team_strength_difference(T, test_cases):\n    mdl = 1000000\n    results = []\n    for case in test_cases:\n        (n, a, b, c, d) = case\n        sqd = {}\n        sqd[d] = 0\n        r = d\n        for e in range(1, n):\n            r = ((a * r + b) * r + c) % mdl\n            try:\n                sqd[r] *= 1\n                break\n            except KeyError:\n                sqd[r] = e\n        if len(sqd) == n:\n            picks = list(sqd.keys())\n        else:\n            inrun = list(sqd.items())\n            inrun.sort(key=lambda x: x[1])\n            nunq = len(sqd)\n            repst = sqd[r]\n            picks = [inrun[e][0] for e in range(0, repst)]\n            reprun = [inrun[e][0] for e in range(repst, nunq)]\n            cyc = (n - len(picks)) // len(reprun)\n            runout = (n - len(picks)) % len(reprun)\n            if 0 == cyc % 2:\n                picks.extend(reprun[:runout])\n            else:\n                picks.extend(reprun[runout:])\n        picks.sort(reverse=True)\n        np = len(picks)\n        sth = sum(picks[0:np:2]) - sum(picks[1:np:0])\n        results.append(abs(sth))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "sth = sum(picks[0:np:2]) - sum(picks[1:np:2])",
      "mutated_line": "sth = sum(picks[0:np:2]) - sum(picks[1:np:1])",
      "code": "def calculate_team_strength_difference(T, test_cases):\n    mdl = 1000000\n    results = []\n    for case in test_cases:\n        (n, a, b, c, d) = case\n        sqd = {}\n        sqd[d] = 0\n        r = d\n        for e in range(1, n):\n            r = ((a * r + b) * r + c) % mdl\n            try:\n                sqd[r] *= 1\n                break\n            except KeyError:\n                sqd[r] = e\n        if len(sqd) == n:\n            picks = list(sqd.keys())\n        else:\n            inrun = list(sqd.items())\n            inrun.sort(key=lambda x: x[1])\n            nunq = len(sqd)\n            repst = sqd[r]\n            picks = [inrun[e][0] for e in range(0, repst)]\n            reprun = [inrun[e][0] for e in range(repst, nunq)]\n            cyc = (n - len(picks)) // len(reprun)\n            runout = (n - len(picks)) % len(reprun)\n            if 0 == cyc % 2:\n                picks.extend(reprun[:runout])\n            else:\n                picks.extend(reprun[runout:])\n        picks.sort(reverse=True)\n        np = len(picks)\n        sth = sum(picks[0:np:2]) - sum(picks[1:np:1])\n        results.append(abs(sth))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "sth = sum(picks[0:np:2]) - sum(picks[1:np:2])",
      "mutated_line": "sth = sum(picks[0:np:2]) - sum(picks[1:np:-2])",
      "code": "def calculate_team_strength_difference(T, test_cases):\n    mdl = 1000000\n    results = []\n    for case in test_cases:\n        (n, a, b, c, d) = case\n        sqd = {}\n        sqd[d] = 0\n        r = d\n        for e in range(1, n):\n            r = ((a * r + b) * r + c) % mdl\n            try:\n                sqd[r] *= 1\n                break\n            except KeyError:\n                sqd[r] = e\n        if len(sqd) == n:\n            picks = list(sqd.keys())\n        else:\n            inrun = list(sqd.items())\n            inrun.sort(key=lambda x: x[1])\n            nunq = len(sqd)\n            repst = sqd[r]\n            picks = [inrun[e][0] for e in range(0, repst)]\n            reprun = [inrun[e][0] for e in range(repst, nunq)]\n            cyc = (n - len(picks)) // len(reprun)\n            runout = (n - len(picks)) % len(reprun)\n            if 0 == cyc % 2:\n                picks.extend(reprun[:runout])\n            else:\n                picks.extend(reprun[runout:])\n        picks.sort(reverse=True)\n        np = len(picks)\n        sth = sum(picks[0:np:2]) - sum(picks[1:np:-2])\n        results.append(abs(sth))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "r = ((a * r + b) * r + c) % mdl",
      "mutated_line": "r = ((a / r + b) * r + c) % mdl",
      "code": "def calculate_team_strength_difference(T, test_cases):\n    mdl = 1000000\n    results = []\n    for case in test_cases:\n        (n, a, b, c, d) = case\n        sqd = {}\n        sqd[d] = 0\n        r = d\n        for e in range(1, n):\n            r = ((a / r + b) * r + c) % mdl\n            try:\n                sqd[r] *= 1\n                break\n            except KeyError:\n                sqd[r] = e\n        if len(sqd) == n:\n            picks = list(sqd.keys())\n        else:\n            inrun = list(sqd.items())\n            inrun.sort(key=lambda x: x[1])\n            nunq = len(sqd)\n            repst = sqd[r]\n            picks = [inrun[e][0] for e in range(0, repst)]\n            reprun = [inrun[e][0] for e in range(repst, nunq)]\n            cyc = (n - len(picks)) // len(reprun)\n            runout = (n - len(picks)) % len(reprun)\n            if 0 == cyc % 2:\n                picks.extend(reprun[:runout])\n            else:\n                picks.extend(reprun[runout:])\n        picks.sort(reverse=True)\n        np = len(picks)\n        sth = sum(picks[0:np:2]) - sum(picks[1:np:2])\n        results.append(abs(sth))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "r = ((a * r + b) * r + c) % mdl",
      "mutated_line": "r = ((a + r + b) * r + c) % mdl",
      "code": "def calculate_team_strength_difference(T, test_cases):\n    mdl = 1000000\n    results = []\n    for case in test_cases:\n        (n, a, b, c, d) = case\n        sqd = {}\n        sqd[d] = 0\n        r = d\n        for e in range(1, n):\n            r = ((a + r + b) * r + c) % mdl\n            try:\n                sqd[r] *= 1\n                break\n            except KeyError:\n                sqd[r] = e\n        if len(sqd) == n:\n            picks = list(sqd.keys())\n        else:\n            inrun = list(sqd.items())\n            inrun.sort(key=lambda x: x[1])\n            nunq = len(sqd)\n            repst = sqd[r]\n            picks = [inrun[e][0] for e in range(0, repst)]\n            reprun = [inrun[e][0] for e in range(repst, nunq)]\n            cyc = (n - len(picks)) // len(reprun)\n            runout = (n - len(picks)) % len(reprun)\n            if 0 == cyc % 2:\n                picks.extend(reprun[:runout])\n            else:\n                picks.extend(reprun[runout:])\n        picks.sort(reverse=True)\n        np = len(picks)\n        sth = sum(picks[0:np:2]) - sum(picks[1:np:2])\n        results.append(abs(sth))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "r = ((a * r + b) * r + c) % mdl",
      "mutated_line": "r = ((a ** r + b) * r + c) % mdl",
      "code": "def calculate_team_strength_difference(T, test_cases):\n    mdl = 1000000\n    results = []\n    for case in test_cases:\n        (n, a, b, c, d) = case\n        sqd = {}\n        sqd[d] = 0\n        r = d\n        for e in range(1, n):\n            r = ((a ** r + b) * r + c) % mdl\n            try:\n                sqd[r] *= 1\n                break\n            except KeyError:\n                sqd[r] = e\n        if len(sqd) == n:\n            picks = list(sqd.keys())\n        else:\n            inrun = list(sqd.items())\n            inrun.sort(key=lambda x: x[1])\n            nunq = len(sqd)\n            repst = sqd[r]\n            picks = [inrun[e][0] for e in range(0, repst)]\n            reprun = [inrun[e][0] for e in range(repst, nunq)]\n            cyc = (n - len(picks)) // len(reprun)\n            runout = (n - len(picks)) % len(reprun)\n            if 0 == cyc % 2:\n                picks.extend(reprun[:runout])\n            else:\n                picks.extend(reprun[runout:])\n        picks.sort(reverse=True)\n        np = len(picks)\n        sth = sum(picks[0:np:2]) - sum(picks[1:np:2])\n        results.append(abs(sth))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "inrun.sort(key=lambda x: x[1])",
      "mutated_line": "inrun.sort(key=lambda x: x[2])",
      "code": "def calculate_team_strength_difference(T, test_cases):\n    mdl = 1000000\n    results = []\n    for case in test_cases:\n        (n, a, b, c, d) = case\n        sqd = {}\n        sqd[d] = 0\n        r = d\n        for e in range(1, n):\n            r = ((a * r + b) * r + c) % mdl\n            try:\n                sqd[r] *= 1\n                break\n            except KeyError:\n                sqd[r] = e\n        if len(sqd) == n:\n            picks = list(sqd.keys())\n        else:\n            inrun = list(sqd.items())\n            inrun.sort(key=lambda x: x[2])\n            nunq = len(sqd)\n            repst = sqd[r]\n            picks = [inrun[e][0] for e in range(0, repst)]\n            reprun = [inrun[e][0] for e in range(repst, nunq)]\n            cyc = (n - len(picks)) // len(reprun)\n            runout = (n - len(picks)) % len(reprun)\n            if 0 == cyc % 2:\n                picks.extend(reprun[:runout])\n            else:\n                picks.extend(reprun[runout:])\n        picks.sort(reverse=True)\n        np = len(picks)\n        sth = sum(picks[0:np:2]) - sum(picks[1:np:2])\n        results.append(abs(sth))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "inrun.sort(key=lambda x: x[1])",
      "mutated_line": "inrun.sort(key=lambda x: x[0])",
      "code": "def calculate_team_strength_difference(T, test_cases):\n    mdl = 1000000\n    results = []\n    for case in test_cases:\n        (n, a, b, c, d) = case\n        sqd = {}\n        sqd[d] = 0\n        r = d\n        for e in range(1, n):\n            r = ((a * r + b) * r + c) % mdl\n            try:\n                sqd[r] *= 1\n                break\n            except KeyError:\n                sqd[r] = e\n        if len(sqd) == n:\n            picks = list(sqd.keys())\n        else:\n            inrun = list(sqd.items())\n            inrun.sort(key=lambda x: x[0])\n            nunq = len(sqd)\n            repst = sqd[r]\n            picks = [inrun[e][0] for e in range(0, repst)]\n            reprun = [inrun[e][0] for e in range(repst, nunq)]\n            cyc = (n - len(picks)) // len(reprun)\n            runout = (n - len(picks)) % len(reprun)\n            if 0 == cyc % 2:\n                picks.extend(reprun[:runout])\n            else:\n                picks.extend(reprun[runout:])\n        picks.sort(reverse=True)\n        np = len(picks)\n        sth = sum(picks[0:np:2]) - sum(picks[1:np:2])\n        results.append(abs(sth))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "inrun.sort(key=lambda x: x[1])",
      "mutated_line": "inrun.sort(key=lambda x: x[0])",
      "code": "def calculate_team_strength_difference(T, test_cases):\n    mdl = 1000000\n    results = []\n    for case in test_cases:\n        (n, a, b, c, d) = case\n        sqd = {}\n        sqd[d] = 0\n        r = d\n        for e in range(1, n):\n            r = ((a * r + b) * r + c) % mdl\n            try:\n                sqd[r] *= 1\n                break\n            except KeyError:\n                sqd[r] = e\n        if len(sqd) == n:\n            picks = list(sqd.keys())\n        else:\n            inrun = list(sqd.items())\n            inrun.sort(key=lambda x: x[0])\n            nunq = len(sqd)\n            repst = sqd[r]\n            picks = [inrun[e][0] for e in range(0, repst)]\n            reprun = [inrun[e][0] for e in range(repst, nunq)]\n            cyc = (n - len(picks)) // len(reprun)\n            runout = (n - len(picks)) % len(reprun)\n            if 0 == cyc % 2:\n                picks.extend(reprun[:runout])\n            else:\n                picks.extend(reprun[runout:])\n        picks.sort(reverse=True)\n        np = len(picks)\n        sth = sum(picks[0:np:2]) - sum(picks[1:np:2])\n        results.append(abs(sth))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "inrun.sort(key=lambda x: x[1])",
      "mutated_line": "inrun.sort(key=lambda x: x[-1])",
      "code": "def calculate_team_strength_difference(T, test_cases):\n    mdl = 1000000\n    results = []\n    for case in test_cases:\n        (n, a, b, c, d) = case\n        sqd = {}\n        sqd[d] = 0\n        r = d\n        for e in range(1, n):\n            r = ((a * r + b) * r + c) % mdl\n            try:\n                sqd[r] *= 1\n                break\n            except KeyError:\n                sqd[r] = e\n        if len(sqd) == n:\n            picks = list(sqd.keys())\n        else:\n            inrun = list(sqd.items())\n            inrun.sort(key=lambda x: x[-1])\n            nunq = len(sqd)\n            repst = sqd[r]\n            picks = [inrun[e][0] for e in range(0, repst)]\n            reprun = [inrun[e][0] for e in range(repst, nunq)]\n            cyc = (n - len(picks)) // len(reprun)\n            runout = (n - len(picks)) % len(reprun)\n            if 0 == cyc % 2:\n                picks.extend(reprun[:runout])\n            else:\n                picks.extend(reprun[runout:])\n        picks.sort(reverse=True)\n        np = len(picks)\n        sth = sum(picks[0:np:2]) - sum(picks[1:np:2])\n        results.append(abs(sth))\n    return results"
    }
  ]
}