{
  "task_id": "taco_16507",
  "entry_point": "min_trees_to_chop",
  "mutant_count": 209,
  "mutants": [
    {
      "operator": "LCR",
      "lineno": 15,
      "original_line": "if a <= n and b <= m:",
      "mutated_line": "if a <= n or b <= m:",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n or b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "LCR",
      "lineno": 21,
      "original_line": "if b <= n and a <= m:",
      "mutated_line": "if b <= n or a <= m:",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n or a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]",
      "mutated_line": "prefix_sum = [[0] / (m + 1) for _ in range(n + 1)]",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] / (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]",
      "mutated_line": "prefix_sum = [[0] + (m + 1) for _ in range(n + 1)]",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] + (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]",
      "mutated_line": "prefix_sum = [[0] ** (m + 1) for _ in range(n + 1)]",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] ** (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(2, n + 1):",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(2, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(0, n + 1):",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(0, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(0, n + 1):",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(0, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(-1, n + 1):",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(-1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n - 1):",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n - 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n * 1):",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n * 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]",
      "mutated_line": "return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] - prefix_sum[x1 - 1][y1 - 1]",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] - prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]",
      "mutated_line": "return (prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1]) * prefix_sum[x1 - 1][y1 - 1]",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return (prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1]) * prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "min_trees = float('inf')",
      "mutated_line": "min_trees = float('')",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if a <= n and b <= m:",
      "mutated_line": "if a < n and b <= m:",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a < n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if a <= n and b <= m:",
      "mutated_line": "if a > n and b <= m:",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a > n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if a <= n and b <= m:",
      "mutated_line": "if a == n and b <= m:",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a == n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if a <= n and b <= m:",
      "mutated_line": "if a <= n and b < m:",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b < m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if a <= n and b <= m:",
      "mutated_line": "if a <= n and b > m:",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b > m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if a <= n and b <= m:",
      "mutated_line": "if a <= n and b == m:",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b == m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if b <= n and a <= m:",
      "mutated_line": "if b < n and a <= m:",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b < n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if b <= n and a <= m:",
      "mutated_line": "if b > n and a <= m:",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b > n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if b <= n and a <= m:",
      "mutated_line": "if b == n and a <= m:",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b == n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if b <= n and a <= m:",
      "mutated_line": "if b <= n and a < m:",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a < m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if b <= n and a <= m:",
      "mutated_line": "if b <= n and a > m:",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a > m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if b <= n and a <= m:",
      "mutated_line": "if b <= n and a == m:",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a == m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]",
      "mutated_line": "prefix_sum = [[0] * (m - 1) for _ in range(n + 1)]",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m - 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]",
      "mutated_line": "prefix_sum = [[0] * (m * 1) for _ in range(n + 1)]",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m * 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + 2):",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 2):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + 0):",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 0):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + 0):",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 0):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + -1):",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + -1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for j in range(1, m + 1):",
      "mutated_line": "for j in range(2, m + 1):",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(2, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for j in range(1, m + 1):",
      "mutated_line": "for j in range(0, m + 1):",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(0, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for j in range(1, m + 1):",
      "mutated_line": "for j in range(0, m + 1):",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(0, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for j in range(1, m + 1):",
      "mutated_line": "for j in range(-1, m + 1):",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(-1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "for j in range(1, m + 1):",
      "mutated_line": "for j in range(1, m - 1):",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m - 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "for j in range(1, m + 1):",
      "mutated_line": "for j in range(1, m * 1):",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m * 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]",
      "mutated_line": "prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] + prefix_sum[i - 1][j - 1]",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] + prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]",
      "mutated_line": "prefix_sum[i][j] = (garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1]) * prefix_sum[i - 1][j - 1]",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = (garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1]) * prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]",
      "mutated_line": "return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] + prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] + prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]",
      "mutated_line": "return (prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2]) * prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return (prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2]) * prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for i in range(1, n - a + 2):",
      "mutated_line": "for i in range(2, n - a + 2):",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(2, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for i in range(1, n - a + 2):",
      "mutated_line": "for i in range(0, n - a + 2):",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(0, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for i in range(1, n - a + 2):",
      "mutated_line": "for i in range(0, n - a + 2):",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(0, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for i in range(1, n - a + 2):",
      "mutated_line": "for i in range(-1, n - a + 2):",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(-1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "for i in range(1, n - a + 2):",
      "mutated_line": "for i in range(1, n - a - 2):",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a - 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "for i in range(1, n - a + 2):",
      "mutated_line": "for i in range(1, (n - a) * 2):",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, (n - a) * 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for i in range(1, n - b + 2):",
      "mutated_line": "for i in range(2, n - b + 2):",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(2, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for i in range(1, n - b + 2):",
      "mutated_line": "for i in range(0, n - b + 2):",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(0, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for i in range(1, n - b + 2):",
      "mutated_line": "for i in range(0, n - b + 2):",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(0, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for i in range(1, n - b + 2):",
      "mutated_line": "for i in range(-1, n - b + 2):",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(-1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "for i in range(1, n - b + 2):",
      "mutated_line": "for i in range(1, n - b - 2):",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b - 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "for i in range(1, n - b + 2):",
      "mutated_line": "for i in range(1, (n - b) * 2):",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, (n - b) * 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]",
      "mutated_line": "prefix_sum = [[1] * (m + 1) for _ in range(n + 1)]",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[1] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]",
      "mutated_line": "prefix_sum = [[-1] * (m + 1) for _ in range(n + 1)]",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[-1] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]",
      "mutated_line": "prefix_sum = [[1] * (m + 1) for _ in range(n + 1)]",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[1] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]",
      "mutated_line": "prefix_sum = [[0] * (m + 2) for _ in range(n + 1)]",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 2) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]",
      "mutated_line": "prefix_sum = [[0] * (m + 0) for _ in range(n + 1)]",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 0) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]",
      "mutated_line": "prefix_sum = [[0] * (m + 0) for _ in range(n + 1)]",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 0) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]",
      "mutated_line": "prefix_sum = [[0] * (m + -1) for _ in range(n + 1)]",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + -1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]",
      "mutated_line": "prefix_sum = [[0] * (m + 1) for _ in range(n - 1)]",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n - 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]",
      "mutated_line": "prefix_sum = [[0] * (m + 1) for _ in range(n * 1)]",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n * 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for j in range(1, m + 1):",
      "mutated_line": "for j in range(1, m + 2):",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 2):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for j in range(1, m + 1):",
      "mutated_line": "for j in range(1, m + 0):",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 0):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for j in range(1, m + 1):",
      "mutated_line": "for j in range(1, m + 0):",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 0):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for j in range(1, m + 1):",
      "mutated_line": "for j in range(1, m + -1):",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + -1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]",
      "mutated_line": "prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] - prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] - prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]",
      "mutated_line": "prefix_sum[i][j] = (garden[i - 1][j - 1] + prefix_sum[i - 1][j]) * prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = (garden[i - 1][j - 1] + prefix_sum[i - 1][j]) * prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]",
      "mutated_line": "return prefix_sum[x2][y2] + prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] + prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]",
      "mutated_line": "return prefix_sum[x2][y2] * prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] * prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]",
      "mutated_line": "return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 + 1]",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 + 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]",
      "mutated_line": "return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 * 1]",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 * 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "for i in range(1, n - a + 2):",
      "mutated_line": "for i in range(1, n + a + 2):",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n + a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "for i in range(1, n - a + 2):",
      "mutated_line": "for i in range(1, n * a + 2):",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n * a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for i in range(1, n - a + 2):",
      "mutated_line": "for i in range(1, n - a + 3):",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 3):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for i in range(1, n - a + 2):",
      "mutated_line": "for i in range(1, n - a + 1):",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 1):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for i in range(1, n - a + 2):",
      "mutated_line": "for i in range(1, n - a + 0):",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 0):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for i in range(1, n - a + 2):",
      "mutated_line": "for i in range(1, n - a + 1):",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 1):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for i in range(1, n - a + 2):",
      "mutated_line": "for i in range(1, n - a + -2):",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + -2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for j in range(1, m - b + 2):",
      "mutated_line": "for j in range(2, m - b + 2):",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(2, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for j in range(1, m - b + 2):",
      "mutated_line": "for j in range(0, m - b + 2):",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(0, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for j in range(1, m - b + 2):",
      "mutated_line": "for j in range(0, m - b + 2):",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(0, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for j in range(1, m - b + 2):",
      "mutated_line": "for j in range(-1, m - b + 2):",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(-1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "for j in range(1, m - b + 2):",
      "mutated_line": "for j in range(1, m - b - 2):",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b - 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "for j in range(1, m - b + 2):",
      "mutated_line": "for j in range(1, (m - b) * 2):",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, (m - b) * 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "for i in range(1, n - b + 2):",
      "mutated_line": "for i in range(1, n + b + 2):",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n + b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "for i in range(1, n - b + 2):",
      "mutated_line": "for i in range(1, n * b + 2):",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n * b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for i in range(1, n - b + 2):",
      "mutated_line": "for i in range(1, n - b + 3):",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 3):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for i in range(1, n - b + 2):",
      "mutated_line": "for i in range(1, n - b + 1):",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 1):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for i in range(1, n - b + 2):",
      "mutated_line": "for i in range(1, n - b + 0):",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 0):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for i in range(1, n - b + 2):",
      "mutated_line": "for i in range(1, n - b + 1):",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 1):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for i in range(1, n - b + 2):",
      "mutated_line": "for i in range(1, n - b + -2):",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + -2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for j in range(1, m - a + 2):",
      "mutated_line": "for j in range(2, m - a + 2):",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(2, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for j in range(1, m - a + 2):",
      "mutated_line": "for j in range(0, m - a + 2):",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(0, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for j in range(1, m - a + 2):",
      "mutated_line": "for j in range(0, m - a + 2):",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(0, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for j in range(1, m - a + 2):",
      "mutated_line": "for j in range(-1, m - a + 2):",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(-1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "for j in range(1, m - a + 2):",
      "mutated_line": "for j in range(1, m - a - 2):",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a - 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "for j in range(1, m - a + 2):",
      "mutated_line": "for j in range(1, (m - a) * 2):",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, (m - a) * 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]",
      "mutated_line": "prefix_sum = [[0] * (m + 1) for _ in range(n + 2)]",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 2)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]",
      "mutated_line": "prefix_sum = [[0] * (m + 1) for _ in range(n + 0)]",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 0)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]",
      "mutated_line": "prefix_sum = [[0] * (m + 1) for _ in range(n + 0)]",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 0)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]",
      "mutated_line": "prefix_sum = [[0] * (m + 1) for _ in range(n + -1)]",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + -1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]",
      "mutated_line": "prefix_sum[i][j] = garden[i - 1][j - 1] - prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] - prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]",
      "mutated_line": "prefix_sum[i][j] = garden[i - 1][j - 1] * prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] * prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]",
      "mutated_line": "prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j + 1]",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j + 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]",
      "mutated_line": "prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j * 1]",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j * 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]",
      "mutated_line": "return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 + 1] + prefix_sum[x1 - 1][y1 - 1]",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 + 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]",
      "mutated_line": "return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 * 1] + prefix_sum[x1 - 1][y1 - 1]",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 * 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]",
      "mutated_line": "return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 + 1][y1 - 1]",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 + 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]",
      "mutated_line": "return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 * 1][y1 - 1]",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 * 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]",
      "mutated_line": "return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 2]",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 2]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]",
      "mutated_line": "return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 0]",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 0]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]",
      "mutated_line": "return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 0]",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 0]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]",
      "mutated_line": "return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - -1]",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - -1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "for j in range(1, m - b + 2):",
      "mutated_line": "for j in range(1, m + b + 2):",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m + b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "for j in range(1, m - b + 2):",
      "mutated_line": "for j in range(1, m * b + 2):",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m * b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for j in range(1, m - b + 2):",
      "mutated_line": "for j in range(1, m - b + 3):",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 3):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for j in range(1, m - b + 2):",
      "mutated_line": "for j in range(1, m - b + 1):",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 1):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for j in range(1, m - b + 2):",
      "mutated_line": "for j in range(1, m - b + 0):",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 0):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for j in range(1, m - b + 2):",
      "mutated_line": "for j in range(1, m - b + 1):",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 1):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for j in range(1, m - b + 2):",
      "mutated_line": "for j in range(1, m - b + -2):",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + -2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "for j in range(1, m - a + 2):",
      "mutated_line": "for j in range(1, m + a + 2):",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m + a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "for j in range(1, m - a + 2):",
      "mutated_line": "for j in range(1, m * a + 2):",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m * a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for j in range(1, m - a + 2):",
      "mutated_line": "for j in range(1, m - a + 3):",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 3):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for j in range(1, m - a + 2):",
      "mutated_line": "for j in range(1, m - a + 1):",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 1):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for j in range(1, m - a + 2):",
      "mutated_line": "for j in range(1, m - a + 0):",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 0):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for j in range(1, m - a + 2):",
      "mutated_line": "for j in range(1, m - a + 1):",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 1):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for j in range(1, m - a + 2):",
      "mutated_line": "for j in range(1, m - a + -2):",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + -2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]",
      "mutated_line": "prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j + 1] - prefix_sum[i - 1][j - 1]",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j + 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]",
      "mutated_line": "prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j * 1] - prefix_sum[i - 1][j - 1]",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j * 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]",
      "mutated_line": "prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i + 1][j - 1]",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i + 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]",
      "mutated_line": "prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i * 1][j - 1]",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i * 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]",
      "mutated_line": "prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 2]",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 2]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]",
      "mutated_line": "prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 0]",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 0]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]",
      "mutated_line": "prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 0]",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 0]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]",
      "mutated_line": "prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - -1]",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - -1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]",
      "mutated_line": "return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 2] + prefix_sum[x1 - 1][y1 - 1]",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 2] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]",
      "mutated_line": "return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 0] + prefix_sum[x1 - 1][y1 - 1]",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 0] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]",
      "mutated_line": "return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 0] + prefix_sum[x1 - 1][y1 - 1]",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 0] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]",
      "mutated_line": "return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - -1] + prefix_sum[x1 - 1][y1 - 1]",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - -1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]",
      "mutated_line": "return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 2][y1 - 1]",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 2][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]",
      "mutated_line": "return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 0][y1 - 1]",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 0][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]",
      "mutated_line": "return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 0][y1 - 1]",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 0][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]",
      "mutated_line": "return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - -1][y1 - 1]",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - -1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))",
      "mutated_line": "min_trees = min(min_trees, count_trees(i, j, i + a + 1, j + b - 1))",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a + 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))",
      "mutated_line": "min_trees = min(min_trees, count_trees(i, j, (i + a) * 1, j + b - 1))",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, (i + a) * 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))",
      "mutated_line": "min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b + 1))",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b + 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))",
      "mutated_line": "min_trees = min(min_trees, count_trees(i, j, i + a - 1, (j + b) * 1))",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, (j + b) * 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))",
      "mutated_line": "min_trees = min(min_trees, count_trees(i, j, i + b + 1, j + a - 1))",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b + 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))",
      "mutated_line": "min_trees = min(min_trees, count_trees(i, j, (i + b) * 1, j + a - 1))",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, (i + b) * 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))",
      "mutated_line": "min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a + 1))",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a + 1))\n    return min_trees"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))",
      "mutated_line": "min_trees = min(min_trees, count_trees(i, j, i + b - 1, (j + a) * 1))",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, (j + a) * 1))\n    return min_trees"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]",
      "mutated_line": "prefix_sum[i][j] = garden[i - 1][j + 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j + 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]",
      "mutated_line": "prefix_sum[i][j] = garden[i - 1][j * 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j * 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]",
      "mutated_line": "prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 2] - prefix_sum[i - 1][j - 1]",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 2] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]",
      "mutated_line": "prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 0] - prefix_sum[i - 1][j - 1]",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 0] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]",
      "mutated_line": "prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 0] - prefix_sum[i - 1][j - 1]",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 0] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]",
      "mutated_line": "prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - -1] - prefix_sum[i - 1][j - 1]",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - -1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]",
      "mutated_line": "prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 2][j - 1]",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 2][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]",
      "mutated_line": "prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 0][j - 1]",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 0][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]",
      "mutated_line": "prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 0][j - 1]",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 0][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]",
      "mutated_line": "prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - -1][j - 1]",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - -1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]",
      "mutated_line": "return prefix_sum[x2][y2] - prefix_sum[x1 + 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 + 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]",
      "mutated_line": "return prefix_sum[x2][y2] - prefix_sum[x1 * 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 * 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))",
      "mutated_line": "min_trees = min(min_trees, count_trees(i, j, i - a - 1, j + b - 1))",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i - a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))",
      "mutated_line": "min_trees = min(min_trees, count_trees(i, j, i * a - 1, j + b - 1))",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i * a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))",
      "mutated_line": "min_trees = min(min_trees, count_trees(i, j, i + a - 2, j + b - 1))",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 2, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))",
      "mutated_line": "min_trees = min(min_trees, count_trees(i, j, i + a - 0, j + b - 1))",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 0, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))",
      "mutated_line": "min_trees = min(min_trees, count_trees(i, j, i + a - 0, j + b - 1))",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 0, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))",
      "mutated_line": "min_trees = min(min_trees, count_trees(i, j, i + a - -1, j + b - 1))",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - -1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))",
      "mutated_line": "min_trees = min(min_trees, count_trees(i, j, i + a - 1, j - b - 1))",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j - b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))",
      "mutated_line": "min_trees = min(min_trees, count_trees(i, j, i + a - 1, j * b - 1))",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j * b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))",
      "mutated_line": "min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 2))",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 2))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))",
      "mutated_line": "min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 0))",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 0))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))",
      "mutated_line": "min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 0))",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 0))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))",
      "mutated_line": "min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - -1))",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - -1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))",
      "mutated_line": "min_trees = min(min_trees, count_trees(i, j, i - b - 1, j + a - 1))",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i - b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))",
      "mutated_line": "min_trees = min(min_trees, count_trees(i, j, i * b - 1, j + a - 1))",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i * b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))",
      "mutated_line": "min_trees = min(min_trees, count_trees(i, j, i + b - 2, j + a - 1))",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 2, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))",
      "mutated_line": "min_trees = min(min_trees, count_trees(i, j, i + b - 0, j + a - 1))",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 0, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))",
      "mutated_line": "min_trees = min(min_trees, count_trees(i, j, i + b - 0, j + a - 1))",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 0, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))",
      "mutated_line": "min_trees = min(min_trees, count_trees(i, j, i + b - -1, j + a - 1))",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - -1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))",
      "mutated_line": "min_trees = min(min_trees, count_trees(i, j, i + b - 1, j - a - 1))",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j - a - 1))\n    return min_trees"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))",
      "mutated_line": "min_trees = min(min_trees, count_trees(i, j, i + b - 1, j * a - 1))",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j * a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))",
      "mutated_line": "min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 2))",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 2))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))",
      "mutated_line": "min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 0))",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 0))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))",
      "mutated_line": "min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 0))",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 0))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))",
      "mutated_line": "min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - -1))",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - -1))\n    return min_trees"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]",
      "mutated_line": "prefix_sum[i][j] = garden[i + 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i + 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]",
      "mutated_line": "prefix_sum[i][j] = garden[i * 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i * 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]",
      "mutated_line": "prefix_sum[i][j] = garden[i - 1][j - 2] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 2] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]",
      "mutated_line": "prefix_sum[i][j] = garden[i - 1][j - 0] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 0] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]",
      "mutated_line": "prefix_sum[i][j] = garden[i - 1][j - 0] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 0] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]",
      "mutated_line": "prefix_sum[i][j] = garden[i - 1][j - -1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - -1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]",
      "mutated_line": "prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i + 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i + 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]",
      "mutated_line": "prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i * 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i * 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]",
      "mutated_line": "return prefix_sum[x2][y2] - prefix_sum[x1 - 2][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 2][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]",
      "mutated_line": "return prefix_sum[x2][y2] - prefix_sum[x1 - 0][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 0][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]",
      "mutated_line": "return prefix_sum[x2][y2] - prefix_sum[x1 - 0][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 0][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]",
      "mutated_line": "return prefix_sum[x2][y2] - prefix_sum[x1 - -1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - -1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]",
      "mutated_line": "prefix_sum[i][j] = garden[i - 2][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 2][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]",
      "mutated_line": "prefix_sum[i][j] = garden[i - 0][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 0][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]",
      "mutated_line": "prefix_sum[i][j] = garden[i - 0][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 0][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]",
      "mutated_line": "prefix_sum[i][j] = garden[i - -1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - -1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]",
      "mutated_line": "prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 2][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 2][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]",
      "mutated_line": "prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 0][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 0][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]",
      "mutated_line": "prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 0][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 0][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]",
      "mutated_line": "prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - -1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]",
      "code": "def min_trees_to_chop(n, m, garden, a, b):\n    prefix_sum = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix_sum[i][j] = garden[i - 1][j - 1] + prefix_sum[i - -1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    def count_trees(x1, y1, x2, y2):\n        return prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]\n    min_trees = float('inf')\n    if a <= n and b <= m:\n        for i in range(1, n - a + 2):\n            for j in range(1, m - b + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + a - 1, j + b - 1))\n    if b <= n and a <= m:\n        for i in range(1, n - b + 2):\n            for j in range(1, m - a + 2):\n                min_trees = min(min_trees, count_trees(i, j, i + b - 1, j + a - 1))\n    return min_trees"
    }
  ]
}