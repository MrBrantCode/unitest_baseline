{
  "task_id": "taco_4466",
  "entry_point": "closest_divisible_number",
  "mutant_count": 28,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "quotient = N // M",
      "mutated_line": "quotient = N / M",
      "code": "def closest_divisible_number(N: int, M: int) -> int:\n    quotient = N / M\n    lower_bound = quotient * M\n    upper_bound = (quotient + 1) * M\n    if abs(N - lower_bound) < abs(N - upper_bound):\n        return lower_bound\n    elif abs(N - lower_bound) > abs(N - upper_bound):\n        return upper_bound\n    else:\n        return max(lower_bound, upper_bound, key=abs)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "quotient = N // M",
      "mutated_line": "quotient = N * M",
      "code": "def closest_divisible_number(N: int, M: int) -> int:\n    quotient = N * M\n    lower_bound = quotient * M\n    upper_bound = (quotient + 1) * M\n    if abs(N - lower_bound) < abs(N - upper_bound):\n        return lower_bound\n    elif abs(N - lower_bound) > abs(N - upper_bound):\n        return upper_bound\n    else:\n        return max(lower_bound, upper_bound, key=abs)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "lower_bound = quotient * M",
      "mutated_line": "lower_bound = quotient / M",
      "code": "def closest_divisible_number(N: int, M: int) -> int:\n    quotient = N // M\n    lower_bound = quotient / M\n    upper_bound = (quotient + 1) * M\n    if abs(N - lower_bound) < abs(N - upper_bound):\n        return lower_bound\n    elif abs(N - lower_bound) > abs(N - upper_bound):\n        return upper_bound\n    else:\n        return max(lower_bound, upper_bound, key=abs)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "lower_bound = quotient * M",
      "mutated_line": "lower_bound = quotient + M",
      "code": "def closest_divisible_number(N: int, M: int) -> int:\n    quotient = N // M\n    lower_bound = quotient + M\n    upper_bound = (quotient + 1) * M\n    if abs(N - lower_bound) < abs(N - upper_bound):\n        return lower_bound\n    elif abs(N - lower_bound) > abs(N - upper_bound):\n        return upper_bound\n    else:\n        return max(lower_bound, upper_bound, key=abs)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "lower_bound = quotient * M",
      "mutated_line": "lower_bound = quotient ** M",
      "code": "def closest_divisible_number(N: int, M: int) -> int:\n    quotient = N // M\n    lower_bound = quotient ** M\n    upper_bound = (quotient + 1) * M\n    if abs(N - lower_bound) < abs(N - upper_bound):\n        return lower_bound\n    elif abs(N - lower_bound) > abs(N - upper_bound):\n        return upper_bound\n    else:\n        return max(lower_bound, upper_bound, key=abs)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "upper_bound = (quotient + 1) * M",
      "mutated_line": "upper_bound = (quotient + 1) / M",
      "code": "def closest_divisible_number(N: int, M: int) -> int:\n    quotient = N // M\n    lower_bound = quotient * M\n    upper_bound = (quotient + 1) / M\n    if abs(N - lower_bound) < abs(N - upper_bound):\n        return lower_bound\n    elif abs(N - lower_bound) > abs(N - upper_bound):\n        return upper_bound\n    else:\n        return max(lower_bound, upper_bound, key=abs)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "upper_bound = (quotient + 1) * M",
      "mutated_line": "upper_bound = quotient + 1 + M",
      "code": "def closest_divisible_number(N: int, M: int) -> int:\n    quotient = N // M\n    lower_bound = quotient * M\n    upper_bound = quotient + 1 + M\n    if abs(N - lower_bound) < abs(N - upper_bound):\n        return lower_bound\n    elif abs(N - lower_bound) > abs(N - upper_bound):\n        return upper_bound\n    else:\n        return max(lower_bound, upper_bound, key=abs)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "upper_bound = (quotient + 1) * M",
      "mutated_line": "upper_bound = (quotient + 1) ** M",
      "code": "def closest_divisible_number(N: int, M: int) -> int:\n    quotient = N // M\n    lower_bound = quotient * M\n    upper_bound = (quotient + 1) ** M\n    if abs(N - lower_bound) < abs(N - upper_bound):\n        return lower_bound\n    elif abs(N - lower_bound) > abs(N - upper_bound):\n        return upper_bound\n    else:\n        return max(lower_bound, upper_bound, key=abs)"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if abs(N - lower_bound) < abs(N - upper_bound):",
      "mutated_line": "if abs(N - lower_bound) <= abs(N - upper_bound):",
      "code": "def closest_divisible_number(N: int, M: int) -> int:\n    quotient = N // M\n    lower_bound = quotient * M\n    upper_bound = (quotient + 1) * M\n    if abs(N - lower_bound) <= abs(N - upper_bound):\n        return lower_bound\n    elif abs(N - lower_bound) > abs(N - upper_bound):\n        return upper_bound\n    else:\n        return max(lower_bound, upper_bound, key=abs)"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if abs(N - lower_bound) < abs(N - upper_bound):",
      "mutated_line": "if abs(N - lower_bound) >= abs(N - upper_bound):",
      "code": "def closest_divisible_number(N: int, M: int) -> int:\n    quotient = N // M\n    lower_bound = quotient * M\n    upper_bound = (quotient + 1) * M\n    if abs(N - lower_bound) >= abs(N - upper_bound):\n        return lower_bound\n    elif abs(N - lower_bound) > abs(N - upper_bound):\n        return upper_bound\n    else:\n        return max(lower_bound, upper_bound, key=abs)"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if abs(N - lower_bound) < abs(N - upper_bound):",
      "mutated_line": "if abs(N - lower_bound) != abs(N - upper_bound):",
      "code": "def closest_divisible_number(N: int, M: int) -> int:\n    quotient = N // M\n    lower_bound = quotient * M\n    upper_bound = (quotient + 1) * M\n    if abs(N - lower_bound) != abs(N - upper_bound):\n        return lower_bound\n    elif abs(N - lower_bound) > abs(N - upper_bound):\n        return upper_bound\n    else:\n        return max(lower_bound, upper_bound, key=abs)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "upper_bound = (quotient + 1) * M",
      "mutated_line": "upper_bound = (quotient - 1) * M",
      "code": "def closest_divisible_number(N: int, M: int) -> int:\n    quotient = N // M\n    lower_bound = quotient * M\n    upper_bound = (quotient - 1) * M\n    if abs(N - lower_bound) < abs(N - upper_bound):\n        return lower_bound\n    elif abs(N - lower_bound) > abs(N - upper_bound):\n        return upper_bound\n    else:\n        return max(lower_bound, upper_bound, key=abs)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "upper_bound = (quotient + 1) * M",
      "mutated_line": "upper_bound = quotient * 1 * M",
      "code": "def closest_divisible_number(N: int, M: int) -> int:\n    quotient = N // M\n    lower_bound = quotient * M\n    upper_bound = quotient * 1 * M\n    if abs(N - lower_bound) < abs(N - upper_bound):\n        return lower_bound\n    elif abs(N - lower_bound) > abs(N - upper_bound):\n        return upper_bound\n    else:\n        return max(lower_bound, upper_bound, key=abs)"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "elif abs(N - lower_bound) > abs(N - upper_bound):",
      "mutated_line": "elif abs(N - lower_bound) >= abs(N - upper_bound):",
      "code": "def closest_divisible_number(N: int, M: int) -> int:\n    quotient = N // M\n    lower_bound = quotient * M\n    upper_bound = (quotient + 1) * M\n    if abs(N - lower_bound) < abs(N - upper_bound):\n        return lower_bound\n    elif abs(N - lower_bound) >= abs(N - upper_bound):\n        return upper_bound\n    else:\n        return max(lower_bound, upper_bound, key=abs)"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "elif abs(N - lower_bound) > abs(N - upper_bound):",
      "mutated_line": "elif abs(N - lower_bound) <= abs(N - upper_bound):",
      "code": "def closest_divisible_number(N: int, M: int) -> int:\n    quotient = N // M\n    lower_bound = quotient * M\n    upper_bound = (quotient + 1) * M\n    if abs(N - lower_bound) < abs(N - upper_bound):\n        return lower_bound\n    elif abs(N - lower_bound) <= abs(N - upper_bound):\n        return upper_bound\n    else:\n        return max(lower_bound, upper_bound, key=abs)"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "elif abs(N - lower_bound) > abs(N - upper_bound):",
      "mutated_line": "elif abs(N - lower_bound) != abs(N - upper_bound):",
      "code": "def closest_divisible_number(N: int, M: int) -> int:\n    quotient = N // M\n    lower_bound = quotient * M\n    upper_bound = (quotient + 1) * M\n    if abs(N - lower_bound) < abs(N - upper_bound):\n        return lower_bound\n    elif abs(N - lower_bound) != abs(N - upper_bound):\n        return upper_bound\n    else:\n        return max(lower_bound, upper_bound, key=abs)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "upper_bound = (quotient + 1) * M",
      "mutated_line": "upper_bound = (quotient + 2) * M",
      "code": "def closest_divisible_number(N: int, M: int) -> int:\n    quotient = N // M\n    lower_bound = quotient * M\n    upper_bound = (quotient + 2) * M\n    if abs(N - lower_bound) < abs(N - upper_bound):\n        return lower_bound\n    elif abs(N - lower_bound) > abs(N - upper_bound):\n        return upper_bound\n    else:\n        return max(lower_bound, upper_bound, key=abs)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "upper_bound = (quotient + 1) * M",
      "mutated_line": "upper_bound = (quotient + 0) * M",
      "code": "def closest_divisible_number(N: int, M: int) -> int:\n    quotient = N // M\n    lower_bound = quotient * M\n    upper_bound = (quotient + 0) * M\n    if abs(N - lower_bound) < abs(N - upper_bound):\n        return lower_bound\n    elif abs(N - lower_bound) > abs(N - upper_bound):\n        return upper_bound\n    else:\n        return max(lower_bound, upper_bound, key=abs)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "upper_bound = (quotient + 1) * M",
      "mutated_line": "upper_bound = (quotient + 0) * M",
      "code": "def closest_divisible_number(N: int, M: int) -> int:\n    quotient = N // M\n    lower_bound = quotient * M\n    upper_bound = (quotient + 0) * M\n    if abs(N - lower_bound) < abs(N - upper_bound):\n        return lower_bound\n    elif abs(N - lower_bound) > abs(N - upper_bound):\n        return upper_bound\n    else:\n        return max(lower_bound, upper_bound, key=abs)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "upper_bound = (quotient + 1) * M",
      "mutated_line": "upper_bound = (quotient + -1) * M",
      "code": "def closest_divisible_number(N: int, M: int) -> int:\n    quotient = N // M\n    lower_bound = quotient * M\n    upper_bound = (quotient + -1) * M\n    if abs(N - lower_bound) < abs(N - upper_bound):\n        return lower_bound\n    elif abs(N - lower_bound) > abs(N - upper_bound):\n        return upper_bound\n    else:\n        return max(lower_bound, upper_bound, key=abs)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "if abs(N - lower_bound) < abs(N - upper_bound):",
      "mutated_line": "if abs(N + lower_bound) < abs(N - upper_bound):",
      "code": "def closest_divisible_number(N: int, M: int) -> int:\n    quotient = N // M\n    lower_bound = quotient * M\n    upper_bound = (quotient + 1) * M\n    if abs(N + lower_bound) < abs(N - upper_bound):\n        return lower_bound\n    elif abs(N - lower_bound) > abs(N - upper_bound):\n        return upper_bound\n    else:\n        return max(lower_bound, upper_bound, key=abs)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "if abs(N - lower_bound) < abs(N - upper_bound):",
      "mutated_line": "if abs(N * lower_bound) < abs(N - upper_bound):",
      "code": "def closest_divisible_number(N: int, M: int) -> int:\n    quotient = N // M\n    lower_bound = quotient * M\n    upper_bound = (quotient + 1) * M\n    if abs(N * lower_bound) < abs(N - upper_bound):\n        return lower_bound\n    elif abs(N - lower_bound) > abs(N - upper_bound):\n        return upper_bound\n    else:\n        return max(lower_bound, upper_bound, key=abs)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "if abs(N - lower_bound) < abs(N - upper_bound):",
      "mutated_line": "if abs(N - lower_bound) < abs(N + upper_bound):",
      "code": "def closest_divisible_number(N: int, M: int) -> int:\n    quotient = N // M\n    lower_bound = quotient * M\n    upper_bound = (quotient + 1) * M\n    if abs(N - lower_bound) < abs(N + upper_bound):\n        return lower_bound\n    elif abs(N - lower_bound) > abs(N - upper_bound):\n        return upper_bound\n    else:\n        return max(lower_bound, upper_bound, key=abs)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "if abs(N - lower_bound) < abs(N - upper_bound):",
      "mutated_line": "if abs(N - lower_bound) < abs(N * upper_bound):",
      "code": "def closest_divisible_number(N: int, M: int) -> int:\n    quotient = N // M\n    lower_bound = quotient * M\n    upper_bound = (quotient + 1) * M\n    if abs(N - lower_bound) < abs(N * upper_bound):\n        return lower_bound\n    elif abs(N - lower_bound) > abs(N - upper_bound):\n        return upper_bound\n    else:\n        return max(lower_bound, upper_bound, key=abs)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "elif abs(N - lower_bound) > abs(N - upper_bound):",
      "mutated_line": "elif abs(N + lower_bound) > abs(N - upper_bound):",
      "code": "def closest_divisible_number(N: int, M: int) -> int:\n    quotient = N // M\n    lower_bound = quotient * M\n    upper_bound = (quotient + 1) * M\n    if abs(N - lower_bound) < abs(N - upper_bound):\n        return lower_bound\n    elif abs(N + lower_bound) > abs(N - upper_bound):\n        return upper_bound\n    else:\n        return max(lower_bound, upper_bound, key=abs)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "elif abs(N - lower_bound) > abs(N - upper_bound):",
      "mutated_line": "elif abs(N * lower_bound) > abs(N - upper_bound):",
      "code": "def closest_divisible_number(N: int, M: int) -> int:\n    quotient = N // M\n    lower_bound = quotient * M\n    upper_bound = (quotient + 1) * M\n    if abs(N - lower_bound) < abs(N - upper_bound):\n        return lower_bound\n    elif abs(N * lower_bound) > abs(N - upper_bound):\n        return upper_bound\n    else:\n        return max(lower_bound, upper_bound, key=abs)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "elif abs(N - lower_bound) > abs(N - upper_bound):",
      "mutated_line": "elif abs(N - lower_bound) > abs(N + upper_bound):",
      "code": "def closest_divisible_number(N: int, M: int) -> int:\n    quotient = N // M\n    lower_bound = quotient * M\n    upper_bound = (quotient + 1) * M\n    if abs(N - lower_bound) < abs(N - upper_bound):\n        return lower_bound\n    elif abs(N - lower_bound) > abs(N + upper_bound):\n        return upper_bound\n    else:\n        return max(lower_bound, upper_bound, key=abs)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "elif abs(N - lower_bound) > abs(N - upper_bound):",
      "mutated_line": "elif abs(N - lower_bound) > abs(N * upper_bound):",
      "code": "def closest_divisible_number(N: int, M: int) -> int:\n    quotient = N // M\n    lower_bound = quotient * M\n    upper_bound = (quotient + 1) * M\n    if abs(N - lower_bound) < abs(N - upper_bound):\n        return lower_bound\n    elif abs(N - lower_bound) > abs(N * upper_bound):\n        return upper_bound\n    else:\n        return max(lower_bound, upper_bound, key=abs)"
    }
  ]
}