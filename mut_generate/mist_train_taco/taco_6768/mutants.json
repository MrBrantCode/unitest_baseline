{
  "task_id": "taco_6768",
  "entry_point": "sieve",
  "mutant_count": 139,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "primes = sieve(45000)",
      "mutated_line": "primes = sieve(45001)",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45001)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "primes = sieve(45000)",
      "mutated_line": "primes = sieve(44999)",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(44999)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "primes = sieve(45000)",
      "mutated_line": "primes = sieve(0)",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(0)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "primes = sieve(45000)",
      "mutated_line": "primes = sieve(1)",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(1)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "primes = sieve(45000)",
      "mutated_line": "primes = sieve(-45000)",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(-45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if n > 1:",
      "mutated_line": "if n >= 1:",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n >= 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if n > 1:",
      "mutated_line": "if n <= 1:",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n <= 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if n > 1:",
      "mutated_line": "if n != 1:",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n != 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "t = 1",
      "mutated_line": "t = 2",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 2\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "t = 1",
      "mutated_line": "t = 0",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 0\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "t = 1",
      "mutated_line": "t = 0",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 0\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "t = 1",
      "mutated_line": "t = -1",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = -1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 32,
      "original_line": "t *= (p - 1) * p ** (f[p] - 1)",
      "mutated_line": "t /= (p - 1) * p ** (f[p] - 1)",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t /= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "primes = [2]",
      "mutated_line": "primes = [3]",
      "code": "import math\n\ndef sieve(lim):\n    primes = [3]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "primes = [2]",
      "mutated_line": "primes = [1]",
      "code": "import math\n\ndef sieve(lim):\n    primes = [1]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "primes = [2]",
      "mutated_line": "primes = [0]",
      "code": "import math\n\ndef sieve(lim):\n    primes = [0]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "primes = [2]",
      "mutated_line": "primes = [1]",
      "code": "import math\n\ndef sieve(lim):\n    primes = [1]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "primes = [2]",
      "mutated_line": "primes = [-2]",
      "code": "import math\n\ndef sieve(lim):\n    primes = [-2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(3, lim, 2):",
      "mutated_line": "for i in range(4, lim, 2):",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(4, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(3, lim, 2):",
      "mutated_line": "for i in range(2, lim, 2):",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(2, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(3, lim, 2):",
      "mutated_line": "for i in range(0, lim, 2):",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(0, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(3, lim, 2):",
      "mutated_line": "for i in range(1, lim, 2):",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(1, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(3, lim, 2):",
      "mutated_line": "for i in range(-3, lim, 2):",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(-3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(3, lim, 2):",
      "mutated_line": "for i in range(3, lim, 3):",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 3):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(3, lim, 2):",
      "mutated_line": "for i in range(3, lim, 1):",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 1):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(3, lim, 2):",
      "mutated_line": "for i in range(3, lim, 0):",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 0):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(3, lim, 2):",
      "mutated_line": "for i in range(3, lim, 1):",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 1):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(3, lim, 2):",
      "mutated_line": "for i in range(3, lim, -2):",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, -2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if p * p > n:",
      "mutated_line": "if p * p >= n:",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p >= n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if p * p > n:",
      "mutated_line": "if p * p <= n:",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p <= n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if p * p > n:",
      "mutated_line": "if p * p != n:",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p != n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "while n % p == 0:",
      "mutated_line": "while n % p != 0:",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p != 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if n > 1:",
      "mutated_line": "if n > 2:",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 2:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if n > 1:",
      "mutated_line": "if n > 0:",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 0:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if n > 1:",
      "mutated_line": "if n > 0:",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 0:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if n > 1:",
      "mutated_line": "if n > -1:",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > -1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "f[n] = 1",
      "mutated_line": "f[n] = 2",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 2\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "f[n] = 1",
      "mutated_line": "f[n] = 0",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 0\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "f[n] = 1",
      "mutated_line": "f[n] = 0",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 0\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "f[n] = 1",
      "mutated_line": "f[n] = -1",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = -1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "t *= (p - 1) * p ** (f[p] - 1)",
      "mutated_line": "t *= (p - 1) / p ** (f[p] - 1)",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) / p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "t *= (p - 1) * p ** (f[p] - 1)",
      "mutated_line": "t *= p - 1 + p ** (f[p] - 1)",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= p - 1 + p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "t *= (p - 1) * p ** (f[p] - 1)",
      "mutated_line": "t *= (p - 1) ** p ** (f[p] - 1)",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) ** p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "m = 2 * N + 1",
      "mutated_line": "m = 2 * N - 1",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N - 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "m = 2 * N + 1",
      "mutated_line": "m = 2 * N * 1",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N * 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "for j in range(3 * i, lim, 2 * i):",
      "mutated_line": "for j in range(3 / i, lim, 2 * i):",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 / i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "for j in range(3 * i, lim, 2 * i):",
      "mutated_line": "for j in range(3 + i, lim, 2 * i):",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 + i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "for j in range(3 * i, lim, 2 * i):",
      "mutated_line": "for j in range(3 ** i, lim, 2 * i):",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 ** i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "for j in range(3 * i, lim, 2 * i):",
      "mutated_line": "for j in range(3 * i, lim, 2 / i):",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 / i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "for j in range(3 * i, lim, 2 * i):",
      "mutated_line": "for j in range(3 * i, lim, 2 + i):",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 + i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "for j in range(3 * i, lim, 2 * i):",
      "mutated_line": "for j in range(3 * i, lim, 2 ** i):",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 ** i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "mark[j] = 1",
      "mutated_line": "mark[j] = 2",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 2\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "mark[j] = 1",
      "mutated_line": "mark[j] = 0",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 0\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "mark[j] = 1",
      "mutated_line": "mark[j] = 0",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 0\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "mark[j] = 1",
      "mutated_line": "mark[j] = -1",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = -1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "if p * p > n:",
      "mutated_line": "if p / p > n:",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p / p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "if p * p > n:",
      "mutated_line": "if p + p > n:",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p + p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "if p * p > n:",
      "mutated_line": "if p ** p > n:",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p ** p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "while n % p == 0:",
      "mutated_line": "while n * p == 0:",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n * p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "while n % p == 0:",
      "mutated_line": "while n + p == 0:",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n + p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "while n % p == 0:",
      "mutated_line": "while n % p == 1:",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 1:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "while n % p == 0:",
      "mutated_line": "while n % p == -1:",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == -1:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "while n % p == 0:",
      "mutated_line": "while n % p == 1:",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 1:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "f[p] = f.get(p, 0) + 1",
      "mutated_line": "f[p] = f.get(p, 0) - 1",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) - 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "f[p] = f.get(p, 0) + 1",
      "mutated_line": "f[p] = f.get(p, 0) * 1",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) * 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "t *= (p - 1) * p ** (f[p] - 1)",
      "mutated_line": "t *= (p + 1) * p ** (f[p] - 1)",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p + 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "t *= (p - 1) * p ** (f[p] - 1)",
      "mutated_line": "t *= p * 1 * p ** (f[p] - 1)",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= p * 1 * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "t *= (p - 1) * p ** (f[p] - 1)",
      "mutated_line": "t *= (p - 1) * (p * (f[p] - 1))",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * (p * (f[p] - 1))\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "t *= (p - 1) * p ** (f[p] - 1)",
      "mutated_line": "t *= (p - 1) * (p + (f[p] - 1))",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * (p + (f[p] - 1))\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "m = 2 * N + 1",
      "mutated_line": "m = 2 / N + 1",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 / N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "m = 2 * N + 1",
      "mutated_line": "m = 2 + N + 1",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 + N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "m = 2 * N + 1",
      "mutated_line": "m = 2 ** N + 1",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 ** N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "m = 2 * N + 1",
      "mutated_line": "m = 2 * N + 2",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 2\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "m = 2 * N + 1",
      "mutated_line": "m = 2 * N + 0",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 0\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "m = 2 * N + 1",
      "mutated_line": "m = 2 * N + 0",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 0\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "m = 2 * N + 1",
      "mutated_line": "m = 2 * N + -1",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + -1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "m //= math.gcd(m, A % m)",
      "mutated_line": "m //= math.gcd(m, A * m)",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A * m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "m //= math.gcd(m, A % m)",
      "mutated_line": "m //= math.gcd(m, A + m)",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A + m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "LCR",
      "lineno": 43,
      "original_line": "while t % p == 0 and pow(2, t // p, m) == 1:",
      "mutated_line": "while t % p == 0 or pow(2, t // p, m) == 1:",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 or pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "results.append(2 * N - t)",
      "mutated_line": "results.append(2 * N + t)",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N + t)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "results.append(2 * N - t)",
      "mutated_line": "results.append(2 * N * t)",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N * t)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for j in range(3 * i, lim, 2 * i):",
      "mutated_line": "for j in range(4 * i, lim, 2 * i):",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(4 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for j in range(3 * i, lim, 2 * i):",
      "mutated_line": "for j in range(2 * i, lim, 2 * i):",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(2 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for j in range(3 * i, lim, 2 * i):",
      "mutated_line": "for j in range(0 * i, lim, 2 * i):",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(0 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for j in range(3 * i, lim, 2 * i):",
      "mutated_line": "for j in range(1 * i, lim, 2 * i):",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(1 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for j in range(3 * i, lim, 2 * i):",
      "mutated_line": "for j in range(-3 * i, lim, 2 * i):",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(-3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for j in range(3 * i, lim, 2 * i):",
      "mutated_line": "for j in range(3 * i, lim, 3 * i):",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 3 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for j in range(3 * i, lim, 2 * i):",
      "mutated_line": "for j in range(3 * i, lim, 1 * i):",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 1 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for j in range(3 * i, lim, 2 * i):",
      "mutated_line": "for j in range(3 * i, lim, 0 * i):",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 0 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for j in range(3 * i, lim, 2 * i):",
      "mutated_line": "for j in range(3 * i, lim, 1 * i):",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 1 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for j in range(3 * i, lim, 2 * i):",
      "mutated_line": "for j in range(3 * i, lim, -2 * i):",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, -2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "f[p] = f.get(p, 0) + 1",
      "mutated_line": "f[p] = f.get(p, 0) + 2",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 2\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "f[p] = f.get(p, 0) + 1",
      "mutated_line": "f[p] = f.get(p, 0) + 0",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 0\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "f[p] = f.get(p, 0) + 1",
      "mutated_line": "f[p] = f.get(p, 0) + 0",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 0\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "f[p] = f.get(p, 0) + 1",
      "mutated_line": "f[p] = f.get(p, 0) + -1",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + -1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "t *= (p - 1) * p ** (f[p] - 1)",
      "mutated_line": "t *= (p - 2) * p ** (f[p] - 1)",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 2) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "t *= (p - 1) * p ** (f[p] - 1)",
      "mutated_line": "t *= (p - 0) * p ** (f[p] - 1)",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 0) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "t *= (p - 1) * p ** (f[p] - 1)",
      "mutated_line": "t *= (p - 0) * p ** (f[p] - 1)",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 0) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "t *= (p - 1) * p ** (f[p] - 1)",
      "mutated_line": "t *= (p - -1) * p ** (f[p] - 1)",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - -1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "t *= (p - 1) * p ** (f[p] - 1)",
      "mutated_line": "t *= (p - 1) * p ** (f[p] + 1)",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] + 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "t *= (p - 1) * p ** (f[p] - 1)",
      "mutated_line": "t *= (p - 1) * p ** (f[p] * 1)",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] * 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "m = 2 * N + 1",
      "mutated_line": "m = 3 * N + 1",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 3 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "m = 2 * N + 1",
      "mutated_line": "m = 1 * N + 1",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 1 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "m = 2 * N + 1",
      "mutated_line": "m = 0 * N + 1",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 0 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "m = 2 * N + 1",
      "mutated_line": "m = 1 * N + 1",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 1 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "m = 2 * N + 1",
      "mutated_line": "m = -2 * N + 1",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = -2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "while t % p == 0 and pow(2, t // p, m) == 1:",
      "mutated_line": "while t % p != 0 and pow(2, t // p, m) == 1:",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p != 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "while t % p == 0 and pow(2, t // p, m) == 1:",
      "mutated_line": "while t % p == 0 and pow(2, t // p, m) != 1:",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) != 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "results.append(2 * N - t)",
      "mutated_line": "results.append(2 / N - t)",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 / N - t)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "results.append(2 * N - t)",
      "mutated_line": "results.append(2 + N - t)",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 + N - t)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "results.append(2 * N - t)",
      "mutated_line": "results.append(2 ** N - t)",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 ** N - t)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "f[p] = f.get(p, 0) + 1",
      "mutated_line": "f[p] = f.get(p, 1) + 1",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 1) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "f[p] = f.get(p, 0) + 1",
      "mutated_line": "f[p] = f.get(p, -1) + 1",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, -1) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "f[p] = f.get(p, 0) + 1",
      "mutated_line": "f[p] = f.get(p, 1) + 1",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 1) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "t *= (p - 1) * p ** (f[p] - 1)",
      "mutated_line": "t *= (p - 1) * p ** (f[p] - 2)",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 2)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "t *= (p - 1) * p ** (f[p] - 1)",
      "mutated_line": "t *= (p - 1) * p ** (f[p] - 0)",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 0)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "t *= (p - 1) * p ** (f[p] - 1)",
      "mutated_line": "t *= (p - 1) * p ** (f[p] - 0)",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 0)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "t *= (p - 1) * p ** (f[p] - 1)",
      "mutated_line": "t *= (p - 1) * p ** (f[p] - -1)",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - -1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "while t % p == 0 and pow(2, t // p, m) == 1:",
      "mutated_line": "while t * p == 0 and pow(2, t // p, m) == 1:",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t * p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "while t % p == 0 and pow(2, t // p, m) == 1:",
      "mutated_line": "while t + p == 0 and pow(2, t // p, m) == 1:",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t + p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "while t % p == 0 and pow(2, t // p, m) == 1:",
      "mutated_line": "while t % p == 1 and pow(2, t // p, m) == 1:",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 1 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "while t % p == 0 and pow(2, t // p, m) == 1:",
      "mutated_line": "while t % p == -1 and pow(2, t // p, m) == 1:",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == -1 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "while t % p == 0 and pow(2, t // p, m) == 1:",
      "mutated_line": "while t % p == 1 and pow(2, t // p, m) == 1:",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 1 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "while t % p == 0 and pow(2, t // p, m) == 1:",
      "mutated_line": "while t % p == 0 and pow(2, t // p, m) == 2:",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 2:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "while t % p == 0 and pow(2, t // p, m) == 1:",
      "mutated_line": "while t % p == 0 and pow(2, t // p, m) == 0:",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 0:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "while t % p == 0 and pow(2, t // p, m) == 1:",
      "mutated_line": "while t % p == 0 and pow(2, t // p, m) == 0:",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 0:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "while t % p == 0 and pow(2, t // p, m) == 1:",
      "mutated_line": "while t % p == 0 and pow(2, t // p, m) == -1:",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == -1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "results.append(2 * N - t)",
      "mutated_line": "results.append(3 * N - t)",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(3 * N - t)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "results.append(2 * N - t)",
      "mutated_line": "results.append(1 * N - t)",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(1 * N - t)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "results.append(2 * N - t)",
      "mutated_line": "results.append(0 * N - t)",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(0 * N - t)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "results.append(2 * N - t)",
      "mutated_line": "results.append(1 * N - t)",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(1 * N - t)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "results.append(2 * N - t)",
      "mutated_line": "results.append(-2 * N - t)",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t // p, m) == 1:\n                t //= p\n        results.append(-2 * N - t)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "while t % p == 0 and pow(2, t // p, m) == 1:",
      "mutated_line": "while t % p == 0 and pow(3, t // p, m) == 1:",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(3, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "while t % p == 0 and pow(2, t // p, m) == 1:",
      "mutated_line": "while t % p == 0 and pow(1, t // p, m) == 1:",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(1, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "while t % p == 0 and pow(2, t // p, m) == 1:",
      "mutated_line": "while t % p == 0 and pow(0, t // p, m) == 1:",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(0, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "while t % p == 0 and pow(2, t // p, m) == 1:",
      "mutated_line": "while t % p == 0 and pow(1, t // p, m) == 1:",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(1, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "while t % p == 0 and pow(2, t // p, m) == 1:",
      "mutated_line": "while t % p == 0 and pow(-2, t // p, m) == 1:",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(-2, t // p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "while t % p == 0 and pow(2, t // p, m) == 1:",
      "mutated_line": "while t % p == 0 and pow(2, t / p, m) == 1:",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t / p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "while t % p == 0 and pow(2, t // p, m) == 1:",
      "mutated_line": "while t % p == 0 and pow(2, t * p, m) == 1:",
      "code": "import math\n\ndef sieve(lim):\n    primes = [2]\n    mark = bytearray(lim)\n    for i in range(3, lim, 2):\n        if mark[i]:\n            continue\n        primes.append(i)\n        for j in range(3 * i, lim, 2 * i):\n            mark[j] = 1\n    return primes\nprimes = sieve(45000)\n\ndef factor(n):\n    f = {}\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n //= p\n            f[p] = f.get(p, 0) + 1\n    if n > 1:\n        f[n] = 1\n    return f\n\ndef totient(n):\n    f = factor(n)\n    t = 1\n    for p in f:\n        t *= (p - 1) * p ** (f[p] - 1)\n    return t\n\ndef count_unreachable_rooms(T, test_cases):\n    results = []\n    for t in range(T):\n        (N, A) = test_cases[t]\n        m = 2 * N + 1\n        m //= math.gcd(m, A % m)\n        t = totient(m)\n        for p in factor(t):\n            while t % p == 0 and pow(2, t * p, m) == 1:\n                t //= p\n        results.append(2 * N - t)\n    return results"
    }
  ]
}