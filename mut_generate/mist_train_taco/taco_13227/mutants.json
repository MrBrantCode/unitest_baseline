{
  "task_id": "taco_13227",
  "entry_point": "minimum_cuts_for_doughnut_chain",
  "mutant_count": 67,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 2,
      "original_line": "if M == 1:",
      "mutated_line": "if M != 1:",
      "code": "def minimum_cuts_for_doughnut_chain(N, M, chain_sizes):\n    if M != 1:\n        return 0\n    chain_sizes.sort(reverse=True)\n    cuts_needed = 0\n    current_chain = [chain_sizes.pop()]\n    while len(chain_sizes) > 0:\n        if current_chain[0] > 0:\n            current_chain[0] -= 1\n            cuts_needed += 1\n        else:\n            current_chain.pop()\n            if len(chain_sizes) > 0:\n                current_chain.append(chain_sizes.pop())\n    if len(current_chain) > 0 and current_chain[0] > 0:\n        cuts_needed += 1\n    return cuts_needed"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "cuts_needed = 0",
      "mutated_line": "cuts_needed = 1",
      "code": "def minimum_cuts_for_doughnut_chain(N, M, chain_sizes):\n    if M == 1:\n        return 0\n    chain_sizes.sort(reverse=True)\n    cuts_needed = 1\n    current_chain = [chain_sizes.pop()]\n    while len(chain_sizes) > 0:\n        if current_chain[0] > 0:\n            current_chain[0] -= 1\n            cuts_needed += 1\n        else:\n            current_chain.pop()\n            if len(chain_sizes) > 0:\n                current_chain.append(chain_sizes.pop())\n    if len(current_chain) > 0 and current_chain[0] > 0:\n        cuts_needed += 1\n    return cuts_needed"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "cuts_needed = 0",
      "mutated_line": "cuts_needed = -1",
      "code": "def minimum_cuts_for_doughnut_chain(N, M, chain_sizes):\n    if M == 1:\n        return 0\n    chain_sizes.sort(reverse=True)\n    cuts_needed = -1\n    current_chain = [chain_sizes.pop()]\n    while len(chain_sizes) > 0:\n        if current_chain[0] > 0:\n            current_chain[0] -= 1\n            cuts_needed += 1\n        else:\n            current_chain.pop()\n            if len(chain_sizes) > 0:\n                current_chain.append(chain_sizes.pop())\n    if len(current_chain) > 0 and current_chain[0] > 0:\n        cuts_needed += 1\n    return cuts_needed"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "cuts_needed = 0",
      "mutated_line": "cuts_needed = 1",
      "code": "def minimum_cuts_for_doughnut_chain(N, M, chain_sizes):\n    if M == 1:\n        return 0\n    chain_sizes.sort(reverse=True)\n    cuts_needed = 1\n    current_chain = [chain_sizes.pop()]\n    while len(chain_sizes) > 0:\n        if current_chain[0] > 0:\n            current_chain[0] -= 1\n            cuts_needed += 1\n        else:\n            current_chain.pop()\n            if len(chain_sizes) > 0:\n                current_chain.append(chain_sizes.pop())\n    if len(current_chain) > 0 and current_chain[0] > 0:\n        cuts_needed += 1\n    return cuts_needed"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "while len(chain_sizes) > 0:",
      "mutated_line": "while len(chain_sizes) >= 0:",
      "code": "def minimum_cuts_for_doughnut_chain(N, M, chain_sizes):\n    if M == 1:\n        return 0\n    chain_sizes.sort(reverse=True)\n    cuts_needed = 0\n    current_chain = [chain_sizes.pop()]\n    while len(chain_sizes) >= 0:\n        if current_chain[0] > 0:\n            current_chain[0] -= 1\n            cuts_needed += 1\n        else:\n            current_chain.pop()\n            if len(chain_sizes) > 0:\n                current_chain.append(chain_sizes.pop())\n    if len(current_chain) > 0 and current_chain[0] > 0:\n        cuts_needed += 1\n    return cuts_needed"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "while len(chain_sizes) > 0:",
      "mutated_line": "while len(chain_sizes) <= 0:",
      "code": "def minimum_cuts_for_doughnut_chain(N, M, chain_sizes):\n    if M == 1:\n        return 0\n    chain_sizes.sort(reverse=True)\n    cuts_needed = 0\n    current_chain = [chain_sizes.pop()]\n    while len(chain_sizes) <= 0:\n        if current_chain[0] > 0:\n            current_chain[0] -= 1\n            cuts_needed += 1\n        else:\n            current_chain.pop()\n            if len(chain_sizes) > 0:\n                current_chain.append(chain_sizes.pop())\n    if len(current_chain) > 0 and current_chain[0] > 0:\n        cuts_needed += 1\n    return cuts_needed"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "while len(chain_sizes) > 0:",
      "mutated_line": "while len(chain_sizes) != 0:",
      "code": "def minimum_cuts_for_doughnut_chain(N, M, chain_sizes):\n    if M == 1:\n        return 0\n    chain_sizes.sort(reverse=True)\n    cuts_needed = 0\n    current_chain = [chain_sizes.pop()]\n    while len(chain_sizes) != 0:\n        if current_chain[0] > 0:\n            current_chain[0] -= 1\n            cuts_needed += 1\n        else:\n            current_chain.pop()\n            if len(chain_sizes) > 0:\n                current_chain.append(chain_sizes.pop())\n    if len(current_chain) > 0 and current_chain[0] > 0:\n        cuts_needed += 1\n    return cuts_needed"
    },
    {
      "operator": "LCR",
      "lineno": 18,
      "original_line": "if len(current_chain) > 0 and current_chain[0] > 0:",
      "mutated_line": "if len(current_chain) > 0 or current_chain[0] > 0:",
      "code": "def minimum_cuts_for_doughnut_chain(N, M, chain_sizes):\n    if M == 1:\n        return 0\n    chain_sizes.sort(reverse=True)\n    cuts_needed = 0\n    current_chain = [chain_sizes.pop()]\n    while len(chain_sizes) > 0:\n        if current_chain[0] > 0:\n            current_chain[0] -= 1\n            cuts_needed += 1\n        else:\n            current_chain.pop()\n            if len(chain_sizes) > 0:\n                current_chain.append(chain_sizes.pop())\n    if len(current_chain) > 0 or current_chain[0] > 0:\n        cuts_needed += 1\n    return cuts_needed"
    },
    {
      "operator": "ASR",
      "lineno": 19,
      "original_line": "cuts_needed += 1",
      "mutated_line": "cuts_needed -= 1",
      "code": "def minimum_cuts_for_doughnut_chain(N, M, chain_sizes):\n    if M == 1:\n        return 0\n    chain_sizes.sort(reverse=True)\n    cuts_needed = 0\n    current_chain = [chain_sizes.pop()]\n    while len(chain_sizes) > 0:\n        if current_chain[0] > 0:\n            current_chain[0] -= 1\n            cuts_needed += 1\n        else:\n            current_chain.pop()\n            if len(chain_sizes) > 0:\n                current_chain.append(chain_sizes.pop())\n    if len(current_chain) > 0 and current_chain[0] > 0:\n        cuts_needed -= 1\n    return cuts_needed"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if M == 1:",
      "mutated_line": "if M == 2:",
      "code": "def minimum_cuts_for_doughnut_chain(N, M, chain_sizes):\n    if M == 2:\n        return 0\n    chain_sizes.sort(reverse=True)\n    cuts_needed = 0\n    current_chain = [chain_sizes.pop()]\n    while len(chain_sizes) > 0:\n        if current_chain[0] > 0:\n            current_chain[0] -= 1\n            cuts_needed += 1\n        else:\n            current_chain.pop()\n            if len(chain_sizes) > 0:\n                current_chain.append(chain_sizes.pop())\n    if len(current_chain) > 0 and current_chain[0] > 0:\n        cuts_needed += 1\n    return cuts_needed"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if M == 1:",
      "mutated_line": "if M == 0:",
      "code": "def minimum_cuts_for_doughnut_chain(N, M, chain_sizes):\n    if M == 0:\n        return 0\n    chain_sizes.sort(reverse=True)\n    cuts_needed = 0\n    current_chain = [chain_sizes.pop()]\n    while len(chain_sizes) > 0:\n        if current_chain[0] > 0:\n            current_chain[0] -= 1\n            cuts_needed += 1\n        else:\n            current_chain.pop()\n            if len(chain_sizes) > 0:\n                current_chain.append(chain_sizes.pop())\n    if len(current_chain) > 0 and current_chain[0] > 0:\n        cuts_needed += 1\n    return cuts_needed"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if M == 1:",
      "mutated_line": "if M == 0:",
      "code": "def minimum_cuts_for_doughnut_chain(N, M, chain_sizes):\n    if M == 0:\n        return 0\n    chain_sizes.sort(reverse=True)\n    cuts_needed = 0\n    current_chain = [chain_sizes.pop()]\n    while len(chain_sizes) > 0:\n        if current_chain[0] > 0:\n            current_chain[0] -= 1\n            cuts_needed += 1\n        else:\n            current_chain.pop()\n            if len(chain_sizes) > 0:\n                current_chain.append(chain_sizes.pop())\n    if len(current_chain) > 0 and current_chain[0] > 0:\n        cuts_needed += 1\n    return cuts_needed"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if M == 1:",
      "mutated_line": "if M == -1:",
      "code": "def minimum_cuts_for_doughnut_chain(N, M, chain_sizes):\n    if M == -1:\n        return 0\n    chain_sizes.sort(reverse=True)\n    cuts_needed = 0\n    current_chain = [chain_sizes.pop()]\n    while len(chain_sizes) > 0:\n        if current_chain[0] > 0:\n            current_chain[0] -= 1\n            cuts_needed += 1\n        else:\n            current_chain.pop()\n            if len(chain_sizes) > 0:\n                current_chain.append(chain_sizes.pop())\n    if len(current_chain) > 0 and current_chain[0] > 0:\n        cuts_needed += 1\n    return cuts_needed"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def minimum_cuts_for_doughnut_chain(N, M, chain_sizes):\n    if M == 1:\n        return 1\n    chain_sizes.sort(reverse=True)\n    cuts_needed = 0\n    current_chain = [chain_sizes.pop()]\n    while len(chain_sizes) > 0:\n        if current_chain[0] > 0:\n            current_chain[0] -= 1\n            cuts_needed += 1\n        else:\n            current_chain.pop()\n            if len(chain_sizes) > 0:\n                current_chain.append(chain_sizes.pop())\n    if len(current_chain) > 0 and current_chain[0] > 0:\n        cuts_needed += 1\n    return cuts_needed"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "def minimum_cuts_for_doughnut_chain(N, M, chain_sizes):\n    if M == 1:\n        return -1\n    chain_sizes.sort(reverse=True)\n    cuts_needed = 0\n    current_chain = [chain_sizes.pop()]\n    while len(chain_sizes) > 0:\n        if current_chain[0] > 0:\n            current_chain[0] -= 1\n            cuts_needed += 1\n        else:\n            current_chain.pop()\n            if len(chain_sizes) > 0:\n                current_chain.append(chain_sizes.pop())\n    if len(current_chain) > 0 and current_chain[0] > 0:\n        cuts_needed += 1\n    return cuts_needed"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def minimum_cuts_for_doughnut_chain(N, M, chain_sizes):\n    if M == 1:\n        return 1\n    chain_sizes.sort(reverse=True)\n    cuts_needed = 0\n    current_chain = [chain_sizes.pop()]\n    while len(chain_sizes) > 0:\n        if current_chain[0] > 0:\n            current_chain[0] -= 1\n            cuts_needed += 1\n        else:\n            current_chain.pop()\n            if len(chain_sizes) > 0:\n                current_chain.append(chain_sizes.pop())\n    if len(current_chain) > 0 and current_chain[0] > 0:\n        cuts_needed += 1\n    return cuts_needed"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "while len(chain_sizes) > 0:",
      "mutated_line": "while len(chain_sizes) > 1:",
      "code": "def minimum_cuts_for_doughnut_chain(N, M, chain_sizes):\n    if M == 1:\n        return 0\n    chain_sizes.sort(reverse=True)\n    cuts_needed = 0\n    current_chain = [chain_sizes.pop()]\n    while len(chain_sizes) > 1:\n        if current_chain[0] > 0:\n            current_chain[0] -= 1\n            cuts_needed += 1\n        else:\n            current_chain.pop()\n            if len(chain_sizes) > 0:\n                current_chain.append(chain_sizes.pop())\n    if len(current_chain) > 0 and current_chain[0] > 0:\n        cuts_needed += 1\n    return cuts_needed"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "while len(chain_sizes) > 0:",
      "mutated_line": "while len(chain_sizes) > -1:",
      "code": "def minimum_cuts_for_doughnut_chain(N, M, chain_sizes):\n    if M == 1:\n        return 0\n    chain_sizes.sort(reverse=True)\n    cuts_needed = 0\n    current_chain = [chain_sizes.pop()]\n    while len(chain_sizes) > -1:\n        if current_chain[0] > 0:\n            current_chain[0] -= 1\n            cuts_needed += 1\n        else:\n            current_chain.pop()\n            if len(chain_sizes) > 0:\n                current_chain.append(chain_sizes.pop())\n    if len(current_chain) > 0 and current_chain[0] > 0:\n        cuts_needed += 1\n    return cuts_needed"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "while len(chain_sizes) > 0:",
      "mutated_line": "while len(chain_sizes) > 1:",
      "code": "def minimum_cuts_for_doughnut_chain(N, M, chain_sizes):\n    if M == 1:\n        return 0\n    chain_sizes.sort(reverse=True)\n    cuts_needed = 0\n    current_chain = [chain_sizes.pop()]\n    while len(chain_sizes) > 1:\n        if current_chain[0] > 0:\n            current_chain[0] -= 1\n            cuts_needed += 1\n        else:\n            current_chain.pop()\n            if len(chain_sizes) > 0:\n                current_chain.append(chain_sizes.pop())\n    if len(current_chain) > 0 and current_chain[0] > 0:\n        cuts_needed += 1\n    return cuts_needed"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if current_chain[0] > 0:",
      "mutated_line": "if current_chain[0] >= 0:",
      "code": "def minimum_cuts_for_doughnut_chain(N, M, chain_sizes):\n    if M == 1:\n        return 0\n    chain_sizes.sort(reverse=True)\n    cuts_needed = 0\n    current_chain = [chain_sizes.pop()]\n    while len(chain_sizes) > 0:\n        if current_chain[0] >= 0:\n            current_chain[0] -= 1\n            cuts_needed += 1\n        else:\n            current_chain.pop()\n            if len(chain_sizes) > 0:\n                current_chain.append(chain_sizes.pop())\n    if len(current_chain) > 0 and current_chain[0] > 0:\n        cuts_needed += 1\n    return cuts_needed"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if current_chain[0] > 0:",
      "mutated_line": "if current_chain[0] <= 0:",
      "code": "def minimum_cuts_for_doughnut_chain(N, M, chain_sizes):\n    if M == 1:\n        return 0\n    chain_sizes.sort(reverse=True)\n    cuts_needed = 0\n    current_chain = [chain_sizes.pop()]\n    while len(chain_sizes) > 0:\n        if current_chain[0] <= 0:\n            current_chain[0] -= 1\n            cuts_needed += 1\n        else:\n            current_chain.pop()\n            if len(chain_sizes) > 0:\n                current_chain.append(chain_sizes.pop())\n    if len(current_chain) > 0 and current_chain[0] > 0:\n        cuts_needed += 1\n    return cuts_needed"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if current_chain[0] > 0:",
      "mutated_line": "if current_chain[0] != 0:",
      "code": "def minimum_cuts_for_doughnut_chain(N, M, chain_sizes):\n    if M == 1:\n        return 0\n    chain_sizes.sort(reverse=True)\n    cuts_needed = 0\n    current_chain = [chain_sizes.pop()]\n    while len(chain_sizes) > 0:\n        if current_chain[0] != 0:\n            current_chain[0] -= 1\n            cuts_needed += 1\n        else:\n            current_chain.pop()\n            if len(chain_sizes) > 0:\n                current_chain.append(chain_sizes.pop())\n    if len(current_chain) > 0 and current_chain[0] > 0:\n        cuts_needed += 1\n    return cuts_needed"
    },
    {
      "operator": "ASR",
      "lineno": 11,
      "original_line": "current_chain[0] -= 1",
      "mutated_line": "current_chain[0] += 1",
      "code": "def minimum_cuts_for_doughnut_chain(N, M, chain_sizes):\n    if M == 1:\n        return 0\n    chain_sizes.sort(reverse=True)\n    cuts_needed = 0\n    current_chain = [chain_sizes.pop()]\n    while len(chain_sizes) > 0:\n        if current_chain[0] > 0:\n            current_chain[0] += 1\n            cuts_needed += 1\n        else:\n            current_chain.pop()\n            if len(chain_sizes) > 0:\n                current_chain.append(chain_sizes.pop())\n    if len(current_chain) > 0 and current_chain[0] > 0:\n        cuts_needed += 1\n    return cuts_needed"
    },
    {
      "operator": "ASR",
      "lineno": 12,
      "original_line": "cuts_needed += 1",
      "mutated_line": "cuts_needed -= 1",
      "code": "def minimum_cuts_for_doughnut_chain(N, M, chain_sizes):\n    if M == 1:\n        return 0\n    chain_sizes.sort(reverse=True)\n    cuts_needed = 0\n    current_chain = [chain_sizes.pop()]\n    while len(chain_sizes) > 0:\n        if current_chain[0] > 0:\n            current_chain[0] -= 1\n            cuts_needed -= 1\n        else:\n            current_chain.pop()\n            if len(chain_sizes) > 0:\n                current_chain.append(chain_sizes.pop())\n    if len(current_chain) > 0 and current_chain[0] > 0:\n        cuts_needed += 1\n    return cuts_needed"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if len(current_chain) > 0 and current_chain[0] > 0:",
      "mutated_line": "if len(current_chain) >= 0 and current_chain[0] > 0:",
      "code": "def minimum_cuts_for_doughnut_chain(N, M, chain_sizes):\n    if M == 1:\n        return 0\n    chain_sizes.sort(reverse=True)\n    cuts_needed = 0\n    current_chain = [chain_sizes.pop()]\n    while len(chain_sizes) > 0:\n        if current_chain[0] > 0:\n            current_chain[0] -= 1\n            cuts_needed += 1\n        else:\n            current_chain.pop()\n            if len(chain_sizes) > 0:\n                current_chain.append(chain_sizes.pop())\n    if len(current_chain) >= 0 and current_chain[0] > 0:\n        cuts_needed += 1\n    return cuts_needed"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if len(current_chain) > 0 and current_chain[0] > 0:",
      "mutated_line": "if len(current_chain) <= 0 and current_chain[0] > 0:",
      "code": "def minimum_cuts_for_doughnut_chain(N, M, chain_sizes):\n    if M == 1:\n        return 0\n    chain_sizes.sort(reverse=True)\n    cuts_needed = 0\n    current_chain = [chain_sizes.pop()]\n    while len(chain_sizes) > 0:\n        if current_chain[0] > 0:\n            current_chain[0] -= 1\n            cuts_needed += 1\n        else:\n            current_chain.pop()\n            if len(chain_sizes) > 0:\n                current_chain.append(chain_sizes.pop())\n    if len(current_chain) <= 0 and current_chain[0] > 0:\n        cuts_needed += 1\n    return cuts_needed"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if len(current_chain) > 0 and current_chain[0] > 0:",
      "mutated_line": "if len(current_chain) != 0 and current_chain[0] > 0:",
      "code": "def minimum_cuts_for_doughnut_chain(N, M, chain_sizes):\n    if M == 1:\n        return 0\n    chain_sizes.sort(reverse=True)\n    cuts_needed = 0\n    current_chain = [chain_sizes.pop()]\n    while len(chain_sizes) > 0:\n        if current_chain[0] > 0:\n            current_chain[0] -= 1\n            cuts_needed += 1\n        else:\n            current_chain.pop()\n            if len(chain_sizes) > 0:\n                current_chain.append(chain_sizes.pop())\n    if len(current_chain) != 0 and current_chain[0] > 0:\n        cuts_needed += 1\n    return cuts_needed"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if len(current_chain) > 0 and current_chain[0] > 0:",
      "mutated_line": "if len(current_chain) > 0 and current_chain[0] >= 0:",
      "code": "def minimum_cuts_for_doughnut_chain(N, M, chain_sizes):\n    if M == 1:\n        return 0\n    chain_sizes.sort(reverse=True)\n    cuts_needed = 0\n    current_chain = [chain_sizes.pop()]\n    while len(chain_sizes) > 0:\n        if current_chain[0] > 0:\n            current_chain[0] -= 1\n            cuts_needed += 1\n        else:\n            current_chain.pop()\n            if len(chain_sizes) > 0:\n                current_chain.append(chain_sizes.pop())\n    if len(current_chain) > 0 and current_chain[0] >= 0:\n        cuts_needed += 1\n    return cuts_needed"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if len(current_chain) > 0 and current_chain[0] > 0:",
      "mutated_line": "if len(current_chain) > 0 and current_chain[0] <= 0:",
      "code": "def minimum_cuts_for_doughnut_chain(N, M, chain_sizes):\n    if M == 1:\n        return 0\n    chain_sizes.sort(reverse=True)\n    cuts_needed = 0\n    current_chain = [chain_sizes.pop()]\n    while len(chain_sizes) > 0:\n        if current_chain[0] > 0:\n            current_chain[0] -= 1\n            cuts_needed += 1\n        else:\n            current_chain.pop()\n            if len(chain_sizes) > 0:\n                current_chain.append(chain_sizes.pop())\n    if len(current_chain) > 0 and current_chain[0] <= 0:\n        cuts_needed += 1\n    return cuts_needed"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if len(current_chain) > 0 and current_chain[0] > 0:",
      "mutated_line": "if len(current_chain) > 0 and current_chain[0] != 0:",
      "code": "def minimum_cuts_for_doughnut_chain(N, M, chain_sizes):\n    if M == 1:\n        return 0\n    chain_sizes.sort(reverse=True)\n    cuts_needed = 0\n    current_chain = [chain_sizes.pop()]\n    while len(chain_sizes) > 0:\n        if current_chain[0] > 0:\n            current_chain[0] -= 1\n            cuts_needed += 1\n        else:\n            current_chain.pop()\n            if len(chain_sizes) > 0:\n                current_chain.append(chain_sizes.pop())\n    if len(current_chain) > 0 and current_chain[0] != 0:\n        cuts_needed += 1\n    return cuts_needed"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "cuts_needed += 1",
      "mutated_line": "cuts_needed += 2",
      "code": "def minimum_cuts_for_doughnut_chain(N, M, chain_sizes):\n    if M == 1:\n        return 0\n    chain_sizes.sort(reverse=True)\n    cuts_needed = 0\n    current_chain = [chain_sizes.pop()]\n    while len(chain_sizes) > 0:\n        if current_chain[0] > 0:\n            current_chain[0] -= 1\n            cuts_needed += 1\n        else:\n            current_chain.pop()\n            if len(chain_sizes) > 0:\n                current_chain.append(chain_sizes.pop())\n    if len(current_chain) > 0 and current_chain[0] > 0:\n        cuts_needed += 2\n    return cuts_needed"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "cuts_needed += 1",
      "mutated_line": "cuts_needed += 0",
      "code": "def minimum_cuts_for_doughnut_chain(N, M, chain_sizes):\n    if M == 1:\n        return 0\n    chain_sizes.sort(reverse=True)\n    cuts_needed = 0\n    current_chain = [chain_sizes.pop()]\n    while len(chain_sizes) > 0:\n        if current_chain[0] > 0:\n            current_chain[0] -= 1\n            cuts_needed += 1\n        else:\n            current_chain.pop()\n            if len(chain_sizes) > 0:\n                current_chain.append(chain_sizes.pop())\n    if len(current_chain) > 0 and current_chain[0] > 0:\n        cuts_needed += 0\n    return cuts_needed"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "cuts_needed += 1",
      "mutated_line": "cuts_needed += 0",
      "code": "def minimum_cuts_for_doughnut_chain(N, M, chain_sizes):\n    if M == 1:\n        return 0\n    chain_sizes.sort(reverse=True)\n    cuts_needed = 0\n    current_chain = [chain_sizes.pop()]\n    while len(chain_sizes) > 0:\n        if current_chain[0] > 0:\n            current_chain[0] -= 1\n            cuts_needed += 1\n        else:\n            current_chain.pop()\n            if len(chain_sizes) > 0:\n                current_chain.append(chain_sizes.pop())\n    if len(current_chain) > 0 and current_chain[0] > 0:\n        cuts_needed += 0\n    return cuts_needed"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "cuts_needed += 1",
      "mutated_line": "cuts_needed += -1",
      "code": "def minimum_cuts_for_doughnut_chain(N, M, chain_sizes):\n    if M == 1:\n        return 0\n    chain_sizes.sort(reverse=True)\n    cuts_needed = 0\n    current_chain = [chain_sizes.pop()]\n    while len(chain_sizes) > 0:\n        if current_chain[0] > 0:\n            current_chain[0] -= 1\n            cuts_needed += 1\n        else:\n            current_chain.pop()\n            if len(chain_sizes) > 0:\n                current_chain.append(chain_sizes.pop())\n    if len(current_chain) > 0 and current_chain[0] > 0:\n        cuts_needed += -1\n    return cuts_needed"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "chain_sizes.sort(reverse=True)",
      "mutated_line": "chain_sizes.sort(reverse=False)",
      "code": "def minimum_cuts_for_doughnut_chain(N, M, chain_sizes):\n    if M == 1:\n        return 0\n    chain_sizes.sort(reverse=False)\n    cuts_needed = 0\n    current_chain = [chain_sizes.pop()]\n    while len(chain_sizes) > 0:\n        if current_chain[0] > 0:\n            current_chain[0] -= 1\n            cuts_needed += 1\n        else:\n            current_chain.pop()\n            if len(chain_sizes) > 0:\n                current_chain.append(chain_sizes.pop())\n    if len(current_chain) > 0 and current_chain[0] > 0:\n        cuts_needed += 1\n    return cuts_needed"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if current_chain[0] > 0:",
      "mutated_line": "if current_chain[0] > 1:",
      "code": "def minimum_cuts_for_doughnut_chain(N, M, chain_sizes):\n    if M == 1:\n        return 0\n    chain_sizes.sort(reverse=True)\n    cuts_needed = 0\n    current_chain = [chain_sizes.pop()]\n    while len(chain_sizes) > 0:\n        if current_chain[0] > 1:\n            current_chain[0] -= 1\n            cuts_needed += 1\n        else:\n            current_chain.pop()\n            if len(chain_sizes) > 0:\n                current_chain.append(chain_sizes.pop())\n    if len(current_chain) > 0 and current_chain[0] > 0:\n        cuts_needed += 1\n    return cuts_needed"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if current_chain[0] > 0:",
      "mutated_line": "if current_chain[0] > -1:",
      "code": "def minimum_cuts_for_doughnut_chain(N, M, chain_sizes):\n    if M == 1:\n        return 0\n    chain_sizes.sort(reverse=True)\n    cuts_needed = 0\n    current_chain = [chain_sizes.pop()]\n    while len(chain_sizes) > 0:\n        if current_chain[0] > -1:\n            current_chain[0] -= 1\n            cuts_needed += 1\n        else:\n            current_chain.pop()\n            if len(chain_sizes) > 0:\n                current_chain.append(chain_sizes.pop())\n    if len(current_chain) > 0 and current_chain[0] > 0:\n        cuts_needed += 1\n    return cuts_needed"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if current_chain[0] > 0:",
      "mutated_line": "if current_chain[0] > 1:",
      "code": "def minimum_cuts_for_doughnut_chain(N, M, chain_sizes):\n    if M == 1:\n        return 0\n    chain_sizes.sort(reverse=True)\n    cuts_needed = 0\n    current_chain = [chain_sizes.pop()]\n    while len(chain_sizes) > 0:\n        if current_chain[0] > 1:\n            current_chain[0] -= 1\n            cuts_needed += 1\n        else:\n            current_chain.pop()\n            if len(chain_sizes) > 0:\n                current_chain.append(chain_sizes.pop())\n    if len(current_chain) > 0 and current_chain[0] > 0:\n        cuts_needed += 1\n    return cuts_needed"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "current_chain[0] -= 1",
      "mutated_line": "current_chain[0] -= 2",
      "code": "def minimum_cuts_for_doughnut_chain(N, M, chain_sizes):\n    if M == 1:\n        return 0\n    chain_sizes.sort(reverse=True)\n    cuts_needed = 0\n    current_chain = [chain_sizes.pop()]\n    while len(chain_sizes) > 0:\n        if current_chain[0] > 0:\n            current_chain[0] -= 2\n            cuts_needed += 1\n        else:\n            current_chain.pop()\n            if len(chain_sizes) > 0:\n                current_chain.append(chain_sizes.pop())\n    if len(current_chain) > 0 and current_chain[0] > 0:\n        cuts_needed += 1\n    return cuts_needed"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "current_chain[0] -= 1",
      "mutated_line": "current_chain[0] -= 0",
      "code": "def minimum_cuts_for_doughnut_chain(N, M, chain_sizes):\n    if M == 1:\n        return 0\n    chain_sizes.sort(reverse=True)\n    cuts_needed = 0\n    current_chain = [chain_sizes.pop()]\n    while len(chain_sizes) > 0:\n        if current_chain[0] > 0:\n            current_chain[0] -= 0\n            cuts_needed += 1\n        else:\n            current_chain.pop()\n            if len(chain_sizes) > 0:\n                current_chain.append(chain_sizes.pop())\n    if len(current_chain) > 0 and current_chain[0] > 0:\n        cuts_needed += 1\n    return cuts_needed"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "current_chain[0] -= 1",
      "mutated_line": "current_chain[0] -= 0",
      "code": "def minimum_cuts_for_doughnut_chain(N, M, chain_sizes):\n    if M == 1:\n        return 0\n    chain_sizes.sort(reverse=True)\n    cuts_needed = 0\n    current_chain = [chain_sizes.pop()]\n    while len(chain_sizes) > 0:\n        if current_chain[0] > 0:\n            current_chain[0] -= 0\n            cuts_needed += 1\n        else:\n            current_chain.pop()\n            if len(chain_sizes) > 0:\n                current_chain.append(chain_sizes.pop())\n    if len(current_chain) > 0 and current_chain[0] > 0:\n        cuts_needed += 1\n    return cuts_needed"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "current_chain[0] -= 1",
      "mutated_line": "current_chain[0] -= -1",
      "code": "def minimum_cuts_for_doughnut_chain(N, M, chain_sizes):\n    if M == 1:\n        return 0\n    chain_sizes.sort(reverse=True)\n    cuts_needed = 0\n    current_chain = [chain_sizes.pop()]\n    while len(chain_sizes) > 0:\n        if current_chain[0] > 0:\n            current_chain[0] -= -1\n            cuts_needed += 1\n        else:\n            current_chain.pop()\n            if len(chain_sizes) > 0:\n                current_chain.append(chain_sizes.pop())\n    if len(current_chain) > 0 and current_chain[0] > 0:\n        cuts_needed += 1\n    return cuts_needed"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "cuts_needed += 1",
      "mutated_line": "cuts_needed += 2",
      "code": "def minimum_cuts_for_doughnut_chain(N, M, chain_sizes):\n    if M == 1:\n        return 0\n    chain_sizes.sort(reverse=True)\n    cuts_needed = 0\n    current_chain = [chain_sizes.pop()]\n    while len(chain_sizes) > 0:\n        if current_chain[0] > 0:\n            current_chain[0] -= 1\n            cuts_needed += 2\n        else:\n            current_chain.pop()\n            if len(chain_sizes) > 0:\n                current_chain.append(chain_sizes.pop())\n    if len(current_chain) > 0 and current_chain[0] > 0:\n        cuts_needed += 1\n    return cuts_needed"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "cuts_needed += 1",
      "mutated_line": "cuts_needed += 0",
      "code": "def minimum_cuts_for_doughnut_chain(N, M, chain_sizes):\n    if M == 1:\n        return 0\n    chain_sizes.sort(reverse=True)\n    cuts_needed = 0\n    current_chain = [chain_sizes.pop()]\n    while len(chain_sizes) > 0:\n        if current_chain[0] > 0:\n            current_chain[0] -= 1\n            cuts_needed += 0\n        else:\n            current_chain.pop()\n            if len(chain_sizes) > 0:\n                current_chain.append(chain_sizes.pop())\n    if len(current_chain) > 0 and current_chain[0] > 0:\n        cuts_needed += 1\n    return cuts_needed"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "cuts_needed += 1",
      "mutated_line": "cuts_needed += 0",
      "code": "def minimum_cuts_for_doughnut_chain(N, M, chain_sizes):\n    if M == 1:\n        return 0\n    chain_sizes.sort(reverse=True)\n    cuts_needed = 0\n    current_chain = [chain_sizes.pop()]\n    while len(chain_sizes) > 0:\n        if current_chain[0] > 0:\n            current_chain[0] -= 1\n            cuts_needed += 0\n        else:\n            current_chain.pop()\n            if len(chain_sizes) > 0:\n                current_chain.append(chain_sizes.pop())\n    if len(current_chain) > 0 and current_chain[0] > 0:\n        cuts_needed += 1\n    return cuts_needed"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "cuts_needed += 1",
      "mutated_line": "cuts_needed += -1",
      "code": "def minimum_cuts_for_doughnut_chain(N, M, chain_sizes):\n    if M == 1:\n        return 0\n    chain_sizes.sort(reverse=True)\n    cuts_needed = 0\n    current_chain = [chain_sizes.pop()]\n    while len(chain_sizes) > 0:\n        if current_chain[0] > 0:\n            current_chain[0] -= 1\n            cuts_needed += -1\n        else:\n            current_chain.pop()\n            if len(chain_sizes) > 0:\n                current_chain.append(chain_sizes.pop())\n    if len(current_chain) > 0 and current_chain[0] > 0:\n        cuts_needed += 1\n    return cuts_needed"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if len(chain_sizes) > 0:",
      "mutated_line": "if len(chain_sizes) >= 0:",
      "code": "def minimum_cuts_for_doughnut_chain(N, M, chain_sizes):\n    if M == 1:\n        return 0\n    chain_sizes.sort(reverse=True)\n    cuts_needed = 0\n    current_chain = [chain_sizes.pop()]\n    while len(chain_sizes) > 0:\n        if current_chain[0] > 0:\n            current_chain[0] -= 1\n            cuts_needed += 1\n        else:\n            current_chain.pop()\n            if len(chain_sizes) >= 0:\n                current_chain.append(chain_sizes.pop())\n    if len(current_chain) > 0 and current_chain[0] > 0:\n        cuts_needed += 1\n    return cuts_needed"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if len(chain_sizes) > 0:",
      "mutated_line": "if len(chain_sizes) <= 0:",
      "code": "def minimum_cuts_for_doughnut_chain(N, M, chain_sizes):\n    if M == 1:\n        return 0\n    chain_sizes.sort(reverse=True)\n    cuts_needed = 0\n    current_chain = [chain_sizes.pop()]\n    while len(chain_sizes) > 0:\n        if current_chain[0] > 0:\n            current_chain[0] -= 1\n            cuts_needed += 1\n        else:\n            current_chain.pop()\n            if len(chain_sizes) <= 0:\n                current_chain.append(chain_sizes.pop())\n    if len(current_chain) > 0 and current_chain[0] > 0:\n        cuts_needed += 1\n    return cuts_needed"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if len(chain_sizes) > 0:",
      "mutated_line": "if len(chain_sizes) != 0:",
      "code": "def minimum_cuts_for_doughnut_chain(N, M, chain_sizes):\n    if M == 1:\n        return 0\n    chain_sizes.sort(reverse=True)\n    cuts_needed = 0\n    current_chain = [chain_sizes.pop()]\n    while len(chain_sizes) > 0:\n        if current_chain[0] > 0:\n            current_chain[0] -= 1\n            cuts_needed += 1\n        else:\n            current_chain.pop()\n            if len(chain_sizes) != 0:\n                current_chain.append(chain_sizes.pop())\n    if len(current_chain) > 0 and current_chain[0] > 0:\n        cuts_needed += 1\n    return cuts_needed"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if len(current_chain) > 0 and current_chain[0] > 0:",
      "mutated_line": "if len(current_chain) > 1 and current_chain[0] > 0:",
      "code": "def minimum_cuts_for_doughnut_chain(N, M, chain_sizes):\n    if M == 1:\n        return 0\n    chain_sizes.sort(reverse=True)\n    cuts_needed = 0\n    current_chain = [chain_sizes.pop()]\n    while len(chain_sizes) > 0:\n        if current_chain[0] > 0:\n            current_chain[0] -= 1\n            cuts_needed += 1\n        else:\n            current_chain.pop()\n            if len(chain_sizes) > 0:\n                current_chain.append(chain_sizes.pop())\n    if len(current_chain) > 1 and current_chain[0] > 0:\n        cuts_needed += 1\n    return cuts_needed"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if len(current_chain) > 0 and current_chain[0] > 0:",
      "mutated_line": "if len(current_chain) > -1 and current_chain[0] > 0:",
      "code": "def minimum_cuts_for_doughnut_chain(N, M, chain_sizes):\n    if M == 1:\n        return 0\n    chain_sizes.sort(reverse=True)\n    cuts_needed = 0\n    current_chain = [chain_sizes.pop()]\n    while len(chain_sizes) > 0:\n        if current_chain[0] > 0:\n            current_chain[0] -= 1\n            cuts_needed += 1\n        else:\n            current_chain.pop()\n            if len(chain_sizes) > 0:\n                current_chain.append(chain_sizes.pop())\n    if len(current_chain) > -1 and current_chain[0] > 0:\n        cuts_needed += 1\n    return cuts_needed"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if len(current_chain) > 0 and current_chain[0] > 0:",
      "mutated_line": "if len(current_chain) > 1 and current_chain[0] > 0:",
      "code": "def minimum_cuts_for_doughnut_chain(N, M, chain_sizes):\n    if M == 1:\n        return 0\n    chain_sizes.sort(reverse=True)\n    cuts_needed = 0\n    current_chain = [chain_sizes.pop()]\n    while len(chain_sizes) > 0:\n        if current_chain[0] > 0:\n            current_chain[0] -= 1\n            cuts_needed += 1\n        else:\n            current_chain.pop()\n            if len(chain_sizes) > 0:\n                current_chain.append(chain_sizes.pop())\n    if len(current_chain) > 1 and current_chain[0] > 0:\n        cuts_needed += 1\n    return cuts_needed"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if len(current_chain) > 0 and current_chain[0] > 0:",
      "mutated_line": "if len(current_chain) > 0 and current_chain[0] > 1:",
      "code": "def minimum_cuts_for_doughnut_chain(N, M, chain_sizes):\n    if M == 1:\n        return 0\n    chain_sizes.sort(reverse=True)\n    cuts_needed = 0\n    current_chain = [chain_sizes.pop()]\n    while len(chain_sizes) > 0:\n        if current_chain[0] > 0:\n            current_chain[0] -= 1\n            cuts_needed += 1\n        else:\n            current_chain.pop()\n            if len(chain_sizes) > 0:\n                current_chain.append(chain_sizes.pop())\n    if len(current_chain) > 0 and current_chain[0] > 1:\n        cuts_needed += 1\n    return cuts_needed"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if len(current_chain) > 0 and current_chain[0] > 0:",
      "mutated_line": "if len(current_chain) > 0 and current_chain[0] > -1:",
      "code": "def minimum_cuts_for_doughnut_chain(N, M, chain_sizes):\n    if M == 1:\n        return 0\n    chain_sizes.sort(reverse=True)\n    cuts_needed = 0\n    current_chain = [chain_sizes.pop()]\n    while len(chain_sizes) > 0:\n        if current_chain[0] > 0:\n            current_chain[0] -= 1\n            cuts_needed += 1\n        else:\n            current_chain.pop()\n            if len(chain_sizes) > 0:\n                current_chain.append(chain_sizes.pop())\n    if len(current_chain) > 0 and current_chain[0] > -1:\n        cuts_needed += 1\n    return cuts_needed"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if len(current_chain) > 0 and current_chain[0] > 0:",
      "mutated_line": "if len(current_chain) > 0 and current_chain[0] > 1:",
      "code": "def minimum_cuts_for_doughnut_chain(N, M, chain_sizes):\n    if M == 1:\n        return 0\n    chain_sizes.sort(reverse=True)\n    cuts_needed = 0\n    current_chain = [chain_sizes.pop()]\n    while len(chain_sizes) > 0:\n        if current_chain[0] > 0:\n            current_chain[0] -= 1\n            cuts_needed += 1\n        else:\n            current_chain.pop()\n            if len(chain_sizes) > 0:\n                current_chain.append(chain_sizes.pop())\n    if len(current_chain) > 0 and current_chain[0] > 1:\n        cuts_needed += 1\n    return cuts_needed"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if current_chain[0] > 0:",
      "mutated_line": "if current_chain[1] > 0:",
      "code": "def minimum_cuts_for_doughnut_chain(N, M, chain_sizes):\n    if M == 1:\n        return 0\n    chain_sizes.sort(reverse=True)\n    cuts_needed = 0\n    current_chain = [chain_sizes.pop()]\n    while len(chain_sizes) > 0:\n        if current_chain[1] > 0:\n            current_chain[0] -= 1\n            cuts_needed += 1\n        else:\n            current_chain.pop()\n            if len(chain_sizes) > 0:\n                current_chain.append(chain_sizes.pop())\n    if len(current_chain) > 0 and current_chain[0] > 0:\n        cuts_needed += 1\n    return cuts_needed"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if current_chain[0] > 0:",
      "mutated_line": "if current_chain[-1] > 0:",
      "code": "def minimum_cuts_for_doughnut_chain(N, M, chain_sizes):\n    if M == 1:\n        return 0\n    chain_sizes.sort(reverse=True)\n    cuts_needed = 0\n    current_chain = [chain_sizes.pop()]\n    while len(chain_sizes) > 0:\n        if current_chain[-1] > 0:\n            current_chain[0] -= 1\n            cuts_needed += 1\n        else:\n            current_chain.pop()\n            if len(chain_sizes) > 0:\n                current_chain.append(chain_sizes.pop())\n    if len(current_chain) > 0 and current_chain[0] > 0:\n        cuts_needed += 1\n    return cuts_needed"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if current_chain[0] > 0:",
      "mutated_line": "if current_chain[1] > 0:",
      "code": "def minimum_cuts_for_doughnut_chain(N, M, chain_sizes):\n    if M == 1:\n        return 0\n    chain_sizes.sort(reverse=True)\n    cuts_needed = 0\n    current_chain = [chain_sizes.pop()]\n    while len(chain_sizes) > 0:\n        if current_chain[1] > 0:\n            current_chain[0] -= 1\n            cuts_needed += 1\n        else:\n            current_chain.pop()\n            if len(chain_sizes) > 0:\n                current_chain.append(chain_sizes.pop())\n    if len(current_chain) > 0 and current_chain[0] > 0:\n        cuts_needed += 1\n    return cuts_needed"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "current_chain[0] -= 1",
      "mutated_line": "current_chain[1] -= 1",
      "code": "def minimum_cuts_for_doughnut_chain(N, M, chain_sizes):\n    if M == 1:\n        return 0\n    chain_sizes.sort(reverse=True)\n    cuts_needed = 0\n    current_chain = [chain_sizes.pop()]\n    while len(chain_sizes) > 0:\n        if current_chain[0] > 0:\n            current_chain[1] -= 1\n            cuts_needed += 1\n        else:\n            current_chain.pop()\n            if len(chain_sizes) > 0:\n                current_chain.append(chain_sizes.pop())\n    if len(current_chain) > 0 and current_chain[0] > 0:\n        cuts_needed += 1\n    return cuts_needed"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "current_chain[0] -= 1",
      "mutated_line": "current_chain[-1] -= 1",
      "code": "def minimum_cuts_for_doughnut_chain(N, M, chain_sizes):\n    if M == 1:\n        return 0\n    chain_sizes.sort(reverse=True)\n    cuts_needed = 0\n    current_chain = [chain_sizes.pop()]\n    while len(chain_sizes) > 0:\n        if current_chain[0] > 0:\n            current_chain[-1] -= 1\n            cuts_needed += 1\n        else:\n            current_chain.pop()\n            if len(chain_sizes) > 0:\n                current_chain.append(chain_sizes.pop())\n    if len(current_chain) > 0 and current_chain[0] > 0:\n        cuts_needed += 1\n    return cuts_needed"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "current_chain[0] -= 1",
      "mutated_line": "current_chain[1] -= 1",
      "code": "def minimum_cuts_for_doughnut_chain(N, M, chain_sizes):\n    if M == 1:\n        return 0\n    chain_sizes.sort(reverse=True)\n    cuts_needed = 0\n    current_chain = [chain_sizes.pop()]\n    while len(chain_sizes) > 0:\n        if current_chain[0] > 0:\n            current_chain[1] -= 1\n            cuts_needed += 1\n        else:\n            current_chain.pop()\n            if len(chain_sizes) > 0:\n                current_chain.append(chain_sizes.pop())\n    if len(current_chain) > 0 and current_chain[0] > 0:\n        cuts_needed += 1\n    return cuts_needed"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if len(chain_sizes) > 0:",
      "mutated_line": "if len(chain_sizes) > 1:",
      "code": "def minimum_cuts_for_doughnut_chain(N, M, chain_sizes):\n    if M == 1:\n        return 0\n    chain_sizes.sort(reverse=True)\n    cuts_needed = 0\n    current_chain = [chain_sizes.pop()]\n    while len(chain_sizes) > 0:\n        if current_chain[0] > 0:\n            current_chain[0] -= 1\n            cuts_needed += 1\n        else:\n            current_chain.pop()\n            if len(chain_sizes) > 1:\n                current_chain.append(chain_sizes.pop())\n    if len(current_chain) > 0 and current_chain[0] > 0:\n        cuts_needed += 1\n    return cuts_needed"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if len(chain_sizes) > 0:",
      "mutated_line": "if len(chain_sizes) > -1:",
      "code": "def minimum_cuts_for_doughnut_chain(N, M, chain_sizes):\n    if M == 1:\n        return 0\n    chain_sizes.sort(reverse=True)\n    cuts_needed = 0\n    current_chain = [chain_sizes.pop()]\n    while len(chain_sizes) > 0:\n        if current_chain[0] > 0:\n            current_chain[0] -= 1\n            cuts_needed += 1\n        else:\n            current_chain.pop()\n            if len(chain_sizes) > -1:\n                current_chain.append(chain_sizes.pop())\n    if len(current_chain) > 0 and current_chain[0] > 0:\n        cuts_needed += 1\n    return cuts_needed"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if len(chain_sizes) > 0:",
      "mutated_line": "if len(chain_sizes) > 1:",
      "code": "def minimum_cuts_for_doughnut_chain(N, M, chain_sizes):\n    if M == 1:\n        return 0\n    chain_sizes.sort(reverse=True)\n    cuts_needed = 0\n    current_chain = [chain_sizes.pop()]\n    while len(chain_sizes) > 0:\n        if current_chain[0] > 0:\n            current_chain[0] -= 1\n            cuts_needed += 1\n        else:\n            current_chain.pop()\n            if len(chain_sizes) > 1:\n                current_chain.append(chain_sizes.pop())\n    if len(current_chain) > 0 and current_chain[0] > 0:\n        cuts_needed += 1\n    return cuts_needed"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if len(current_chain) > 0 and current_chain[0] > 0:",
      "mutated_line": "if len(current_chain) > 0 and current_chain[1] > 0:",
      "code": "def minimum_cuts_for_doughnut_chain(N, M, chain_sizes):\n    if M == 1:\n        return 0\n    chain_sizes.sort(reverse=True)\n    cuts_needed = 0\n    current_chain = [chain_sizes.pop()]\n    while len(chain_sizes) > 0:\n        if current_chain[0] > 0:\n            current_chain[0] -= 1\n            cuts_needed += 1\n        else:\n            current_chain.pop()\n            if len(chain_sizes) > 0:\n                current_chain.append(chain_sizes.pop())\n    if len(current_chain) > 0 and current_chain[1] > 0:\n        cuts_needed += 1\n    return cuts_needed"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if len(current_chain) > 0 and current_chain[0] > 0:",
      "mutated_line": "if len(current_chain) > 0 and current_chain[-1] > 0:",
      "code": "def minimum_cuts_for_doughnut_chain(N, M, chain_sizes):\n    if M == 1:\n        return 0\n    chain_sizes.sort(reverse=True)\n    cuts_needed = 0\n    current_chain = [chain_sizes.pop()]\n    while len(chain_sizes) > 0:\n        if current_chain[0] > 0:\n            current_chain[0] -= 1\n            cuts_needed += 1\n        else:\n            current_chain.pop()\n            if len(chain_sizes) > 0:\n                current_chain.append(chain_sizes.pop())\n    if len(current_chain) > 0 and current_chain[-1] > 0:\n        cuts_needed += 1\n    return cuts_needed"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if len(current_chain) > 0 and current_chain[0] > 0:",
      "mutated_line": "if len(current_chain) > 0 and current_chain[1] > 0:",
      "code": "def minimum_cuts_for_doughnut_chain(N, M, chain_sizes):\n    if M == 1:\n        return 0\n    chain_sizes.sort(reverse=True)\n    cuts_needed = 0\n    current_chain = [chain_sizes.pop()]\n    while len(chain_sizes) > 0:\n        if current_chain[0] > 0:\n            current_chain[0] -= 1\n            cuts_needed += 1\n        else:\n            current_chain.pop()\n            if len(chain_sizes) > 0:\n                current_chain.append(chain_sizes.pop())\n    if len(current_chain) > 0 and current_chain[1] > 0:\n        cuts_needed += 1\n    return cuts_needed"
    }
  ]
}