{
  "task_id": "taco_11029",
  "entry_point": "count_sliding_patterns",
  "mutant_count": 165,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 1\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "ans = 0",
      "mutated_line": "ans = -1",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = -1\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 1\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "(BLANK, OBSTACLE, JUMP) = (0, 1, 2)",
      "mutated_line": "(BLANK, OBSTACLE, JUMP) = (1, 1, 2)",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (1, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "(BLANK, OBSTACLE, JUMP) = (0, 1, 2)",
      "mutated_line": "(BLANK, OBSTACLE, JUMP) = (-1, 1, 2)",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (-1, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "(BLANK, OBSTACLE, JUMP) = (0, 1, 2)",
      "mutated_line": "(BLANK, OBSTACLE, JUMP) = (1, 1, 2)",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (1, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "(BLANK, OBSTACLE, JUMP) = (0, 1, 2)",
      "mutated_line": "(BLANK, OBSTACLE, JUMP) = (0, 2, 2)",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 2, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "(BLANK, OBSTACLE, JUMP) = (0, 1, 2)",
      "mutated_line": "(BLANK, OBSTACLE, JUMP) = (0, 0, 2)",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 0, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "(BLANK, OBSTACLE, JUMP) = (0, 1, 2)",
      "mutated_line": "(BLANK, OBSTACLE, JUMP) = (0, 0, 2)",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 0, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "(BLANK, OBSTACLE, JUMP) = (0, 1, 2)",
      "mutated_line": "(BLANK, OBSTACLE, JUMP) = (0, -1, 2)",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, -1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "(BLANK, OBSTACLE, JUMP) = (0, 1, 2)",
      "mutated_line": "(BLANK, OBSTACLE, JUMP) = (0, 1, 3)",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 3)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "(BLANK, OBSTACLE, JUMP) = (0, 1, 2)",
      "mutated_line": "(BLANK, OBSTACLE, JUMP) = (0, 1, 1)",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 1)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "(BLANK, OBSTACLE, JUMP) = (0, 1, 2)",
      "mutated_line": "(BLANK, OBSTACLE, JUMP) = (0, 1, 0)",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 0)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "(BLANK, OBSTACLE, JUMP) = (0, 1, 2)",
      "mutated_line": "(BLANK, OBSTACLE, JUMP) = (0, 1, 1)",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 1)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "(BLANK, OBSTACLE, JUMP) = (0, 1, 2)",
      "mutated_line": "(BLANK, OBSTACLE, JUMP) = (0, 1, -2)",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, -2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dy = [1, 1, 1]",
      "mutated_line": "dy = [2, 1, 1]",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [2, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dy = [1, 1, 1]",
      "mutated_line": "dy = [0, 1, 1]",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [0, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dy = [1, 1, 1]",
      "mutated_line": "dy = [0, 1, 1]",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [0, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dy = [1, 1, 1]",
      "mutated_line": "dy = [-1, 1, 1]",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [-1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dy = [1, 1, 1]",
      "mutated_line": "dy = [1, 2, 1]",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 2, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dy = [1, 1, 1]",
      "mutated_line": "dy = [1, 0, 1]",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 0, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dy = [1, 1, 1]",
      "mutated_line": "dy = [1, 0, 1]",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 0, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dy = [1, 1, 1]",
      "mutated_line": "dy = [1, -1, 1]",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, -1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dy = [1, 1, 1]",
      "mutated_line": "dy = [1, 1, 2]",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 2]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dy = [1, 1, 1]",
      "mutated_line": "dy = [1, 1, 0]",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 0]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dy = [1, 1, 1]",
      "mutated_line": "dy = [1, 1, 0]",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 0]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dy = [1, 1, 1]",
      "mutated_line": "dy = [1, 1, -1]",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, -1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dx = [0, -1, 1]",
      "mutated_line": "dx = [1, -1, 1]",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [1, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dx = [0, -1, 1]",
      "mutated_line": "dx = [-1, -1, 1]",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [-1, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dx = [0, -1, 1]",
      "mutated_line": "dx = [1, -1, 1]",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [1, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 5,
      "original_line": "dx = [0, -1, 1]",
      "mutated_line": "dx = [0, +1, 1]",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, +1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dx = [0, -1, 1]",
      "mutated_line": "dx = [0, -1, 2]",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 2]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dx = [0, -1, 1]",
      "mutated_line": "dx = [0, -1, 0]",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 0]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dx = [0, -1, 1]",
      "mutated_line": "dx = [0, -1, 0]",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 0]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dx = [0, -1, 1]",
      "mutated_line": "dx = [0, -1, -1]",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, -1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if course[0][x] == BLANK:",
      "mutated_line": "if course[0][x] != BLANK:",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] != BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if course[cy][cx] == OBSTACLE:",
      "mutated_line": "if course[cy][cx] != OBSTACLE:",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] != OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dx = [0, -1, 1]",
      "mutated_line": "dx = [0, -2, 1]",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -2, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dx = [0, -1, 1]",
      "mutated_line": "dx = [0, -0, 1]",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -0, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dx = [0, -1, 1]",
      "mutated_line": "dx = [0, -0, 1]",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -0, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dx = [0, -1, 1]",
      "mutated_line": "dx = [0, --1, 1]",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, --1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "path[t] = 1",
      "mutated_line": "path[t] = 2",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 2\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "path[t] = 1",
      "mutated_line": "path[t] = 0",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 0\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "path[t] = 1",
      "mutated_line": "path[t] = 0",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 0\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "path[t] = 1",
      "mutated_line": "path[t] = -1",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = -1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "t = f'{cx}_{cy}'",
      "mutated_line": "t = f'{cx}{cy}'",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "elif course[cy][cx] == JUMP:",
      "mutated_line": "elif course[cy][cx] != JUMP:",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] != JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for i in range(3):",
      "mutated_line": "for i in range(4):",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(4):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for i in range(3):",
      "mutated_line": "for i in range(2):",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(2):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for i in range(3):",
      "mutated_line": "for i in range(0):",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(0):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for i in range(3):",
      "mutated_line": "for i in range(1):",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(1):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for i in range(3):",
      "mutated_line": "for i in range(-3):",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(-3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "nx = cx + dx[i]",
      "mutated_line": "nx = cx - dx[i]",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx - dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "nx = cx + dx[i]",
      "mutated_line": "nx = cx * dx[i]",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx * dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "ny = cy + dy[i]",
      "mutated_line": "ny = cy - dy[i]",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy - dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "ny = cy + dy[i]",
      "mutated_line": "ny = cy * dy[i]",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy * dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if 0 <= nx < x_limit:",
      "mutated_line": "if 0 < nx < x_limit:",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 < nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if 0 <= nx < x_limit:",
      "mutated_line": "if 0 > nx < x_limit:",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 > nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if 0 <= nx < x_limit:",
      "mutated_line": "if 0 == nx < x_limit:",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 == nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "t = f'{x}_{0}'",
      "mutated_line": "t = f'{x}{0}'",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if cy + 2 > y_limit - 1:",
      "mutated_line": "if cy + 2 >= y_limit - 1:",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 >= y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if cy + 2 > y_limit - 1:",
      "mutated_line": "if cy + 2 <= y_limit - 1:",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 <= y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if cy + 2 > y_limit - 1:",
      "mutated_line": "if cy + 2 != y_limit - 1:",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 != y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 26,
      "original_line": "ans += num",
      "mutated_line": "ans -= num",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans -= num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 31,
      "original_line": "path[t] += num",
      "mutated_line": "path[t] -= num",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] -= num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "elif cy == y_limit - 1:",
      "mutated_line": "elif cy != y_limit - 1:",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy != y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 34,
      "original_line": "ans += num",
      "mutated_line": "ans -= num",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans -= num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if 0 <= nx < x_limit:",
      "mutated_line": "if 1 <= nx < x_limit:",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 1 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if 0 <= nx < x_limit:",
      "mutated_line": "if -1 <= nx < x_limit:",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if -1 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if 0 <= nx < x_limit:",
      "mutated_line": "if 1 <= nx < x_limit:",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 1 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "LCR",
      "lineno": 41,
      "original_line": "if course[ny][nx] == JUMP and dx[i] == 0:",
      "mutated_line": "if course[ny][nx] == JUMP or dx[i] == 0:",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP or dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if course[0][x] == BLANK:",
      "mutated_line": "if course[1][x] == BLANK:",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[1][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if course[0][x] == BLANK:",
      "mutated_line": "if course[-1][x] == BLANK:",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[-1][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if course[0][x] == BLANK:",
      "mutated_line": "if course[1][x] == BLANK:",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[1][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "t = f'{x}_{0}'",
      "mutated_line": "t = f'{x}_{1}'",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{1}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "t = f'{x}_{0}'",
      "mutated_line": "t = f'{x}_{-1}'",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{-1}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "t = f'{x}_{0}'",
      "mutated_line": "t = f'{x}_{1}'",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{1}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "Q.append((x, 0))",
      "mutated_line": "Q.append((x, 1))",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 1))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "Q.append((x, 0))",
      "mutated_line": "Q.append((x, -1))",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, -1))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "Q.append((x, 0))",
      "mutated_line": "Q.append((x, 1))",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 1))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if cy + 2 > y_limit - 1:",
      "mutated_line": "if cy - 2 > y_limit - 1:",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy - 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if cy + 2 > y_limit - 1:",
      "mutated_line": "if cy * 2 > y_limit - 1:",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy * 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if cy + 2 > y_limit - 1:",
      "mutated_line": "if cy + 2 > y_limit + 1:",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit + 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if cy + 2 > y_limit - 1:",
      "mutated_line": "if cy + 2 > y_limit * 1:",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit * 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "elif cy == y_limit - 1:",
      "mutated_line": "elif cy == y_limit + 1:",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit + 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "elif cy == y_limit - 1:",
      "mutated_line": "elif cy == y_limit * 1:",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit * 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if course[ny][nx] == JUMP and dx[i] == 0:",
      "mutated_line": "if course[ny][nx] != JUMP and dx[i] == 0:",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] != JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if course[ny][nx] == JUMP and dx[i] == 0:",
      "mutated_line": "if course[ny][nx] == JUMP and dx[i] != 0:",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] != 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if ny + 2 > y_limit - 1:",
      "mutated_line": "if ny + 2 >= y_limit - 1:",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if ny + 2 > y_limit - 1:",
      "mutated_line": "if ny + 2 <= y_limit - 1:",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 <= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if ny + 2 > y_limit - 1:",
      "mutated_line": "if ny + 2 != y_limit - 1:",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 != y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 43,
      "original_line": "ans += num",
      "mutated_line": "ans -= num",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans -= num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 48,
      "original_line": "path[t] += num",
      "mutated_line": "path[t] -= num",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] -= num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 49,
      "original_line": "elif course[ny][nx] == BLANK:",
      "mutated_line": "elif course[ny][nx] != BLANK:",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] != BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if cy + 2 > y_limit - 1:",
      "mutated_line": "if cy + 3 > y_limit - 1:",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 3 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if cy + 2 > y_limit - 1:",
      "mutated_line": "if cy + 1 > y_limit - 1:",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 1 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if cy + 2 > y_limit - 1:",
      "mutated_line": "if cy + 0 > y_limit - 1:",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 0 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if cy + 2 > y_limit - 1:",
      "mutated_line": "if cy + 1 > y_limit - 1:",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 1 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if cy + 2 > y_limit - 1:",
      "mutated_line": "if cy + -2 > y_limit - 1:",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + -2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if cy + 2 > y_limit - 1:",
      "mutated_line": "if cy + 2 > y_limit - 2:",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 2:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if cy + 2 > y_limit - 1:",
      "mutated_line": "if cy + 2 > y_limit - 0:",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 0:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if cy + 2 > y_limit - 1:",
      "mutated_line": "if cy + 2 > y_limit - 0:",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 0:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if cy + 2 > y_limit - 1:",
      "mutated_line": "if cy + 2 > y_limit - -1:",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - -1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "t = f'{cx}_{cy + 2}'",
      "mutated_line": "t = f'{cx}{cy + 2}'",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "elif cy == y_limit - 1:",
      "mutated_line": "elif cy == y_limit - 2:",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 2:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "elif cy == y_limit - 1:",
      "mutated_line": "elif cy == y_limit - 0:",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 0:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "elif cy == y_limit - 1:",
      "mutated_line": "elif cy == y_limit - 0:",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 0:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "elif cy == y_limit - 1:",
      "mutated_line": "elif cy == y_limit - -1:",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - -1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if course[ny][nx] == JUMP and dx[i] == 0:",
      "mutated_line": "if course[ny][nx] == JUMP and dx[i] == 1:",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 1:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if course[ny][nx] == JUMP and dx[i] == 0:",
      "mutated_line": "if course[ny][nx] == JUMP and dx[i] == -1:",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == -1:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if course[ny][nx] == JUMP and dx[i] == 0:",
      "mutated_line": "if course[ny][nx] == JUMP and dx[i] == 1:",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 1:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "if ny + 2 > y_limit - 1:",
      "mutated_line": "if ny - 2 > y_limit - 1:",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny - 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "if ny + 2 > y_limit - 1:",
      "mutated_line": "if ny * 2 > y_limit - 1:",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny * 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "if ny + 2 > y_limit - 1:",
      "mutated_line": "if ny + 2 > y_limit + 1:",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit + 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "if ny + 2 > y_limit - 1:",
      "mutated_line": "if ny + 2 > y_limit * 1:",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit * 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 50,
      "original_line": "if ny >= y_limit - 1:",
      "mutated_line": "if ny > y_limit - 1:",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 50,
      "original_line": "if ny >= y_limit - 1:",
      "mutated_line": "if ny < y_limit - 1:",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny < y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 50,
      "original_line": "if ny >= y_limit - 1:",
      "mutated_line": "if ny == y_limit - 1:",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny == y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 51,
      "original_line": "ans += num",
      "mutated_line": "ans -= num",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans -= num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 56,
      "original_line": "path[t] += num",
      "mutated_line": "path[t] -= num",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] -= num\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "t = f'{cx}_{cy + 2}'",
      "mutated_line": "t = f'{cx}_{cy - 2}'",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy - 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "t = f'{cx}_{cy + 2}'",
      "mutated_line": "t = f'{cx}_{cy * 2}'",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy * 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if ny + 2 > y_limit - 1:",
      "mutated_line": "if ny + 3 > y_limit - 1:",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 3 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if ny + 2 > y_limit - 1:",
      "mutated_line": "if ny + 1 > y_limit - 1:",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 1 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if ny + 2 > y_limit - 1:",
      "mutated_line": "if ny + 0 > y_limit - 1:",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 0 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if ny + 2 > y_limit - 1:",
      "mutated_line": "if ny + 1 > y_limit - 1:",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 1 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if ny + 2 > y_limit - 1:",
      "mutated_line": "if ny + -2 > y_limit - 1:",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + -2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if ny + 2 > y_limit - 1:",
      "mutated_line": "if ny + 2 > y_limit - 2:",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 2:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if ny + 2 > y_limit - 1:",
      "mutated_line": "if ny + 2 > y_limit - 0:",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 0:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if ny + 2 > y_limit - 1:",
      "mutated_line": "if ny + 2 > y_limit - 0:",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 0:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if ny + 2 > y_limit - 1:",
      "mutated_line": "if ny + 2 > y_limit - -1:",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - -1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "t = f'{nx}_{ny + 2}'",
      "mutated_line": "t = f'{nx}{ny + 2}'",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "if ny >= y_limit - 1:",
      "mutated_line": "if ny >= y_limit + 1:",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit + 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "if ny >= y_limit - 1:",
      "mutated_line": "if ny >= y_limit * 1:",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit * 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "t = f'{cx}_{cy + 2}'",
      "mutated_line": "t = f'{cx}_{cy + 3}'",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 3}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "t = f'{cx}_{cy + 2}'",
      "mutated_line": "t = f'{cx}_{cy + 1}'",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 1}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "t = f'{cx}_{cy + 2}'",
      "mutated_line": "t = f'{cx}_{cy + 0}'",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 0}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "t = f'{cx}_{cy + 2}'",
      "mutated_line": "t = f'{cx}_{cy + 1}'",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 1}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "t = f'{cx}_{cy + 2}'",
      "mutated_line": "t = f'{cx}_{cy + -2}'",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + -2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "Q.append((cx, cy + 2))",
      "mutated_line": "Q.append((cx, cy - 2))",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy - 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "Q.append((cx, cy + 2))",
      "mutated_line": "Q.append((cx, cy * 2))",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy * 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "t = f'{nx}_{ny + 2}'",
      "mutated_line": "t = f'{nx}_{ny - 2}'",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny - 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "t = f'{nx}_{ny + 2}'",
      "mutated_line": "t = f'{nx}_{ny * 2}'",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny * 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "if ny >= y_limit - 1:",
      "mutated_line": "if ny >= y_limit - 2:",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 2:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "if ny >= y_limit - 1:",
      "mutated_line": "if ny >= y_limit - 0:",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 0:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "if ny >= y_limit - 1:",
      "mutated_line": "if ny >= y_limit - 0:",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 0:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "if ny >= y_limit - 1:",
      "mutated_line": "if ny >= y_limit - -1:",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - -1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "t = f'{nx}_{ny}'",
      "mutated_line": "t = f'{nx}{ny}'",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "Q.append((cx, cy + 2))",
      "mutated_line": "Q.append((cx, cy + 3))",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 3))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "Q.append((cx, cy + 2))",
      "mutated_line": "Q.append((cx, cy + 1))",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 1))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "Q.append((cx, cy + 2))",
      "mutated_line": "Q.append((cx, cy + 0))",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 0))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "Q.append((cx, cy + 2))",
      "mutated_line": "Q.append((cx, cy + 1))",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 1))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "Q.append((cx, cy + 2))",
      "mutated_line": "Q.append((cx, cy + -2))",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + -2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "t = f'{nx}_{ny + 2}'",
      "mutated_line": "t = f'{nx}_{ny + 3}'",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 3}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "t = f'{nx}_{ny + 2}'",
      "mutated_line": "t = f'{nx}_{ny + 1}'",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 1}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "t = f'{nx}_{ny + 2}'",
      "mutated_line": "t = f'{nx}_{ny + 0}'",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 0}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "t = f'{nx}_{ny + 2}'",
      "mutated_line": "t = f'{nx}_{ny + 1}'",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 1}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "t = f'{nx}_{ny + 2}'",
      "mutated_line": "t = f'{nx}_{ny + -2}'",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + -2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "Q.append((nx, ny + 2))",
      "mutated_line": "Q.append((nx, ny - 2))",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny - 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "Q.append((nx, ny + 2))",
      "mutated_line": "Q.append((nx, ny * 2))",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny * 2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "Q.append((nx, ny + 2))",
      "mutated_line": "Q.append((nx, ny + 3))",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 3))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "Q.append((nx, ny + 2))",
      "mutated_line": "Q.append((nx, ny + 1))",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 1))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "Q.append((nx, ny + 2))",
      "mutated_line": "Q.append((nx, ny + 0))",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 0))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "Q.append((nx, ny + 2))",
      "mutated_line": "Q.append((nx, ny + 1))",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + 1))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "Q.append((nx, ny + 2))",
      "mutated_line": "Q.append((nx, ny + -2))",
      "code": "def count_sliding_patterns(X, Y, course):\n    (BLANK, OBSTACLE, JUMP) = (0, 1, 2)\n    ans = 0\n    dy = [1, 1, 1]\n    dx = [0, -1, 1]\n    x_limit = X\n    y_limit = Y\n    path = defaultdict(int)\n    Q = deque()\n    for x in range(X):\n        if course[0][x] == BLANK:\n            t = f'{x}_{0}'\n            Q.append((x, 0))\n            path[t] = 1\n    while Q:\n        (cx, cy) = Q.popleft()\n        t = f'{cx}_{cy}'\n        num = path.pop(t)\n        if course[cy][cx] == OBSTACLE:\n            continue\n        elif course[cy][cx] == JUMP:\n            if cy + 2 > y_limit - 1:\n                ans += num\n            else:\n                t = f'{cx}_{cy + 2}'\n                if not path[t]:\n                    Q.append((cx, cy + 2))\n                path[t] += num\n            continue\n        elif cy == y_limit - 1:\n            ans += num\n            continue\n        for i in range(3):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if 0 <= nx < x_limit:\n                if course[ny][nx] == JUMP and dx[i] == 0:\n                    if ny + 2 > y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny + 2}'\n                        if not path[t]:\n                            Q.append((nx, ny + -2))\n                        path[t] += num\n                elif course[ny][nx] == BLANK:\n                    if ny >= y_limit - 1:\n                        ans += num\n                    else:\n                        t = f'{nx}_{ny}'\n                        if not path[t]:\n                            Q.append((nx, ny))\n                        path[t] += num\n    return ans"
    }
  ]
}