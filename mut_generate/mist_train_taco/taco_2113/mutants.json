{
  "task_id": "taco_2113",
  "entry_point": "binsearch",
  "mutant_count": 136,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "MOD = 1000000007",
      "mutated_line": "MOD = 1000000008",
      "code": "MOD = 1000000008\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "MOD = 1000000007",
      "mutated_line": "MOD = 1000000006",
      "code": "MOD = 1000000006\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "MOD = 1000000007",
      "mutated_line": "MOD = 0",
      "code": "MOD = 0\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "MOD = 1000000007",
      "mutated_line": "MOD = 1",
      "code": "MOD = 1\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "MOD = 1000000007",
      "mutated_line": "MOD = -1000000007",
      "code": "MOD = -1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "left = 0",
      "mutated_line": "left = 1",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 1\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "left = 0",
      "mutated_line": "left = -1",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = -1\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "left = 0",
      "mutated_line": "left = 1",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 1\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "while left < right:",
      "mutated_line": "while left <= right:",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left <= right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "while left < right:",
      "mutated_line": "while left >= right:",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left >= right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "while left < right:",
      "mutated_line": "while left != right:",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left != right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "retval = 1",
      "mutated_line": "retval = 2",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 2\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "retval = 1",
      "mutated_line": "retval = 0",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 0\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "retval = 1",
      "mutated_line": "retval = 0",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 0\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "retval = 1",
      "mutated_line": "retval = -1",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = -1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "ASR",
      "lineno": 39,
      "original_line": "retval *= icandidates * jcandidates - (N * M - num) * just",
      "mutated_line": "retval /= icandidates * jcandidates - (N * M - num) * just",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval /= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "center = (left + right) // 2",
      "mutated_line": "center = (left + right) / 2",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) / 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "center = (left + right) // 2",
      "mutated_line": "center = (left + right) * 2",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) * 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if num <= ary[center]:",
      "mutated_line": "if num < ary[center]:",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num < ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if num <= ary[center]:",
      "mutated_line": "if num > ary[center]:",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num > ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if num <= ary[center]:",
      "mutated_line": "if num == ary[center]:",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num == ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for i in range(1, N):",
      "mutated_line": "for i in range(2, N):",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(2, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for i in range(1, N):",
      "mutated_line": "for i in range(0, N):",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(0, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for i in range(1, N):",
      "mutated_line": "for i in range(0, N):",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(0, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for i in range(1, N):",
      "mutated_line": "for i in range(-1, N):",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(-1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if sortA[i] == sortA[i - 1]:",
      "mutated_line": "if sortA[i] != sortA[i - 1]:",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] != sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for j in range(1, M):",
      "mutated_line": "for j in range(2, M):",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(2, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for j in range(1, M):",
      "mutated_line": "for j in range(0, M):",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(0, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for j in range(1, M):",
      "mutated_line": "for j in range(0, M):",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(0, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for j in range(1, M):",
      "mutated_line": "for j in range(-1, M):",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(-1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if sortB[j] == sortB[j - 1]:",
      "mutated_line": "if sortB[j] != sortB[j - 1]:",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] != sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "for num in range(N * M, 0, -1):",
      "mutated_line": "for num in range(N / M, 0, -1):",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N / M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "for num in range(N * M, 0, -1):",
      "mutated_line": "for num in range(N + M, 0, -1):",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N + M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "for num in range(N * M, 0, -1):",
      "mutated_line": "for num in range(N ** M, 0, -1):",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N ** M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for num in range(N * M, 0, -1):",
      "mutated_line": "for num in range(N * M, 1, -1):",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 1, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for num in range(N * M, 0, -1):",
      "mutated_line": "for num in range(N * M, -1, -1):",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, -1, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for num in range(N * M, 0, -1):",
      "mutated_line": "for num in range(N * M, 1, -1):",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 1, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "UOI",
      "lineno": 27,
      "original_line": "for num in range(N * M, 0, -1):",
      "mutated_line": "for num in range(N * M, 0, +1):",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, +1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "just = 1",
      "mutated_line": "just = 2",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 2\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "just = 1",
      "mutated_line": "just = 0",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 0\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "just = 1",
      "mutated_line": "just = 0",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 0\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "just = 1",
      "mutated_line": "just = -1",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = -1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "LCR",
      "lineno": 32,
      "original_line": "if icandidates >= 1 and sortA[icandidates - 1] == num:",
      "mutated_line": "if icandidates >= 1 or sortA[icandidates - 1] == num:",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 or sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "LCR",
      "lineno": 35,
      "original_line": "if jcandidates >= 1 and sortB[jcandidates - 1] == num:",
      "mutated_line": "if jcandidates >= 1 or sortB[jcandidates - 1] == num:",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 or sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "retval *= icandidates * jcandidates - (N * M - num) * just",
      "mutated_line": "retval *= icandidates * jcandidates + (N * M - num) * just",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates + (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "retval *= icandidates * jcandidates - (N * M - num) * just",
      "mutated_line": "retval *= icandidates * jcandidates * ((N * M - num) * just)",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates * ((N * M - num) * just)\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "center = (left + right) // 2",
      "mutated_line": "center = (left - right) // 2",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left - right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "center = (left + right) // 2",
      "mutated_line": "center = left * right // 2",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = left * right // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "center = (left + right) // 2",
      "mutated_line": "center = (left + right) // 3",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 3\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "center = (left + right) // 2",
      "mutated_line": "center = (left + right) // 1",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 1\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "center = (left + right) // 2",
      "mutated_line": "center = (left + right) // 0",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 0\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "center = (left + right) // 2",
      "mutated_line": "center = (left + right) // 1",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 1\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "center = (left + right) // 2",
      "mutated_line": "center = (left + right) // -2",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // -2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "left = center + 1",
      "mutated_line": "left = center - 1",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center - 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "left = center + 1",
      "mutated_line": "left = center * 1",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center * 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "sortA = sorted(A, reverse=True)",
      "mutated_line": "sortA = sorted(A, reverse=False)",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=False)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "sortB = sorted(B, reverse=True)",
      "mutated_line": "sortB = sorted(B, reverse=False)",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=False)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 1\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return -1\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 1\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 1\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return -1\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 1\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for num in range(N * M, 0, -1):",
      "mutated_line": "for num in range(N * M, 0, -2):",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -2):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for num in range(N * M, 0, -1):",
      "mutated_line": "for num in range(N * M, 0, -0):",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -0):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for num in range(N * M, 0, -1):",
      "mutated_line": "for num in range(N * M, 0, -0):",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -0):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for num in range(N * M, 0, -1):",
      "mutated_line": "for num in range(N * M, 0, --1):",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, --1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if icandidates >= 1 and sortA[icandidates - 1] == num:",
      "mutated_line": "if icandidates > 1 and sortA[icandidates - 1] == num:",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates > 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if icandidates >= 1 and sortA[icandidates - 1] == num:",
      "mutated_line": "if icandidates < 1 and sortA[icandidates - 1] == num:",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates < 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if icandidates >= 1 and sortA[icandidates - 1] == num:",
      "mutated_line": "if icandidates == 1 and sortA[icandidates - 1] == num:",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates == 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if icandidates >= 1 and sortA[icandidates - 1] == num:",
      "mutated_line": "if icandidates >= 1 and sortA[icandidates - 1] != num:",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] != num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "icandidates = 1",
      "mutated_line": "icandidates = 2",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 2\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "icandidates = 1",
      "mutated_line": "icandidates = 0",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 0\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "icandidates = 1",
      "mutated_line": "icandidates = 0",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 0\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "icandidates = 1",
      "mutated_line": "icandidates = -1",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = -1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "just = 0",
      "mutated_line": "just = 1",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 1\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "just = 0",
      "mutated_line": "just = -1",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = -1\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "just = 0",
      "mutated_line": "just = 1",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 1\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if jcandidates >= 1 and sortB[jcandidates - 1] == num:",
      "mutated_line": "if jcandidates > 1 and sortB[jcandidates - 1] == num:",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates > 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if jcandidates >= 1 and sortB[jcandidates - 1] == num:",
      "mutated_line": "if jcandidates < 1 and sortB[jcandidates - 1] == num:",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates < 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if jcandidates >= 1 and sortB[jcandidates - 1] == num:",
      "mutated_line": "if jcandidates == 1 and sortB[jcandidates - 1] == num:",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates == 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if jcandidates >= 1 and sortB[jcandidates - 1] == num:",
      "mutated_line": "if jcandidates >= 1 and sortB[jcandidates - 1] != num:",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] != num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "jcandidates = 1",
      "mutated_line": "jcandidates = 2",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 2\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "jcandidates = 1",
      "mutated_line": "jcandidates = 0",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 0\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "jcandidates = 1",
      "mutated_line": "jcandidates = 0",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 0\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "jcandidates = 1",
      "mutated_line": "jcandidates = -1",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = -1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "just = 0",
      "mutated_line": "just = 1",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 1\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "just = 0",
      "mutated_line": "just = -1",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = -1\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "just = 0",
      "mutated_line": "just = 1",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 1\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "retval *= icandidates * jcandidates - (N * M - num) * just",
      "mutated_line": "retval *= icandidates / jcandidates - (N * M - num) * just",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates / jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "retval *= icandidates * jcandidates - (N * M - num) * just",
      "mutated_line": "retval *= icandidates + jcandidates - (N * M - num) * just",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates + jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "retval *= icandidates * jcandidates - (N * M - num) * just",
      "mutated_line": "retval *= icandidates ** jcandidates - (N * M - num) * just",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates ** jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "retval *= icandidates * jcandidates - (N * M - num) * just",
      "mutated_line": "retval *= icandidates * jcandidates - (N * M - num) / just",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) / just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "retval *= icandidates * jcandidates - (N * M - num) * just",
      "mutated_line": "retval *= icandidates * jcandidates - (N * M - num + just)",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num + just)\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "retval *= icandidates * jcandidates - (N * M - num) * just",
      "mutated_line": "retval *= icandidates * jcandidates - (N * M - num) ** just",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) ** just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "left = center + 1",
      "mutated_line": "left = center + 2",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 2\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "left = center + 1",
      "mutated_line": "left = center + 0",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 0\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "left = center + 1",
      "mutated_line": "left = center + 0",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 0\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "left = center + 1",
      "mutated_line": "left = center + -1",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + -1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "if sortA[i] == sortA[i - 1]:",
      "mutated_line": "if sortA[i] == sortA[i + 1]:",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i + 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "if sortA[i] == sortA[i - 1]:",
      "mutated_line": "if sortA[i] == sortA[i * 1]:",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i * 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "if sortB[j] == sortB[j - 1]:",
      "mutated_line": "if sortB[j] == sortB[j + 1]:",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j + 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "if sortB[j] == sortB[j - 1]:",
      "mutated_line": "if sortB[j] == sortB[j * 1]:",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j * 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if icandidates >= 1 and sortA[icandidates - 1] == num:",
      "mutated_line": "if icandidates >= 2 and sortA[icandidates - 1] == num:",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 2 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if icandidates >= 1 and sortA[icandidates - 1] == num:",
      "mutated_line": "if icandidates >= 0 and sortA[icandidates - 1] == num:",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 0 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if icandidates >= 1 and sortA[icandidates - 1] == num:",
      "mutated_line": "if icandidates >= 0 and sortA[icandidates - 1] == num:",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 0 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if icandidates >= 1 and sortA[icandidates - 1] == num:",
      "mutated_line": "if icandidates >= -1 and sortA[icandidates - 1] == num:",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= -1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if jcandidates >= 1 and sortB[jcandidates - 1] == num:",
      "mutated_line": "if jcandidates >= 2 and sortB[jcandidates - 1] == num:",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 2 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if jcandidates >= 1 and sortB[jcandidates - 1] == num:",
      "mutated_line": "if jcandidates >= 0 and sortB[jcandidates - 1] == num:",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 0 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if jcandidates >= 1 and sortB[jcandidates - 1] == num:",
      "mutated_line": "if jcandidates >= 0 and sortB[jcandidates - 1] == num:",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 0 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if jcandidates >= 1 and sortB[jcandidates - 1] == num:",
      "mutated_line": "if jcandidates >= -1 and sortB[jcandidates - 1] == num:",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= -1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "retval *= icandidates * jcandidates - (N * M - num) * just",
      "mutated_line": "retval *= icandidates * jcandidates - (N * M + num) * just",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M + num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "retval *= icandidates * jcandidates - (N * M - num) * just",
      "mutated_line": "retval *= icandidates * jcandidates - N * M * num * just",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - N * M * num * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if sortA[i] == sortA[i - 1]:",
      "mutated_line": "if sortA[i] == sortA[i - 2]:",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 2]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if sortA[i] == sortA[i - 1]:",
      "mutated_line": "if sortA[i] == sortA[i - 0]:",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 0]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if sortA[i] == sortA[i - 1]:",
      "mutated_line": "if sortA[i] == sortA[i - 0]:",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 0]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if sortA[i] == sortA[i - 1]:",
      "mutated_line": "if sortA[i] == sortA[i - -1]:",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - -1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if sortB[j] == sortB[j - 1]:",
      "mutated_line": "if sortB[j] == sortB[j - 2]:",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 2]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if sortB[j] == sortB[j - 1]:",
      "mutated_line": "if sortB[j] == sortB[j - 0]:",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 0]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if sortB[j] == sortB[j - 1]:",
      "mutated_line": "if sortB[j] == sortB[j - 0]:",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 0]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if sortB[j] == sortB[j - 1]:",
      "mutated_line": "if sortB[j] == sortB[j - -1]:",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - -1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "if icandidates >= 1 and sortA[icandidates - 1] == num:",
      "mutated_line": "if icandidates >= 1 and sortA[icandidates + 1] == num:",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates + 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "if icandidates >= 1 and sortA[icandidates - 1] == num:",
      "mutated_line": "if icandidates >= 1 and sortA[icandidates * 1] == num:",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates * 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "if jcandidates >= 1 and sortB[jcandidates - 1] == num:",
      "mutated_line": "if jcandidates >= 1 and sortB[jcandidates + 1] == num:",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates + 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "if jcandidates >= 1 and sortB[jcandidates - 1] == num:",
      "mutated_line": "if jcandidates >= 1 and sortB[jcandidates * 1] == num:",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates * 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "retval *= icandidates * jcandidates - (N * M - num) * just",
      "mutated_line": "retval *= icandidates * jcandidates - (N / M - num) * just",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N / M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "retval *= icandidates * jcandidates - (N * M - num) * just",
      "mutated_line": "retval *= icandidates * jcandidates - (N + M - num) * just",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N + M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "retval *= icandidates * jcandidates - (N * M - num) * just",
      "mutated_line": "retval *= icandidates * jcandidates - (N ** M - num) * just",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N ** M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if icandidates >= 1 and sortA[icandidates - 1] == num:",
      "mutated_line": "if icandidates >= 1 and sortA[icandidates - 2] == num:",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 2] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if icandidates >= 1 and sortA[icandidates - 1] == num:",
      "mutated_line": "if icandidates >= 1 and sortA[icandidates - 0] == num:",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 0] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if icandidates >= 1 and sortA[icandidates - 1] == num:",
      "mutated_line": "if icandidates >= 1 and sortA[icandidates - 0] == num:",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 0] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if icandidates >= 1 and sortA[icandidates - 1] == num:",
      "mutated_line": "if icandidates >= 1 and sortA[icandidates - -1] == num:",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - -1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if jcandidates >= 1 and sortB[jcandidates - 1] == num:",
      "mutated_line": "if jcandidates >= 1 and sortB[jcandidates - 2] == num:",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 2] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if jcandidates >= 1 and sortB[jcandidates - 1] == num:",
      "mutated_line": "if jcandidates >= 1 and sortB[jcandidates - 0] == num:",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 0] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if jcandidates >= 1 and sortB[jcandidates - 1] == num:",
      "mutated_line": "if jcandidates >= 1 and sortB[jcandidates - 0] == num:",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - 0] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if jcandidates >= 1 and sortB[jcandidates - 1] == num:",
      "mutated_line": "if jcandidates >= 1 and sortB[jcandidates - -1] == num:",
      "code": "MOD = 1000000007\n\ndef binsearch(num, ary):\n    left = 0\n    right = len(ary)\n    while left < right:\n        center = (left + right) // 2\n        if num <= ary[center]:\n            left = center + 1\n        else:\n            right = center\n    return left\n\ndef count_number_of_ways(N, M, A, B):\n    sortA = sorted(A, reverse=True)\n    sortB = sorted(B, reverse=True)\n    for i in range(1, N):\n        if sortA[i] == sortA[i - 1]:\n            return 0\n    for j in range(1, M):\n        if sortB[j] == sortB[j - 1]:\n            return 0\n    retval = 1\n    for num in range(N * M, 0, -1):\n        just = 1\n        icandidates = binsearch(num, sortA)\n        jcandidates = binsearch(num, sortB)\n        if icandidates >= 1 and sortA[icandidates - 1] == num:\n            icandidates = 1\n            just = 0\n        if jcandidates >= 1 and sortB[jcandidates - -1] == num:\n            jcandidates = 1\n            just = 0\n        retval *= icandidates * jcandidates - (N * M - num) * just\n        retval %= MOD\n    return retval"
    }
  ]
}