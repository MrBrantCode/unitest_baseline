{
  "task_id": "taco_12739",
  "entry_point": "min_moves_to_remove_vk",
  "mutant_count": 215,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dp[0][0][0][0] = 0",
      "mutated_line": "dp[0][0][0][0] = 1",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 1\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dp[0][0][0][0] = 0",
      "mutated_line": "dp[0][0][0][0] = -1",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = -1\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dp[0][0][0][0] = 0",
      "mutated_line": "dp[0][0][0][0] = 1",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 1\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "X = [i - V[i] - K[i] for i in range(n + 1)]",
      "mutated_line": "X = [i - V[i] + K[i] for i in range(n + 1)]",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] + K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "X = [i - V[i] - K[i] for i in range(n + 1)]",
      "mutated_line": "X = [(i - V[i]) * K[i] for i in range(n + 1)]",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [(i - V[i]) * K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dp[0][0][0][0] = 0",
      "mutated_line": "dp[0][0][0][1] = 0",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][1] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dp[0][0][0][0] = 0",
      "mutated_line": "dp[0][0][0][-1] = 0",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][-1] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dp[0][0][0][0] = 0",
      "mutated_line": "dp[0][0][0][1] = 0",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][1] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "for v in range(n_v + 1):",
      "mutated_line": "for v in range(n_v - 1):",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v - 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "for v in range(n_v + 1):",
      "mutated_line": "for v in range(n_v * 1):",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v * 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "V = [s[0:i].count('V') for i in range(n + 1)]",
      "mutated_line": "V = [s[0:i].count('') for i in range(n + 1)]",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "K = [s[0:i].count('K') for i in range(n + 1)]",
      "mutated_line": "K = [s[0:i].count('') for i in range(n + 1)]",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "X = [i - V[i] - K[i] for i in range(n + 1)]",
      "mutated_line": "X = [i + V[i] - K[i] for i in range(n + 1)]",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i + V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "X = [i - V[i] - K[i] for i in range(n + 1)]",
      "mutated_line": "X = [i * V[i] - K[i] for i in range(n + 1)]",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i * V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dp[0][0][0][0] = 0",
      "mutated_line": "dp[0][0][1][0] = 0",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][1][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dp[0][0][0][0] = 0",
      "mutated_line": "dp[0][0][-1][0] = 0",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][-1][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dp[0][0][0][0] = 0",
      "mutated_line": "dp[0][0][1][0] = 0",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][1][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for v in range(n_v + 1):",
      "mutated_line": "for v in range(n_v + 2):",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 2):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for v in range(n_v + 1):",
      "mutated_line": "for v in range(n_v + 0):",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 0):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for v in range(n_v + 1):",
      "mutated_line": "for v in range(n_v + 0):",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 0):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for v in range(n_v + 1):",
      "mutated_line": "for v in range(n_v + -1):",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + -1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "for k in range(n_k + 1):",
      "mutated_line": "for k in range(n_k - 1):",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k - 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "for k in range(n_k + 1):",
      "mutated_line": "for k in range(n_k * 1):",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k * 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "V = [s[0:i].count('V') for i in range(n + 1)]",
      "mutated_line": "V = [s[0:i].count('V') for i in range(n - 1)]",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n - 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "V = [s[0:i].count('V') for i in range(n + 1)]",
      "mutated_line": "V = [s[0:i].count('V') for i in range(n * 1)]",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n * 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "K = [s[0:i].count('K') for i in range(n + 1)]",
      "mutated_line": "K = [s[0:i].count('K') for i in range(n - 1)]",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n - 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "K = [s[0:i].count('K') for i in range(n + 1)]",
      "mutated_line": "K = [s[0:i].count('K') for i in range(n * 1)]",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n * 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "X = [i - V[i] - K[i] for i in range(n + 1)]",
      "mutated_line": "X = [i - V[i] - K[i] for i in range(n - 1)]",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n - 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "X = [i - V[i] - K[i] for i in range(n + 1)]",
      "mutated_line": "X = [i - V[i] - K[i] for i in range(n * 1)]",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n * 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]",
      "mutated_line": "dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v - 1)]",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v - 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]",
      "mutated_line": "dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v * 1)]",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v * 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dp[0][0][0][0] = 0",
      "mutated_line": "dp[0][1][0][0] = 0",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][1][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dp[0][0][0][0] = 0",
      "mutated_line": "dp[0][-1][0][0] = 0",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][-1][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dp[0][0][0][0] = 0",
      "mutated_line": "dp[0][1][0][0] = 0",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][1][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for k in range(n_k + 1):",
      "mutated_line": "for k in range(n_k + 2):",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 2):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for k in range(n_k + 1):",
      "mutated_line": "for k in range(n_k + 0):",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 0):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for k in range(n_k + 1):",
      "mutated_line": "for k in range(n_k + 0):",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 0):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for k in range(n_k + 1):",
      "mutated_line": "for k in range(n_k + -1):",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + -1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "for x in range(n_x + 1):",
      "mutated_line": "for x in range(n_x - 1):",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x - 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "for x in range(n_x + 1):",
      "mutated_line": "for x in range(n_x * 1):",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x * 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])",
      "mutated_line": "cost = sum([max(1, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(1, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])",
      "mutated_line": "cost = sum([max(-1, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(-1, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])",
      "mutated_line": "cost = sum([max(1, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(1, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])",
      "mutated_line": "cost = sum([max(0, V[ss_ind - 1] + curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] + curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])",
      "mutated_line": "cost = sum([max(0, V[ss_ind - 1] * curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] * curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])",
      "mutated_line": "cost = sum([max(0, V[ss_ind - 1] - curr_v), max(1, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(1, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])",
      "mutated_line": "cost = sum([max(0, V[ss_ind - 1] - curr_v), max(-1, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(-1, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])",
      "mutated_line": "cost = sum([max(0, V[ss_ind - 1] - curr_v), max(1, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(1, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])",
      "mutated_line": "cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] + curr_k), max(0, X[ss_ind - 1] - curr_x)])",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] + curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])",
      "mutated_line": "cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] * curr_k), max(0, X[ss_ind - 1] - curr_x)])",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] * curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])",
      "mutated_line": "cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(1, X[ss_ind - 1] - curr_x)])",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(1, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])",
      "mutated_line": "cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(-1, X[ss_ind - 1] - curr_x)])",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(-1, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])",
      "mutated_line": "cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(1, X[ss_ind - 1] - curr_x)])",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(1, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])",
      "mutated_line": "cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] + curr_x)])",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] + curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])",
      "mutated_line": "cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] * curr_x)])",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] * curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "V = [s[0:i].count('V') for i in range(n + 1)]",
      "mutated_line": "V = [s[0:i].count('V') for i in range(n + 2)]",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 2)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "V = [s[0:i].count('V') for i in range(n + 1)]",
      "mutated_line": "V = [s[0:i].count('V') for i in range(n + 0)]",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 0)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "V = [s[0:i].count('V') for i in range(n + 1)]",
      "mutated_line": "V = [s[0:i].count('V') for i in range(n + 0)]",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 0)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "V = [s[0:i].count('V') for i in range(n + 1)]",
      "mutated_line": "V = [s[0:i].count('V') for i in range(n + -1)]",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + -1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "K = [s[0:i].count('K') for i in range(n + 1)]",
      "mutated_line": "K = [s[0:i].count('K') for i in range(n + 2)]",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 2)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "K = [s[0:i].count('K') for i in range(n + 1)]",
      "mutated_line": "K = [s[0:i].count('K') for i in range(n + 0)]",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 0)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "K = [s[0:i].count('K') for i in range(n + 1)]",
      "mutated_line": "K = [s[0:i].count('K') for i in range(n + 0)]",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 0)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "K = [s[0:i].count('K') for i in range(n + 1)]",
      "mutated_line": "K = [s[0:i].count('K') for i in range(n + -1)]",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + -1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "X = [i - V[i] - K[i] for i in range(n + 1)]",
      "mutated_line": "X = [i - V[i] - K[i] for i in range(n + 2)]",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 2)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "X = [i - V[i] - K[i] for i in range(n + 1)]",
      "mutated_line": "X = [i - V[i] - K[i] for i in range(n + 0)]",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 0)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "X = [i - V[i] - K[i] for i in range(n + 1)]",
      "mutated_line": "X = [i - V[i] - K[i] for i in range(n + 0)]",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 0)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "X = [i - V[i] - K[i] for i in range(n + 1)]",
      "mutated_line": "X = [i - V[i] - K[i] for i in range(n + -1)]",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + -1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]",
      "mutated_line": "dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k - 1)] for v in range(n_v + 1)]",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k - 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]",
      "mutated_line": "dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k * 1)] for v in range(n_v + 1)]",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k * 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]",
      "mutated_line": "dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 2)]",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 2)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]",
      "mutated_line": "dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 0)]",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 0)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]",
      "mutated_line": "dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 0)]",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 0)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]",
      "mutated_line": "dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + -1)]",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + -1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dp[0][0][0][0] = 0",
      "mutated_line": "dp[1][0][0][0] = 0",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[1][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dp[0][0][0][0] = 0",
      "mutated_line": "dp[-1][0][0][0] = 0",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[-1][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dp[0][0][0][0] = 0",
      "mutated_line": "dp[1][0][0][0] = 0",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[1][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for x in range(n_x + 1):",
      "mutated_line": "for x in range(n_x + 2):",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 2):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for x in range(n_x + 1):",
      "mutated_line": "for x in range(n_x + 0):",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 0):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for x in range(n_x + 1):",
      "mutated_line": "for x in range(n_x + 0):",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 0):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for x in range(n_x + 1):",
      "mutated_line": "for x in range(n_x + -1):",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + -1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for vtype in range(2):",
      "mutated_line": "for vtype in range(3):",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(3):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for vtype in range(2):",
      "mutated_line": "for vtype in range(1):",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(1):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for vtype in range(2):",
      "mutated_line": "for vtype in range(0):",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(0):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for vtype in range(2):",
      "mutated_line": "for vtype in range(1):",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(1):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for vtype in range(2):",
      "mutated_line": "for vtype in range(-2):",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(-2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if v < n_v:",
      "mutated_line": "if v <= n_v:",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v <= n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if v < n_v:",
      "mutated_line": "if v >= n_v:",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v >= n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if v < n_v:",
      "mutated_line": "if v != n_v:",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v != n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "LCR",
      "lineno": 22,
      "original_line": "if k < n_k and vtype == 0:",
      "mutated_line": "if k < n_k or vtype == 0:",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k or vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if x < n_x:",
      "mutated_line": "if x <= n_x:",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x <= n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if x < n_x:",
      "mutated_line": "if x >= n_x:",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x >= n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if x < n_x:",
      "mutated_line": "if x != n_x:",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x != n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "V = [s[0:i].count('V') for i in range(n + 1)]",
      "mutated_line": "V = [s[1:i].count('V') for i in range(n + 1)]",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[1:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "V = [s[0:i].count('V') for i in range(n + 1)]",
      "mutated_line": "V = [s[-1:i].count('V') for i in range(n + 1)]",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[-1:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "V = [s[0:i].count('V') for i in range(n + 1)]",
      "mutated_line": "V = [s[1:i].count('V') for i in range(n + 1)]",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[1:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "K = [s[0:i].count('K') for i in range(n + 1)]",
      "mutated_line": "K = [s[1:i].count('K') for i in range(n + 1)]",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[1:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "K = [s[0:i].count('K') for i in range(n + 1)]",
      "mutated_line": "K = [s[-1:i].count('K') for i in range(n + 1)]",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[-1:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "K = [s[0:i].count('K') for i in range(n + 1)]",
      "mutated_line": "K = [s[1:i].count('K') for i in range(n + 1)]",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[1:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]",
      "mutated_line": "dp = [[[[float('') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]",
      "mutated_line": "dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x - 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x - 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]",
      "mutated_line": "dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x * 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x * 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]",
      "mutated_line": "dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 2)] for v in range(n_v + 1)]",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 2)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]",
      "mutated_line": "dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 0)] for v in range(n_v + 1)]",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 0)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]",
      "mutated_line": "dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 0)] for v in range(n_v + 1)]",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 0)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]",
      "mutated_line": "dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + -1)] for v in range(n_v + 1)]",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + -1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if k < n_k and vtype == 0:",
      "mutated_line": "if k <= n_k and vtype == 0:",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k <= n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if k < n_k and vtype == 0:",
      "mutated_line": "if k >= n_k and vtype == 0:",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k >= n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if k < n_k and vtype == 0:",
      "mutated_line": "if k != n_k and vtype == 0:",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k != n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if k < n_k and vtype == 0:",
      "mutated_line": "if k < n_k and vtype != 0:",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype != 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])",
      "mutated_line": "cost = sum([max(0, V[ss_ind + 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind + 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])",
      "mutated_line": "cost = sum([max(0, V[ss_ind * 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind * 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])",
      "mutated_line": "cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind + 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind + 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])",
      "mutated_line": "cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind * 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind * 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])",
      "mutated_line": "cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind + 1] - curr_x)])",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind + 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])",
      "mutated_line": "cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind * 1] - curr_x)])",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind * 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]",
      "mutated_line": "dp = [[[[float('Inf') for vtype in range(3)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(3)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]",
      "mutated_line": "dp = [[[[float('Inf') for vtype in range(1)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(1)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]",
      "mutated_line": "dp = [[[[float('Inf') for vtype in range(0)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(0)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]",
      "mutated_line": "dp = [[[[float('Inf') for vtype in range(1)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(1)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]",
      "mutated_line": "dp = [[[[float('Inf') for vtype in range(-2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(-2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]",
      "mutated_line": "dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 2)] for k in range(n_k + 1)] for v in range(n_v + 1)]",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 2)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]",
      "mutated_line": "dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 0)] for k in range(n_k + 1)] for v in range(n_v + 1)]",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 0)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]",
      "mutated_line": "dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 0)] for k in range(n_k + 1)] for v in range(n_v + 1)]",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 0)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]",
      "mutated_line": "dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + -1)] for k in range(n_k + 1)] for v in range(n_v + 1)]",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + -1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))",
      "mutated_line": "dp[v + 1][k][x][2] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][2] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))",
      "mutated_line": "dp[v + 1][k][x][0] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][0] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))",
      "mutated_line": "dp[v + 1][k][x][0] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][0] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))",
      "mutated_line": "dp[v + 1][k][x][-1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][-1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))",
      "mutated_line": "dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig - cost_of_move([v, k, x], V.index(v + 1)))",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig - cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))",
      "mutated_line": "dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig * cost_of_move([v, k, x], V.index(v + 1)))",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig * cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if k < n_k and vtype == 0:",
      "mutated_line": "if k < n_k and vtype == 1:",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 1:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if k < n_k and vtype == 0:",
      "mutated_line": "if k < n_k and vtype == -1:",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == -1:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if k < n_k and vtype == 0:",
      "mutated_line": "if k < n_k and vtype == 1:",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 1:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))",
      "mutated_line": "dp[v][k + 1][x][1] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][1] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))",
      "mutated_line": "dp[v][k + 1][x][-1] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][-1] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))",
      "mutated_line": "dp[v][k + 1][x][1] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][1] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))",
      "mutated_line": "dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig - cost_of_move([v, k, x], K.index(k + 1)))",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig - cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))",
      "mutated_line": "dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig * cost_of_move([v, k, x], K.index(k + 1)))",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig * cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))",
      "mutated_line": "dp[v][k][x + 1][1] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][1] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))",
      "mutated_line": "dp[v][k][x + 1][-1] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][-1] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))",
      "mutated_line": "dp[v][k][x + 1][1] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][1] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))",
      "mutated_line": "dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig - cost_of_move([v, k, x], X.index(x + 1)))",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig - cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))",
      "mutated_line": "dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig * cost_of_move([v, k, x], X.index(x + 1)))",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig * cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])",
      "mutated_line": "cost = sum([max(0, V[ss_ind - 2] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 2] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])",
      "mutated_line": "cost = sum([max(0, V[ss_ind - 0] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 0] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])",
      "mutated_line": "cost = sum([max(0, V[ss_ind - 0] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 0] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])",
      "mutated_line": "cost = sum([max(0, V[ss_ind - -1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - -1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])",
      "mutated_line": "cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 2] - curr_k), max(0, X[ss_ind - 1] - curr_x)])",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 2] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])",
      "mutated_line": "cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 0] - curr_k), max(0, X[ss_ind - 1] - curr_x)])",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 0] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])",
      "mutated_line": "cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 0] - curr_k), max(0, X[ss_ind - 1] - curr_x)])",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 0] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])",
      "mutated_line": "cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - -1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - -1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])",
      "mutated_line": "cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 2] - curr_x)])",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 2] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])",
      "mutated_line": "cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 0] - curr_x)])",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 0] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])",
      "mutated_line": "cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 0] - curr_x)])",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 0] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])",
      "mutated_line": "cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - -1] - curr_x)])",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - -1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))",
      "mutated_line": "dp[v][k + 1][x][0] = min(dp[v][k + 1][x][1], orig + cost_of_move([v, k, x], K.index(k + 1)))",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][1], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))",
      "mutated_line": "dp[v][k + 1][x][0] = min(dp[v][k + 1][x][-1], orig + cost_of_move([v, k, x], K.index(k + 1)))",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][-1], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))",
      "mutated_line": "dp[v][k + 1][x][0] = min(dp[v][k + 1][x][1], orig + cost_of_move([v, k, x], K.index(k + 1)))",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][1], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))",
      "mutated_line": "dp[v][k][x - 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x - 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))",
      "mutated_line": "dp[v][k][x * 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x * 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))",
      "mutated_line": "dp[v][k][x + 1][0] = min(dp[v][k][x + 1][1], orig + cost_of_move([v, k, x], X.index(x + 1)))",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][1], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))",
      "mutated_line": "dp[v][k][x + 1][0] = min(dp[v][k][x + 1][-1], orig + cost_of_move([v, k, x], X.index(x + 1)))",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][-1], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))",
      "mutated_line": "dp[v][k][x + 1][0] = min(dp[v][k][x + 1][1], orig + cost_of_move([v, k, x], X.index(x + 1)))",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][1], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))",
      "mutated_line": "dp[v][k - 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k - 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))",
      "mutated_line": "dp[v][k * 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k * 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))",
      "mutated_line": "dp[v][k][x + 2][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 2][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))",
      "mutated_line": "dp[v][k][x + 0][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 0][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))",
      "mutated_line": "dp[v][k][x + 0][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 0][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))",
      "mutated_line": "dp[v][k][x + -1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + -1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))",
      "mutated_line": "dp[v][k][x + 1][0] = min(dp[v][k][x - 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x - 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))",
      "mutated_line": "dp[v][k][x + 1][0] = min(dp[v][k][x * 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x * 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))",
      "mutated_line": "dp[v - 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v - 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))",
      "mutated_line": "dp[v * 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v * 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))",
      "mutated_line": "dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v - 1)))",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v - 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))",
      "mutated_line": "dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v * 1)))",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v * 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))",
      "mutated_line": "dp[v][k + 2][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 2][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))",
      "mutated_line": "dp[v][k + 0][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 0][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))",
      "mutated_line": "dp[v][k + 0][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 0][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))",
      "mutated_line": "dp[v][k + -1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + -1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))",
      "mutated_line": "dp[v][k + 1][x][0] = min(dp[v][k - 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k - 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))",
      "mutated_line": "dp[v][k + 1][x][0] = min(dp[v][k * 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k * 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))",
      "mutated_line": "dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k - 1)))",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k - 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))",
      "mutated_line": "dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k * 1)))",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k * 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))",
      "mutated_line": "dp[v][k][x + 1][0] = min(dp[v][k][x + 2][0], orig + cost_of_move([v, k, x], X.index(x + 1)))",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 2][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))",
      "mutated_line": "dp[v][k][x + 1][0] = min(dp[v][k][x + 0][0], orig + cost_of_move([v, k, x], X.index(x + 1)))",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 0][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))",
      "mutated_line": "dp[v][k][x + 1][0] = min(dp[v][k][x + 0][0], orig + cost_of_move([v, k, x], X.index(x + 1)))",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 0][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))",
      "mutated_line": "dp[v][k][x + 1][0] = min(dp[v][k][x + -1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + -1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))",
      "mutated_line": "dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x - 1)))",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x - 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))",
      "mutated_line": "dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x * 1)))",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x * 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))",
      "mutated_line": "dp[v + 2][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 2][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))",
      "mutated_line": "dp[v + 0][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 0][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))",
      "mutated_line": "dp[v + 0][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 0][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))",
      "mutated_line": "dp[v + -1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + -1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))",
      "mutated_line": "dp[v + 1][k][x][1] = min(dp[v - 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v - 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))",
      "mutated_line": "dp[v + 1][k][x][1] = min(dp[v * 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v * 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))",
      "mutated_line": "dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 2)))",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 2)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))",
      "mutated_line": "dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 0)))",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 0)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))",
      "mutated_line": "dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 0)))",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 0)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))",
      "mutated_line": "dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + -1)))",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + -1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))",
      "mutated_line": "dp[v][k + 1][x][0] = min(dp[v][k + 2][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 2][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))",
      "mutated_line": "dp[v][k + 1][x][0] = min(dp[v][k + 0][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 0][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))",
      "mutated_line": "dp[v][k + 1][x][0] = min(dp[v][k + 0][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 0][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))",
      "mutated_line": "dp[v][k + 1][x][0] = min(dp[v][k + -1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + -1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))",
      "mutated_line": "dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 2)))",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 2)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))",
      "mutated_line": "dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 0)))",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 0)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))",
      "mutated_line": "dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 0)))",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 0)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))",
      "mutated_line": "dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + -1)))",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + -1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))",
      "mutated_line": "dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 2)))",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 2)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))",
      "mutated_line": "dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 0)))",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 0)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))",
      "mutated_line": "dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 0)))",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 0)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))",
      "mutated_line": "dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + -1)))",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + -1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))",
      "mutated_line": "dp[v + 1][k][x][1] = min(dp[v + 2][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 2][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))",
      "mutated_line": "dp[v + 1][k][x][1] = min(dp[v + 0][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 0][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))",
      "mutated_line": "dp[v + 1][k][x][1] = min(dp[v + 0][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + 0][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "dp[v + 1][k][x][1] = min(dp[v + 1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))",
      "mutated_line": "dp[v + 1][k][x][1] = min(dp[v + -1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))",
      "code": "def min_moves_to_remove_vk(n, s):\n\n    def cost_of_move(state, ss_ind):\n        (curr_v, curr_k, curr_x) = state\n        cost = sum([max(0, V[ss_ind - 1] - curr_v), max(0, K[ss_ind - 1] - curr_k), max(0, X[ss_ind - 1] - curr_x)])\n        return cost\n    V = [s[0:i].count('V') for i in range(n + 1)]\n    K = [s[0:i].count('K') for i in range(n + 1)]\n    X = [i - V[i] - K[i] for i in range(n + 1)]\n    (n_v, n_k, n_x) = (V[n], K[n], X[n])\n    dp = [[[[float('Inf') for vtype in range(2)] for x in range(n_x + 1)] for k in range(n_k + 1)] for v in range(n_v + 1)]\n    dp[0][0][0][0] = 0\n    for v in range(n_v + 1):\n        for k in range(n_k + 1):\n            for x in range(n_x + 1):\n                for vtype in range(2):\n                    orig = dp[v][k][x][vtype]\n                    if v < n_v:\n                        dp[v + 1][k][x][1] = min(dp[v + -1][k][x][vtype], orig + cost_of_move([v, k, x], V.index(v + 1)))\n                    if k < n_k and vtype == 0:\n                        dp[v][k + 1][x][0] = min(dp[v][k + 1][x][0], orig + cost_of_move([v, k, x], K.index(k + 1)))\n                    if x < n_x:\n                        dp[v][k][x + 1][0] = min(dp[v][k][x + 1][0], orig + cost_of_move([v, k, x], X.index(x + 1)))\n    return min(dp[n_v][n_k][n_x])"
    }
  ]
}