{
  "task_id": "taco_11157",
  "entry_point": "ragbaby_cipher",
  "mutant_count": 44,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "from string import ascii_lowercase as aLow\nimport re\n\ndef ragbaby_cipher(text: str, key: str, mode: str) -> str:\n    \"\"\"\"\"\"\n    if mode not in ['encode', 'decode']:\n        raise ValueError(\"Mode must be either 'encode' or 'decode'\")\n    d = 1 if mode == 'encode' else -1\n    remains = set(aLow)\n    alpha = []\n    for c in key + aLow:\n        if c in remains:\n            remains.remove(c)\n            alpha.append(c)\n    alpha = ''.join(alpha)\n    dct = {c: i for (i, c) in enumerate(alpha)}\n\n    def rotateWord(w, alpha, dct, d):\n        lst = []\n        for (i, c) in enumerate(w.lower(), 1):\n            transChar = alpha[(dct[c] + i * d) % 26]\n            if w[i - 1].isupper():\n                transChar = transChar.upper()\n            lst.append(transChar)\n        return ''.join(lst)\n    return re.sub('[a-zA-Z]+', lambda m: rotateWord(m.group(), alpha, dct, d), text)"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if mode not in [\"encode\", \"decode\"]:",
      "mutated_line": "if mode in ['encode', 'decode']:",
      "code": "from string import ascii_lowercase as aLow\nimport re\n\ndef ragbaby_cipher(text: str, key: str, mode: str) -> str:\n    \"\"\"\n    Encodes or decodes a text using the Ragbaby cipher with the given key.\n\n    Parameters:\n    - text (str): The text to be encoded or decoded.\n    - key (str): The key used to construct the keyed alphabet.\n    - mode (str): The mode of operation, either \"encode\" or \"decode\".\n\n    Returns:\n    - str: The encoded or decoded text.\n    \"\"\"\n    if mode in ['encode', 'decode']:\n        raise ValueError(\"Mode must be either 'encode' or 'decode'\")\n    d = 1 if mode == 'encode' else -1\n    remains = set(aLow)\n    alpha = []\n    for c in key + aLow:\n        if c in remains:\n            remains.remove(c)\n            alpha.append(c)\n    alpha = ''.join(alpha)\n    dct = {c: i for (i, c) in enumerate(alpha)}\n\n    def rotateWord(w, alpha, dct, d):\n        lst = []\n        for (i, c) in enumerate(w.lower(), 1):\n            transChar = alpha[(dct[c] + i * d) % 26]\n            if w[i - 1].isupper():\n                transChar = transChar.upper()\n            lst.append(transChar)\n        return ''.join(lst)\n    return re.sub('[a-zA-Z]+', lambda m: rotateWord(m.group(), alpha, dct, d), text)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "for c in key + aLow:",
      "mutated_line": "for c in key - aLow:",
      "code": "from string import ascii_lowercase as aLow\nimport re\n\ndef ragbaby_cipher(text: str, key: str, mode: str) -> str:\n    \"\"\"\n    Encodes or decodes a text using the Ragbaby cipher with the given key.\n\n    Parameters:\n    - text (str): The text to be encoded or decoded.\n    - key (str): The key used to construct the keyed alphabet.\n    - mode (str): The mode of operation, either \"encode\" or \"decode\".\n\n    Returns:\n    - str: The encoded or decoded text.\n    \"\"\"\n    if mode not in ['encode', 'decode']:\n        raise ValueError(\"Mode must be either 'encode' or 'decode'\")\n    d = 1 if mode == 'encode' else -1\n    remains = set(aLow)\n    alpha = []\n    for c in key - aLow:\n        if c in remains:\n            remains.remove(c)\n            alpha.append(c)\n    alpha = ''.join(alpha)\n    dct = {c: i for (i, c) in enumerate(alpha)}\n\n    def rotateWord(w, alpha, dct, d):\n        lst = []\n        for (i, c) in enumerate(w.lower(), 1):\n            transChar = alpha[(dct[c] + i * d) % 26]\n            if w[i - 1].isupper():\n                transChar = transChar.upper()\n            lst.append(transChar)\n        return ''.join(lst)\n    return re.sub('[a-zA-Z]+', lambda m: rotateWord(m.group(), alpha, dct, d), text)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "for c in key + aLow:",
      "mutated_line": "for c in key * aLow:",
      "code": "from string import ascii_lowercase as aLow\nimport re\n\ndef ragbaby_cipher(text: str, key: str, mode: str) -> str:\n    \"\"\"\n    Encodes or decodes a text using the Ragbaby cipher with the given key.\n\n    Parameters:\n    - text (str): The text to be encoded or decoded.\n    - key (str): The key used to construct the keyed alphabet.\n    - mode (str): The mode of operation, either \"encode\" or \"decode\".\n\n    Returns:\n    - str: The encoded or decoded text.\n    \"\"\"\n    if mode not in ['encode', 'decode']:\n        raise ValueError(\"Mode must be either 'encode' or 'decode'\")\n    d = 1 if mode == 'encode' else -1\n    remains = set(aLow)\n    alpha = []\n    for c in key * aLow:\n        if c in remains:\n            remains.remove(c)\n            alpha.append(c)\n    alpha = ''.join(alpha)\n    dct = {c: i for (i, c) in enumerate(alpha)}\n\n    def rotateWord(w, alpha, dct, d):\n        lst = []\n        for (i, c) in enumerate(w.lower(), 1):\n            transChar = alpha[(dct[c] + i * d) % 26]\n            if w[i - 1].isupper():\n                transChar = transChar.upper()\n            lst.append(transChar)\n        return ''.join(lst)\n    return re.sub('[a-zA-Z]+', lambda m: rotateWord(m.group(), alpha, dct, d), text)"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "d = 1 if mode == \"encode\" else -1",
      "mutated_line": "d = 1 if mode != 'encode' else -1",
      "code": "from string import ascii_lowercase as aLow\nimport re\n\ndef ragbaby_cipher(text: str, key: str, mode: str) -> str:\n    \"\"\"\n    Encodes or decodes a text using the Ragbaby cipher with the given key.\n\n    Parameters:\n    - text (str): The text to be encoded or decoded.\n    - key (str): The key used to construct the keyed alphabet.\n    - mode (str): The mode of operation, either \"encode\" or \"decode\".\n\n    Returns:\n    - str: The encoded or decoded text.\n    \"\"\"\n    if mode not in ['encode', 'decode']:\n        raise ValueError(\"Mode must be either 'encode' or 'decode'\")\n    d = 1 if mode != 'encode' else -1\n    remains = set(aLow)\n    alpha = []\n    for c in key + aLow:\n        if c in remains:\n            remains.remove(c)\n            alpha.append(c)\n    alpha = ''.join(alpha)\n    dct = {c: i for (i, c) in enumerate(alpha)}\n\n    def rotateWord(w, alpha, dct, d):\n        lst = []\n        for (i, c) in enumerate(w.lower(), 1):\n            transChar = alpha[(dct[c] + i * d) % 26]\n            if w[i - 1].isupper():\n                transChar = transChar.upper()\n            lst.append(transChar)\n        return ''.join(lst)\n    return re.sub('[a-zA-Z]+', lambda m: rotateWord(m.group(), alpha, dct, d), text)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "d = 1 if mode == \"encode\" else -1",
      "mutated_line": "d = 2 if mode == 'encode' else -1",
      "code": "from string import ascii_lowercase as aLow\nimport re\n\ndef ragbaby_cipher(text: str, key: str, mode: str) -> str:\n    \"\"\"\n    Encodes or decodes a text using the Ragbaby cipher with the given key.\n\n    Parameters:\n    - text (str): The text to be encoded or decoded.\n    - key (str): The key used to construct the keyed alphabet.\n    - mode (str): The mode of operation, either \"encode\" or \"decode\".\n\n    Returns:\n    - str: The encoded or decoded text.\n    \"\"\"\n    if mode not in ['encode', 'decode']:\n        raise ValueError(\"Mode must be either 'encode' or 'decode'\")\n    d = 2 if mode == 'encode' else -1\n    remains = set(aLow)\n    alpha = []\n    for c in key + aLow:\n        if c in remains:\n            remains.remove(c)\n            alpha.append(c)\n    alpha = ''.join(alpha)\n    dct = {c: i for (i, c) in enumerate(alpha)}\n\n    def rotateWord(w, alpha, dct, d):\n        lst = []\n        for (i, c) in enumerate(w.lower(), 1):\n            transChar = alpha[(dct[c] + i * d) % 26]\n            if w[i - 1].isupper():\n                transChar = transChar.upper()\n            lst.append(transChar)\n        return ''.join(lst)\n    return re.sub('[a-zA-Z]+', lambda m: rotateWord(m.group(), alpha, dct, d), text)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "d = 1 if mode == \"encode\" else -1",
      "mutated_line": "d = 0 if mode == 'encode' else -1",
      "code": "from string import ascii_lowercase as aLow\nimport re\n\ndef ragbaby_cipher(text: str, key: str, mode: str) -> str:\n    \"\"\"\n    Encodes or decodes a text using the Ragbaby cipher with the given key.\n\n    Parameters:\n    - text (str): The text to be encoded or decoded.\n    - key (str): The key used to construct the keyed alphabet.\n    - mode (str): The mode of operation, either \"encode\" or \"decode\".\n\n    Returns:\n    - str: The encoded or decoded text.\n    \"\"\"\n    if mode not in ['encode', 'decode']:\n        raise ValueError(\"Mode must be either 'encode' or 'decode'\")\n    d = 0 if mode == 'encode' else -1\n    remains = set(aLow)\n    alpha = []\n    for c in key + aLow:\n        if c in remains:\n            remains.remove(c)\n            alpha.append(c)\n    alpha = ''.join(alpha)\n    dct = {c: i for (i, c) in enumerate(alpha)}\n\n    def rotateWord(w, alpha, dct, d):\n        lst = []\n        for (i, c) in enumerate(w.lower(), 1):\n            transChar = alpha[(dct[c] + i * d) % 26]\n            if w[i - 1].isupper():\n                transChar = transChar.upper()\n            lst.append(transChar)\n        return ''.join(lst)\n    return re.sub('[a-zA-Z]+', lambda m: rotateWord(m.group(), alpha, dct, d), text)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "d = 1 if mode == \"encode\" else -1",
      "mutated_line": "d = 0 if mode == 'encode' else -1",
      "code": "from string import ascii_lowercase as aLow\nimport re\n\ndef ragbaby_cipher(text: str, key: str, mode: str) -> str:\n    \"\"\"\n    Encodes or decodes a text using the Ragbaby cipher with the given key.\n\n    Parameters:\n    - text (str): The text to be encoded or decoded.\n    - key (str): The key used to construct the keyed alphabet.\n    - mode (str): The mode of operation, either \"encode\" or \"decode\".\n\n    Returns:\n    - str: The encoded or decoded text.\n    \"\"\"\n    if mode not in ['encode', 'decode']:\n        raise ValueError(\"Mode must be either 'encode' or 'decode'\")\n    d = 0 if mode == 'encode' else -1\n    remains = set(aLow)\n    alpha = []\n    for c in key + aLow:\n        if c in remains:\n            remains.remove(c)\n            alpha.append(c)\n    alpha = ''.join(alpha)\n    dct = {c: i for (i, c) in enumerate(alpha)}\n\n    def rotateWord(w, alpha, dct, d):\n        lst = []\n        for (i, c) in enumerate(w.lower(), 1):\n            transChar = alpha[(dct[c] + i * d) % 26]\n            if w[i - 1].isupper():\n                transChar = transChar.upper()\n            lst.append(transChar)\n        return ''.join(lst)\n    return re.sub('[a-zA-Z]+', lambda m: rotateWord(m.group(), alpha, dct, d), text)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "d = 1 if mode == \"encode\" else -1",
      "mutated_line": "d = -1 if mode == 'encode' else -1",
      "code": "from string import ascii_lowercase as aLow\nimport re\n\ndef ragbaby_cipher(text: str, key: str, mode: str) -> str:\n    \"\"\"\n    Encodes or decodes a text using the Ragbaby cipher with the given key.\n\n    Parameters:\n    - text (str): The text to be encoded or decoded.\n    - key (str): The key used to construct the keyed alphabet.\n    - mode (str): The mode of operation, either \"encode\" or \"decode\".\n\n    Returns:\n    - str: The encoded or decoded text.\n    \"\"\"\n    if mode not in ['encode', 'decode']:\n        raise ValueError(\"Mode must be either 'encode' or 'decode'\")\n    d = -1 if mode == 'encode' else -1\n    remains = set(aLow)\n    alpha = []\n    for c in key + aLow:\n        if c in remains:\n            remains.remove(c)\n            alpha.append(c)\n    alpha = ''.join(alpha)\n    dct = {c: i for (i, c) in enumerate(alpha)}\n\n    def rotateWord(w, alpha, dct, d):\n        lst = []\n        for (i, c) in enumerate(w.lower(), 1):\n            transChar = alpha[(dct[c] + i * d) % 26]\n            if w[i - 1].isupper():\n                transChar = transChar.upper()\n            lst.append(transChar)\n        return ''.join(lst)\n    return re.sub('[a-zA-Z]+', lambda m: rotateWord(m.group(), alpha, dct, d), text)"
    },
    {
      "operator": "UOI",
      "lineno": 19,
      "original_line": "d = 1 if mode == \"encode\" else -1",
      "mutated_line": "d = 1 if mode == 'encode' else +1",
      "code": "from string import ascii_lowercase as aLow\nimport re\n\ndef ragbaby_cipher(text: str, key: str, mode: str) -> str:\n    \"\"\"\n    Encodes or decodes a text using the Ragbaby cipher with the given key.\n\n    Parameters:\n    - text (str): The text to be encoded or decoded.\n    - key (str): The key used to construct the keyed alphabet.\n    - mode (str): The mode of operation, either \"encode\" or \"decode\".\n\n    Returns:\n    - str: The encoded or decoded text.\n    \"\"\"\n    if mode not in ['encode', 'decode']:\n        raise ValueError(\"Mode must be either 'encode' or 'decode'\")\n    d = 1 if mode == 'encode' else +1\n    remains = set(aLow)\n    alpha = []\n    for c in key + aLow:\n        if c in remains:\n            remains.remove(c)\n            alpha.append(c)\n    alpha = ''.join(alpha)\n    dct = {c: i for (i, c) in enumerate(alpha)}\n\n    def rotateWord(w, alpha, dct, d):\n        lst = []\n        for (i, c) in enumerate(w.lower(), 1):\n            transChar = alpha[(dct[c] + i * d) % 26]\n            if w[i - 1].isupper():\n                transChar = transChar.upper()\n            lst.append(transChar)\n        return ''.join(lst)\n    return re.sub('[a-zA-Z]+', lambda m: rotateWord(m.group(), alpha, dct, d), text)"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if c in remains:",
      "mutated_line": "if c not in remains:",
      "code": "from string import ascii_lowercase as aLow\nimport re\n\ndef ragbaby_cipher(text: str, key: str, mode: str) -> str:\n    \"\"\"\n    Encodes or decodes a text using the Ragbaby cipher with the given key.\n\n    Parameters:\n    - text (str): The text to be encoded or decoded.\n    - key (str): The key used to construct the keyed alphabet.\n    - mode (str): The mode of operation, either \"encode\" or \"decode\".\n\n    Returns:\n    - str: The encoded or decoded text.\n    \"\"\"\n    if mode not in ['encode', 'decode']:\n        raise ValueError(\"Mode must be either 'encode' or 'decode'\")\n    d = 1 if mode == 'encode' else -1\n    remains = set(aLow)\n    alpha = []\n    for c in key + aLow:\n        if c not in remains:\n            remains.remove(c)\n            alpha.append(c)\n    alpha = ''.join(alpha)\n    dct = {c: i for (i, c) in enumerate(alpha)}\n\n    def rotateWord(w, alpha, dct, d):\n        lst = []\n        for (i, c) in enumerate(w.lower(), 1):\n            transChar = alpha[(dct[c] + i * d) % 26]\n            if w[i - 1].isupper():\n                transChar = transChar.upper()\n            lst.append(transChar)\n        return ''.join(lst)\n    return re.sub('[a-zA-Z]+', lambda m: rotateWord(m.group(), alpha, dct, d), text)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "return re.sub('[a-zA-Z]+', lambda m: rotateWord(m.group(), alpha, dct, d), text)",
      "mutated_line": "return re.sub('', lambda m: rotateWord(m.group(), alpha, dct, d), text)",
      "code": "from string import ascii_lowercase as aLow\nimport re\n\ndef ragbaby_cipher(text: str, key: str, mode: str) -> str:\n    \"\"\"\n    Encodes or decodes a text using the Ragbaby cipher with the given key.\n\n    Parameters:\n    - text (str): The text to be encoded or decoded.\n    - key (str): The key used to construct the keyed alphabet.\n    - mode (str): The mode of operation, either \"encode\" or \"decode\".\n\n    Returns:\n    - str: The encoded or decoded text.\n    \"\"\"\n    if mode not in ['encode', 'decode']:\n        raise ValueError(\"Mode must be either 'encode' or 'decode'\")\n    d = 1 if mode == 'encode' else -1\n    remains = set(aLow)\n    alpha = []\n    for c in key + aLow:\n        if c in remains:\n            remains.remove(c)\n            alpha.append(c)\n    alpha = ''.join(alpha)\n    dct = {c: i for (i, c) in enumerate(alpha)}\n\n    def rotateWord(w, alpha, dct, d):\n        lst = []\n        for (i, c) in enumerate(w.lower(), 1):\n            transChar = alpha[(dct[c] + i * d) % 26]\n            if w[i - 1].isupper():\n                transChar = transChar.upper()\n            lst.append(transChar)\n        return ''.join(lst)\n    return re.sub('', lambda m: rotateWord(m.group(), alpha, dct, d), text)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if mode not in [\"encode\", \"decode\"]:",
      "mutated_line": "if mode not in ['', 'decode']:",
      "code": "from string import ascii_lowercase as aLow\nimport re\n\ndef ragbaby_cipher(text: str, key: str, mode: str) -> str:\n    \"\"\"\n    Encodes or decodes a text using the Ragbaby cipher with the given key.\n\n    Parameters:\n    - text (str): The text to be encoded or decoded.\n    - key (str): The key used to construct the keyed alphabet.\n    - mode (str): The mode of operation, either \"encode\" or \"decode\".\n\n    Returns:\n    - str: The encoded or decoded text.\n    \"\"\"\n    if mode not in ['', 'decode']:\n        raise ValueError(\"Mode must be either 'encode' or 'decode'\")\n    d = 1 if mode == 'encode' else -1\n    remains = set(aLow)\n    alpha = []\n    for c in key + aLow:\n        if c in remains:\n            remains.remove(c)\n            alpha.append(c)\n    alpha = ''.join(alpha)\n    dct = {c: i for (i, c) in enumerate(alpha)}\n\n    def rotateWord(w, alpha, dct, d):\n        lst = []\n        for (i, c) in enumerate(w.lower(), 1):\n            transChar = alpha[(dct[c] + i * d) % 26]\n            if w[i - 1].isupper():\n                transChar = transChar.upper()\n            lst.append(transChar)\n        return ''.join(lst)\n    return re.sub('[a-zA-Z]+', lambda m: rotateWord(m.group(), alpha, dct, d), text)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if mode not in [\"encode\", \"decode\"]:",
      "mutated_line": "if mode not in ['encode', '']:",
      "code": "from string import ascii_lowercase as aLow\nimport re\n\ndef ragbaby_cipher(text: str, key: str, mode: str) -> str:\n    \"\"\"\n    Encodes or decodes a text using the Ragbaby cipher with the given key.\n\n    Parameters:\n    - text (str): The text to be encoded or decoded.\n    - key (str): The key used to construct the keyed alphabet.\n    - mode (str): The mode of operation, either \"encode\" or \"decode\".\n\n    Returns:\n    - str: The encoded or decoded text.\n    \"\"\"\n    if mode not in ['encode', '']:\n        raise ValueError(\"Mode must be either 'encode' or 'decode'\")\n    d = 1 if mode == 'encode' else -1\n    remains = set(aLow)\n    alpha = []\n    for c in key + aLow:\n        if c in remains:\n            remains.remove(c)\n            alpha.append(c)\n    alpha = ''.join(alpha)\n    dct = {c: i for (i, c) in enumerate(alpha)}\n\n    def rotateWord(w, alpha, dct, d):\n        lst = []\n        for (i, c) in enumerate(w.lower(), 1):\n            transChar = alpha[(dct[c] + i * d) % 26]\n            if w[i - 1].isupper():\n                transChar = transChar.upper()\n            lst.append(transChar)\n        return ''.join(lst)\n    return re.sub('[a-zA-Z]+', lambda m: rotateWord(m.group(), alpha, dct, d), text)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "raise ValueError(\"Mode must be either 'encode' or 'decode'\")",
      "mutated_line": "raise ValueError('')",
      "code": "from string import ascii_lowercase as aLow\nimport re\n\ndef ragbaby_cipher(text: str, key: str, mode: str) -> str:\n    \"\"\"\n    Encodes or decodes a text using the Ragbaby cipher with the given key.\n\n    Parameters:\n    - text (str): The text to be encoded or decoded.\n    - key (str): The key used to construct the keyed alphabet.\n    - mode (str): The mode of operation, either \"encode\" or \"decode\".\n\n    Returns:\n    - str: The encoded or decoded text.\n    \"\"\"\n    if mode not in ['encode', 'decode']:\n        raise ValueError('')\n    d = 1 if mode == 'encode' else -1\n    remains = set(aLow)\n    alpha = []\n    for c in key + aLow:\n        if c in remains:\n            remains.remove(c)\n            alpha.append(c)\n    alpha = ''.join(alpha)\n    dct = {c: i for (i, c) in enumerate(alpha)}\n\n    def rotateWord(w, alpha, dct, d):\n        lst = []\n        for (i, c) in enumerate(w.lower(), 1):\n            transChar = alpha[(dct[c] + i * d) % 26]\n            if w[i - 1].isupper():\n                transChar = transChar.upper()\n            lst.append(transChar)\n        return ''.join(lst)\n    return re.sub('[a-zA-Z]+', lambda m: rotateWord(m.group(), alpha, dct, d), text)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "d = 1 if mode == \"encode\" else -1",
      "mutated_line": "d = 1 if mode == '' else -1",
      "code": "from string import ascii_lowercase as aLow\nimport re\n\ndef ragbaby_cipher(text: str, key: str, mode: str) -> str:\n    \"\"\"\n    Encodes or decodes a text using the Ragbaby cipher with the given key.\n\n    Parameters:\n    - text (str): The text to be encoded or decoded.\n    - key (str): The key used to construct the keyed alphabet.\n    - mode (str): The mode of operation, either \"encode\" or \"decode\".\n\n    Returns:\n    - str: The encoded or decoded text.\n    \"\"\"\n    if mode not in ['encode', 'decode']:\n        raise ValueError(\"Mode must be either 'encode' or 'decode'\")\n    d = 1 if mode == '' else -1\n    remains = set(aLow)\n    alpha = []\n    for c in key + aLow:\n        if c in remains:\n            remains.remove(c)\n            alpha.append(c)\n    alpha = ''.join(alpha)\n    dct = {c: i for (i, c) in enumerate(alpha)}\n\n    def rotateWord(w, alpha, dct, d):\n        lst = []\n        for (i, c) in enumerate(w.lower(), 1):\n            transChar = alpha[(dct[c] + i * d) % 26]\n            if w[i - 1].isupper():\n                transChar = transChar.upper()\n            lst.append(transChar)\n        return ''.join(lst)\n    return re.sub('[a-zA-Z]+', lambda m: rotateWord(m.group(), alpha, dct, d), text)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "d = 1 if mode == \"encode\" else -1",
      "mutated_line": "d = 1 if mode == 'encode' else -2",
      "code": "from string import ascii_lowercase as aLow\nimport re\n\ndef ragbaby_cipher(text: str, key: str, mode: str) -> str:\n    \"\"\"\n    Encodes or decodes a text using the Ragbaby cipher with the given key.\n\n    Parameters:\n    - text (str): The text to be encoded or decoded.\n    - key (str): The key used to construct the keyed alphabet.\n    - mode (str): The mode of operation, either \"encode\" or \"decode\".\n\n    Returns:\n    - str: The encoded or decoded text.\n    \"\"\"\n    if mode not in ['encode', 'decode']:\n        raise ValueError(\"Mode must be either 'encode' or 'decode'\")\n    d = 1 if mode == 'encode' else -2\n    remains = set(aLow)\n    alpha = []\n    for c in key + aLow:\n        if c in remains:\n            remains.remove(c)\n            alpha.append(c)\n    alpha = ''.join(alpha)\n    dct = {c: i for (i, c) in enumerate(alpha)}\n\n    def rotateWord(w, alpha, dct, d):\n        lst = []\n        for (i, c) in enumerate(w.lower(), 1):\n            transChar = alpha[(dct[c] + i * d) % 26]\n            if w[i - 1].isupper():\n                transChar = transChar.upper()\n            lst.append(transChar)\n        return ''.join(lst)\n    return re.sub('[a-zA-Z]+', lambda m: rotateWord(m.group(), alpha, dct, d), text)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "d = 1 if mode == \"encode\" else -1",
      "mutated_line": "d = 1 if mode == 'encode' else -0",
      "code": "from string import ascii_lowercase as aLow\nimport re\n\ndef ragbaby_cipher(text: str, key: str, mode: str) -> str:\n    \"\"\"\n    Encodes or decodes a text using the Ragbaby cipher with the given key.\n\n    Parameters:\n    - text (str): The text to be encoded or decoded.\n    - key (str): The key used to construct the keyed alphabet.\n    - mode (str): The mode of operation, either \"encode\" or \"decode\".\n\n    Returns:\n    - str: The encoded or decoded text.\n    \"\"\"\n    if mode not in ['encode', 'decode']:\n        raise ValueError(\"Mode must be either 'encode' or 'decode'\")\n    d = 1 if mode == 'encode' else -0\n    remains = set(aLow)\n    alpha = []\n    for c in key + aLow:\n        if c in remains:\n            remains.remove(c)\n            alpha.append(c)\n    alpha = ''.join(alpha)\n    dct = {c: i for (i, c) in enumerate(alpha)}\n\n    def rotateWord(w, alpha, dct, d):\n        lst = []\n        for (i, c) in enumerate(w.lower(), 1):\n            transChar = alpha[(dct[c] + i * d) % 26]\n            if w[i - 1].isupper():\n                transChar = transChar.upper()\n            lst.append(transChar)\n        return ''.join(lst)\n    return re.sub('[a-zA-Z]+', lambda m: rotateWord(m.group(), alpha, dct, d), text)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "d = 1 if mode == \"encode\" else -1",
      "mutated_line": "d = 1 if mode == 'encode' else -0",
      "code": "from string import ascii_lowercase as aLow\nimport re\n\ndef ragbaby_cipher(text: str, key: str, mode: str) -> str:\n    \"\"\"\n    Encodes or decodes a text using the Ragbaby cipher with the given key.\n\n    Parameters:\n    - text (str): The text to be encoded or decoded.\n    - key (str): The key used to construct the keyed alphabet.\n    - mode (str): The mode of operation, either \"encode\" or \"decode\".\n\n    Returns:\n    - str: The encoded or decoded text.\n    \"\"\"\n    if mode not in ['encode', 'decode']:\n        raise ValueError(\"Mode must be either 'encode' or 'decode'\")\n    d = 1 if mode == 'encode' else -0\n    remains = set(aLow)\n    alpha = []\n    for c in key + aLow:\n        if c in remains:\n            remains.remove(c)\n            alpha.append(c)\n    alpha = ''.join(alpha)\n    dct = {c: i for (i, c) in enumerate(alpha)}\n\n    def rotateWord(w, alpha, dct, d):\n        lst = []\n        for (i, c) in enumerate(w.lower(), 1):\n            transChar = alpha[(dct[c] + i * d) % 26]\n            if w[i - 1].isupper():\n                transChar = transChar.upper()\n            lst.append(transChar)\n        return ''.join(lst)\n    return re.sub('[a-zA-Z]+', lambda m: rotateWord(m.group(), alpha, dct, d), text)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "d = 1 if mode == \"encode\" else -1",
      "mutated_line": "d = 1 if mode == 'encode' else --1",
      "code": "from string import ascii_lowercase as aLow\nimport re\n\ndef ragbaby_cipher(text: str, key: str, mode: str) -> str:\n    \"\"\"\n    Encodes or decodes a text using the Ragbaby cipher with the given key.\n\n    Parameters:\n    - text (str): The text to be encoded or decoded.\n    - key (str): The key used to construct the keyed alphabet.\n    - mode (str): The mode of operation, either \"encode\" or \"decode\".\n\n    Returns:\n    - str: The encoded or decoded text.\n    \"\"\"\n    if mode not in ['encode', 'decode']:\n        raise ValueError(\"Mode must be either 'encode' or 'decode'\")\n    d = 1 if mode == 'encode' else --1\n    remains = set(aLow)\n    alpha = []\n    for c in key + aLow:\n        if c in remains:\n            remains.remove(c)\n            alpha.append(c)\n    alpha = ''.join(alpha)\n    dct = {c: i for (i, c) in enumerate(alpha)}\n\n    def rotateWord(w, alpha, dct, d):\n        lst = []\n        for (i, c) in enumerate(w.lower(), 1):\n            transChar = alpha[(dct[c] + i * d) % 26]\n            if w[i - 1].isupper():\n                transChar = transChar.upper()\n            lst.append(transChar)\n        return ''.join(lst)\n    return re.sub('[a-zA-Z]+', lambda m: rotateWord(m.group(), alpha, dct, d), text)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "alpha = ''.join(alpha)",
      "mutated_line": "alpha = 'MUTATED'.join(alpha)",
      "code": "from string import ascii_lowercase as aLow\nimport re\n\ndef ragbaby_cipher(text: str, key: str, mode: str) -> str:\n    \"\"\"\n    Encodes or decodes a text using the Ragbaby cipher with the given key.\n\n    Parameters:\n    - text (str): The text to be encoded or decoded.\n    - key (str): The key used to construct the keyed alphabet.\n    - mode (str): The mode of operation, either \"encode\" or \"decode\".\n\n    Returns:\n    - str: The encoded or decoded text.\n    \"\"\"\n    if mode not in ['encode', 'decode']:\n        raise ValueError(\"Mode must be either 'encode' or 'decode'\")\n    d = 1 if mode == 'encode' else -1\n    remains = set(aLow)\n    alpha = []\n    for c in key + aLow:\n        if c in remains:\n            remains.remove(c)\n            alpha.append(c)\n    alpha = 'MUTATED'.join(alpha)\n    dct = {c: i for (i, c) in enumerate(alpha)}\n\n    def rotateWord(w, alpha, dct, d):\n        lst = []\n        for (i, c) in enumerate(w.lower(), 1):\n            transChar = alpha[(dct[c] + i * d) % 26]\n            if w[i - 1].isupper():\n                transChar = transChar.upper()\n            lst.append(transChar)\n        return ''.join(lst)\n    return re.sub('[a-zA-Z]+', lambda m: rotateWord(m.group(), alpha, dct, d), text)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for i, c in enumerate(w.lower(), 1):",
      "mutated_line": "for (i, c) in enumerate(w.lower(), 2):",
      "code": "from string import ascii_lowercase as aLow\nimport re\n\ndef ragbaby_cipher(text: str, key: str, mode: str) -> str:\n    \"\"\"\n    Encodes or decodes a text using the Ragbaby cipher with the given key.\n\n    Parameters:\n    - text (str): The text to be encoded or decoded.\n    - key (str): The key used to construct the keyed alphabet.\n    - mode (str): The mode of operation, either \"encode\" or \"decode\".\n\n    Returns:\n    - str: The encoded or decoded text.\n    \"\"\"\n    if mode not in ['encode', 'decode']:\n        raise ValueError(\"Mode must be either 'encode' or 'decode'\")\n    d = 1 if mode == 'encode' else -1\n    remains = set(aLow)\n    alpha = []\n    for c in key + aLow:\n        if c in remains:\n            remains.remove(c)\n            alpha.append(c)\n    alpha = ''.join(alpha)\n    dct = {c: i for (i, c) in enumerate(alpha)}\n\n    def rotateWord(w, alpha, dct, d):\n        lst = []\n        for (i, c) in enumerate(w.lower(), 2):\n            transChar = alpha[(dct[c] + i * d) % 26]\n            if w[i - 1].isupper():\n                transChar = transChar.upper()\n            lst.append(transChar)\n        return ''.join(lst)\n    return re.sub('[a-zA-Z]+', lambda m: rotateWord(m.group(), alpha, dct, d), text)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for i, c in enumerate(w.lower(), 1):",
      "mutated_line": "for (i, c) in enumerate(w.lower(), 0):",
      "code": "from string import ascii_lowercase as aLow\nimport re\n\ndef ragbaby_cipher(text: str, key: str, mode: str) -> str:\n    \"\"\"\n    Encodes or decodes a text using the Ragbaby cipher with the given key.\n\n    Parameters:\n    - text (str): The text to be encoded or decoded.\n    - key (str): The key used to construct the keyed alphabet.\n    - mode (str): The mode of operation, either \"encode\" or \"decode\".\n\n    Returns:\n    - str: The encoded or decoded text.\n    \"\"\"\n    if mode not in ['encode', 'decode']:\n        raise ValueError(\"Mode must be either 'encode' or 'decode'\")\n    d = 1 if mode == 'encode' else -1\n    remains = set(aLow)\n    alpha = []\n    for c in key + aLow:\n        if c in remains:\n            remains.remove(c)\n            alpha.append(c)\n    alpha = ''.join(alpha)\n    dct = {c: i for (i, c) in enumerate(alpha)}\n\n    def rotateWord(w, alpha, dct, d):\n        lst = []\n        for (i, c) in enumerate(w.lower(), 0):\n            transChar = alpha[(dct[c] + i * d) % 26]\n            if w[i - 1].isupper():\n                transChar = transChar.upper()\n            lst.append(transChar)\n        return ''.join(lst)\n    return re.sub('[a-zA-Z]+', lambda m: rotateWord(m.group(), alpha, dct, d), text)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for i, c in enumerate(w.lower(), 1):",
      "mutated_line": "for (i, c) in enumerate(w.lower(), 0):",
      "code": "from string import ascii_lowercase as aLow\nimport re\n\ndef ragbaby_cipher(text: str, key: str, mode: str) -> str:\n    \"\"\"\n    Encodes or decodes a text using the Ragbaby cipher with the given key.\n\n    Parameters:\n    - text (str): The text to be encoded or decoded.\n    - key (str): The key used to construct the keyed alphabet.\n    - mode (str): The mode of operation, either \"encode\" or \"decode\".\n\n    Returns:\n    - str: The encoded or decoded text.\n    \"\"\"\n    if mode not in ['encode', 'decode']:\n        raise ValueError(\"Mode must be either 'encode' or 'decode'\")\n    d = 1 if mode == 'encode' else -1\n    remains = set(aLow)\n    alpha = []\n    for c in key + aLow:\n        if c in remains:\n            remains.remove(c)\n            alpha.append(c)\n    alpha = ''.join(alpha)\n    dct = {c: i for (i, c) in enumerate(alpha)}\n\n    def rotateWord(w, alpha, dct, d):\n        lst = []\n        for (i, c) in enumerate(w.lower(), 0):\n            transChar = alpha[(dct[c] + i * d) % 26]\n            if w[i - 1].isupper():\n                transChar = transChar.upper()\n            lst.append(transChar)\n        return ''.join(lst)\n    return re.sub('[a-zA-Z]+', lambda m: rotateWord(m.group(), alpha, dct, d), text)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for i, c in enumerate(w.lower(), 1):",
      "mutated_line": "for (i, c) in enumerate(w.lower(), -1):",
      "code": "from string import ascii_lowercase as aLow\nimport re\n\ndef ragbaby_cipher(text: str, key: str, mode: str) -> str:\n    \"\"\"\n    Encodes or decodes a text using the Ragbaby cipher with the given key.\n\n    Parameters:\n    - text (str): The text to be encoded or decoded.\n    - key (str): The key used to construct the keyed alphabet.\n    - mode (str): The mode of operation, either \"encode\" or \"decode\".\n\n    Returns:\n    - str: The encoded or decoded text.\n    \"\"\"\n    if mode not in ['encode', 'decode']:\n        raise ValueError(\"Mode must be either 'encode' or 'decode'\")\n    d = 1 if mode == 'encode' else -1\n    remains = set(aLow)\n    alpha = []\n    for c in key + aLow:\n        if c in remains:\n            remains.remove(c)\n            alpha.append(c)\n    alpha = ''.join(alpha)\n    dct = {c: i for (i, c) in enumerate(alpha)}\n\n    def rotateWord(w, alpha, dct, d):\n        lst = []\n        for (i, c) in enumerate(w.lower(), -1):\n            transChar = alpha[(dct[c] + i * d) % 26]\n            if w[i - 1].isupper():\n                transChar = transChar.upper()\n            lst.append(transChar)\n        return ''.join(lst)\n    return re.sub('[a-zA-Z]+', lambda m: rotateWord(m.group(), alpha, dct, d), text)"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "transChar = alpha[(dct[c] + i * d) % 26]",
      "mutated_line": "transChar = alpha[(dct[c] + i * d) * 26]",
      "code": "from string import ascii_lowercase as aLow\nimport re\n\ndef ragbaby_cipher(text: str, key: str, mode: str) -> str:\n    \"\"\"\n    Encodes or decodes a text using the Ragbaby cipher with the given key.\n\n    Parameters:\n    - text (str): The text to be encoded or decoded.\n    - key (str): The key used to construct the keyed alphabet.\n    - mode (str): The mode of operation, either \"encode\" or \"decode\".\n\n    Returns:\n    - str: The encoded or decoded text.\n    \"\"\"\n    if mode not in ['encode', 'decode']:\n        raise ValueError(\"Mode must be either 'encode' or 'decode'\")\n    d = 1 if mode == 'encode' else -1\n    remains = set(aLow)\n    alpha = []\n    for c in key + aLow:\n        if c in remains:\n            remains.remove(c)\n            alpha.append(c)\n    alpha = ''.join(alpha)\n    dct = {c: i for (i, c) in enumerate(alpha)}\n\n    def rotateWord(w, alpha, dct, d):\n        lst = []\n        for (i, c) in enumerate(w.lower(), 1):\n            transChar = alpha[(dct[c] + i * d) * 26]\n            if w[i - 1].isupper():\n                transChar = transChar.upper()\n            lst.append(transChar)\n        return ''.join(lst)\n    return re.sub('[a-zA-Z]+', lambda m: rotateWord(m.group(), alpha, dct, d), text)"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "transChar = alpha[(dct[c] + i * d) % 26]",
      "mutated_line": "transChar = alpha[dct[c] + i * d + 26]",
      "code": "from string import ascii_lowercase as aLow\nimport re\n\ndef ragbaby_cipher(text: str, key: str, mode: str) -> str:\n    \"\"\"\n    Encodes or decodes a text using the Ragbaby cipher with the given key.\n\n    Parameters:\n    - text (str): The text to be encoded or decoded.\n    - key (str): The key used to construct the keyed alphabet.\n    - mode (str): The mode of operation, either \"encode\" or \"decode\".\n\n    Returns:\n    - str: The encoded or decoded text.\n    \"\"\"\n    if mode not in ['encode', 'decode']:\n        raise ValueError(\"Mode must be either 'encode' or 'decode'\")\n    d = 1 if mode == 'encode' else -1\n    remains = set(aLow)\n    alpha = []\n    for c in key + aLow:\n        if c in remains:\n            remains.remove(c)\n            alpha.append(c)\n    alpha = ''.join(alpha)\n    dct = {c: i for (i, c) in enumerate(alpha)}\n\n    def rotateWord(w, alpha, dct, d):\n        lst = []\n        for (i, c) in enumerate(w.lower(), 1):\n            transChar = alpha[dct[c] + i * d + 26]\n            if w[i - 1].isupper():\n                transChar = transChar.upper()\n            lst.append(transChar)\n        return ''.join(lst)\n    return re.sub('[a-zA-Z]+', lambda m: rotateWord(m.group(), alpha, dct, d), text)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "return ''.join(lst)",
      "mutated_line": "return 'MUTATED'.join(lst)",
      "code": "from string import ascii_lowercase as aLow\nimport re\n\ndef ragbaby_cipher(text: str, key: str, mode: str) -> str:\n    \"\"\"\n    Encodes or decodes a text using the Ragbaby cipher with the given key.\n\n    Parameters:\n    - text (str): The text to be encoded or decoded.\n    - key (str): The key used to construct the keyed alphabet.\n    - mode (str): The mode of operation, either \"encode\" or \"decode\".\n\n    Returns:\n    - str: The encoded or decoded text.\n    \"\"\"\n    if mode not in ['encode', 'decode']:\n        raise ValueError(\"Mode must be either 'encode' or 'decode'\")\n    d = 1 if mode == 'encode' else -1\n    remains = set(aLow)\n    alpha = []\n    for c in key + aLow:\n        if c in remains:\n            remains.remove(c)\n            alpha.append(c)\n    alpha = ''.join(alpha)\n    dct = {c: i for (i, c) in enumerate(alpha)}\n\n    def rotateWord(w, alpha, dct, d):\n        lst = []\n        for (i, c) in enumerate(w.lower(), 1):\n            transChar = alpha[(dct[c] + i * d) % 26]\n            if w[i - 1].isupper():\n                transChar = transChar.upper()\n            lst.append(transChar)\n        return 'MUTATED'.join(lst)\n    return re.sub('[a-zA-Z]+', lambda m: rotateWord(m.group(), alpha, dct, d), text)"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "transChar = alpha[(dct[c] + i * d) % 26]",
      "mutated_line": "transChar = alpha[(dct[c] - i * d) % 26]",
      "code": "from string import ascii_lowercase as aLow\nimport re\n\ndef ragbaby_cipher(text: str, key: str, mode: str) -> str:\n    \"\"\"\n    Encodes or decodes a text using the Ragbaby cipher with the given key.\n\n    Parameters:\n    - text (str): The text to be encoded or decoded.\n    - key (str): The key used to construct the keyed alphabet.\n    - mode (str): The mode of operation, either \"encode\" or \"decode\".\n\n    Returns:\n    - str: The encoded or decoded text.\n    \"\"\"\n    if mode not in ['encode', 'decode']:\n        raise ValueError(\"Mode must be either 'encode' or 'decode'\")\n    d = 1 if mode == 'encode' else -1\n    remains = set(aLow)\n    alpha = []\n    for c in key + aLow:\n        if c in remains:\n            remains.remove(c)\n            alpha.append(c)\n    alpha = ''.join(alpha)\n    dct = {c: i for (i, c) in enumerate(alpha)}\n\n    def rotateWord(w, alpha, dct, d):\n        lst = []\n        for (i, c) in enumerate(w.lower(), 1):\n            transChar = alpha[(dct[c] - i * d) % 26]\n            if w[i - 1].isupper():\n                transChar = transChar.upper()\n            lst.append(transChar)\n        return ''.join(lst)\n    return re.sub('[a-zA-Z]+', lambda m: rotateWord(m.group(), alpha, dct, d), text)"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "transChar = alpha[(dct[c] + i * d) % 26]",
      "mutated_line": "transChar = alpha[dct[c] * (i * d) % 26]",
      "code": "from string import ascii_lowercase as aLow\nimport re\n\ndef ragbaby_cipher(text: str, key: str, mode: str) -> str:\n    \"\"\"\n    Encodes or decodes a text using the Ragbaby cipher with the given key.\n\n    Parameters:\n    - text (str): The text to be encoded or decoded.\n    - key (str): The key used to construct the keyed alphabet.\n    - mode (str): The mode of operation, either \"encode\" or \"decode\".\n\n    Returns:\n    - str: The encoded or decoded text.\n    \"\"\"\n    if mode not in ['encode', 'decode']:\n        raise ValueError(\"Mode must be either 'encode' or 'decode'\")\n    d = 1 if mode == 'encode' else -1\n    remains = set(aLow)\n    alpha = []\n    for c in key + aLow:\n        if c in remains:\n            remains.remove(c)\n            alpha.append(c)\n    alpha = ''.join(alpha)\n    dct = {c: i for (i, c) in enumerate(alpha)}\n\n    def rotateWord(w, alpha, dct, d):\n        lst = []\n        for (i, c) in enumerate(w.lower(), 1):\n            transChar = alpha[dct[c] * (i * d) % 26]\n            if w[i - 1].isupper():\n                transChar = transChar.upper()\n            lst.append(transChar)\n        return ''.join(lst)\n    return re.sub('[a-zA-Z]+', lambda m: rotateWord(m.group(), alpha, dct, d), text)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "transChar = alpha[(dct[c] + i * d) % 26]",
      "mutated_line": "transChar = alpha[(dct[c] + i * d) % 27]",
      "code": "from string import ascii_lowercase as aLow\nimport re\n\ndef ragbaby_cipher(text: str, key: str, mode: str) -> str:\n    \"\"\"\n    Encodes or decodes a text using the Ragbaby cipher with the given key.\n\n    Parameters:\n    - text (str): The text to be encoded or decoded.\n    - key (str): The key used to construct the keyed alphabet.\n    - mode (str): The mode of operation, either \"encode\" or \"decode\".\n\n    Returns:\n    - str: The encoded or decoded text.\n    \"\"\"\n    if mode not in ['encode', 'decode']:\n        raise ValueError(\"Mode must be either 'encode' or 'decode'\")\n    d = 1 if mode == 'encode' else -1\n    remains = set(aLow)\n    alpha = []\n    for c in key + aLow:\n        if c in remains:\n            remains.remove(c)\n            alpha.append(c)\n    alpha = ''.join(alpha)\n    dct = {c: i for (i, c) in enumerate(alpha)}\n\n    def rotateWord(w, alpha, dct, d):\n        lst = []\n        for (i, c) in enumerate(w.lower(), 1):\n            transChar = alpha[(dct[c] + i * d) % 27]\n            if w[i - 1].isupper():\n                transChar = transChar.upper()\n            lst.append(transChar)\n        return ''.join(lst)\n    return re.sub('[a-zA-Z]+', lambda m: rotateWord(m.group(), alpha, dct, d), text)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "transChar = alpha[(dct[c] + i * d) % 26]",
      "mutated_line": "transChar = alpha[(dct[c] + i * d) % 25]",
      "code": "from string import ascii_lowercase as aLow\nimport re\n\ndef ragbaby_cipher(text: str, key: str, mode: str) -> str:\n    \"\"\"\n    Encodes or decodes a text using the Ragbaby cipher with the given key.\n\n    Parameters:\n    - text (str): The text to be encoded or decoded.\n    - key (str): The key used to construct the keyed alphabet.\n    - mode (str): The mode of operation, either \"encode\" or \"decode\".\n\n    Returns:\n    - str: The encoded or decoded text.\n    \"\"\"\n    if mode not in ['encode', 'decode']:\n        raise ValueError(\"Mode must be either 'encode' or 'decode'\")\n    d = 1 if mode == 'encode' else -1\n    remains = set(aLow)\n    alpha = []\n    for c in key + aLow:\n        if c in remains:\n            remains.remove(c)\n            alpha.append(c)\n    alpha = ''.join(alpha)\n    dct = {c: i for (i, c) in enumerate(alpha)}\n\n    def rotateWord(w, alpha, dct, d):\n        lst = []\n        for (i, c) in enumerate(w.lower(), 1):\n            transChar = alpha[(dct[c] + i * d) % 25]\n            if w[i - 1].isupper():\n                transChar = transChar.upper()\n            lst.append(transChar)\n        return ''.join(lst)\n    return re.sub('[a-zA-Z]+', lambda m: rotateWord(m.group(), alpha, dct, d), text)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "transChar = alpha[(dct[c] + i * d) % 26]",
      "mutated_line": "transChar = alpha[(dct[c] + i * d) % 0]",
      "code": "from string import ascii_lowercase as aLow\nimport re\n\ndef ragbaby_cipher(text: str, key: str, mode: str) -> str:\n    \"\"\"\n    Encodes or decodes a text using the Ragbaby cipher with the given key.\n\n    Parameters:\n    - text (str): The text to be encoded or decoded.\n    - key (str): The key used to construct the keyed alphabet.\n    - mode (str): The mode of operation, either \"encode\" or \"decode\".\n\n    Returns:\n    - str: The encoded or decoded text.\n    \"\"\"\n    if mode not in ['encode', 'decode']:\n        raise ValueError(\"Mode must be either 'encode' or 'decode'\")\n    d = 1 if mode == 'encode' else -1\n    remains = set(aLow)\n    alpha = []\n    for c in key + aLow:\n        if c in remains:\n            remains.remove(c)\n            alpha.append(c)\n    alpha = ''.join(alpha)\n    dct = {c: i for (i, c) in enumerate(alpha)}\n\n    def rotateWord(w, alpha, dct, d):\n        lst = []\n        for (i, c) in enumerate(w.lower(), 1):\n            transChar = alpha[(dct[c] + i * d) % 0]\n            if w[i - 1].isupper():\n                transChar = transChar.upper()\n            lst.append(transChar)\n        return ''.join(lst)\n    return re.sub('[a-zA-Z]+', lambda m: rotateWord(m.group(), alpha, dct, d), text)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "transChar = alpha[(dct[c] + i * d) % 26]",
      "mutated_line": "transChar = alpha[(dct[c] + i * d) % 1]",
      "code": "from string import ascii_lowercase as aLow\nimport re\n\ndef ragbaby_cipher(text: str, key: str, mode: str) -> str:\n    \"\"\"\n    Encodes or decodes a text using the Ragbaby cipher with the given key.\n\n    Parameters:\n    - text (str): The text to be encoded or decoded.\n    - key (str): The key used to construct the keyed alphabet.\n    - mode (str): The mode of operation, either \"encode\" or \"decode\".\n\n    Returns:\n    - str: The encoded or decoded text.\n    \"\"\"\n    if mode not in ['encode', 'decode']:\n        raise ValueError(\"Mode must be either 'encode' or 'decode'\")\n    d = 1 if mode == 'encode' else -1\n    remains = set(aLow)\n    alpha = []\n    for c in key + aLow:\n        if c in remains:\n            remains.remove(c)\n            alpha.append(c)\n    alpha = ''.join(alpha)\n    dct = {c: i for (i, c) in enumerate(alpha)}\n\n    def rotateWord(w, alpha, dct, d):\n        lst = []\n        for (i, c) in enumerate(w.lower(), 1):\n            transChar = alpha[(dct[c] + i * d) % 1]\n            if w[i - 1].isupper():\n                transChar = transChar.upper()\n            lst.append(transChar)\n        return ''.join(lst)\n    return re.sub('[a-zA-Z]+', lambda m: rotateWord(m.group(), alpha, dct, d), text)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "transChar = alpha[(dct[c] + i * d) % 26]",
      "mutated_line": "transChar = alpha[(dct[c] + i * d) % -26]",
      "code": "from string import ascii_lowercase as aLow\nimport re\n\ndef ragbaby_cipher(text: str, key: str, mode: str) -> str:\n    \"\"\"\n    Encodes or decodes a text using the Ragbaby cipher with the given key.\n\n    Parameters:\n    - text (str): The text to be encoded or decoded.\n    - key (str): The key used to construct the keyed alphabet.\n    - mode (str): The mode of operation, either \"encode\" or \"decode\".\n\n    Returns:\n    - str: The encoded or decoded text.\n    \"\"\"\n    if mode not in ['encode', 'decode']:\n        raise ValueError(\"Mode must be either 'encode' or 'decode'\")\n    d = 1 if mode == 'encode' else -1\n    remains = set(aLow)\n    alpha = []\n    for c in key + aLow:\n        if c in remains:\n            remains.remove(c)\n            alpha.append(c)\n    alpha = ''.join(alpha)\n    dct = {c: i for (i, c) in enumerate(alpha)}\n\n    def rotateWord(w, alpha, dct, d):\n        lst = []\n        for (i, c) in enumerate(w.lower(), 1):\n            transChar = alpha[(dct[c] + i * d) % -26]\n            if w[i - 1].isupper():\n                transChar = transChar.upper()\n            lst.append(transChar)\n        return ''.join(lst)\n    return re.sub('[a-zA-Z]+', lambda m: rotateWord(m.group(), alpha, dct, d), text)"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "transChar = alpha[(dct[c] + i * d) % 26]",
      "mutated_line": "transChar = alpha[(dct[c] + i / d) % 26]",
      "code": "from string import ascii_lowercase as aLow\nimport re\n\ndef ragbaby_cipher(text: str, key: str, mode: str) -> str:\n    \"\"\"\n    Encodes or decodes a text using the Ragbaby cipher with the given key.\n\n    Parameters:\n    - text (str): The text to be encoded or decoded.\n    - key (str): The key used to construct the keyed alphabet.\n    - mode (str): The mode of operation, either \"encode\" or \"decode\".\n\n    Returns:\n    - str: The encoded or decoded text.\n    \"\"\"\n    if mode not in ['encode', 'decode']:\n        raise ValueError(\"Mode must be either 'encode' or 'decode'\")\n    d = 1 if mode == 'encode' else -1\n    remains = set(aLow)\n    alpha = []\n    for c in key + aLow:\n        if c in remains:\n            remains.remove(c)\n            alpha.append(c)\n    alpha = ''.join(alpha)\n    dct = {c: i for (i, c) in enumerate(alpha)}\n\n    def rotateWord(w, alpha, dct, d):\n        lst = []\n        for (i, c) in enumerate(w.lower(), 1):\n            transChar = alpha[(dct[c] + i / d) % 26]\n            if w[i - 1].isupper():\n                transChar = transChar.upper()\n            lst.append(transChar)\n        return ''.join(lst)\n    return re.sub('[a-zA-Z]+', lambda m: rotateWord(m.group(), alpha, dct, d), text)"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "transChar = alpha[(dct[c] + i * d) % 26]",
      "mutated_line": "transChar = alpha[(dct[c] + (i + d)) % 26]",
      "code": "from string import ascii_lowercase as aLow\nimport re\n\ndef ragbaby_cipher(text: str, key: str, mode: str) -> str:\n    \"\"\"\n    Encodes or decodes a text using the Ragbaby cipher with the given key.\n\n    Parameters:\n    - text (str): The text to be encoded or decoded.\n    - key (str): The key used to construct the keyed alphabet.\n    - mode (str): The mode of operation, either \"encode\" or \"decode\".\n\n    Returns:\n    - str: The encoded or decoded text.\n    \"\"\"\n    if mode not in ['encode', 'decode']:\n        raise ValueError(\"Mode must be either 'encode' or 'decode'\")\n    d = 1 if mode == 'encode' else -1\n    remains = set(aLow)\n    alpha = []\n    for c in key + aLow:\n        if c in remains:\n            remains.remove(c)\n            alpha.append(c)\n    alpha = ''.join(alpha)\n    dct = {c: i for (i, c) in enumerate(alpha)}\n\n    def rotateWord(w, alpha, dct, d):\n        lst = []\n        for (i, c) in enumerate(w.lower(), 1):\n            transChar = alpha[(dct[c] + (i + d)) % 26]\n            if w[i - 1].isupper():\n                transChar = transChar.upper()\n            lst.append(transChar)\n        return ''.join(lst)\n    return re.sub('[a-zA-Z]+', lambda m: rotateWord(m.group(), alpha, dct, d), text)"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "transChar = alpha[(dct[c] + i * d) % 26]",
      "mutated_line": "transChar = alpha[(dct[c] + i ** d) % 26]",
      "code": "from string import ascii_lowercase as aLow\nimport re\n\ndef ragbaby_cipher(text: str, key: str, mode: str) -> str:\n    \"\"\"\n    Encodes or decodes a text using the Ragbaby cipher with the given key.\n\n    Parameters:\n    - text (str): The text to be encoded or decoded.\n    - key (str): The key used to construct the keyed alphabet.\n    - mode (str): The mode of operation, either \"encode\" or \"decode\".\n\n    Returns:\n    - str: The encoded or decoded text.\n    \"\"\"\n    if mode not in ['encode', 'decode']:\n        raise ValueError(\"Mode must be either 'encode' or 'decode'\")\n    d = 1 if mode == 'encode' else -1\n    remains = set(aLow)\n    alpha = []\n    for c in key + aLow:\n        if c in remains:\n            remains.remove(c)\n            alpha.append(c)\n    alpha = ''.join(alpha)\n    dct = {c: i for (i, c) in enumerate(alpha)}\n\n    def rotateWord(w, alpha, dct, d):\n        lst = []\n        for (i, c) in enumerate(w.lower(), 1):\n            transChar = alpha[(dct[c] + i ** d) % 26]\n            if w[i - 1].isupper():\n                transChar = transChar.upper()\n            lst.append(transChar)\n        return ''.join(lst)\n    return re.sub('[a-zA-Z]+', lambda m: rotateWord(m.group(), alpha, dct, d), text)"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "if w[i - 1].isupper():",
      "mutated_line": "if w[i + 1].isupper():",
      "code": "from string import ascii_lowercase as aLow\nimport re\n\ndef ragbaby_cipher(text: str, key: str, mode: str) -> str:\n    \"\"\"\n    Encodes or decodes a text using the Ragbaby cipher with the given key.\n\n    Parameters:\n    - text (str): The text to be encoded or decoded.\n    - key (str): The key used to construct the keyed alphabet.\n    - mode (str): The mode of operation, either \"encode\" or \"decode\".\n\n    Returns:\n    - str: The encoded or decoded text.\n    \"\"\"\n    if mode not in ['encode', 'decode']:\n        raise ValueError(\"Mode must be either 'encode' or 'decode'\")\n    d = 1 if mode == 'encode' else -1\n    remains = set(aLow)\n    alpha = []\n    for c in key + aLow:\n        if c in remains:\n            remains.remove(c)\n            alpha.append(c)\n    alpha = ''.join(alpha)\n    dct = {c: i for (i, c) in enumerate(alpha)}\n\n    def rotateWord(w, alpha, dct, d):\n        lst = []\n        for (i, c) in enumerate(w.lower(), 1):\n            transChar = alpha[(dct[c] + i * d) % 26]\n            if w[i + 1].isupper():\n                transChar = transChar.upper()\n            lst.append(transChar)\n        return ''.join(lst)\n    return re.sub('[a-zA-Z]+', lambda m: rotateWord(m.group(), alpha, dct, d), text)"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "if w[i - 1].isupper():",
      "mutated_line": "if w[i * 1].isupper():",
      "code": "from string import ascii_lowercase as aLow\nimport re\n\ndef ragbaby_cipher(text: str, key: str, mode: str) -> str:\n    \"\"\"\n    Encodes or decodes a text using the Ragbaby cipher with the given key.\n\n    Parameters:\n    - text (str): The text to be encoded or decoded.\n    - key (str): The key used to construct the keyed alphabet.\n    - mode (str): The mode of operation, either \"encode\" or \"decode\".\n\n    Returns:\n    - str: The encoded or decoded text.\n    \"\"\"\n    if mode not in ['encode', 'decode']:\n        raise ValueError(\"Mode must be either 'encode' or 'decode'\")\n    d = 1 if mode == 'encode' else -1\n    remains = set(aLow)\n    alpha = []\n    for c in key + aLow:\n        if c in remains:\n            remains.remove(c)\n            alpha.append(c)\n    alpha = ''.join(alpha)\n    dct = {c: i for (i, c) in enumerate(alpha)}\n\n    def rotateWord(w, alpha, dct, d):\n        lst = []\n        for (i, c) in enumerate(w.lower(), 1):\n            transChar = alpha[(dct[c] + i * d) % 26]\n            if w[i * 1].isupper():\n                transChar = transChar.upper()\n            lst.append(transChar)\n        return ''.join(lst)\n    return re.sub('[a-zA-Z]+', lambda m: rotateWord(m.group(), alpha, dct, d), text)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if w[i - 1].isupper():",
      "mutated_line": "if w[i - 2].isupper():",
      "code": "from string import ascii_lowercase as aLow\nimport re\n\ndef ragbaby_cipher(text: str, key: str, mode: str) -> str:\n    \"\"\"\n    Encodes or decodes a text using the Ragbaby cipher with the given key.\n\n    Parameters:\n    - text (str): The text to be encoded or decoded.\n    - key (str): The key used to construct the keyed alphabet.\n    - mode (str): The mode of operation, either \"encode\" or \"decode\".\n\n    Returns:\n    - str: The encoded or decoded text.\n    \"\"\"\n    if mode not in ['encode', 'decode']:\n        raise ValueError(\"Mode must be either 'encode' or 'decode'\")\n    d = 1 if mode == 'encode' else -1\n    remains = set(aLow)\n    alpha = []\n    for c in key + aLow:\n        if c in remains:\n            remains.remove(c)\n            alpha.append(c)\n    alpha = ''.join(alpha)\n    dct = {c: i for (i, c) in enumerate(alpha)}\n\n    def rotateWord(w, alpha, dct, d):\n        lst = []\n        for (i, c) in enumerate(w.lower(), 1):\n            transChar = alpha[(dct[c] + i * d) % 26]\n            if w[i - 2].isupper():\n                transChar = transChar.upper()\n            lst.append(transChar)\n        return ''.join(lst)\n    return re.sub('[a-zA-Z]+', lambda m: rotateWord(m.group(), alpha, dct, d), text)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if w[i - 1].isupper():",
      "mutated_line": "if w[i - 0].isupper():",
      "code": "from string import ascii_lowercase as aLow\nimport re\n\ndef ragbaby_cipher(text: str, key: str, mode: str) -> str:\n    \"\"\"\n    Encodes or decodes a text using the Ragbaby cipher with the given key.\n\n    Parameters:\n    - text (str): The text to be encoded or decoded.\n    - key (str): The key used to construct the keyed alphabet.\n    - mode (str): The mode of operation, either \"encode\" or \"decode\".\n\n    Returns:\n    - str: The encoded or decoded text.\n    \"\"\"\n    if mode not in ['encode', 'decode']:\n        raise ValueError(\"Mode must be either 'encode' or 'decode'\")\n    d = 1 if mode == 'encode' else -1\n    remains = set(aLow)\n    alpha = []\n    for c in key + aLow:\n        if c in remains:\n            remains.remove(c)\n            alpha.append(c)\n    alpha = ''.join(alpha)\n    dct = {c: i for (i, c) in enumerate(alpha)}\n\n    def rotateWord(w, alpha, dct, d):\n        lst = []\n        for (i, c) in enumerate(w.lower(), 1):\n            transChar = alpha[(dct[c] + i * d) % 26]\n            if w[i - 0].isupper():\n                transChar = transChar.upper()\n            lst.append(transChar)\n        return ''.join(lst)\n    return re.sub('[a-zA-Z]+', lambda m: rotateWord(m.group(), alpha, dct, d), text)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if w[i - 1].isupper():",
      "mutated_line": "if w[i - 0].isupper():",
      "code": "from string import ascii_lowercase as aLow\nimport re\n\ndef ragbaby_cipher(text: str, key: str, mode: str) -> str:\n    \"\"\"\n    Encodes or decodes a text using the Ragbaby cipher with the given key.\n\n    Parameters:\n    - text (str): The text to be encoded or decoded.\n    - key (str): The key used to construct the keyed alphabet.\n    - mode (str): The mode of operation, either \"encode\" or \"decode\".\n\n    Returns:\n    - str: The encoded or decoded text.\n    \"\"\"\n    if mode not in ['encode', 'decode']:\n        raise ValueError(\"Mode must be either 'encode' or 'decode'\")\n    d = 1 if mode == 'encode' else -1\n    remains = set(aLow)\n    alpha = []\n    for c in key + aLow:\n        if c in remains:\n            remains.remove(c)\n            alpha.append(c)\n    alpha = ''.join(alpha)\n    dct = {c: i for (i, c) in enumerate(alpha)}\n\n    def rotateWord(w, alpha, dct, d):\n        lst = []\n        for (i, c) in enumerate(w.lower(), 1):\n            transChar = alpha[(dct[c] + i * d) % 26]\n            if w[i - 0].isupper():\n                transChar = transChar.upper()\n            lst.append(transChar)\n        return ''.join(lst)\n    return re.sub('[a-zA-Z]+', lambda m: rotateWord(m.group(), alpha, dct, d), text)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if w[i - 1].isupper():",
      "mutated_line": "if w[i - -1].isupper():",
      "code": "from string import ascii_lowercase as aLow\nimport re\n\ndef ragbaby_cipher(text: str, key: str, mode: str) -> str:\n    \"\"\"\n    Encodes or decodes a text using the Ragbaby cipher with the given key.\n\n    Parameters:\n    - text (str): The text to be encoded or decoded.\n    - key (str): The key used to construct the keyed alphabet.\n    - mode (str): The mode of operation, either \"encode\" or \"decode\".\n\n    Returns:\n    - str: The encoded or decoded text.\n    \"\"\"\n    if mode not in ['encode', 'decode']:\n        raise ValueError(\"Mode must be either 'encode' or 'decode'\")\n    d = 1 if mode == 'encode' else -1\n    remains = set(aLow)\n    alpha = []\n    for c in key + aLow:\n        if c in remains:\n            remains.remove(c)\n            alpha.append(c)\n    alpha = ''.join(alpha)\n    dct = {c: i for (i, c) in enumerate(alpha)}\n\n    def rotateWord(w, alpha, dct, d):\n        lst = []\n        for (i, c) in enumerate(w.lower(), 1):\n            transChar = alpha[(dct[c] + i * d) % 26]\n            if w[i - -1].isupper():\n                transChar = transChar.upper()\n            lst.append(transChar)\n        return ''.join(lst)\n    return re.sub('[a-zA-Z]+', lambda m: rotateWord(m.group(), alpha, dct, d), text)"
    }
  ]
}