{
  "task_id": "taco_15230",
  "entry_point": "calculate_expected_steps",
  "mutant_count": 22,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if nid in depths:",
      "mutated_line": "if nid not in depths:",
      "code": "from collections import defaultdict, deque\n\ndef calculate_expected_steps(n, edges):\n    tree = defaultdict(list)\n    for (a, b) in edges:\n        tree[a].append(b)\n        tree[b].append(a)\n    bfs = deque([(1, 1)])\n    depths = {}\n    while bfs:\n        (nid, depth) = bfs.popleft()\n        if nid not in depths:\n            continue\n        depths[nid] = depth\n        for n2 in tree[nid]:\n            bfs.append((n2, depth + 1))\n    expected_steps = sum((1.0 / d for d in sorted(depths.values(), reverse=True)))\n    return expected_steps"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "expected_steps = sum((1.0 / d for d in sorted(depths.values(), reverse=True)))",
      "mutated_line": "expected_steps = sum((1.0 * d for d in sorted(depths.values(), reverse=True)))",
      "code": "from collections import defaultdict, deque\n\ndef calculate_expected_steps(n, edges):\n    tree = defaultdict(list)\n    for (a, b) in edges:\n        tree[a].append(b)\n        tree[b].append(a)\n    bfs = deque([(1, 1)])\n    depths = {}\n    while bfs:\n        (nid, depth) = bfs.popleft()\n        if nid in depths:\n            continue\n        depths[nid] = depth\n        for n2 in tree[nid]:\n            bfs.append((n2, depth + 1))\n    expected_steps = sum((1.0 * d for d in sorted(depths.values(), reverse=True)))\n    return expected_steps"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "expected_steps = sum((1.0 / d for d in sorted(depths.values(), reverse=True)))",
      "mutated_line": "expected_steps = sum((1.0 // d for d in sorted(depths.values(), reverse=True)))",
      "code": "from collections import defaultdict, deque\n\ndef calculate_expected_steps(n, edges):\n    tree = defaultdict(list)\n    for (a, b) in edges:\n        tree[a].append(b)\n        tree[b].append(a)\n    bfs = deque([(1, 1)])\n    depths = {}\n    while bfs:\n        (nid, depth) = bfs.popleft()\n        if nid in depths:\n            continue\n        depths[nid] = depth\n        for n2 in tree[nid]:\n            bfs.append((n2, depth + 1))\n    expected_steps = sum((1.0 // d for d in sorted(depths.values(), reverse=True)))\n    return expected_steps"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "bfs = deque([(1, 1)])",
      "mutated_line": "bfs = deque([(2, 1)])",
      "code": "from collections import defaultdict, deque\n\ndef calculate_expected_steps(n, edges):\n    tree = defaultdict(list)\n    for (a, b) in edges:\n        tree[a].append(b)\n        tree[b].append(a)\n    bfs = deque([(2, 1)])\n    depths = {}\n    while bfs:\n        (nid, depth) = bfs.popleft()\n        if nid in depths:\n            continue\n        depths[nid] = depth\n        for n2 in tree[nid]:\n            bfs.append((n2, depth + 1))\n    expected_steps = sum((1.0 / d for d in sorted(depths.values(), reverse=True)))\n    return expected_steps"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "bfs = deque([(1, 1)])",
      "mutated_line": "bfs = deque([(0, 1)])",
      "code": "from collections import defaultdict, deque\n\ndef calculate_expected_steps(n, edges):\n    tree = defaultdict(list)\n    for (a, b) in edges:\n        tree[a].append(b)\n        tree[b].append(a)\n    bfs = deque([(0, 1)])\n    depths = {}\n    while bfs:\n        (nid, depth) = bfs.popleft()\n        if nid in depths:\n            continue\n        depths[nid] = depth\n        for n2 in tree[nid]:\n            bfs.append((n2, depth + 1))\n    expected_steps = sum((1.0 / d for d in sorted(depths.values(), reverse=True)))\n    return expected_steps"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "bfs = deque([(1, 1)])",
      "mutated_line": "bfs = deque([(0, 1)])",
      "code": "from collections import defaultdict, deque\n\ndef calculate_expected_steps(n, edges):\n    tree = defaultdict(list)\n    for (a, b) in edges:\n        tree[a].append(b)\n        tree[b].append(a)\n    bfs = deque([(0, 1)])\n    depths = {}\n    while bfs:\n        (nid, depth) = bfs.popleft()\n        if nid in depths:\n            continue\n        depths[nid] = depth\n        for n2 in tree[nid]:\n            bfs.append((n2, depth + 1))\n    expected_steps = sum((1.0 / d for d in sorted(depths.values(), reverse=True)))\n    return expected_steps"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "bfs = deque([(1, 1)])",
      "mutated_line": "bfs = deque([(-1, 1)])",
      "code": "from collections import defaultdict, deque\n\ndef calculate_expected_steps(n, edges):\n    tree = defaultdict(list)\n    for (a, b) in edges:\n        tree[a].append(b)\n        tree[b].append(a)\n    bfs = deque([(-1, 1)])\n    depths = {}\n    while bfs:\n        (nid, depth) = bfs.popleft()\n        if nid in depths:\n            continue\n        depths[nid] = depth\n        for n2 in tree[nid]:\n            bfs.append((n2, depth + 1))\n    expected_steps = sum((1.0 / d for d in sorted(depths.values(), reverse=True)))\n    return expected_steps"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "bfs = deque([(1, 1)])",
      "mutated_line": "bfs = deque([(1, 2)])",
      "code": "from collections import defaultdict, deque\n\ndef calculate_expected_steps(n, edges):\n    tree = defaultdict(list)\n    for (a, b) in edges:\n        tree[a].append(b)\n        tree[b].append(a)\n    bfs = deque([(1, 2)])\n    depths = {}\n    while bfs:\n        (nid, depth) = bfs.popleft()\n        if nid in depths:\n            continue\n        depths[nid] = depth\n        for n2 in tree[nid]:\n            bfs.append((n2, depth + 1))\n    expected_steps = sum((1.0 / d for d in sorted(depths.values(), reverse=True)))\n    return expected_steps"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "bfs = deque([(1, 1)])",
      "mutated_line": "bfs = deque([(1, 0)])",
      "code": "from collections import defaultdict, deque\n\ndef calculate_expected_steps(n, edges):\n    tree = defaultdict(list)\n    for (a, b) in edges:\n        tree[a].append(b)\n        tree[b].append(a)\n    bfs = deque([(1, 0)])\n    depths = {}\n    while bfs:\n        (nid, depth) = bfs.popleft()\n        if nid in depths:\n            continue\n        depths[nid] = depth\n        for n2 in tree[nid]:\n            bfs.append((n2, depth + 1))\n    expected_steps = sum((1.0 / d for d in sorted(depths.values(), reverse=True)))\n    return expected_steps"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "bfs = deque([(1, 1)])",
      "mutated_line": "bfs = deque([(1, 0)])",
      "code": "from collections import defaultdict, deque\n\ndef calculate_expected_steps(n, edges):\n    tree = defaultdict(list)\n    for (a, b) in edges:\n        tree[a].append(b)\n        tree[b].append(a)\n    bfs = deque([(1, 0)])\n    depths = {}\n    while bfs:\n        (nid, depth) = bfs.popleft()\n        if nid in depths:\n            continue\n        depths[nid] = depth\n        for n2 in tree[nid]:\n            bfs.append((n2, depth + 1))\n    expected_steps = sum((1.0 / d for d in sorted(depths.values(), reverse=True)))\n    return expected_steps"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "bfs = deque([(1, 1)])",
      "mutated_line": "bfs = deque([(1, -1)])",
      "code": "from collections import defaultdict, deque\n\ndef calculate_expected_steps(n, edges):\n    tree = defaultdict(list)\n    for (a, b) in edges:\n        tree[a].append(b)\n        tree[b].append(a)\n    bfs = deque([(1, -1)])\n    depths = {}\n    while bfs:\n        (nid, depth) = bfs.popleft()\n        if nid in depths:\n            continue\n        depths[nid] = depth\n        for n2 in tree[nid]:\n            bfs.append((n2, depth + 1))\n    expected_steps = sum((1.0 / d for d in sorted(depths.values(), reverse=True)))\n    return expected_steps"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "expected_steps = sum((1.0 / d for d in sorted(depths.values(), reverse=True)))",
      "mutated_line": "expected_steps = sum((2.0 / d for d in sorted(depths.values(), reverse=True)))",
      "code": "from collections import defaultdict, deque\n\ndef calculate_expected_steps(n, edges):\n    tree = defaultdict(list)\n    for (a, b) in edges:\n        tree[a].append(b)\n        tree[b].append(a)\n    bfs = deque([(1, 1)])\n    depths = {}\n    while bfs:\n        (nid, depth) = bfs.popleft()\n        if nid in depths:\n            continue\n        depths[nid] = depth\n        for n2 in tree[nid]:\n            bfs.append((n2, depth + 1))\n    expected_steps = sum((2.0 / d for d in sorted(depths.values(), reverse=True)))\n    return expected_steps"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "expected_steps = sum((1.0 / d for d in sorted(depths.values(), reverse=True)))",
      "mutated_line": "expected_steps = sum((0.0 / d for d in sorted(depths.values(), reverse=True)))",
      "code": "from collections import defaultdict, deque\n\ndef calculate_expected_steps(n, edges):\n    tree = defaultdict(list)\n    for (a, b) in edges:\n        tree[a].append(b)\n        tree[b].append(a)\n    bfs = deque([(1, 1)])\n    depths = {}\n    while bfs:\n        (nid, depth) = bfs.popleft()\n        if nid in depths:\n            continue\n        depths[nid] = depth\n        for n2 in tree[nid]:\n            bfs.append((n2, depth + 1))\n    expected_steps = sum((0.0 / d for d in sorted(depths.values(), reverse=True)))\n    return expected_steps"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "expected_steps = sum((1.0 / d for d in sorted(depths.values(), reverse=True)))",
      "mutated_line": "expected_steps = sum((0 / d for d in sorted(depths.values(), reverse=True)))",
      "code": "from collections import defaultdict, deque\n\ndef calculate_expected_steps(n, edges):\n    tree = defaultdict(list)\n    for (a, b) in edges:\n        tree[a].append(b)\n        tree[b].append(a)\n    bfs = deque([(1, 1)])\n    depths = {}\n    while bfs:\n        (nid, depth) = bfs.popleft()\n        if nid in depths:\n            continue\n        depths[nid] = depth\n        for n2 in tree[nid]:\n            bfs.append((n2, depth + 1))\n    expected_steps = sum((0 / d for d in sorted(depths.values(), reverse=True)))\n    return expected_steps"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "expected_steps = sum((1.0 / d for d in sorted(depths.values(), reverse=True)))",
      "mutated_line": "expected_steps = sum((-1.0 / d for d in sorted(depths.values(), reverse=True)))",
      "code": "from collections import defaultdict, deque\n\ndef calculate_expected_steps(n, edges):\n    tree = defaultdict(list)\n    for (a, b) in edges:\n        tree[a].append(b)\n        tree[b].append(a)\n    bfs = deque([(1, 1)])\n    depths = {}\n    while bfs:\n        (nid, depth) = bfs.popleft()\n        if nid in depths:\n            continue\n        depths[nid] = depth\n        for n2 in tree[nid]:\n            bfs.append((n2, depth + 1))\n    expected_steps = sum((-1.0 / d for d in sorted(depths.values(), reverse=True)))\n    return expected_steps"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "bfs.append((n2, depth + 1))",
      "mutated_line": "bfs.append((n2, depth - 1))",
      "code": "from collections import defaultdict, deque\n\ndef calculate_expected_steps(n, edges):\n    tree = defaultdict(list)\n    for (a, b) in edges:\n        tree[a].append(b)\n        tree[b].append(a)\n    bfs = deque([(1, 1)])\n    depths = {}\n    while bfs:\n        (nid, depth) = bfs.popleft()\n        if nid in depths:\n            continue\n        depths[nid] = depth\n        for n2 in tree[nid]:\n            bfs.append((n2, depth - 1))\n    expected_steps = sum((1.0 / d for d in sorted(depths.values(), reverse=True)))\n    return expected_steps"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "bfs.append((n2, depth + 1))",
      "mutated_line": "bfs.append((n2, depth * 1))",
      "code": "from collections import defaultdict, deque\n\ndef calculate_expected_steps(n, edges):\n    tree = defaultdict(list)\n    for (a, b) in edges:\n        tree[a].append(b)\n        tree[b].append(a)\n    bfs = deque([(1, 1)])\n    depths = {}\n    while bfs:\n        (nid, depth) = bfs.popleft()\n        if nid in depths:\n            continue\n        depths[nid] = depth\n        for n2 in tree[nid]:\n            bfs.append((n2, depth * 1))\n    expected_steps = sum((1.0 / d for d in sorted(depths.values(), reverse=True)))\n    return expected_steps"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "bfs.append((n2, depth + 1))",
      "mutated_line": "bfs.append((n2, depth + 2))",
      "code": "from collections import defaultdict, deque\n\ndef calculate_expected_steps(n, edges):\n    tree = defaultdict(list)\n    for (a, b) in edges:\n        tree[a].append(b)\n        tree[b].append(a)\n    bfs = deque([(1, 1)])\n    depths = {}\n    while bfs:\n        (nid, depth) = bfs.popleft()\n        if nid in depths:\n            continue\n        depths[nid] = depth\n        for n2 in tree[nid]:\n            bfs.append((n2, depth + 2))\n    expected_steps = sum((1.0 / d for d in sorted(depths.values(), reverse=True)))\n    return expected_steps"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "bfs.append((n2, depth + 1))",
      "mutated_line": "bfs.append((n2, depth + 0))",
      "code": "from collections import defaultdict, deque\n\ndef calculate_expected_steps(n, edges):\n    tree = defaultdict(list)\n    for (a, b) in edges:\n        tree[a].append(b)\n        tree[b].append(a)\n    bfs = deque([(1, 1)])\n    depths = {}\n    while bfs:\n        (nid, depth) = bfs.popleft()\n        if nid in depths:\n            continue\n        depths[nid] = depth\n        for n2 in tree[nid]:\n            bfs.append((n2, depth + 0))\n    expected_steps = sum((1.0 / d for d in sorted(depths.values(), reverse=True)))\n    return expected_steps"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "bfs.append((n2, depth + 1))",
      "mutated_line": "bfs.append((n2, depth + 0))",
      "code": "from collections import defaultdict, deque\n\ndef calculate_expected_steps(n, edges):\n    tree = defaultdict(list)\n    for (a, b) in edges:\n        tree[a].append(b)\n        tree[b].append(a)\n    bfs = deque([(1, 1)])\n    depths = {}\n    while bfs:\n        (nid, depth) = bfs.popleft()\n        if nid in depths:\n            continue\n        depths[nid] = depth\n        for n2 in tree[nid]:\n            bfs.append((n2, depth + 0))\n    expected_steps = sum((1.0 / d for d in sorted(depths.values(), reverse=True)))\n    return expected_steps"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "bfs.append((n2, depth + 1))",
      "mutated_line": "bfs.append((n2, depth + -1))",
      "code": "from collections import defaultdict, deque\n\ndef calculate_expected_steps(n, edges):\n    tree = defaultdict(list)\n    for (a, b) in edges:\n        tree[a].append(b)\n        tree[b].append(a)\n    bfs = deque([(1, 1)])\n    depths = {}\n    while bfs:\n        (nid, depth) = bfs.popleft()\n        if nid in depths:\n            continue\n        depths[nid] = depth\n        for n2 in tree[nid]:\n            bfs.append((n2, depth + -1))\n    expected_steps = sum((1.0 / d for d in sorted(depths.values(), reverse=True)))\n    return expected_steps"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "expected_steps = sum((1.0 / d for d in sorted(depths.values(), reverse=True)))",
      "mutated_line": "expected_steps = sum((1.0 / d for d in sorted(depths.values(), reverse=False)))",
      "code": "from collections import defaultdict, deque\n\ndef calculate_expected_steps(n, edges):\n    tree = defaultdict(list)\n    for (a, b) in edges:\n        tree[a].append(b)\n        tree[b].append(a)\n    bfs = deque([(1, 1)])\n    depths = {}\n    while bfs:\n        (nid, depth) = bfs.popleft()\n        if nid in depths:\n            continue\n        depths[nid] = depth\n        for n2 in tree[nid]:\n            bfs.append((n2, depth + 1))\n    expected_steps = sum((1.0 / d for d in sorted(depths.values(), reverse=False)))\n    return expected_steps"
    }
  ]
}