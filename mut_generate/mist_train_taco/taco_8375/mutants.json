{
  "task_id": "taco_8375",
  "entry_point": "build_trees_from_sequence",
  "mutant_count": 78,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "ambiguous = False",
      "mutated_line": "ambiguous = True",
      "code": "def build_trees_from_sequence(h, sequence):\n    p1 = [0]\n    p2 = [0]\n    ambiguous = True\n    cur_index = 1\n    for i in range(1, h + 1):\n        if i > 0 and sequence[i - 1] > 1 and (sequence[i] > 1):\n            ambiguous = True\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index - 1] + [cur_index] * (sequence[i] - 1))\n        else:\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index] * sequence[i])\n        cur_index += sequence[i]\n    if ambiguous:\n        return ('ambiguous', p1, p2)\n    else:\n        return 'perfect'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "cur_index = 1",
      "mutated_line": "cur_index = 2",
      "code": "def build_trees_from_sequence(h, sequence):\n    p1 = [0]\n    p2 = [0]\n    ambiguous = False\n    cur_index = 2\n    for i in range(1, h + 1):\n        if i > 0 and sequence[i - 1] > 1 and (sequence[i] > 1):\n            ambiguous = True\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index - 1] + [cur_index] * (sequence[i] - 1))\n        else:\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index] * sequence[i])\n        cur_index += sequence[i]\n    if ambiguous:\n        return ('ambiguous', p1, p2)\n    else:\n        return 'perfect'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "cur_index = 1",
      "mutated_line": "cur_index = 0",
      "code": "def build_trees_from_sequence(h, sequence):\n    p1 = [0]\n    p2 = [0]\n    ambiguous = False\n    cur_index = 0\n    for i in range(1, h + 1):\n        if i > 0 and sequence[i - 1] > 1 and (sequence[i] > 1):\n            ambiguous = True\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index - 1] + [cur_index] * (sequence[i] - 1))\n        else:\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index] * sequence[i])\n        cur_index += sequence[i]\n    if ambiguous:\n        return ('ambiguous', p1, p2)\n    else:\n        return 'perfect'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "cur_index = 1",
      "mutated_line": "cur_index = 0",
      "code": "def build_trees_from_sequence(h, sequence):\n    p1 = [0]\n    p2 = [0]\n    ambiguous = False\n    cur_index = 0\n    for i in range(1, h + 1):\n        if i > 0 and sequence[i - 1] > 1 and (sequence[i] > 1):\n            ambiguous = True\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index - 1] + [cur_index] * (sequence[i] - 1))\n        else:\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index] * sequence[i])\n        cur_index += sequence[i]\n    if ambiguous:\n        return ('ambiguous', p1, p2)\n    else:\n        return 'perfect'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "cur_index = 1",
      "mutated_line": "cur_index = -1",
      "code": "def build_trees_from_sequence(h, sequence):\n    p1 = [0]\n    p2 = [0]\n    ambiguous = False\n    cur_index = -1\n    for i in range(1, h + 1):\n        if i > 0 and sequence[i - 1] > 1 and (sequence[i] > 1):\n            ambiguous = True\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index - 1] + [cur_index] * (sequence[i] - 1))\n        else:\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index] * sequence[i])\n        cur_index += sequence[i]\n    if ambiguous:\n        return ('ambiguous', p1, p2)\n    else:\n        return 'perfect'"
    },
    {
      "operator": "ASR",
      "lineno": 15,
      "original_line": "cur_index += sequence[i]",
      "mutated_line": "cur_index -= sequence[i]",
      "code": "def build_trees_from_sequence(h, sequence):\n    p1 = [0]\n    p2 = [0]\n    ambiguous = False\n    cur_index = 1\n    for i in range(1, h + 1):\n        if i > 0 and sequence[i - 1] > 1 and (sequence[i] > 1):\n            ambiguous = True\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index - 1] + [cur_index] * (sequence[i] - 1))\n        else:\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index] * sequence[i])\n        cur_index -= sequence[i]\n    if ambiguous:\n        return ('ambiguous', p1, p2)\n    else:\n        return 'perfect'"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "p1 = [0]",
      "mutated_line": "p1 = [1]",
      "code": "def build_trees_from_sequence(h, sequence):\n    p1 = [1]\n    p2 = [0]\n    ambiguous = False\n    cur_index = 1\n    for i in range(1, h + 1):\n        if i > 0 and sequence[i - 1] > 1 and (sequence[i] > 1):\n            ambiguous = True\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index - 1] + [cur_index] * (sequence[i] - 1))\n        else:\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index] * sequence[i])\n        cur_index += sequence[i]\n    if ambiguous:\n        return ('ambiguous', p1, p2)\n    else:\n        return 'perfect'"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "p1 = [0]",
      "mutated_line": "p1 = [-1]",
      "code": "def build_trees_from_sequence(h, sequence):\n    p1 = [-1]\n    p2 = [0]\n    ambiguous = False\n    cur_index = 1\n    for i in range(1, h + 1):\n        if i > 0 and sequence[i - 1] > 1 and (sequence[i] > 1):\n            ambiguous = True\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index - 1] + [cur_index] * (sequence[i] - 1))\n        else:\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index] * sequence[i])\n        cur_index += sequence[i]\n    if ambiguous:\n        return ('ambiguous', p1, p2)\n    else:\n        return 'perfect'"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "p1 = [0]",
      "mutated_line": "p1 = [1]",
      "code": "def build_trees_from_sequence(h, sequence):\n    p1 = [1]\n    p2 = [0]\n    ambiguous = False\n    cur_index = 1\n    for i in range(1, h + 1):\n        if i > 0 and sequence[i - 1] > 1 and (sequence[i] > 1):\n            ambiguous = True\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index - 1] + [cur_index] * (sequence[i] - 1))\n        else:\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index] * sequence[i])\n        cur_index += sequence[i]\n    if ambiguous:\n        return ('ambiguous', p1, p2)\n    else:\n        return 'perfect'"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "p2 = [0]",
      "mutated_line": "p2 = [1]",
      "code": "def build_trees_from_sequence(h, sequence):\n    p1 = [0]\n    p2 = [1]\n    ambiguous = False\n    cur_index = 1\n    for i in range(1, h + 1):\n        if i > 0 and sequence[i - 1] > 1 and (sequence[i] > 1):\n            ambiguous = True\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index - 1] + [cur_index] * (sequence[i] - 1))\n        else:\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index] * sequence[i])\n        cur_index += sequence[i]\n    if ambiguous:\n        return ('ambiguous', p1, p2)\n    else:\n        return 'perfect'"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "p2 = [0]",
      "mutated_line": "p2 = [-1]",
      "code": "def build_trees_from_sequence(h, sequence):\n    p1 = [0]\n    p2 = [-1]\n    ambiguous = False\n    cur_index = 1\n    for i in range(1, h + 1):\n        if i > 0 and sequence[i - 1] > 1 and (sequence[i] > 1):\n            ambiguous = True\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index - 1] + [cur_index] * (sequence[i] - 1))\n        else:\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index] * sequence[i])\n        cur_index += sequence[i]\n    if ambiguous:\n        return ('ambiguous', p1, p2)\n    else:\n        return 'perfect'"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "p2 = [0]",
      "mutated_line": "p2 = [1]",
      "code": "def build_trees_from_sequence(h, sequence):\n    p1 = [0]\n    p2 = [1]\n    ambiguous = False\n    cur_index = 1\n    for i in range(1, h + 1):\n        if i > 0 and sequence[i - 1] > 1 and (sequence[i] > 1):\n            ambiguous = True\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index - 1] + [cur_index] * (sequence[i] - 1))\n        else:\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index] * sequence[i])\n        cur_index += sequence[i]\n    if ambiguous:\n        return ('ambiguous', p1, p2)\n    else:\n        return 'perfect'"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(1, h + 1):",
      "mutated_line": "if i > 0 and sequence[i - 1] > 1 and (sequence[i] > 1):",
      "code": "def build_trees_from_sequence(h, sequence):\n    p1 = [0]\n    p2 = [0]\n    ambiguous = False\n    cur_index = 1\n    for i in range(2, h + 1):\n        if i > 0 and sequence[i - 1] > 1 and (sequence[i] > 1):\n            ambiguous = True\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index - 1] + [cur_index] * (sequence[i] - 1))\n        else:\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index] * sequence[i])\n        cur_index += sequence[i]\n    if ambiguous:\n        return ('ambiguous', p1, p2)\n    else:\n        return 'perfect'"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(1, h + 1):",
      "mutated_line": "if i > 0 and sequence[i - 1] > 1 and (sequence[i] > 1):",
      "code": "def build_trees_from_sequence(h, sequence):\n    p1 = [0]\n    p2 = [0]\n    ambiguous = False\n    cur_index = 1\n    for i in range(0, h + 1):\n        if i > 0 and sequence[i - 1] > 1 and (sequence[i] > 1):\n            ambiguous = True\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index - 1] + [cur_index] * (sequence[i] - 1))\n        else:\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index] * sequence[i])\n        cur_index += sequence[i]\n    if ambiguous:\n        return ('ambiguous', p1, p2)\n    else:\n        return 'perfect'"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(1, h + 1):",
      "mutated_line": "if i > 0 and sequence[i - 1] > 1 and (sequence[i] > 1):",
      "code": "def build_trees_from_sequence(h, sequence):\n    p1 = [0]\n    p2 = [0]\n    ambiguous = False\n    cur_index = 1\n    for i in range(0, h + 1):\n        if i > 0 and sequence[i - 1] > 1 and (sequence[i] > 1):\n            ambiguous = True\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index - 1] + [cur_index] * (sequence[i] - 1))\n        else:\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index] * sequence[i])\n        cur_index += sequence[i]\n    if ambiguous:\n        return ('ambiguous', p1, p2)\n    else:\n        return 'perfect'"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(1, h + 1):",
      "mutated_line": "if i > 0 and sequence[i - 1] > 1 and (sequence[i] > 1):",
      "code": "def build_trees_from_sequence(h, sequence):\n    p1 = [0]\n    p2 = [0]\n    ambiguous = False\n    cur_index = 1\n    for i in range(-1, h + 1):\n        if i > 0 and sequence[i - 1] > 1 and (sequence[i] > 1):\n            ambiguous = True\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index - 1] + [cur_index] * (sequence[i] - 1))\n        else:\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index] * sequence[i])\n        cur_index += sequence[i]\n    if ambiguous:\n        return ('ambiguous', p1, p2)\n    else:\n        return 'perfect'"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "for i in range(1, h + 1):",
      "mutated_line": "if i > 0 and sequence[i - 1] > 1 and (sequence[i] > 1):",
      "code": "def build_trees_from_sequence(h, sequence):\n    p1 = [0]\n    p2 = [0]\n    ambiguous = False\n    cur_index = 1\n    for i in range(1, h - 1):\n        if i > 0 and sequence[i - 1] > 1 and (sequence[i] > 1):\n            ambiguous = True\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index - 1] + [cur_index] * (sequence[i] - 1))\n        else:\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index] * sequence[i])\n        cur_index += sequence[i]\n    if ambiguous:\n        return ('ambiguous', p1, p2)\n    else:\n        return 'perfect'"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "for i in range(1, h + 1):",
      "mutated_line": "if i > 0 and sequence[i - 1] > 1 and (sequence[i] > 1):",
      "code": "def build_trees_from_sequence(h, sequence):\n    p1 = [0]\n    p2 = [0]\n    ambiguous = False\n    cur_index = 1\n    for i in range(1, h * 1):\n        if i > 0 and sequence[i - 1] > 1 and (sequence[i] > 1):\n            ambiguous = True\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index - 1] + [cur_index] * (sequence[i] - 1))\n        else:\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index] * sequence[i])\n        cur_index += sequence[i]\n    if ambiguous:\n        return ('ambiguous', p1, p2)\n    else:\n        return 'perfect'"
    },
    {
      "operator": "LCR",
      "lineno": 8,
      "original_line": "if i > 0 and sequence[i - 1] > 1 and sequence[i] > 1:",
      "mutated_line": "if i > 0 or sequence[i - 1] > 1 or sequence[i] > 1:",
      "code": "def build_trees_from_sequence(h, sequence):\n    p1 = [0]\n    p2 = [0]\n    ambiguous = False\n    cur_index = 1\n    for i in range(1, h + 1):\n        if i > 0 or sequence[i - 1] > 1 or sequence[i] > 1:\n            ambiguous = True\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index - 1] + [cur_index] * (sequence[i] - 1))\n        else:\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index] * sequence[i])\n        cur_index += sequence[i]\n    if ambiguous:\n        return ('ambiguous', p1, p2)\n    else:\n        return 'perfect'"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return \"perfect\"",
      "mutated_line": "return ''",
      "code": "def build_trees_from_sequence(h, sequence):\n    p1 = [0]\n    p2 = [0]\n    ambiguous = False\n    cur_index = 1\n    for i in range(1, h + 1):\n        if i > 0 and sequence[i - 1] > 1 and (sequence[i] > 1):\n            ambiguous = True\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index - 1] + [cur_index] * (sequence[i] - 1))\n        else:\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index] * sequence[i])\n        cur_index += sequence[i]\n    if ambiguous:\n        return ('ambiguous', p1, p2)\n    else:\n        return ''"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(1, h + 1):",
      "mutated_line": "if i > 0 and sequence[i - 1] > 1 and (sequence[i] > 1):",
      "code": "def build_trees_from_sequence(h, sequence):\n    p1 = [0]\n    p2 = [0]\n    ambiguous = False\n    cur_index = 1\n    for i in range(1, h + 2):\n        if i > 0 and sequence[i - 1] > 1 and (sequence[i] > 1):\n            ambiguous = True\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index - 1] + [cur_index] * (sequence[i] - 1))\n        else:\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index] * sequence[i])\n        cur_index += sequence[i]\n    if ambiguous:\n        return ('ambiguous', p1, p2)\n    else:\n        return 'perfect'"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(1, h + 1):",
      "mutated_line": "if i > 0 and sequence[i - 1] > 1 and (sequence[i] > 1):",
      "code": "def build_trees_from_sequence(h, sequence):\n    p1 = [0]\n    p2 = [0]\n    ambiguous = False\n    cur_index = 1\n    for i in range(1, h + 0):\n        if i > 0 and sequence[i - 1] > 1 and (sequence[i] > 1):\n            ambiguous = True\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index - 1] + [cur_index] * (sequence[i] - 1))\n        else:\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index] * sequence[i])\n        cur_index += sequence[i]\n    if ambiguous:\n        return ('ambiguous', p1, p2)\n    else:\n        return 'perfect'"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(1, h + 1):",
      "mutated_line": "if i > 0 and sequence[i - 1] > 1 and (sequence[i] > 1):",
      "code": "def build_trees_from_sequence(h, sequence):\n    p1 = [0]\n    p2 = [0]\n    ambiguous = False\n    cur_index = 1\n    for i in range(1, h + 0):\n        if i > 0 and sequence[i - 1] > 1 and (sequence[i] > 1):\n            ambiguous = True\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index - 1] + [cur_index] * (sequence[i] - 1))\n        else:\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index] * sequence[i])\n        cur_index += sequence[i]\n    if ambiguous:\n        return ('ambiguous', p1, p2)\n    else:\n        return 'perfect'"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(1, h + 1):",
      "mutated_line": "if i > 0 and sequence[i - 1] > 1 and (sequence[i] > 1):",
      "code": "def build_trees_from_sequence(h, sequence):\n    p1 = [0]\n    p2 = [0]\n    ambiguous = False\n    cur_index = 1\n    for i in range(1, h + -1):\n        if i > 0 and sequence[i - 1] > 1 and (sequence[i] > 1):\n            ambiguous = True\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index - 1] + [cur_index] * (sequence[i] - 1))\n        else:\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index] * sequence[i])\n        cur_index += sequence[i]\n    if ambiguous:\n        return ('ambiguous', p1, p2)\n    else:\n        return 'perfect'"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if i > 0 and sequence[i - 1] > 1 and sequence[i] > 1:",
      "mutated_line": "if i >= 0 and sequence[i - 1] > 1 and (sequence[i] > 1):",
      "code": "def build_trees_from_sequence(h, sequence):\n    p1 = [0]\n    p2 = [0]\n    ambiguous = False\n    cur_index = 1\n    for i in range(1, h + 1):\n        if i >= 0 and sequence[i - 1] > 1 and (sequence[i] > 1):\n            ambiguous = True\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index - 1] + [cur_index] * (sequence[i] - 1))\n        else:\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index] * sequence[i])\n        cur_index += sequence[i]\n    if ambiguous:\n        return ('ambiguous', p1, p2)\n    else:\n        return 'perfect'"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if i > 0 and sequence[i - 1] > 1 and sequence[i] > 1:",
      "mutated_line": "if i <= 0 and sequence[i - 1] > 1 and (sequence[i] > 1):",
      "code": "def build_trees_from_sequence(h, sequence):\n    p1 = [0]\n    p2 = [0]\n    ambiguous = False\n    cur_index = 1\n    for i in range(1, h + 1):\n        if i <= 0 and sequence[i - 1] > 1 and (sequence[i] > 1):\n            ambiguous = True\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index - 1] + [cur_index] * (sequence[i] - 1))\n        else:\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index] * sequence[i])\n        cur_index += sequence[i]\n    if ambiguous:\n        return ('ambiguous', p1, p2)\n    else:\n        return 'perfect'"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if i > 0 and sequence[i - 1] > 1 and sequence[i] > 1:",
      "mutated_line": "if i != 0 and sequence[i - 1] > 1 and (sequence[i] > 1):",
      "code": "def build_trees_from_sequence(h, sequence):\n    p1 = [0]\n    p2 = [0]\n    ambiguous = False\n    cur_index = 1\n    for i in range(1, h + 1):\n        if i != 0 and sequence[i - 1] > 1 and (sequence[i] > 1):\n            ambiguous = True\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index - 1] + [cur_index] * (sequence[i] - 1))\n        else:\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index] * sequence[i])\n        cur_index += sequence[i]\n    if ambiguous:\n        return ('ambiguous', p1, p2)\n    else:\n        return 'perfect'"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if i > 0 and sequence[i - 1] > 1 and sequence[i] > 1:",
      "mutated_line": "if i > 0 and sequence[i - 1] >= 1 and (sequence[i] > 1):",
      "code": "def build_trees_from_sequence(h, sequence):\n    p1 = [0]\n    p2 = [0]\n    ambiguous = False\n    cur_index = 1\n    for i in range(1, h + 1):\n        if i > 0 and sequence[i - 1] >= 1 and (sequence[i] > 1):\n            ambiguous = True\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index - 1] + [cur_index] * (sequence[i] - 1))\n        else:\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index] * sequence[i])\n        cur_index += sequence[i]\n    if ambiguous:\n        return ('ambiguous', p1, p2)\n    else:\n        return 'perfect'"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if i > 0 and sequence[i - 1] > 1 and sequence[i] > 1:",
      "mutated_line": "if i > 0 and sequence[i - 1] <= 1 and (sequence[i] > 1):",
      "code": "def build_trees_from_sequence(h, sequence):\n    p1 = [0]\n    p2 = [0]\n    ambiguous = False\n    cur_index = 1\n    for i in range(1, h + 1):\n        if i > 0 and sequence[i - 1] <= 1 and (sequence[i] > 1):\n            ambiguous = True\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index - 1] + [cur_index] * (sequence[i] - 1))\n        else:\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index] * sequence[i])\n        cur_index += sequence[i]\n    if ambiguous:\n        return ('ambiguous', p1, p2)\n    else:\n        return 'perfect'"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if i > 0 and sequence[i - 1] > 1 and sequence[i] > 1:",
      "mutated_line": "if i > 0 and sequence[i - 1] != 1 and (sequence[i] > 1):",
      "code": "def build_trees_from_sequence(h, sequence):\n    p1 = [0]\n    p2 = [0]\n    ambiguous = False\n    cur_index = 1\n    for i in range(1, h + 1):\n        if i > 0 and sequence[i - 1] != 1 and (sequence[i] > 1):\n            ambiguous = True\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index - 1] + [cur_index] * (sequence[i] - 1))\n        else:\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index] * sequence[i])\n        cur_index += sequence[i]\n    if ambiguous:\n        return ('ambiguous', p1, p2)\n    else:\n        return 'perfect'"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if i > 0 and sequence[i - 1] > 1 and sequence[i] > 1:",
      "mutated_line": "if i > 0 and sequence[i - 1] > 1 and (sequence[i] >= 1):",
      "code": "def build_trees_from_sequence(h, sequence):\n    p1 = [0]\n    p2 = [0]\n    ambiguous = False\n    cur_index = 1\n    for i in range(1, h + 1):\n        if i > 0 and sequence[i - 1] > 1 and (sequence[i] >= 1):\n            ambiguous = True\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index - 1] + [cur_index] * (sequence[i] - 1))\n        else:\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index] * sequence[i])\n        cur_index += sequence[i]\n    if ambiguous:\n        return ('ambiguous', p1, p2)\n    else:\n        return 'perfect'"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if i > 0 and sequence[i - 1] > 1 and sequence[i] > 1:",
      "mutated_line": "if i > 0 and sequence[i - 1] > 1 and (sequence[i] <= 1):",
      "code": "def build_trees_from_sequence(h, sequence):\n    p1 = [0]\n    p2 = [0]\n    ambiguous = False\n    cur_index = 1\n    for i in range(1, h + 1):\n        if i > 0 and sequence[i - 1] > 1 and (sequence[i] <= 1):\n            ambiguous = True\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index - 1] + [cur_index] * (sequence[i] - 1))\n        else:\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index] * sequence[i])\n        cur_index += sequence[i]\n    if ambiguous:\n        return ('ambiguous', p1, p2)\n    else:\n        return 'perfect'"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if i > 0 and sequence[i - 1] > 1 and sequence[i] > 1:",
      "mutated_line": "if i > 0 and sequence[i - 1] > 1 and (sequence[i] != 1):",
      "code": "def build_trees_from_sequence(h, sequence):\n    p1 = [0]\n    p2 = [0]\n    ambiguous = False\n    cur_index = 1\n    for i in range(1, h + 1):\n        if i > 0 and sequence[i - 1] > 1 and (sequence[i] != 1):\n            ambiguous = True\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index - 1] + [cur_index] * (sequence[i] - 1))\n        else:\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index] * sequence[i])\n        cur_index += sequence[i]\n    if ambiguous:\n        return ('ambiguous', p1, p2)\n    else:\n        return 'perfect'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "ambiguous = True",
      "mutated_line": "ambiguous = False",
      "code": "def build_trees_from_sequence(h, sequence):\n    p1 = [0]\n    p2 = [0]\n    ambiguous = False\n    cur_index = 1\n    for i in range(1, h + 1):\n        if i > 0 and sequence[i - 1] > 1 and (sequence[i] > 1):\n            ambiguous = False\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index - 1] + [cur_index] * (sequence[i] - 1))\n        else:\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index] * sequence[i])\n        cur_index += sequence[i]\n    if ambiguous:\n        return ('ambiguous', p1, p2)\n    else:\n        return 'perfect'"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return \"ambiguous\", p1, p2",
      "mutated_line": "return ('', p1, p2)",
      "code": "def build_trees_from_sequence(h, sequence):\n    p1 = [0]\n    p2 = [0]\n    ambiguous = False\n    cur_index = 1\n    for i in range(1, h + 1):\n        if i > 0 and sequence[i - 1] > 1 and (sequence[i] > 1):\n            ambiguous = True\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index - 1] + [cur_index] * (sequence[i] - 1))\n        else:\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index] * sequence[i])\n        cur_index += sequence[i]\n    if ambiguous:\n        return ('', p1, p2)\n    else:\n        return 'perfect'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if i > 0 and sequence[i - 1] > 1 and sequence[i] > 1:",
      "mutated_line": "if i > 1 and sequence[i - 1] > 1 and (sequence[i] > 1):",
      "code": "def build_trees_from_sequence(h, sequence):\n    p1 = [0]\n    p2 = [0]\n    ambiguous = False\n    cur_index = 1\n    for i in range(1, h + 1):\n        if i > 1 and sequence[i - 1] > 1 and (sequence[i] > 1):\n            ambiguous = True\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index - 1] + [cur_index] * (sequence[i] - 1))\n        else:\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index] * sequence[i])\n        cur_index += sequence[i]\n    if ambiguous:\n        return ('ambiguous', p1, p2)\n    else:\n        return 'perfect'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if i > 0 and sequence[i - 1] > 1 and sequence[i] > 1:",
      "mutated_line": "if i > -1 and sequence[i - 1] > 1 and (sequence[i] > 1):",
      "code": "def build_trees_from_sequence(h, sequence):\n    p1 = [0]\n    p2 = [0]\n    ambiguous = False\n    cur_index = 1\n    for i in range(1, h + 1):\n        if i > -1 and sequence[i - 1] > 1 and (sequence[i] > 1):\n            ambiguous = True\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index - 1] + [cur_index] * (sequence[i] - 1))\n        else:\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index] * sequence[i])\n        cur_index += sequence[i]\n    if ambiguous:\n        return ('ambiguous', p1, p2)\n    else:\n        return 'perfect'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if i > 0 and sequence[i - 1] > 1 and sequence[i] > 1:",
      "mutated_line": "if i > 1 and sequence[i - 1] > 1 and (sequence[i] > 1):",
      "code": "def build_trees_from_sequence(h, sequence):\n    p1 = [0]\n    p2 = [0]\n    ambiguous = False\n    cur_index = 1\n    for i in range(1, h + 1):\n        if i > 1 and sequence[i - 1] > 1 and (sequence[i] > 1):\n            ambiguous = True\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index - 1] + [cur_index] * (sequence[i] - 1))\n        else:\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index] * sequence[i])\n        cur_index += sequence[i]\n    if ambiguous:\n        return ('ambiguous', p1, p2)\n    else:\n        return 'perfect'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if i > 0 and sequence[i - 1] > 1 and sequence[i] > 1:",
      "mutated_line": "if i > 0 and sequence[i - 1] > 2 and (sequence[i] > 1):",
      "code": "def build_trees_from_sequence(h, sequence):\n    p1 = [0]\n    p2 = [0]\n    ambiguous = False\n    cur_index = 1\n    for i in range(1, h + 1):\n        if i > 0 and sequence[i - 1] > 2 and (sequence[i] > 1):\n            ambiguous = True\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index - 1] + [cur_index] * (sequence[i] - 1))\n        else:\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index] * sequence[i])\n        cur_index += sequence[i]\n    if ambiguous:\n        return ('ambiguous', p1, p2)\n    else:\n        return 'perfect'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if i > 0 and sequence[i - 1] > 1 and sequence[i] > 1:",
      "mutated_line": "if i > 0 and sequence[i - 1] > 0 and (sequence[i] > 1):",
      "code": "def build_trees_from_sequence(h, sequence):\n    p1 = [0]\n    p2 = [0]\n    ambiguous = False\n    cur_index = 1\n    for i in range(1, h + 1):\n        if i > 0 and sequence[i - 1] > 0 and (sequence[i] > 1):\n            ambiguous = True\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index - 1] + [cur_index] * (sequence[i] - 1))\n        else:\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index] * sequence[i])\n        cur_index += sequence[i]\n    if ambiguous:\n        return ('ambiguous', p1, p2)\n    else:\n        return 'perfect'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if i > 0 and sequence[i - 1] > 1 and sequence[i] > 1:",
      "mutated_line": "if i > 0 and sequence[i - 1] > 0 and (sequence[i] > 1):",
      "code": "def build_trees_from_sequence(h, sequence):\n    p1 = [0]\n    p2 = [0]\n    ambiguous = False\n    cur_index = 1\n    for i in range(1, h + 1):\n        if i > 0 and sequence[i - 1] > 0 and (sequence[i] > 1):\n            ambiguous = True\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index - 1] + [cur_index] * (sequence[i] - 1))\n        else:\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index] * sequence[i])\n        cur_index += sequence[i]\n    if ambiguous:\n        return ('ambiguous', p1, p2)\n    else:\n        return 'perfect'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if i > 0 and sequence[i - 1] > 1 and sequence[i] > 1:",
      "mutated_line": "if i > 0 and sequence[i - 1] > -1 and (sequence[i] > 1):",
      "code": "def build_trees_from_sequence(h, sequence):\n    p1 = [0]\n    p2 = [0]\n    ambiguous = False\n    cur_index = 1\n    for i in range(1, h + 1):\n        if i > 0 and sequence[i - 1] > -1 and (sequence[i] > 1):\n            ambiguous = True\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index - 1] + [cur_index] * (sequence[i] - 1))\n        else:\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index] * sequence[i])\n        cur_index += sequence[i]\n    if ambiguous:\n        return ('ambiguous', p1, p2)\n    else:\n        return 'perfect'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if i > 0 and sequence[i - 1] > 1 and sequence[i] > 1:",
      "mutated_line": "if i > 0 and sequence[i - 1] > 1 and (sequence[i] > 2):",
      "code": "def build_trees_from_sequence(h, sequence):\n    p1 = [0]\n    p2 = [0]\n    ambiguous = False\n    cur_index = 1\n    for i in range(1, h + 1):\n        if i > 0 and sequence[i - 1] > 1 and (sequence[i] > 2):\n            ambiguous = True\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index - 1] + [cur_index] * (sequence[i] - 1))\n        else:\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index] * sequence[i])\n        cur_index += sequence[i]\n    if ambiguous:\n        return ('ambiguous', p1, p2)\n    else:\n        return 'perfect'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if i > 0 and sequence[i - 1] > 1 and sequence[i] > 1:",
      "mutated_line": "if i > 0 and sequence[i - 1] > 1 and (sequence[i] > 0):",
      "code": "def build_trees_from_sequence(h, sequence):\n    p1 = [0]\n    p2 = [0]\n    ambiguous = False\n    cur_index = 1\n    for i in range(1, h + 1):\n        if i > 0 and sequence[i - 1] > 1 and (sequence[i] > 0):\n            ambiguous = True\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index - 1] + [cur_index] * (sequence[i] - 1))\n        else:\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index] * sequence[i])\n        cur_index += sequence[i]\n    if ambiguous:\n        return ('ambiguous', p1, p2)\n    else:\n        return 'perfect'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if i > 0 and sequence[i - 1] > 1 and sequence[i] > 1:",
      "mutated_line": "if i > 0 and sequence[i - 1] > 1 and (sequence[i] > 0):",
      "code": "def build_trees_from_sequence(h, sequence):\n    p1 = [0]\n    p2 = [0]\n    ambiguous = False\n    cur_index = 1\n    for i in range(1, h + 1):\n        if i > 0 and sequence[i - 1] > 1 and (sequence[i] > 0):\n            ambiguous = True\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index - 1] + [cur_index] * (sequence[i] - 1))\n        else:\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index] * sequence[i])\n        cur_index += sequence[i]\n    if ambiguous:\n        return ('ambiguous', p1, p2)\n    else:\n        return 'perfect'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if i > 0 and sequence[i - 1] > 1 and sequence[i] > 1:",
      "mutated_line": "if i > 0 and sequence[i - 1] > 1 and (sequence[i] > -1):",
      "code": "def build_trees_from_sequence(h, sequence):\n    p1 = [0]\n    p2 = [0]\n    ambiguous = False\n    cur_index = 1\n    for i in range(1, h + 1):\n        if i > 0 and sequence[i - 1] > 1 and (sequence[i] > -1):\n            ambiguous = True\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index - 1] + [cur_index] * (sequence[i] - 1))\n        else:\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index] * sequence[i])\n        cur_index += sequence[i]\n    if ambiguous:\n        return ('ambiguous', p1, p2)\n    else:\n        return 'perfect'"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "p1.extend([cur_index] * sequence[i])",
      "mutated_line": "p1.extend([cur_index] / sequence[i])",
      "code": "def build_trees_from_sequence(h, sequence):\n    p1 = [0]\n    p2 = [0]\n    ambiguous = False\n    cur_index = 1\n    for i in range(1, h + 1):\n        if i > 0 and sequence[i - 1] > 1 and (sequence[i] > 1):\n            ambiguous = True\n            p1.extend([cur_index] / sequence[i])\n            p2.extend([cur_index - 1] + [cur_index] * (sequence[i] - 1))\n        else:\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index] * sequence[i])\n        cur_index += sequence[i]\n    if ambiguous:\n        return ('ambiguous', p1, p2)\n    else:\n        return 'perfect'"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "p1.extend([cur_index] * sequence[i])",
      "mutated_line": "p1.extend([cur_index] + sequence[i])",
      "code": "def build_trees_from_sequence(h, sequence):\n    p1 = [0]\n    p2 = [0]\n    ambiguous = False\n    cur_index = 1\n    for i in range(1, h + 1):\n        if i > 0 and sequence[i - 1] > 1 and (sequence[i] > 1):\n            ambiguous = True\n            p1.extend([cur_index] + sequence[i])\n            p2.extend([cur_index - 1] + [cur_index] * (sequence[i] - 1))\n        else:\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index] * sequence[i])\n        cur_index += sequence[i]\n    if ambiguous:\n        return ('ambiguous', p1, p2)\n    else:\n        return 'perfect'"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "p1.extend([cur_index] * sequence[i])",
      "mutated_line": "p1.extend([cur_index] ** sequence[i])",
      "code": "def build_trees_from_sequence(h, sequence):\n    p1 = [0]\n    p2 = [0]\n    ambiguous = False\n    cur_index = 1\n    for i in range(1, h + 1):\n        if i > 0 and sequence[i - 1] > 1 and (sequence[i] > 1):\n            ambiguous = True\n            p1.extend([cur_index] ** sequence[i])\n            p2.extend([cur_index - 1] + [cur_index] * (sequence[i] - 1))\n        else:\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index] * sequence[i])\n        cur_index += sequence[i]\n    if ambiguous:\n        return ('ambiguous', p1, p2)\n    else:\n        return 'perfect'"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "p2.extend([cur_index - 1] + [cur_index] * (sequence[i] - 1))",
      "mutated_line": "p2.extend([cur_index - 1] - [cur_index] * (sequence[i] - 1))",
      "code": "def build_trees_from_sequence(h, sequence):\n    p1 = [0]\n    p2 = [0]\n    ambiguous = False\n    cur_index = 1\n    for i in range(1, h + 1):\n        if i > 0 and sequence[i - 1] > 1 and (sequence[i] > 1):\n            ambiguous = True\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index - 1] - [cur_index] * (sequence[i] - 1))\n        else:\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index] * sequence[i])\n        cur_index += sequence[i]\n    if ambiguous:\n        return ('ambiguous', p1, p2)\n    else:\n        return 'perfect'"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "p2.extend([cur_index - 1] + [cur_index] * (sequence[i] - 1))",
      "mutated_line": "p2.extend([cur_index - 1] * ([cur_index] * (sequence[i] - 1)))",
      "code": "def build_trees_from_sequence(h, sequence):\n    p1 = [0]\n    p2 = [0]\n    ambiguous = False\n    cur_index = 1\n    for i in range(1, h + 1):\n        if i > 0 and sequence[i - 1] > 1 and (sequence[i] > 1):\n            ambiguous = True\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index - 1] * ([cur_index] * (sequence[i] - 1)))\n        else:\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index] * sequence[i])\n        cur_index += sequence[i]\n    if ambiguous:\n        return ('ambiguous', p1, p2)\n    else:\n        return 'perfect'"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "p1.extend([cur_index] * sequence[i])",
      "mutated_line": "p1.extend([cur_index] / sequence[i])",
      "code": "def build_trees_from_sequence(h, sequence):\n    p1 = [0]\n    p2 = [0]\n    ambiguous = False\n    cur_index = 1\n    for i in range(1, h + 1):\n        if i > 0 and sequence[i - 1] > 1 and (sequence[i] > 1):\n            ambiguous = True\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index - 1] + [cur_index] * (sequence[i] - 1))\n        else:\n            p1.extend([cur_index] / sequence[i])\n            p2.extend([cur_index] * sequence[i])\n        cur_index += sequence[i]\n    if ambiguous:\n        return ('ambiguous', p1, p2)\n    else:\n        return 'perfect'"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "p1.extend([cur_index] * sequence[i])",
      "mutated_line": "p1.extend([cur_index] + sequence[i])",
      "code": "def build_trees_from_sequence(h, sequence):\n    p1 = [0]\n    p2 = [0]\n    ambiguous = False\n    cur_index = 1\n    for i in range(1, h + 1):\n        if i > 0 and sequence[i - 1] > 1 and (sequence[i] > 1):\n            ambiguous = True\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index - 1] + [cur_index] * (sequence[i] - 1))\n        else:\n            p1.extend([cur_index] + sequence[i])\n            p2.extend([cur_index] * sequence[i])\n        cur_index += sequence[i]\n    if ambiguous:\n        return ('ambiguous', p1, p2)\n    else:\n        return 'perfect'"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "p1.extend([cur_index] * sequence[i])",
      "mutated_line": "p1.extend([cur_index] ** sequence[i])",
      "code": "def build_trees_from_sequence(h, sequence):\n    p1 = [0]\n    p2 = [0]\n    ambiguous = False\n    cur_index = 1\n    for i in range(1, h + 1):\n        if i > 0 and sequence[i - 1] > 1 and (sequence[i] > 1):\n            ambiguous = True\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index - 1] + [cur_index] * (sequence[i] - 1))\n        else:\n            p1.extend([cur_index] ** sequence[i])\n            p2.extend([cur_index] * sequence[i])\n        cur_index += sequence[i]\n    if ambiguous:\n        return ('ambiguous', p1, p2)\n    else:\n        return 'perfect'"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "p2.extend([cur_index] * sequence[i])",
      "mutated_line": "p2.extend([cur_index] / sequence[i])",
      "code": "def build_trees_from_sequence(h, sequence):\n    p1 = [0]\n    p2 = [0]\n    ambiguous = False\n    cur_index = 1\n    for i in range(1, h + 1):\n        if i > 0 and sequence[i - 1] > 1 and (sequence[i] > 1):\n            ambiguous = True\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index - 1] + [cur_index] * (sequence[i] - 1))\n        else:\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index] / sequence[i])\n        cur_index += sequence[i]\n    if ambiguous:\n        return ('ambiguous', p1, p2)\n    else:\n        return 'perfect'"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "p2.extend([cur_index] * sequence[i])",
      "mutated_line": "p2.extend([cur_index] + sequence[i])",
      "code": "def build_trees_from_sequence(h, sequence):\n    p1 = [0]\n    p2 = [0]\n    ambiguous = False\n    cur_index = 1\n    for i in range(1, h + 1):\n        if i > 0 and sequence[i - 1] > 1 and (sequence[i] > 1):\n            ambiguous = True\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index - 1] + [cur_index] * (sequence[i] - 1))\n        else:\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index] + sequence[i])\n        cur_index += sequence[i]\n    if ambiguous:\n        return ('ambiguous', p1, p2)\n    else:\n        return 'perfect'"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "p2.extend([cur_index] * sequence[i])",
      "mutated_line": "p2.extend([cur_index] ** sequence[i])",
      "code": "def build_trees_from_sequence(h, sequence):\n    p1 = [0]\n    p2 = [0]\n    ambiguous = False\n    cur_index = 1\n    for i in range(1, h + 1):\n        if i > 0 and sequence[i - 1] > 1 and (sequence[i] > 1):\n            ambiguous = True\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index - 1] + [cur_index] * (sequence[i] - 1))\n        else:\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index] ** sequence[i])\n        cur_index += sequence[i]\n    if ambiguous:\n        return ('ambiguous', p1, p2)\n    else:\n        return 'perfect'"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "if i > 0 and sequence[i - 1] > 1 and sequence[i] > 1:",
      "mutated_line": "if i > 0 and sequence[i + 1] > 1 and (sequence[i] > 1):",
      "code": "def build_trees_from_sequence(h, sequence):\n    p1 = [0]\n    p2 = [0]\n    ambiguous = False\n    cur_index = 1\n    for i in range(1, h + 1):\n        if i > 0 and sequence[i + 1] > 1 and (sequence[i] > 1):\n            ambiguous = True\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index - 1] + [cur_index] * (sequence[i] - 1))\n        else:\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index] * sequence[i])\n        cur_index += sequence[i]\n    if ambiguous:\n        return ('ambiguous', p1, p2)\n    else:\n        return 'perfect'"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "if i > 0 and sequence[i - 1] > 1 and sequence[i] > 1:",
      "mutated_line": "if i > 0 and sequence[i * 1] > 1 and (sequence[i] > 1):",
      "code": "def build_trees_from_sequence(h, sequence):\n    p1 = [0]\n    p2 = [0]\n    ambiguous = False\n    cur_index = 1\n    for i in range(1, h + 1):\n        if i > 0 and sequence[i * 1] > 1 and (sequence[i] > 1):\n            ambiguous = True\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index - 1] + [cur_index] * (sequence[i] - 1))\n        else:\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index] * sequence[i])\n        cur_index += sequence[i]\n    if ambiguous:\n        return ('ambiguous', p1, p2)\n    else:\n        return 'perfect'"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "p2.extend([cur_index - 1] + [cur_index] * (sequence[i] - 1))",
      "mutated_line": "p2.extend([cur_index - 1] + [cur_index] / (sequence[i] - 1))",
      "code": "def build_trees_from_sequence(h, sequence):\n    p1 = [0]\n    p2 = [0]\n    ambiguous = False\n    cur_index = 1\n    for i in range(1, h + 1):\n        if i > 0 and sequence[i - 1] > 1 and (sequence[i] > 1):\n            ambiguous = True\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index - 1] + [cur_index] / (sequence[i] - 1))\n        else:\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index] * sequence[i])\n        cur_index += sequence[i]\n    if ambiguous:\n        return ('ambiguous', p1, p2)\n    else:\n        return 'perfect'"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "p2.extend([cur_index - 1] + [cur_index] * (sequence[i] - 1))",
      "mutated_line": "p2.extend([cur_index - 1] + ([cur_index] + (sequence[i] - 1)))",
      "code": "def build_trees_from_sequence(h, sequence):\n    p1 = [0]\n    p2 = [0]\n    ambiguous = False\n    cur_index = 1\n    for i in range(1, h + 1):\n        if i > 0 and sequence[i - 1] > 1 and (sequence[i] > 1):\n            ambiguous = True\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index - 1] + ([cur_index] + (sequence[i] - 1)))\n        else:\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index] * sequence[i])\n        cur_index += sequence[i]\n    if ambiguous:\n        return ('ambiguous', p1, p2)\n    else:\n        return 'perfect'"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "p2.extend([cur_index - 1] + [cur_index] * (sequence[i] - 1))",
      "mutated_line": "p2.extend([cur_index - 1] + [cur_index] ** (sequence[i] - 1))",
      "code": "def build_trees_from_sequence(h, sequence):\n    p1 = [0]\n    p2 = [0]\n    ambiguous = False\n    cur_index = 1\n    for i in range(1, h + 1):\n        if i > 0 and sequence[i - 1] > 1 and (sequence[i] > 1):\n            ambiguous = True\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index - 1] + [cur_index] ** (sequence[i] - 1))\n        else:\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index] * sequence[i])\n        cur_index += sequence[i]\n    if ambiguous:\n        return ('ambiguous', p1, p2)\n    else:\n        return 'perfect'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if i > 0 and sequence[i - 1] > 1 and sequence[i] > 1:",
      "mutated_line": "if i > 0 and sequence[i - 2] > 1 and (sequence[i] > 1):",
      "code": "def build_trees_from_sequence(h, sequence):\n    p1 = [0]\n    p2 = [0]\n    ambiguous = False\n    cur_index = 1\n    for i in range(1, h + 1):\n        if i > 0 and sequence[i - 2] > 1 and (sequence[i] > 1):\n            ambiguous = True\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index - 1] + [cur_index] * (sequence[i] - 1))\n        else:\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index] * sequence[i])\n        cur_index += sequence[i]\n    if ambiguous:\n        return ('ambiguous', p1, p2)\n    else:\n        return 'perfect'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if i > 0 and sequence[i - 1] > 1 and sequence[i] > 1:",
      "mutated_line": "if i > 0 and sequence[i - 0] > 1 and (sequence[i] > 1):",
      "code": "def build_trees_from_sequence(h, sequence):\n    p1 = [0]\n    p2 = [0]\n    ambiguous = False\n    cur_index = 1\n    for i in range(1, h + 1):\n        if i > 0 and sequence[i - 0] > 1 and (sequence[i] > 1):\n            ambiguous = True\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index - 1] + [cur_index] * (sequence[i] - 1))\n        else:\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index] * sequence[i])\n        cur_index += sequence[i]\n    if ambiguous:\n        return ('ambiguous', p1, p2)\n    else:\n        return 'perfect'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if i > 0 and sequence[i - 1] > 1 and sequence[i] > 1:",
      "mutated_line": "if i > 0 and sequence[i - 0] > 1 and (sequence[i] > 1):",
      "code": "def build_trees_from_sequence(h, sequence):\n    p1 = [0]\n    p2 = [0]\n    ambiguous = False\n    cur_index = 1\n    for i in range(1, h + 1):\n        if i > 0 and sequence[i - 0] > 1 and (sequence[i] > 1):\n            ambiguous = True\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index - 1] + [cur_index] * (sequence[i] - 1))\n        else:\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index] * sequence[i])\n        cur_index += sequence[i]\n    if ambiguous:\n        return ('ambiguous', p1, p2)\n    else:\n        return 'perfect'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if i > 0 and sequence[i - 1] > 1 and sequence[i] > 1:",
      "mutated_line": "if i > 0 and sequence[i - -1] > 1 and (sequence[i] > 1):",
      "code": "def build_trees_from_sequence(h, sequence):\n    p1 = [0]\n    p2 = [0]\n    ambiguous = False\n    cur_index = 1\n    for i in range(1, h + 1):\n        if i > 0 and sequence[i - -1] > 1 and (sequence[i] > 1):\n            ambiguous = True\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index - 1] + [cur_index] * (sequence[i] - 1))\n        else:\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index] * sequence[i])\n        cur_index += sequence[i]\n    if ambiguous:\n        return ('ambiguous', p1, p2)\n    else:\n        return 'perfect'"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "p2.extend([cur_index - 1] + [cur_index] * (sequence[i] - 1))",
      "mutated_line": "p2.extend([cur_index + 1] + [cur_index] * (sequence[i] - 1))",
      "code": "def build_trees_from_sequence(h, sequence):\n    p1 = [0]\n    p2 = [0]\n    ambiguous = False\n    cur_index = 1\n    for i in range(1, h + 1):\n        if i > 0 and sequence[i - 1] > 1 and (sequence[i] > 1):\n            ambiguous = True\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index + 1] + [cur_index] * (sequence[i] - 1))\n        else:\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index] * sequence[i])\n        cur_index += sequence[i]\n    if ambiguous:\n        return ('ambiguous', p1, p2)\n    else:\n        return 'perfect'"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "p2.extend([cur_index - 1] + [cur_index] * (sequence[i] - 1))",
      "mutated_line": "p2.extend([cur_index * 1] + [cur_index] * (sequence[i] - 1))",
      "code": "def build_trees_from_sequence(h, sequence):\n    p1 = [0]\n    p2 = [0]\n    ambiguous = False\n    cur_index = 1\n    for i in range(1, h + 1):\n        if i > 0 and sequence[i - 1] > 1 and (sequence[i] > 1):\n            ambiguous = True\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index * 1] + [cur_index] * (sequence[i] - 1))\n        else:\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index] * sequence[i])\n        cur_index += sequence[i]\n    if ambiguous:\n        return ('ambiguous', p1, p2)\n    else:\n        return 'perfect'"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "p2.extend([cur_index - 1] + [cur_index] * (sequence[i] - 1))",
      "mutated_line": "p2.extend([cur_index - 1] + [cur_index] * (sequence[i] + 1))",
      "code": "def build_trees_from_sequence(h, sequence):\n    p1 = [0]\n    p2 = [0]\n    ambiguous = False\n    cur_index = 1\n    for i in range(1, h + 1):\n        if i > 0 and sequence[i - 1] > 1 and (sequence[i] > 1):\n            ambiguous = True\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index - 1] + [cur_index] * (sequence[i] + 1))\n        else:\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index] * sequence[i])\n        cur_index += sequence[i]\n    if ambiguous:\n        return ('ambiguous', p1, p2)\n    else:\n        return 'perfect'"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "p2.extend([cur_index - 1] + [cur_index] * (sequence[i] - 1))",
      "mutated_line": "p2.extend([cur_index - 1] + [cur_index] * (sequence[i] * 1))",
      "code": "def build_trees_from_sequence(h, sequence):\n    p1 = [0]\n    p2 = [0]\n    ambiguous = False\n    cur_index = 1\n    for i in range(1, h + 1):\n        if i > 0 and sequence[i - 1] > 1 and (sequence[i] > 1):\n            ambiguous = True\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index - 1] + [cur_index] * (sequence[i] * 1))\n        else:\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index] * sequence[i])\n        cur_index += sequence[i]\n    if ambiguous:\n        return ('ambiguous', p1, p2)\n    else:\n        return 'perfect'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "p2.extend([cur_index - 1] + [cur_index] * (sequence[i] - 1))",
      "mutated_line": "p2.extend([cur_index - 2] + [cur_index] * (sequence[i] - 1))",
      "code": "def build_trees_from_sequence(h, sequence):\n    p1 = [0]\n    p2 = [0]\n    ambiguous = False\n    cur_index = 1\n    for i in range(1, h + 1):\n        if i > 0 and sequence[i - 1] > 1 and (sequence[i] > 1):\n            ambiguous = True\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index - 2] + [cur_index] * (sequence[i] - 1))\n        else:\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index] * sequence[i])\n        cur_index += sequence[i]\n    if ambiguous:\n        return ('ambiguous', p1, p2)\n    else:\n        return 'perfect'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "p2.extend([cur_index - 1] + [cur_index] * (sequence[i] - 1))",
      "mutated_line": "p2.extend([cur_index - 0] + [cur_index] * (sequence[i] - 1))",
      "code": "def build_trees_from_sequence(h, sequence):\n    p1 = [0]\n    p2 = [0]\n    ambiguous = False\n    cur_index = 1\n    for i in range(1, h + 1):\n        if i > 0 and sequence[i - 1] > 1 and (sequence[i] > 1):\n            ambiguous = True\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index - 0] + [cur_index] * (sequence[i] - 1))\n        else:\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index] * sequence[i])\n        cur_index += sequence[i]\n    if ambiguous:\n        return ('ambiguous', p1, p2)\n    else:\n        return 'perfect'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "p2.extend([cur_index - 1] + [cur_index] * (sequence[i] - 1))",
      "mutated_line": "p2.extend([cur_index - 0] + [cur_index] * (sequence[i] - 1))",
      "code": "def build_trees_from_sequence(h, sequence):\n    p1 = [0]\n    p2 = [0]\n    ambiguous = False\n    cur_index = 1\n    for i in range(1, h + 1):\n        if i > 0 and sequence[i - 1] > 1 and (sequence[i] > 1):\n            ambiguous = True\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index - 0] + [cur_index] * (sequence[i] - 1))\n        else:\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index] * sequence[i])\n        cur_index += sequence[i]\n    if ambiguous:\n        return ('ambiguous', p1, p2)\n    else:\n        return 'perfect'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "p2.extend([cur_index - 1] + [cur_index] * (sequence[i] - 1))",
      "mutated_line": "p2.extend([cur_index - -1] + [cur_index] * (sequence[i] - 1))",
      "code": "def build_trees_from_sequence(h, sequence):\n    p1 = [0]\n    p2 = [0]\n    ambiguous = False\n    cur_index = 1\n    for i in range(1, h + 1):\n        if i > 0 and sequence[i - 1] > 1 and (sequence[i] > 1):\n            ambiguous = True\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index - -1] + [cur_index] * (sequence[i] - 1))\n        else:\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index] * sequence[i])\n        cur_index += sequence[i]\n    if ambiguous:\n        return ('ambiguous', p1, p2)\n    else:\n        return 'perfect'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "p2.extend([cur_index - 1] + [cur_index] * (sequence[i] - 1))",
      "mutated_line": "p2.extend([cur_index - 1] + [cur_index] * (sequence[i] - 2))",
      "code": "def build_trees_from_sequence(h, sequence):\n    p1 = [0]\n    p2 = [0]\n    ambiguous = False\n    cur_index = 1\n    for i in range(1, h + 1):\n        if i > 0 and sequence[i - 1] > 1 and (sequence[i] > 1):\n            ambiguous = True\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index - 1] + [cur_index] * (sequence[i] - 2))\n        else:\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index] * sequence[i])\n        cur_index += sequence[i]\n    if ambiguous:\n        return ('ambiguous', p1, p2)\n    else:\n        return 'perfect'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "p2.extend([cur_index - 1] + [cur_index] * (sequence[i] - 1))",
      "mutated_line": "p2.extend([cur_index - 1] + [cur_index] * (sequence[i] - 0))",
      "code": "def build_trees_from_sequence(h, sequence):\n    p1 = [0]\n    p2 = [0]\n    ambiguous = False\n    cur_index = 1\n    for i in range(1, h + 1):\n        if i > 0 and sequence[i - 1] > 1 and (sequence[i] > 1):\n            ambiguous = True\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index - 1] + [cur_index] * (sequence[i] - 0))\n        else:\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index] * sequence[i])\n        cur_index += sequence[i]\n    if ambiguous:\n        return ('ambiguous', p1, p2)\n    else:\n        return 'perfect'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "p2.extend([cur_index - 1] + [cur_index] * (sequence[i] - 1))",
      "mutated_line": "p2.extend([cur_index - 1] + [cur_index] * (sequence[i] - 0))",
      "code": "def build_trees_from_sequence(h, sequence):\n    p1 = [0]\n    p2 = [0]\n    ambiguous = False\n    cur_index = 1\n    for i in range(1, h + 1):\n        if i > 0 and sequence[i - 1] > 1 and (sequence[i] > 1):\n            ambiguous = True\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index - 1] + [cur_index] * (sequence[i] - 0))\n        else:\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index] * sequence[i])\n        cur_index += sequence[i]\n    if ambiguous:\n        return ('ambiguous', p1, p2)\n    else:\n        return 'perfect'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "p2.extend([cur_index - 1] + [cur_index] * (sequence[i] - 1))",
      "mutated_line": "p2.extend([cur_index - 1] + [cur_index] * (sequence[i] - -1))",
      "code": "def build_trees_from_sequence(h, sequence):\n    p1 = [0]\n    p2 = [0]\n    ambiguous = False\n    cur_index = 1\n    for i in range(1, h + 1):\n        if i > 0 and sequence[i - 1] > 1 and (sequence[i] > 1):\n            ambiguous = True\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index - 1] + [cur_index] * (sequence[i] - -1))\n        else:\n            p1.extend([cur_index] * sequence[i])\n            p2.extend([cur_index] * sequence[i])\n        cur_index += sequence[i]\n    if ambiguous:\n        return ('ambiguous', p1, p2)\n    else:\n        return 'perfect'"
    }
  ]
}