{
  "task_id": "taco_10517",
  "entry_point": "calculate_minimum_total_cost",
  "mutant_count": 166,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "A = [0] + A + [0]",
      "mutated_line": "A = [0] + A - [0]",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A - [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "A = [0] + A + [0]",
      "mutated_line": "A = ([0] + A) * [0]",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = ([0] + A) * [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "mask = (1 << 32) - 1",
      "mutated_line": "mask = (1 << 32) + 1",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) + 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "mask = (1 << 32) - 1",
      "mutated_line": "mask = (1 << 32) * 1",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) * 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "A = [0] + A + [0]",
      "mutated_line": "A = [0] - A + [0]",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] - A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "A = [0] + A + [0]",
      "mutated_line": "A = [0] * A + [0]",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] * A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "mask = (1 << 32) - 1",
      "mutated_line": "mask = (1 << 32) - 2",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 2\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "mask = (1 << 32) - 1",
      "mutated_line": "mask = (1 << 32) - 0",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 0\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "mask = (1 << 32) - 1",
      "mutated_line": "mask = (1 << 32) - 0",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 0\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "mask = (1 << 32) - 1",
      "mutated_line": "mask = (1 << 32) - -1",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - -1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]",
      "mutated_line": "q = [(x << 32) - i for (i, x) in enumerate(A[1:-1], 1)]",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) - i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]",
      "mutated_line": "q = [(x << 32) * i for (i, x) in enumerate(A[1:-1], 1)]",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) * i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "ASR",
      "lineno": 18,
      "original_line": "removed[x] -= 1",
      "mutated_line": "removed[x] += 1",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] += 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "A[ind] = 0",
      "mutated_line": "A[ind] = 1",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 1\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "A[ind] = 0",
      "mutated_line": "A[ind] = -1",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = -1\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "A[ind] = 0",
      "mutated_line": "A[ind] = 1",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 1\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "A = [0] + A + [0]",
      "mutated_line": "A = [0] + A + [1]",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [1]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "A = [0] + A + [0]",
      "mutated_line": "A = [0] + A + [-1]",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [-1]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "A = [0] + A + [0]",
      "mutated_line": "A = [0] + A + [1]",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [1]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "mask = (1 << 32) - 1",
      "mutated_line": "mask = (2 << 32) - 1",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (2 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "mask = (1 << 32) - 1",
      "mutated_line": "mask = (0 << 32) - 1",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (0 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "mask = (1 << 32) - 1",
      "mutated_line": "mask = (0 << 32) - 1",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (0 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "mask = (1 << 32) - 1",
      "mutated_line": "mask = (-1 << 32) - 1",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (-1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "mask = (1 << 32) - 1",
      "mutated_line": "mask = (1 << 33) - 1",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 33) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "mask = (1 << 32) - 1",
      "mutated_line": "mask = (1 << 31) - 1",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 31) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "mask = (1 << 32) - 1",
      "mutated_line": "mask = (1 << 0) - 1",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 0) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "mask = (1 << 32) - 1",
      "mutated_line": "mask = (1 << 1) - 1",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 1) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "mask = (1 << 32) - 1",
      "mutated_line": "mask = (1 << -32) - 1",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << -32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "removed[x] -= 1",
      "mutated_line": "removed[x] -= 2",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 2\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "removed[x] -= 1",
      "mutated_line": "removed[x] -= 0",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 0\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "removed[x] -= 1",
      "mutated_line": "removed[x] -= 0",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 0\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "removed[x] -= 1",
      "mutated_line": "removed[x] -= -1",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= -1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "(val, ind) = (x >> 32, x & mask)",
      "mutated_line": "(val, ind) = (x >> 32, x | mask)",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x | mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "L = A[ind - 1]",
      "mutated_line": "L = A[ind + 1]",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind + 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "L = A[ind - 1]",
      "mutated_line": "L = A[ind * 1]",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind * 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "R = A[ind + 1]",
      "mutated_line": "R = A[ind - 1]",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind - 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "R = A[ind + 1]",
      "mutated_line": "R = A[ind * 1]",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind * 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "newL = val + D",
      "mutated_line": "newL = val - D",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val - D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "newL = val + D",
      "mutated_line": "newL = val * D",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val * D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if L > newL:",
      "mutated_line": "if L >= newL:",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L >= newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if L > newL:",
      "mutated_line": "if L <= newL:",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L <= newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if L > newL:",
      "mutated_line": "if L != newL:",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L != newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "ASR",
      "lineno": 30,
      "original_line": "removed[(L << 32) + (ind - 1)] += 1",
      "mutated_line": "removed[(L << 32) + (ind - 1)] -= 1",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] -= 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "newR = val + D",
      "mutated_line": "newR = val - D",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val - D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "newR = val + D",
      "mutated_line": "newR = val * D",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val * D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if R > newR:",
      "mutated_line": "if R >= newR:",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R >= newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if R > newR:",
      "mutated_line": "if R <= newR:",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R <= newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if R > newR:",
      "mutated_line": "if R != newR:",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R != newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "ASR",
      "lineno": 37,
      "original_line": "removed[(R << 32) + (ind + 1)] += 1",
      "mutated_line": "removed[(R << 32) + (ind + 1)] -= 1",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] -= 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "A = [0] + A + [0]",
      "mutated_line": "A = [1] + A + [0]",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [1] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "A = [0] + A + [0]",
      "mutated_line": "A = [-1] + A + [0]",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [-1] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "A = [0] + A + [0]",
      "mutated_line": "A = [1] + A + [0]",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [1] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]",
      "mutated_line": "q = [(x << 33) + i for (i, x) in enumerate(A[1:-1], 1)]",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 33) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]",
      "mutated_line": "q = [(x << 31) + i for (i, x) in enumerate(A[1:-1], 1)]",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 31) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]",
      "mutated_line": "q = [(x << 0) + i for (i, x) in enumerate(A[1:-1], 1)]",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 0) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]",
      "mutated_line": "q = [(x << 1) + i for (i, x) in enumerate(A[1:-1], 1)]",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 1) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]",
      "mutated_line": "q = [(x << -32) + i for (i, x) in enumerate(A[1:-1], 1)]",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << -32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]",
      "mutated_line": "q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 2)]",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 2)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]",
      "mutated_line": "q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 0)]",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 0)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]",
      "mutated_line": "q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 0)]",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 0)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]",
      "mutated_line": "q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], -1)]",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], -1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "x = q[0]",
      "mutated_line": "x = q[1]",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[1]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "x = q[0]",
      "mutated_line": "x = q[-1]",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[-1]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "x = q[0]",
      "mutated_line": "x = q[1]",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[1]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "(val, ind) = (x >> 32, x & mask)",
      "mutated_line": "(val, ind) = (x >> 33, x & mask)",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 33, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "(val, ind) = (x >> 32, x & mask)",
      "mutated_line": "(val, ind) = (x >> 31, x & mask)",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 31, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "(val, ind) = (x >> 32, x & mask)",
      "mutated_line": "(val, ind) = (x >> 0, x & mask)",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 0, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "(val, ind) = (x >> 32, x & mask)",
      "mutated_line": "(val, ind) = (x >> 1, x & mask)",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 1, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "(val, ind) = (x >> 32, x & mask)",
      "mutated_line": "(val, ind) = (x >> -32, x & mask)",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> -32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "L = A[ind - 1]",
      "mutated_line": "L = A[ind - 2]",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 2]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "L = A[ind - 1]",
      "mutated_line": "L = A[ind - 0]",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 0]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "L = A[ind - 1]",
      "mutated_line": "L = A[ind - 0]",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 0]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "L = A[ind - 1]",
      "mutated_line": "L = A[ind - -1]",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - -1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "R = A[ind + 1]",
      "mutated_line": "R = A[ind + 2]",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 2]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "R = A[ind + 1]",
      "mutated_line": "R = A[ind + 0]",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 0]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "R = A[ind + 1]",
      "mutated_line": "R = A[ind + 0]",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 0]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "R = A[ind + 1]",
      "mutated_line": "R = A[ind + -1]",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + -1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "cost.append(L + val + D)",
      "mutated_line": "cost.append(L + val - D)",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val - D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "cost.append(L + val + D)",
      "mutated_line": "cost.append((L + val) * D)",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append((L + val) * D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "removed[(L << 32) + (ind - 1)] += 1",
      "mutated_line": "removed[(L << 32) + (ind - 1)] += 2",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 2\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "removed[(L << 32) + (ind - 1)] += 1",
      "mutated_line": "removed[(L << 32) + (ind - 1)] += 0",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 0\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "removed[(L << 32) + (ind - 1)] += 1",
      "mutated_line": "removed[(L << 32) + (ind - 1)] += 0",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 0\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "removed[(L << 32) + (ind - 1)] += 1",
      "mutated_line": "removed[(L << 32) + (ind - 1)] += -1",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += -1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "cost.append(R + val + D)",
      "mutated_line": "cost.append(R + val - D)",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val - D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "cost.append(R + val + D)",
      "mutated_line": "cost.append((R + val) * D)",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append((R + val) * D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "removed[(R << 32) + (ind + 1)] += 1",
      "mutated_line": "removed[(R << 32) + (ind + 1)] += 2",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 2\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "removed[(R << 32) + (ind + 1)] += 1",
      "mutated_line": "removed[(R << 32) + (ind + 1)] += 0",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 0\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "removed[(R << 32) + (ind + 1)] += 1",
      "mutated_line": "removed[(R << 32) + (ind + 1)] += 0",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 0\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "removed[(R << 32) + (ind + 1)] += 1",
      "mutated_line": "removed[(R << 32) + (ind + 1)] += -1",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += -1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "cost.append(L + val + D)",
      "mutated_line": "cost.append(L - val + D)",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L - val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "cost.append(L + val + D)",
      "mutated_line": "cost.append(L * val + D)",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L * val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "A[ind - 1] = newL",
      "mutated_line": "A[ind + 1] = newL",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind + 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "A[ind - 1] = newL",
      "mutated_line": "A[ind * 1] = newL",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind * 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "removed[(L << 32) + (ind - 1)] += 1",
      "mutated_line": "removed[(L << 32) - (ind - 1)] += 1",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) - (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "removed[(L << 32) + (ind - 1)] += 1",
      "mutated_line": "removed[(L << 32) * (ind - 1)] += 1",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) * (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "heapq.heappush(q, (newL << 32) + (ind - 1))",
      "mutated_line": "heapq.heappush(q, (newL << 32) - (ind - 1))",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) - (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "heapq.heappush(q, (newL << 32) + (ind - 1))",
      "mutated_line": "heapq.heappush(q, (newL << 32) * (ind - 1))",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) * (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "cost.append(R + val + D)",
      "mutated_line": "cost.append(R - val + D)",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R - val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "cost.append(R + val + D)",
      "mutated_line": "cost.append(R * val + D)",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R * val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "A[ind + 1] = newR",
      "mutated_line": "A[ind - 1] = newR",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind - 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "A[ind + 1] = newR",
      "mutated_line": "A[ind * 1] = newR",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind * 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "removed[(R << 32) + (ind + 1)] += 1",
      "mutated_line": "removed[(R << 32) - (ind + 1)] += 1",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) - (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "removed[(R << 32) + (ind + 1)] += 1",
      "mutated_line": "removed[(R << 32) * (ind + 1)] += 1",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) * (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "heapq.heappush(q, (newR << 32) + (ind + 1))",
      "mutated_line": "heapq.heappush(q, (newR << 32) - (ind + 1))",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) - (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "heapq.heappush(q, (newR << 32) + (ind + 1))",
      "mutated_line": "heapq.heappush(q, (newR << 32) * (ind + 1))",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) * (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]",
      "mutated_line": "q = [(x << 32) + i for (i, x) in enumerate(A[2:-1], 1)]",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[2:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]",
      "mutated_line": "q = [(x << 32) + i for (i, x) in enumerate(A[0:-1], 1)]",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[0:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]",
      "mutated_line": "q = [(x << 32) + i for (i, x) in enumerate(A[0:-1], 1)]",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[0:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]",
      "mutated_line": "q = [(x << 32) + i for (i, x) in enumerate(A[-1:-1], 1)]",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[-1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "UOI",
      "lineno": 7,
      "original_line": "q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]",
      "mutated_line": "q = [(x << 32) + i for (i, x) in enumerate(A[1:+1], 1)]",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:+1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "A[ind - 1] = newL",
      "mutated_line": "A[ind - 2] = newL",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 2] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "A[ind - 1] = newL",
      "mutated_line": "A[ind - 0] = newL",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 0] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "A[ind - 1] = newL",
      "mutated_line": "A[ind - 0] = newL",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 0] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "A[ind - 1] = newL",
      "mutated_line": "A[ind - -1] = newL",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - -1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "removed[(L << 32) + (ind - 1)] += 1",
      "mutated_line": "removed[(L << 32) + (ind + 1)] += 1",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "removed[(L << 32) + (ind - 1)] += 1",
      "mutated_line": "removed[(L << 32) + ind * 1] += 1",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + ind * 1] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "heapq.heappush(q, (newL << 32) + (ind - 1))",
      "mutated_line": "heapq.heappush(q, (newL << 32) + (ind + 1))",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind + 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "heapq.heappush(q, (newL << 32) + (ind - 1))",
      "mutated_line": "heapq.heappush(q, (newL << 32) + ind * 1)",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + ind * 1)\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "A[ind + 1] = newR",
      "mutated_line": "A[ind + 2] = newR",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 2] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "A[ind + 1] = newR",
      "mutated_line": "A[ind + 0] = newR",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 0] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "A[ind + 1] = newR",
      "mutated_line": "A[ind + 0] = newR",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 0] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "A[ind + 1] = newR",
      "mutated_line": "A[ind + -1] = newR",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + -1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "removed[(R << 32) + (ind + 1)] += 1",
      "mutated_line": "removed[(R << 32) + (ind - 1)] += 1",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "removed[(R << 32) + (ind + 1)] += 1",
      "mutated_line": "removed[(R << 32) + ind * 1] += 1",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + ind * 1] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "heapq.heappush(q, (newR << 32) + (ind + 1))",
      "mutated_line": "heapq.heappush(q, (newR << 32) + (ind - 1))",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind - 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "heapq.heappush(q, (newR << 32) + (ind + 1))",
      "mutated_line": "heapq.heappush(q, (newR << 32) + ind * 1)",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + ind * 1)\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]",
      "mutated_line": "q = [(x << 32) + i for (i, x) in enumerate(A[1:-2], 1)]",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-2], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]",
      "mutated_line": "q = [(x << 32) + i for (i, x) in enumerate(A[1:-0], 1)]",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-0], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]",
      "mutated_line": "q = [(x << 32) + i for (i, x) in enumerate(A[1:-0], 1)]",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-0], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]",
      "mutated_line": "q = [(x << 32) + i for (i, x) in enumerate(A[1:--1], 1)]",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:--1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "removed[(L << 32) + (ind - 1)] += 1",
      "mutated_line": "removed[(L << 33) + (ind - 1)] += 1",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 33) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "removed[(L << 32) + (ind - 1)] += 1",
      "mutated_line": "removed[(L << 31) + (ind - 1)] += 1",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 31) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "removed[(L << 32) + (ind - 1)] += 1",
      "mutated_line": "removed[(L << 0) + (ind - 1)] += 1",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 0) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "removed[(L << 32) + (ind - 1)] += 1",
      "mutated_line": "removed[(L << 1) + (ind - 1)] += 1",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 1) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "removed[(L << 32) + (ind - 1)] += 1",
      "mutated_line": "removed[(L << -32) + (ind - 1)] += 1",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << -32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "removed[(L << 32) + (ind - 1)] += 1",
      "mutated_line": "removed[(L << 32) + (ind - 2)] += 1",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 2)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "removed[(L << 32) + (ind - 1)] += 1",
      "mutated_line": "removed[(L << 32) + (ind - 0)] += 1",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 0)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "removed[(L << 32) + (ind - 1)] += 1",
      "mutated_line": "removed[(L << 32) + (ind - 0)] += 1",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 0)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "removed[(L << 32) + (ind - 1)] += 1",
      "mutated_line": "removed[(L << 32) + (ind - -1)] += 1",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - -1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "heapq.heappush(q, (newL << 32) + (ind - 1))",
      "mutated_line": "heapq.heappush(q, (newL << 33) + (ind - 1))",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 33) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "heapq.heappush(q, (newL << 32) + (ind - 1))",
      "mutated_line": "heapq.heappush(q, (newL << 31) + (ind - 1))",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 31) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "heapq.heappush(q, (newL << 32) + (ind - 1))",
      "mutated_line": "heapq.heappush(q, (newL << 0) + (ind - 1))",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 0) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "heapq.heappush(q, (newL << 32) + (ind - 1))",
      "mutated_line": "heapq.heappush(q, (newL << 1) + (ind - 1))",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 1) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "heapq.heappush(q, (newL << 32) + (ind - 1))",
      "mutated_line": "heapq.heappush(q, (newL << -32) + (ind - 1))",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << -32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "heapq.heappush(q, (newL << 32) + (ind - 1))",
      "mutated_line": "heapq.heappush(q, (newL << 32) + (ind - 2))",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 2))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "heapq.heappush(q, (newL << 32) + (ind - 1))",
      "mutated_line": "heapq.heappush(q, (newL << 32) + (ind - 0))",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 0))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "heapq.heappush(q, (newL << 32) + (ind - 1))",
      "mutated_line": "heapq.heappush(q, (newL << 32) + (ind - 0))",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 0))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "heapq.heappush(q, (newL << 32) + (ind - 1))",
      "mutated_line": "heapq.heappush(q, (newL << 32) + (ind - -1))",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - -1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "removed[(R << 32) + (ind + 1)] += 1",
      "mutated_line": "removed[(R << 33) + (ind + 1)] += 1",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 33) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "removed[(R << 32) + (ind + 1)] += 1",
      "mutated_line": "removed[(R << 31) + (ind + 1)] += 1",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 31) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "removed[(R << 32) + (ind + 1)] += 1",
      "mutated_line": "removed[(R << 0) + (ind + 1)] += 1",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 0) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "removed[(R << 32) + (ind + 1)] += 1",
      "mutated_line": "removed[(R << 1) + (ind + 1)] += 1",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 1) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "removed[(R << 32) + (ind + 1)] += 1",
      "mutated_line": "removed[(R << -32) + (ind + 1)] += 1",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << -32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "removed[(R << 32) + (ind + 1)] += 1",
      "mutated_line": "removed[(R << 32) + (ind + 2)] += 1",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 2)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "removed[(R << 32) + (ind + 1)] += 1",
      "mutated_line": "removed[(R << 32) + (ind + 0)] += 1",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 0)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "removed[(R << 32) + (ind + 1)] += 1",
      "mutated_line": "removed[(R << 32) + (ind + 0)] += 1",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 0)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "removed[(R << 32) + (ind + 1)] += 1",
      "mutated_line": "removed[(R << 32) + (ind + -1)] += 1",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + -1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "heapq.heappush(q, (newR << 32) + (ind + 1))",
      "mutated_line": "heapq.heappush(q, (newR << 33) + (ind + 1))",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 33) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "heapq.heappush(q, (newR << 32) + (ind + 1))",
      "mutated_line": "heapq.heappush(q, (newR << 31) + (ind + 1))",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 31) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "heapq.heappush(q, (newR << 32) + (ind + 1))",
      "mutated_line": "heapq.heappush(q, (newR << 0) + (ind + 1))",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 0) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "heapq.heappush(q, (newR << 32) + (ind + 1))",
      "mutated_line": "heapq.heappush(q, (newR << 1) + (ind + 1))",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 1) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "heapq.heappush(q, (newR << 32) + (ind + 1))",
      "mutated_line": "heapq.heappush(q, (newR << -32) + (ind + 1))",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << -32) + (ind + 1))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "heapq.heappush(q, (newR << 32) + (ind + 1))",
      "mutated_line": "heapq.heappush(q, (newR << 32) + (ind + 2))",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 2))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "heapq.heappush(q, (newR << 32) + (ind + 1))",
      "mutated_line": "heapq.heappush(q, (newR << 32) + (ind + 0))",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 0))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "heapq.heappush(q, (newR << 32) + (ind + 1))",
      "mutated_line": "heapq.heappush(q, (newR << 32) + (ind + 0))",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + 0))\n        A[ind] = 0\n    return sum(cost)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "heapq.heappush(q, (newR << 32) + (ind + 1))",
      "mutated_line": "heapq.heappush(q, (newR << 32) + (ind + -1))",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_total_cost(N, D, A):\n    A = [0] + A + [0]\n    mask = (1 << 32) - 1\n    q = [(x << 32) + i for (i, x) in enumerate(A[1:-1], 1)]\n    heapq.heapify(q)\n    removed = defaultdict(int)\n    cost = []\n    while q:\n        while q:\n            x = q[0]\n            if not removed[x]:\n                break\n            heapq.heappop(q)\n            removed[x] -= 1\n        if not q:\n            break\n        x = heapq.heappop(q)\n        (val, ind) = (x >> 32, x & mask)\n        L = A[ind - 1]\n        R = A[ind + 1]\n        if L:\n            cost.append(L + val + D)\n            newL = val + D\n            if L > newL:\n                A[ind - 1] = newL\n                removed[(L << 32) + (ind - 1)] += 1\n                heapq.heappush(q, (newL << 32) + (ind - 1))\n        if R:\n            cost.append(R + val + D)\n            newR = val + D\n            if R > newR:\n                A[ind + 1] = newR\n                removed[(R << 32) + (ind + 1)] += 1\n                heapq.heappush(q, (newR << 32) + (ind + -1))\n        A[ind] = 0\n    return sum(cost)"
    }
  ]
}