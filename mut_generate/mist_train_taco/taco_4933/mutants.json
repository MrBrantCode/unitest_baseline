{
  "task_id": "taco_4933",
  "entry_point": "calculate_max_happiness",
  "mutant_count": 92,
  "mutants": [
    {
      "operator": "ASR",
      "lineno": 31,
      "original_line": "res += sum(hq)",
      "mutated_line": "res -= sum(hq)",
      "code": "import heapq\nfrom operator import itemgetter\n\ndef calculate_max_happiness(T, test_cases):\n    results = []\n    for case in test_cases:\n        N = len(case)\n        res = 0\n        camel_left = []\n        camel_right = []\n        for (K, L, R) in case:\n            res += min(L, R)\n            if R <= L:\n                camel_left.append([K, L, R])\n            elif K != N:\n                camel_right.append([N - K, L, R])\n        camel_left.sort(key=itemgetter(0))\n        camel_right.sort(key=itemgetter(0))\n        hq = []\n        i = 0\n        for j in range(1, N + 1):\n            while i < len(camel_left) and camel_left[i][0] == j:\n                heapq.heappush(hq, camel_left[i][1] - camel_left[i][2])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res -= sum(hq)\n        hq = []\n        i = 0\n        for j in range(1, N):\n            while i < len(camel_right) and camel_right[i][0] == j:\n                heapq.heappush(hq, camel_right[i][2] - camel_right[i][1])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        results.append(res)\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 41,
      "original_line": "res += sum(hq)",
      "mutated_line": "res -= sum(hq)",
      "code": "import heapq\nfrom operator import itemgetter\n\ndef calculate_max_happiness(T, test_cases):\n    results = []\n    for case in test_cases:\n        N = len(case)\n        res = 0\n        camel_left = []\n        camel_right = []\n        for (K, L, R) in case:\n            res += min(L, R)\n            if R <= L:\n                camel_left.append([K, L, R])\n            elif K != N:\n                camel_right.append([N - K, L, R])\n        camel_left.sort(key=itemgetter(0))\n        camel_right.sort(key=itemgetter(0))\n        hq = []\n        i = 0\n        for j in range(1, N + 1):\n            while i < len(camel_left) and camel_left[i][0] == j:\n                heapq.heappush(hq, camel_left[i][1] - camel_left[i][2])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        hq = []\n        i = 0\n        for j in range(1, N):\n            while i < len(camel_right) and camel_right[i][0] == j:\n                heapq.heappush(hq, camel_right[i][2] - camel_right[i][1])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res -= sum(hq)\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "res = 0",
      "mutated_line": "res = 1",
      "code": "import heapq\nfrom operator import itemgetter\n\ndef calculate_max_happiness(T, test_cases):\n    results = []\n    for case in test_cases:\n        N = len(case)\n        res = 1\n        camel_left = []\n        camel_right = []\n        for (K, L, R) in case:\n            res += min(L, R)\n            if R <= L:\n                camel_left.append([K, L, R])\n            elif K != N:\n                camel_right.append([N - K, L, R])\n        camel_left.sort(key=itemgetter(0))\n        camel_right.sort(key=itemgetter(0))\n        hq = []\n        i = 0\n        for j in range(1, N + 1):\n            while i < len(camel_left) and camel_left[i][0] == j:\n                heapq.heappush(hq, camel_left[i][1] - camel_left[i][2])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        hq = []\n        i = 0\n        for j in range(1, N):\n            while i < len(camel_right) and camel_right[i][0] == j:\n                heapq.heappush(hq, camel_right[i][2] - camel_right[i][1])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "res = 0",
      "mutated_line": "res = -1",
      "code": "import heapq\nfrom operator import itemgetter\n\ndef calculate_max_happiness(T, test_cases):\n    results = []\n    for case in test_cases:\n        N = len(case)\n        res = -1\n        camel_left = []\n        camel_right = []\n        for (K, L, R) in case:\n            res += min(L, R)\n            if R <= L:\n                camel_left.append([K, L, R])\n            elif K != N:\n                camel_right.append([N - K, L, R])\n        camel_left.sort(key=itemgetter(0))\n        camel_right.sort(key=itemgetter(0))\n        hq = []\n        i = 0\n        for j in range(1, N + 1):\n            while i < len(camel_left) and camel_left[i][0] == j:\n                heapq.heappush(hq, camel_left[i][1] - camel_left[i][2])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        hq = []\n        i = 0\n        for j in range(1, N):\n            while i < len(camel_right) and camel_right[i][0] == j:\n                heapq.heappush(hq, camel_right[i][2] - camel_right[i][1])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "res = 0",
      "mutated_line": "res = 1",
      "code": "import heapq\nfrom operator import itemgetter\n\ndef calculate_max_happiness(T, test_cases):\n    results = []\n    for case in test_cases:\n        N = len(case)\n        res = 1\n        camel_left = []\n        camel_right = []\n        for (K, L, R) in case:\n            res += min(L, R)\n            if R <= L:\n                camel_left.append([K, L, R])\n            elif K != N:\n                camel_right.append([N - K, L, R])\n        camel_left.sort(key=itemgetter(0))\n        camel_right.sort(key=itemgetter(0))\n        hq = []\n        i = 0\n        for j in range(1, N + 1):\n            while i < len(camel_left) and camel_left[i][0] == j:\n                heapq.heappush(hq, camel_left[i][1] - camel_left[i][2])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        hq = []\n        i = 0\n        for j in range(1, N):\n            while i < len(camel_right) and camel_right[i][0] == j:\n                heapq.heappush(hq, camel_right[i][2] - camel_right[i][1])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        results.append(res)\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 14,
      "original_line": "res += min(L, R)",
      "mutated_line": "res -= min(L, R)",
      "code": "import heapq\nfrom operator import itemgetter\n\ndef calculate_max_happiness(T, test_cases):\n    results = []\n    for case in test_cases:\n        N = len(case)\n        res = 0\n        camel_left = []\n        camel_right = []\n        for (K, L, R) in case:\n            res -= min(L, R)\n            if R <= L:\n                camel_left.append([K, L, R])\n            elif K != N:\n                camel_right.append([N - K, L, R])\n        camel_left.sort(key=itemgetter(0))\n        camel_right.sort(key=itemgetter(0))\n        hq = []\n        i = 0\n        for j in range(1, N + 1):\n            while i < len(camel_left) and camel_left[i][0] == j:\n                heapq.heappush(hq, camel_left[i][1] - camel_left[i][2])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        hq = []\n        i = 0\n        for j in range(1, N):\n            while i < len(camel_right) and camel_right[i][0] == j:\n                heapq.heappush(hq, camel_right[i][2] - camel_right[i][1])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "i = 0",
      "mutated_line": "i = 1",
      "code": "import heapq\nfrom operator import itemgetter\n\ndef calculate_max_happiness(T, test_cases):\n    results = []\n    for case in test_cases:\n        N = len(case)\n        res = 0\n        camel_left = []\n        camel_right = []\n        for (K, L, R) in case:\n            res += min(L, R)\n            if R <= L:\n                camel_left.append([K, L, R])\n            elif K != N:\n                camel_right.append([N - K, L, R])\n        camel_left.sort(key=itemgetter(0))\n        camel_right.sort(key=itemgetter(0))\n        hq = []\n        i = 1\n        for j in range(1, N + 1):\n            while i < len(camel_left) and camel_left[i][0] == j:\n                heapq.heappush(hq, camel_left[i][1] - camel_left[i][2])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        hq = []\n        i = 0\n        for j in range(1, N):\n            while i < len(camel_right) and camel_right[i][0] == j:\n                heapq.heappush(hq, camel_right[i][2] - camel_right[i][1])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "i = 0",
      "mutated_line": "i = -1",
      "code": "import heapq\nfrom operator import itemgetter\n\ndef calculate_max_happiness(T, test_cases):\n    results = []\n    for case in test_cases:\n        N = len(case)\n        res = 0\n        camel_left = []\n        camel_right = []\n        for (K, L, R) in case:\n            res += min(L, R)\n            if R <= L:\n                camel_left.append([K, L, R])\n            elif K != N:\n                camel_right.append([N - K, L, R])\n        camel_left.sort(key=itemgetter(0))\n        camel_right.sort(key=itemgetter(0))\n        hq = []\n        i = -1\n        for j in range(1, N + 1):\n            while i < len(camel_left) and camel_left[i][0] == j:\n                heapq.heappush(hq, camel_left[i][1] - camel_left[i][2])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        hq = []\n        i = 0\n        for j in range(1, N):\n            while i < len(camel_right) and camel_right[i][0] == j:\n                heapq.heappush(hq, camel_right[i][2] - camel_right[i][1])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "i = 0",
      "mutated_line": "i = 1",
      "code": "import heapq\nfrom operator import itemgetter\n\ndef calculate_max_happiness(T, test_cases):\n    results = []\n    for case in test_cases:\n        N = len(case)\n        res = 0\n        camel_left = []\n        camel_right = []\n        for (K, L, R) in case:\n            res += min(L, R)\n            if R <= L:\n                camel_left.append([K, L, R])\n            elif K != N:\n                camel_right.append([N - K, L, R])\n        camel_left.sort(key=itemgetter(0))\n        camel_right.sort(key=itemgetter(0))\n        hq = []\n        i = 1\n        for j in range(1, N + 1):\n            while i < len(camel_left) and camel_left[i][0] == j:\n                heapq.heappush(hq, camel_left[i][1] - camel_left[i][2])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        hq = []\n        i = 0\n        for j in range(1, N):\n            while i < len(camel_right) and camel_right[i][0] == j:\n                heapq.heappush(hq, camel_right[i][2] - camel_right[i][1])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "i = 0",
      "mutated_line": "i = 1",
      "code": "import heapq\nfrom operator import itemgetter\n\ndef calculate_max_happiness(T, test_cases):\n    results = []\n    for case in test_cases:\n        N = len(case)\n        res = 0\n        camel_left = []\n        camel_right = []\n        for (K, L, R) in case:\n            res += min(L, R)\n            if R <= L:\n                camel_left.append([K, L, R])\n            elif K != N:\n                camel_right.append([N - K, L, R])\n        camel_left.sort(key=itemgetter(0))\n        camel_right.sort(key=itemgetter(0))\n        hq = []\n        i = 0\n        for j in range(1, N + 1):\n            while i < len(camel_left) and camel_left[i][0] == j:\n                heapq.heappush(hq, camel_left[i][1] - camel_left[i][2])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        hq = []\n        i = 1\n        for j in range(1, N):\n            while i < len(camel_right) and camel_right[i][0] == j:\n                heapq.heappush(hq, camel_right[i][2] - camel_right[i][1])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "i = 0",
      "mutated_line": "i = -1",
      "code": "import heapq\nfrom operator import itemgetter\n\ndef calculate_max_happiness(T, test_cases):\n    results = []\n    for case in test_cases:\n        N = len(case)\n        res = 0\n        camel_left = []\n        camel_right = []\n        for (K, L, R) in case:\n            res += min(L, R)\n            if R <= L:\n                camel_left.append([K, L, R])\n            elif K != N:\n                camel_right.append([N - K, L, R])\n        camel_left.sort(key=itemgetter(0))\n        camel_right.sort(key=itemgetter(0))\n        hq = []\n        i = 0\n        for j in range(1, N + 1):\n            while i < len(camel_left) and camel_left[i][0] == j:\n                heapq.heappush(hq, camel_left[i][1] - camel_left[i][2])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        hq = []\n        i = -1\n        for j in range(1, N):\n            while i < len(camel_right) and camel_right[i][0] == j:\n                heapq.heappush(hq, camel_right[i][2] - camel_right[i][1])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "i = 0",
      "mutated_line": "i = 1",
      "code": "import heapq\nfrom operator import itemgetter\n\ndef calculate_max_happiness(T, test_cases):\n    results = []\n    for case in test_cases:\n        N = len(case)\n        res = 0\n        camel_left = []\n        camel_right = []\n        for (K, L, R) in case:\n            res += min(L, R)\n            if R <= L:\n                camel_left.append([K, L, R])\n            elif K != N:\n                camel_right.append([N - K, L, R])\n        camel_left.sort(key=itemgetter(0))\n        camel_right.sort(key=itemgetter(0))\n        hq = []\n        i = 0\n        for j in range(1, N + 1):\n            while i < len(camel_left) and camel_left[i][0] == j:\n                heapq.heappush(hq, camel_left[i][1] - camel_left[i][2])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        hq = []\n        i = 1\n        for j in range(1, N):\n            while i < len(camel_right) and camel_right[i][0] == j:\n                heapq.heappush(hq, camel_right[i][2] - camel_right[i][1])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        results.append(res)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if R <= L:",
      "mutated_line": "if R < L:",
      "code": "import heapq\nfrom operator import itemgetter\n\ndef calculate_max_happiness(T, test_cases):\n    results = []\n    for case in test_cases:\n        N = len(case)\n        res = 0\n        camel_left = []\n        camel_right = []\n        for (K, L, R) in case:\n            res += min(L, R)\n            if R < L:\n                camel_left.append([K, L, R])\n            elif K != N:\n                camel_right.append([N - K, L, R])\n        camel_left.sort(key=itemgetter(0))\n        camel_right.sort(key=itemgetter(0))\n        hq = []\n        i = 0\n        for j in range(1, N + 1):\n            while i < len(camel_left) and camel_left[i][0] == j:\n                heapq.heappush(hq, camel_left[i][1] - camel_left[i][2])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        hq = []\n        i = 0\n        for j in range(1, N):\n            while i < len(camel_right) and camel_right[i][0] == j:\n                heapq.heappush(hq, camel_right[i][2] - camel_right[i][1])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        results.append(res)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if R <= L:",
      "mutated_line": "if R > L:",
      "code": "import heapq\nfrom operator import itemgetter\n\ndef calculate_max_happiness(T, test_cases):\n    results = []\n    for case in test_cases:\n        N = len(case)\n        res = 0\n        camel_left = []\n        camel_right = []\n        for (K, L, R) in case:\n            res += min(L, R)\n            if R > L:\n                camel_left.append([K, L, R])\n            elif K != N:\n                camel_right.append([N - K, L, R])\n        camel_left.sort(key=itemgetter(0))\n        camel_right.sort(key=itemgetter(0))\n        hq = []\n        i = 0\n        for j in range(1, N + 1):\n            while i < len(camel_left) and camel_left[i][0] == j:\n                heapq.heappush(hq, camel_left[i][1] - camel_left[i][2])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        hq = []\n        i = 0\n        for j in range(1, N):\n            while i < len(camel_right) and camel_right[i][0] == j:\n                heapq.heappush(hq, camel_right[i][2] - camel_right[i][1])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        results.append(res)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if R <= L:",
      "mutated_line": "if R == L:",
      "code": "import heapq\nfrom operator import itemgetter\n\ndef calculate_max_happiness(T, test_cases):\n    results = []\n    for case in test_cases:\n        N = len(case)\n        res = 0\n        camel_left = []\n        camel_right = []\n        for (K, L, R) in case:\n            res += min(L, R)\n            if R == L:\n                camel_left.append([K, L, R])\n            elif K != N:\n                camel_right.append([N - K, L, R])\n        camel_left.sort(key=itemgetter(0))\n        camel_right.sort(key=itemgetter(0))\n        hq = []\n        i = 0\n        for j in range(1, N + 1):\n            while i < len(camel_left) and camel_left[i][0] == j:\n                heapq.heappush(hq, camel_left[i][1] - camel_left[i][2])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        hq = []\n        i = 0\n        for j in range(1, N):\n            while i < len(camel_right) and camel_right[i][0] == j:\n                heapq.heappush(hq, camel_right[i][2] - camel_right[i][1])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for j in range(1, N + 1):",
      "mutated_line": "for j in range(2, N + 1):",
      "code": "import heapq\nfrom operator import itemgetter\n\ndef calculate_max_happiness(T, test_cases):\n    results = []\n    for case in test_cases:\n        N = len(case)\n        res = 0\n        camel_left = []\n        camel_right = []\n        for (K, L, R) in case:\n            res += min(L, R)\n            if R <= L:\n                camel_left.append([K, L, R])\n            elif K != N:\n                camel_right.append([N - K, L, R])\n        camel_left.sort(key=itemgetter(0))\n        camel_right.sort(key=itemgetter(0))\n        hq = []\n        i = 0\n        for j in range(2, N + 1):\n            while i < len(camel_left) and camel_left[i][0] == j:\n                heapq.heappush(hq, camel_left[i][1] - camel_left[i][2])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        hq = []\n        i = 0\n        for j in range(1, N):\n            while i < len(camel_right) and camel_right[i][0] == j:\n                heapq.heappush(hq, camel_right[i][2] - camel_right[i][1])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for j in range(1, N + 1):",
      "mutated_line": "for j in range(0, N + 1):",
      "code": "import heapq\nfrom operator import itemgetter\n\ndef calculate_max_happiness(T, test_cases):\n    results = []\n    for case in test_cases:\n        N = len(case)\n        res = 0\n        camel_left = []\n        camel_right = []\n        for (K, L, R) in case:\n            res += min(L, R)\n            if R <= L:\n                camel_left.append([K, L, R])\n            elif K != N:\n                camel_right.append([N - K, L, R])\n        camel_left.sort(key=itemgetter(0))\n        camel_right.sort(key=itemgetter(0))\n        hq = []\n        i = 0\n        for j in range(0, N + 1):\n            while i < len(camel_left) and camel_left[i][0] == j:\n                heapq.heappush(hq, camel_left[i][1] - camel_left[i][2])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        hq = []\n        i = 0\n        for j in range(1, N):\n            while i < len(camel_right) and camel_right[i][0] == j:\n                heapq.heappush(hq, camel_right[i][2] - camel_right[i][1])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for j in range(1, N + 1):",
      "mutated_line": "for j in range(0, N + 1):",
      "code": "import heapq\nfrom operator import itemgetter\n\ndef calculate_max_happiness(T, test_cases):\n    results = []\n    for case in test_cases:\n        N = len(case)\n        res = 0\n        camel_left = []\n        camel_right = []\n        for (K, L, R) in case:\n            res += min(L, R)\n            if R <= L:\n                camel_left.append([K, L, R])\n            elif K != N:\n                camel_right.append([N - K, L, R])\n        camel_left.sort(key=itemgetter(0))\n        camel_right.sort(key=itemgetter(0))\n        hq = []\n        i = 0\n        for j in range(0, N + 1):\n            while i < len(camel_left) and camel_left[i][0] == j:\n                heapq.heappush(hq, camel_left[i][1] - camel_left[i][2])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        hq = []\n        i = 0\n        for j in range(1, N):\n            while i < len(camel_right) and camel_right[i][0] == j:\n                heapq.heappush(hq, camel_right[i][2] - camel_right[i][1])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for j in range(1, N + 1):",
      "mutated_line": "for j in range(-1, N + 1):",
      "code": "import heapq\nfrom operator import itemgetter\n\ndef calculate_max_happiness(T, test_cases):\n    results = []\n    for case in test_cases:\n        N = len(case)\n        res = 0\n        camel_left = []\n        camel_right = []\n        for (K, L, R) in case:\n            res += min(L, R)\n            if R <= L:\n                camel_left.append([K, L, R])\n            elif K != N:\n                camel_right.append([N - K, L, R])\n        camel_left.sort(key=itemgetter(0))\n        camel_right.sort(key=itemgetter(0))\n        hq = []\n        i = 0\n        for j in range(-1, N + 1):\n            while i < len(camel_left) and camel_left[i][0] == j:\n                heapq.heappush(hq, camel_left[i][1] - camel_left[i][2])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        hq = []\n        i = 0\n        for j in range(1, N):\n            while i < len(camel_right) and camel_right[i][0] == j:\n                heapq.heappush(hq, camel_right[i][2] - camel_right[i][1])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        results.append(res)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "for j in range(1, N + 1):",
      "mutated_line": "for j in range(1, N - 1):",
      "code": "import heapq\nfrom operator import itemgetter\n\ndef calculate_max_happiness(T, test_cases):\n    results = []\n    for case in test_cases:\n        N = len(case)\n        res = 0\n        camel_left = []\n        camel_right = []\n        for (K, L, R) in case:\n            res += min(L, R)\n            if R <= L:\n                camel_left.append([K, L, R])\n            elif K != N:\n                camel_right.append([N - K, L, R])\n        camel_left.sort(key=itemgetter(0))\n        camel_right.sort(key=itemgetter(0))\n        hq = []\n        i = 0\n        for j in range(1, N - 1):\n            while i < len(camel_left) and camel_left[i][0] == j:\n                heapq.heappush(hq, camel_left[i][1] - camel_left[i][2])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        hq = []\n        i = 0\n        for j in range(1, N):\n            while i < len(camel_right) and camel_right[i][0] == j:\n                heapq.heappush(hq, camel_right[i][2] - camel_right[i][1])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        results.append(res)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "for j in range(1, N + 1):",
      "mutated_line": "for j in range(1, N * 1):",
      "code": "import heapq\nfrom operator import itemgetter\n\ndef calculate_max_happiness(T, test_cases):\n    results = []\n    for case in test_cases:\n        N = len(case)\n        res = 0\n        camel_left = []\n        camel_right = []\n        for (K, L, R) in case:\n            res += min(L, R)\n            if R <= L:\n                camel_left.append([K, L, R])\n            elif K != N:\n                camel_right.append([N - K, L, R])\n        camel_left.sort(key=itemgetter(0))\n        camel_right.sort(key=itemgetter(0))\n        hq = []\n        i = 0\n        for j in range(1, N * 1):\n            while i < len(camel_left) and camel_left[i][0] == j:\n                heapq.heappush(hq, camel_left[i][1] - camel_left[i][2])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        hq = []\n        i = 0\n        for j in range(1, N):\n            while i < len(camel_right) and camel_right[i][0] == j:\n                heapq.heappush(hq, camel_right[i][2] - camel_right[i][1])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        results.append(res)\n    return results"
    },
    {
      "operator": "LCR",
      "lineno": 26,
      "original_line": "while i < len(camel_left) and camel_left[i][0] == j:",
      "mutated_line": "while i < len(camel_left) or camel_left[i][0] == j:",
      "code": "import heapq\nfrom operator import itemgetter\n\ndef calculate_max_happiness(T, test_cases):\n    results = []\n    for case in test_cases:\n        N = len(case)\n        res = 0\n        camel_left = []\n        camel_right = []\n        for (K, L, R) in case:\n            res += min(L, R)\n            if R <= L:\n                camel_left.append([K, L, R])\n            elif K != N:\n                camel_right.append([N - K, L, R])\n        camel_left.sort(key=itemgetter(0))\n        camel_right.sort(key=itemgetter(0))\n        hq = []\n        i = 0\n        for j in range(1, N + 1):\n            while i < len(camel_left) or camel_left[i][0] == j:\n                heapq.heappush(hq, camel_left[i][1] - camel_left[i][2])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        hq = []\n        i = 0\n        for j in range(1, N):\n            while i < len(camel_right) and camel_right[i][0] == j:\n                heapq.heappush(hq, camel_right[i][2] - camel_right[i][1])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        results.append(res)\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 28,
      "original_line": "i += 1",
      "mutated_line": "i -= 1",
      "code": "import heapq\nfrom operator import itemgetter\n\ndef calculate_max_happiness(T, test_cases):\n    results = []\n    for case in test_cases:\n        N = len(case)\n        res = 0\n        camel_left = []\n        camel_right = []\n        for (K, L, R) in case:\n            res += min(L, R)\n            if R <= L:\n                camel_left.append([K, L, R])\n            elif K != N:\n                camel_right.append([N - K, L, R])\n        camel_left.sort(key=itemgetter(0))\n        camel_right.sort(key=itemgetter(0))\n        hq = []\n        i = 0\n        for j in range(1, N + 1):\n            while i < len(camel_left) and camel_left[i][0] == j:\n                heapq.heappush(hq, camel_left[i][1] - camel_left[i][2])\n                i -= 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        hq = []\n        i = 0\n        for j in range(1, N):\n            while i < len(camel_right) and camel_right[i][0] == j:\n                heapq.heappush(hq, camel_right[i][2] - camel_right[i][1])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        results.append(res)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "while len(hq) > j:",
      "mutated_line": "while len(hq) >= j:",
      "code": "import heapq\nfrom operator import itemgetter\n\ndef calculate_max_happiness(T, test_cases):\n    results = []\n    for case in test_cases:\n        N = len(case)\n        res = 0\n        camel_left = []\n        camel_right = []\n        for (K, L, R) in case:\n            res += min(L, R)\n            if R <= L:\n                camel_left.append([K, L, R])\n            elif K != N:\n                camel_right.append([N - K, L, R])\n        camel_left.sort(key=itemgetter(0))\n        camel_right.sort(key=itemgetter(0))\n        hq = []\n        i = 0\n        for j in range(1, N + 1):\n            while i < len(camel_left) and camel_left[i][0] == j:\n                heapq.heappush(hq, camel_left[i][1] - camel_left[i][2])\n                i += 1\n            while len(hq) >= j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        hq = []\n        i = 0\n        for j in range(1, N):\n            while i < len(camel_right) and camel_right[i][0] == j:\n                heapq.heappush(hq, camel_right[i][2] - camel_right[i][1])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        results.append(res)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "while len(hq) > j:",
      "mutated_line": "while len(hq) <= j:",
      "code": "import heapq\nfrom operator import itemgetter\n\ndef calculate_max_happiness(T, test_cases):\n    results = []\n    for case in test_cases:\n        N = len(case)\n        res = 0\n        camel_left = []\n        camel_right = []\n        for (K, L, R) in case:\n            res += min(L, R)\n            if R <= L:\n                camel_left.append([K, L, R])\n            elif K != N:\n                camel_right.append([N - K, L, R])\n        camel_left.sort(key=itemgetter(0))\n        camel_right.sort(key=itemgetter(0))\n        hq = []\n        i = 0\n        for j in range(1, N + 1):\n            while i < len(camel_left) and camel_left[i][0] == j:\n                heapq.heappush(hq, camel_left[i][1] - camel_left[i][2])\n                i += 1\n            while len(hq) <= j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        hq = []\n        i = 0\n        for j in range(1, N):\n            while i < len(camel_right) and camel_right[i][0] == j:\n                heapq.heappush(hq, camel_right[i][2] - camel_right[i][1])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        results.append(res)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "while len(hq) > j:",
      "mutated_line": "while len(hq) != j:",
      "code": "import heapq\nfrom operator import itemgetter\n\ndef calculate_max_happiness(T, test_cases):\n    results = []\n    for case in test_cases:\n        N = len(case)\n        res = 0\n        camel_left = []\n        camel_right = []\n        for (K, L, R) in case:\n            res += min(L, R)\n            if R <= L:\n                camel_left.append([K, L, R])\n            elif K != N:\n                camel_right.append([N - K, L, R])\n        camel_left.sort(key=itemgetter(0))\n        camel_right.sort(key=itemgetter(0))\n        hq = []\n        i = 0\n        for j in range(1, N + 1):\n            while i < len(camel_left) and camel_left[i][0] == j:\n                heapq.heappush(hq, camel_left[i][1] - camel_left[i][2])\n                i += 1\n            while len(hq) != j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        hq = []\n        i = 0\n        for j in range(1, N):\n            while i < len(camel_right) and camel_right[i][0] == j:\n                heapq.heappush(hq, camel_right[i][2] - camel_right[i][1])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for j in range(1, N):",
      "mutated_line": "for j in range(2, N):",
      "code": "import heapq\nfrom operator import itemgetter\n\ndef calculate_max_happiness(T, test_cases):\n    results = []\n    for case in test_cases:\n        N = len(case)\n        res = 0\n        camel_left = []\n        camel_right = []\n        for (K, L, R) in case:\n            res += min(L, R)\n            if R <= L:\n                camel_left.append([K, L, R])\n            elif K != N:\n                camel_right.append([N - K, L, R])\n        camel_left.sort(key=itemgetter(0))\n        camel_right.sort(key=itemgetter(0))\n        hq = []\n        i = 0\n        for j in range(1, N + 1):\n            while i < len(camel_left) and camel_left[i][0] == j:\n                heapq.heappush(hq, camel_left[i][1] - camel_left[i][2])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        hq = []\n        i = 0\n        for j in range(2, N):\n            while i < len(camel_right) and camel_right[i][0] == j:\n                heapq.heappush(hq, camel_right[i][2] - camel_right[i][1])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for j in range(1, N):",
      "mutated_line": "for j in range(0, N):",
      "code": "import heapq\nfrom operator import itemgetter\n\ndef calculate_max_happiness(T, test_cases):\n    results = []\n    for case in test_cases:\n        N = len(case)\n        res = 0\n        camel_left = []\n        camel_right = []\n        for (K, L, R) in case:\n            res += min(L, R)\n            if R <= L:\n                camel_left.append([K, L, R])\n            elif K != N:\n                camel_right.append([N - K, L, R])\n        camel_left.sort(key=itemgetter(0))\n        camel_right.sort(key=itemgetter(0))\n        hq = []\n        i = 0\n        for j in range(1, N + 1):\n            while i < len(camel_left) and camel_left[i][0] == j:\n                heapq.heappush(hq, camel_left[i][1] - camel_left[i][2])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        hq = []\n        i = 0\n        for j in range(0, N):\n            while i < len(camel_right) and camel_right[i][0] == j:\n                heapq.heappush(hq, camel_right[i][2] - camel_right[i][1])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for j in range(1, N):",
      "mutated_line": "for j in range(0, N):",
      "code": "import heapq\nfrom operator import itemgetter\n\ndef calculate_max_happiness(T, test_cases):\n    results = []\n    for case in test_cases:\n        N = len(case)\n        res = 0\n        camel_left = []\n        camel_right = []\n        for (K, L, R) in case:\n            res += min(L, R)\n            if R <= L:\n                camel_left.append([K, L, R])\n            elif K != N:\n                camel_right.append([N - K, L, R])\n        camel_left.sort(key=itemgetter(0))\n        camel_right.sort(key=itemgetter(0))\n        hq = []\n        i = 0\n        for j in range(1, N + 1):\n            while i < len(camel_left) and camel_left[i][0] == j:\n                heapq.heappush(hq, camel_left[i][1] - camel_left[i][2])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        hq = []\n        i = 0\n        for j in range(0, N):\n            while i < len(camel_right) and camel_right[i][0] == j:\n                heapq.heappush(hq, camel_right[i][2] - camel_right[i][1])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for j in range(1, N):",
      "mutated_line": "for j in range(-1, N):",
      "code": "import heapq\nfrom operator import itemgetter\n\ndef calculate_max_happiness(T, test_cases):\n    results = []\n    for case in test_cases:\n        N = len(case)\n        res = 0\n        camel_left = []\n        camel_right = []\n        for (K, L, R) in case:\n            res += min(L, R)\n            if R <= L:\n                camel_left.append([K, L, R])\n            elif K != N:\n                camel_right.append([N - K, L, R])\n        camel_left.sort(key=itemgetter(0))\n        camel_right.sort(key=itemgetter(0))\n        hq = []\n        i = 0\n        for j in range(1, N + 1):\n            while i < len(camel_left) and camel_left[i][0] == j:\n                heapq.heappush(hq, camel_left[i][1] - camel_left[i][2])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        hq = []\n        i = 0\n        for j in range(-1, N):\n            while i < len(camel_right) and camel_right[i][0] == j:\n                heapq.heappush(hq, camel_right[i][2] - camel_right[i][1])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        results.append(res)\n    return results"
    },
    {
      "operator": "LCR",
      "lineno": 36,
      "original_line": "while i < len(camel_right) and camel_right[i][0] == j:",
      "mutated_line": "while i < len(camel_right) or camel_right[i][0] == j:",
      "code": "import heapq\nfrom operator import itemgetter\n\ndef calculate_max_happiness(T, test_cases):\n    results = []\n    for case in test_cases:\n        N = len(case)\n        res = 0\n        camel_left = []\n        camel_right = []\n        for (K, L, R) in case:\n            res += min(L, R)\n            if R <= L:\n                camel_left.append([K, L, R])\n            elif K != N:\n                camel_right.append([N - K, L, R])\n        camel_left.sort(key=itemgetter(0))\n        camel_right.sort(key=itemgetter(0))\n        hq = []\n        i = 0\n        for j in range(1, N + 1):\n            while i < len(camel_left) and camel_left[i][0] == j:\n                heapq.heappush(hq, camel_left[i][1] - camel_left[i][2])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        hq = []\n        i = 0\n        for j in range(1, N):\n            while i < len(camel_right) or camel_right[i][0] == j:\n                heapq.heappush(hq, camel_right[i][2] - camel_right[i][1])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        results.append(res)\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 38,
      "original_line": "i += 1",
      "mutated_line": "i -= 1",
      "code": "import heapq\nfrom operator import itemgetter\n\ndef calculate_max_happiness(T, test_cases):\n    results = []\n    for case in test_cases:\n        N = len(case)\n        res = 0\n        camel_left = []\n        camel_right = []\n        for (K, L, R) in case:\n            res += min(L, R)\n            if R <= L:\n                camel_left.append([K, L, R])\n            elif K != N:\n                camel_right.append([N - K, L, R])\n        camel_left.sort(key=itemgetter(0))\n        camel_right.sort(key=itemgetter(0))\n        hq = []\n        i = 0\n        for j in range(1, N + 1):\n            while i < len(camel_left) and camel_left[i][0] == j:\n                heapq.heappush(hq, camel_left[i][1] - camel_left[i][2])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        hq = []\n        i = 0\n        for j in range(1, N):\n            while i < len(camel_right) and camel_right[i][0] == j:\n                heapq.heappush(hq, camel_right[i][2] - camel_right[i][1])\n                i -= 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        results.append(res)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "while len(hq) > j:",
      "mutated_line": "while len(hq) >= j:",
      "code": "import heapq\nfrom operator import itemgetter\n\ndef calculate_max_happiness(T, test_cases):\n    results = []\n    for case in test_cases:\n        N = len(case)\n        res = 0\n        camel_left = []\n        camel_right = []\n        for (K, L, R) in case:\n            res += min(L, R)\n            if R <= L:\n                camel_left.append([K, L, R])\n            elif K != N:\n                camel_right.append([N - K, L, R])\n        camel_left.sort(key=itemgetter(0))\n        camel_right.sort(key=itemgetter(0))\n        hq = []\n        i = 0\n        for j in range(1, N + 1):\n            while i < len(camel_left) and camel_left[i][0] == j:\n                heapq.heappush(hq, camel_left[i][1] - camel_left[i][2])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        hq = []\n        i = 0\n        for j in range(1, N):\n            while i < len(camel_right) and camel_right[i][0] == j:\n                heapq.heappush(hq, camel_right[i][2] - camel_right[i][1])\n                i += 1\n            while len(hq) >= j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        results.append(res)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "while len(hq) > j:",
      "mutated_line": "while len(hq) <= j:",
      "code": "import heapq\nfrom operator import itemgetter\n\ndef calculate_max_happiness(T, test_cases):\n    results = []\n    for case in test_cases:\n        N = len(case)\n        res = 0\n        camel_left = []\n        camel_right = []\n        for (K, L, R) in case:\n            res += min(L, R)\n            if R <= L:\n                camel_left.append([K, L, R])\n            elif K != N:\n                camel_right.append([N - K, L, R])\n        camel_left.sort(key=itemgetter(0))\n        camel_right.sort(key=itemgetter(0))\n        hq = []\n        i = 0\n        for j in range(1, N + 1):\n            while i < len(camel_left) and camel_left[i][0] == j:\n                heapq.heappush(hq, camel_left[i][1] - camel_left[i][2])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        hq = []\n        i = 0\n        for j in range(1, N):\n            while i < len(camel_right) and camel_right[i][0] == j:\n                heapq.heappush(hq, camel_right[i][2] - camel_right[i][1])\n                i += 1\n            while len(hq) <= j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        results.append(res)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "while len(hq) > j:",
      "mutated_line": "while len(hq) != j:",
      "code": "import heapq\nfrom operator import itemgetter\n\ndef calculate_max_happiness(T, test_cases):\n    results = []\n    for case in test_cases:\n        N = len(case)\n        res = 0\n        camel_left = []\n        camel_right = []\n        for (K, L, R) in case:\n            res += min(L, R)\n            if R <= L:\n                camel_left.append([K, L, R])\n            elif K != N:\n                camel_right.append([N - K, L, R])\n        camel_left.sort(key=itemgetter(0))\n        camel_right.sort(key=itemgetter(0))\n        hq = []\n        i = 0\n        for j in range(1, N + 1):\n            while i < len(camel_left) and camel_left[i][0] == j:\n                heapq.heappush(hq, camel_left[i][1] - camel_left[i][2])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        hq = []\n        i = 0\n        for j in range(1, N):\n            while i < len(camel_right) and camel_right[i][0] == j:\n                heapq.heappush(hq, camel_right[i][2] - camel_right[i][1])\n                i += 1\n            while len(hq) != j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        results.append(res)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "elif K != N:",
      "mutated_line": "elif K == N:",
      "code": "import heapq\nfrom operator import itemgetter\n\ndef calculate_max_happiness(T, test_cases):\n    results = []\n    for case in test_cases:\n        N = len(case)\n        res = 0\n        camel_left = []\n        camel_right = []\n        for (K, L, R) in case:\n            res += min(L, R)\n            if R <= L:\n                camel_left.append([K, L, R])\n            elif K == N:\n                camel_right.append([N - K, L, R])\n        camel_left.sort(key=itemgetter(0))\n        camel_right.sort(key=itemgetter(0))\n        hq = []\n        i = 0\n        for j in range(1, N + 1):\n            while i < len(camel_left) and camel_left[i][0] == j:\n                heapq.heappush(hq, camel_left[i][1] - camel_left[i][2])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        hq = []\n        i = 0\n        for j in range(1, N):\n            while i < len(camel_right) and camel_right[i][0] == j:\n                heapq.heappush(hq, camel_right[i][2] - camel_right[i][1])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for j in range(1, N + 1):",
      "mutated_line": "for j in range(1, N + 2):",
      "code": "import heapq\nfrom operator import itemgetter\n\ndef calculate_max_happiness(T, test_cases):\n    results = []\n    for case in test_cases:\n        N = len(case)\n        res = 0\n        camel_left = []\n        camel_right = []\n        for (K, L, R) in case:\n            res += min(L, R)\n            if R <= L:\n                camel_left.append([K, L, R])\n            elif K != N:\n                camel_right.append([N - K, L, R])\n        camel_left.sort(key=itemgetter(0))\n        camel_right.sort(key=itemgetter(0))\n        hq = []\n        i = 0\n        for j in range(1, N + 2):\n            while i < len(camel_left) and camel_left[i][0] == j:\n                heapq.heappush(hq, camel_left[i][1] - camel_left[i][2])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        hq = []\n        i = 0\n        for j in range(1, N):\n            while i < len(camel_right) and camel_right[i][0] == j:\n                heapq.heappush(hq, camel_right[i][2] - camel_right[i][1])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for j in range(1, N + 1):",
      "mutated_line": "for j in range(1, N + 0):",
      "code": "import heapq\nfrom operator import itemgetter\n\ndef calculate_max_happiness(T, test_cases):\n    results = []\n    for case in test_cases:\n        N = len(case)\n        res = 0\n        camel_left = []\n        camel_right = []\n        for (K, L, R) in case:\n            res += min(L, R)\n            if R <= L:\n                camel_left.append([K, L, R])\n            elif K != N:\n                camel_right.append([N - K, L, R])\n        camel_left.sort(key=itemgetter(0))\n        camel_right.sort(key=itemgetter(0))\n        hq = []\n        i = 0\n        for j in range(1, N + 0):\n            while i < len(camel_left) and camel_left[i][0] == j:\n                heapq.heappush(hq, camel_left[i][1] - camel_left[i][2])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        hq = []\n        i = 0\n        for j in range(1, N):\n            while i < len(camel_right) and camel_right[i][0] == j:\n                heapq.heappush(hq, camel_right[i][2] - camel_right[i][1])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for j in range(1, N + 1):",
      "mutated_line": "for j in range(1, N + 0):",
      "code": "import heapq\nfrom operator import itemgetter\n\ndef calculate_max_happiness(T, test_cases):\n    results = []\n    for case in test_cases:\n        N = len(case)\n        res = 0\n        camel_left = []\n        camel_right = []\n        for (K, L, R) in case:\n            res += min(L, R)\n            if R <= L:\n                camel_left.append([K, L, R])\n            elif K != N:\n                camel_right.append([N - K, L, R])\n        camel_left.sort(key=itemgetter(0))\n        camel_right.sort(key=itemgetter(0))\n        hq = []\n        i = 0\n        for j in range(1, N + 0):\n            while i < len(camel_left) and camel_left[i][0] == j:\n                heapq.heappush(hq, camel_left[i][1] - camel_left[i][2])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        hq = []\n        i = 0\n        for j in range(1, N):\n            while i < len(camel_right) and camel_right[i][0] == j:\n                heapq.heappush(hq, camel_right[i][2] - camel_right[i][1])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for j in range(1, N + 1):",
      "mutated_line": "for j in range(1, N + -1):",
      "code": "import heapq\nfrom operator import itemgetter\n\ndef calculate_max_happiness(T, test_cases):\n    results = []\n    for case in test_cases:\n        N = len(case)\n        res = 0\n        camel_left = []\n        camel_right = []\n        for (K, L, R) in case:\n            res += min(L, R)\n            if R <= L:\n                camel_left.append([K, L, R])\n            elif K != N:\n                camel_right.append([N - K, L, R])\n        camel_left.sort(key=itemgetter(0))\n        camel_right.sort(key=itemgetter(0))\n        hq = []\n        i = 0\n        for j in range(1, N + -1):\n            while i < len(camel_left) and camel_left[i][0] == j:\n                heapq.heappush(hq, camel_left[i][1] - camel_left[i][2])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        hq = []\n        i = 0\n        for j in range(1, N):\n            while i < len(camel_right) and camel_right[i][0] == j:\n                heapq.heappush(hq, camel_right[i][2] - camel_right[i][1])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        results.append(res)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "while i < len(camel_left) and camel_left[i][0] == j:",
      "mutated_line": "while i <= len(camel_left) and camel_left[i][0] == j:",
      "code": "import heapq\nfrom operator import itemgetter\n\ndef calculate_max_happiness(T, test_cases):\n    results = []\n    for case in test_cases:\n        N = len(case)\n        res = 0\n        camel_left = []\n        camel_right = []\n        for (K, L, R) in case:\n            res += min(L, R)\n            if R <= L:\n                camel_left.append([K, L, R])\n            elif K != N:\n                camel_right.append([N - K, L, R])\n        camel_left.sort(key=itemgetter(0))\n        camel_right.sort(key=itemgetter(0))\n        hq = []\n        i = 0\n        for j in range(1, N + 1):\n            while i <= len(camel_left) and camel_left[i][0] == j:\n                heapq.heappush(hq, camel_left[i][1] - camel_left[i][2])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        hq = []\n        i = 0\n        for j in range(1, N):\n            while i < len(camel_right) and camel_right[i][0] == j:\n                heapq.heappush(hq, camel_right[i][2] - camel_right[i][1])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        results.append(res)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "while i < len(camel_left) and camel_left[i][0] == j:",
      "mutated_line": "while i >= len(camel_left) and camel_left[i][0] == j:",
      "code": "import heapq\nfrom operator import itemgetter\n\ndef calculate_max_happiness(T, test_cases):\n    results = []\n    for case in test_cases:\n        N = len(case)\n        res = 0\n        camel_left = []\n        camel_right = []\n        for (K, L, R) in case:\n            res += min(L, R)\n            if R <= L:\n                camel_left.append([K, L, R])\n            elif K != N:\n                camel_right.append([N - K, L, R])\n        camel_left.sort(key=itemgetter(0))\n        camel_right.sort(key=itemgetter(0))\n        hq = []\n        i = 0\n        for j in range(1, N + 1):\n            while i >= len(camel_left) and camel_left[i][0] == j:\n                heapq.heappush(hq, camel_left[i][1] - camel_left[i][2])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        hq = []\n        i = 0\n        for j in range(1, N):\n            while i < len(camel_right) and camel_right[i][0] == j:\n                heapq.heappush(hq, camel_right[i][2] - camel_right[i][1])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        results.append(res)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "while i < len(camel_left) and camel_left[i][0] == j:",
      "mutated_line": "while i != len(camel_left) and camel_left[i][0] == j:",
      "code": "import heapq\nfrom operator import itemgetter\n\ndef calculate_max_happiness(T, test_cases):\n    results = []\n    for case in test_cases:\n        N = len(case)\n        res = 0\n        camel_left = []\n        camel_right = []\n        for (K, L, R) in case:\n            res += min(L, R)\n            if R <= L:\n                camel_left.append([K, L, R])\n            elif K != N:\n                camel_right.append([N - K, L, R])\n        camel_left.sort(key=itemgetter(0))\n        camel_right.sort(key=itemgetter(0))\n        hq = []\n        i = 0\n        for j in range(1, N + 1):\n            while i != len(camel_left) and camel_left[i][0] == j:\n                heapq.heappush(hq, camel_left[i][1] - camel_left[i][2])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        hq = []\n        i = 0\n        for j in range(1, N):\n            while i < len(camel_right) and camel_right[i][0] == j:\n                heapq.heappush(hq, camel_right[i][2] - camel_right[i][1])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        results.append(res)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "while i < len(camel_left) and camel_left[i][0] == j:",
      "mutated_line": "while i < len(camel_left) and camel_left[i][0] != j:",
      "code": "import heapq\nfrom operator import itemgetter\n\ndef calculate_max_happiness(T, test_cases):\n    results = []\n    for case in test_cases:\n        N = len(case)\n        res = 0\n        camel_left = []\n        camel_right = []\n        for (K, L, R) in case:\n            res += min(L, R)\n            if R <= L:\n                camel_left.append([K, L, R])\n            elif K != N:\n                camel_right.append([N - K, L, R])\n        camel_left.sort(key=itemgetter(0))\n        camel_right.sort(key=itemgetter(0))\n        hq = []\n        i = 0\n        for j in range(1, N + 1):\n            while i < len(camel_left) and camel_left[i][0] != j:\n                heapq.heappush(hq, camel_left[i][1] - camel_left[i][2])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        hq = []\n        i = 0\n        for j in range(1, N):\n            while i < len(camel_right) and camel_right[i][0] == j:\n                heapq.heappush(hq, camel_right[i][2] - camel_right[i][1])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "i += 1",
      "mutated_line": "i += 2",
      "code": "import heapq\nfrom operator import itemgetter\n\ndef calculate_max_happiness(T, test_cases):\n    results = []\n    for case in test_cases:\n        N = len(case)\n        res = 0\n        camel_left = []\n        camel_right = []\n        for (K, L, R) in case:\n            res += min(L, R)\n            if R <= L:\n                camel_left.append([K, L, R])\n            elif K != N:\n                camel_right.append([N - K, L, R])\n        camel_left.sort(key=itemgetter(0))\n        camel_right.sort(key=itemgetter(0))\n        hq = []\n        i = 0\n        for j in range(1, N + 1):\n            while i < len(camel_left) and camel_left[i][0] == j:\n                heapq.heappush(hq, camel_left[i][1] - camel_left[i][2])\n                i += 2\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        hq = []\n        i = 0\n        for j in range(1, N):\n            while i < len(camel_right) and camel_right[i][0] == j:\n                heapq.heappush(hq, camel_right[i][2] - camel_right[i][1])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "i += 1",
      "mutated_line": "i += 0",
      "code": "import heapq\nfrom operator import itemgetter\n\ndef calculate_max_happiness(T, test_cases):\n    results = []\n    for case in test_cases:\n        N = len(case)\n        res = 0\n        camel_left = []\n        camel_right = []\n        for (K, L, R) in case:\n            res += min(L, R)\n            if R <= L:\n                camel_left.append([K, L, R])\n            elif K != N:\n                camel_right.append([N - K, L, R])\n        camel_left.sort(key=itemgetter(0))\n        camel_right.sort(key=itemgetter(0))\n        hq = []\n        i = 0\n        for j in range(1, N + 1):\n            while i < len(camel_left) and camel_left[i][0] == j:\n                heapq.heappush(hq, camel_left[i][1] - camel_left[i][2])\n                i += 0\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        hq = []\n        i = 0\n        for j in range(1, N):\n            while i < len(camel_right) and camel_right[i][0] == j:\n                heapq.heappush(hq, camel_right[i][2] - camel_right[i][1])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "i += 1",
      "mutated_line": "i += 0",
      "code": "import heapq\nfrom operator import itemgetter\n\ndef calculate_max_happiness(T, test_cases):\n    results = []\n    for case in test_cases:\n        N = len(case)\n        res = 0\n        camel_left = []\n        camel_right = []\n        for (K, L, R) in case:\n            res += min(L, R)\n            if R <= L:\n                camel_left.append([K, L, R])\n            elif K != N:\n                camel_right.append([N - K, L, R])\n        camel_left.sort(key=itemgetter(0))\n        camel_right.sort(key=itemgetter(0))\n        hq = []\n        i = 0\n        for j in range(1, N + 1):\n            while i < len(camel_left) and camel_left[i][0] == j:\n                heapq.heappush(hq, camel_left[i][1] - camel_left[i][2])\n                i += 0\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        hq = []\n        i = 0\n        for j in range(1, N):\n            while i < len(camel_right) and camel_right[i][0] == j:\n                heapq.heappush(hq, camel_right[i][2] - camel_right[i][1])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "i += 1",
      "mutated_line": "i += -1",
      "code": "import heapq\nfrom operator import itemgetter\n\ndef calculate_max_happiness(T, test_cases):\n    results = []\n    for case in test_cases:\n        N = len(case)\n        res = 0\n        camel_left = []\n        camel_right = []\n        for (K, L, R) in case:\n            res += min(L, R)\n            if R <= L:\n                camel_left.append([K, L, R])\n            elif K != N:\n                camel_right.append([N - K, L, R])\n        camel_left.sort(key=itemgetter(0))\n        camel_right.sort(key=itemgetter(0))\n        hq = []\n        i = 0\n        for j in range(1, N + 1):\n            while i < len(camel_left) and camel_left[i][0] == j:\n                heapq.heappush(hq, camel_left[i][1] - camel_left[i][2])\n                i += -1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        hq = []\n        i = 0\n        for j in range(1, N):\n            while i < len(camel_right) and camel_right[i][0] == j:\n                heapq.heappush(hq, camel_right[i][2] - camel_right[i][1])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        results.append(res)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "while i < len(camel_right) and camel_right[i][0] == j:",
      "mutated_line": "while i <= len(camel_right) and camel_right[i][0] == j:",
      "code": "import heapq\nfrom operator import itemgetter\n\ndef calculate_max_happiness(T, test_cases):\n    results = []\n    for case in test_cases:\n        N = len(case)\n        res = 0\n        camel_left = []\n        camel_right = []\n        for (K, L, R) in case:\n            res += min(L, R)\n            if R <= L:\n                camel_left.append([K, L, R])\n            elif K != N:\n                camel_right.append([N - K, L, R])\n        camel_left.sort(key=itemgetter(0))\n        camel_right.sort(key=itemgetter(0))\n        hq = []\n        i = 0\n        for j in range(1, N + 1):\n            while i < len(camel_left) and camel_left[i][0] == j:\n                heapq.heappush(hq, camel_left[i][1] - camel_left[i][2])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        hq = []\n        i = 0\n        for j in range(1, N):\n            while i <= len(camel_right) and camel_right[i][0] == j:\n                heapq.heappush(hq, camel_right[i][2] - camel_right[i][1])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        results.append(res)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "while i < len(camel_right) and camel_right[i][0] == j:",
      "mutated_line": "while i >= len(camel_right) and camel_right[i][0] == j:",
      "code": "import heapq\nfrom operator import itemgetter\n\ndef calculate_max_happiness(T, test_cases):\n    results = []\n    for case in test_cases:\n        N = len(case)\n        res = 0\n        camel_left = []\n        camel_right = []\n        for (K, L, R) in case:\n            res += min(L, R)\n            if R <= L:\n                camel_left.append([K, L, R])\n            elif K != N:\n                camel_right.append([N - K, L, R])\n        camel_left.sort(key=itemgetter(0))\n        camel_right.sort(key=itemgetter(0))\n        hq = []\n        i = 0\n        for j in range(1, N + 1):\n            while i < len(camel_left) and camel_left[i][0] == j:\n                heapq.heappush(hq, camel_left[i][1] - camel_left[i][2])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        hq = []\n        i = 0\n        for j in range(1, N):\n            while i >= len(camel_right) and camel_right[i][0] == j:\n                heapq.heappush(hq, camel_right[i][2] - camel_right[i][1])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        results.append(res)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "while i < len(camel_right) and camel_right[i][0] == j:",
      "mutated_line": "while i != len(camel_right) and camel_right[i][0] == j:",
      "code": "import heapq\nfrom operator import itemgetter\n\ndef calculate_max_happiness(T, test_cases):\n    results = []\n    for case in test_cases:\n        N = len(case)\n        res = 0\n        camel_left = []\n        camel_right = []\n        for (K, L, R) in case:\n            res += min(L, R)\n            if R <= L:\n                camel_left.append([K, L, R])\n            elif K != N:\n                camel_right.append([N - K, L, R])\n        camel_left.sort(key=itemgetter(0))\n        camel_right.sort(key=itemgetter(0))\n        hq = []\n        i = 0\n        for j in range(1, N + 1):\n            while i < len(camel_left) and camel_left[i][0] == j:\n                heapq.heappush(hq, camel_left[i][1] - camel_left[i][2])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        hq = []\n        i = 0\n        for j in range(1, N):\n            while i != len(camel_right) and camel_right[i][0] == j:\n                heapq.heappush(hq, camel_right[i][2] - camel_right[i][1])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        results.append(res)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "while i < len(camel_right) and camel_right[i][0] == j:",
      "mutated_line": "while i < len(camel_right) and camel_right[i][0] != j:",
      "code": "import heapq\nfrom operator import itemgetter\n\ndef calculate_max_happiness(T, test_cases):\n    results = []\n    for case in test_cases:\n        N = len(case)\n        res = 0\n        camel_left = []\n        camel_right = []\n        for (K, L, R) in case:\n            res += min(L, R)\n            if R <= L:\n                camel_left.append([K, L, R])\n            elif K != N:\n                camel_right.append([N - K, L, R])\n        camel_left.sort(key=itemgetter(0))\n        camel_right.sort(key=itemgetter(0))\n        hq = []\n        i = 0\n        for j in range(1, N + 1):\n            while i < len(camel_left) and camel_left[i][0] == j:\n                heapq.heappush(hq, camel_left[i][1] - camel_left[i][2])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        hq = []\n        i = 0\n        for j in range(1, N):\n            while i < len(camel_right) and camel_right[i][0] != j:\n                heapq.heappush(hq, camel_right[i][2] - camel_right[i][1])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "i += 1",
      "mutated_line": "i += 2",
      "code": "import heapq\nfrom operator import itemgetter\n\ndef calculate_max_happiness(T, test_cases):\n    results = []\n    for case in test_cases:\n        N = len(case)\n        res = 0\n        camel_left = []\n        camel_right = []\n        for (K, L, R) in case:\n            res += min(L, R)\n            if R <= L:\n                camel_left.append([K, L, R])\n            elif K != N:\n                camel_right.append([N - K, L, R])\n        camel_left.sort(key=itemgetter(0))\n        camel_right.sort(key=itemgetter(0))\n        hq = []\n        i = 0\n        for j in range(1, N + 1):\n            while i < len(camel_left) and camel_left[i][0] == j:\n                heapq.heappush(hq, camel_left[i][1] - camel_left[i][2])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        hq = []\n        i = 0\n        for j in range(1, N):\n            while i < len(camel_right) and camel_right[i][0] == j:\n                heapq.heappush(hq, camel_right[i][2] - camel_right[i][1])\n                i += 2\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "i += 1",
      "mutated_line": "i += 0",
      "code": "import heapq\nfrom operator import itemgetter\n\ndef calculate_max_happiness(T, test_cases):\n    results = []\n    for case in test_cases:\n        N = len(case)\n        res = 0\n        camel_left = []\n        camel_right = []\n        for (K, L, R) in case:\n            res += min(L, R)\n            if R <= L:\n                camel_left.append([K, L, R])\n            elif K != N:\n                camel_right.append([N - K, L, R])\n        camel_left.sort(key=itemgetter(0))\n        camel_right.sort(key=itemgetter(0))\n        hq = []\n        i = 0\n        for j in range(1, N + 1):\n            while i < len(camel_left) and camel_left[i][0] == j:\n                heapq.heappush(hq, camel_left[i][1] - camel_left[i][2])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        hq = []\n        i = 0\n        for j in range(1, N):\n            while i < len(camel_right) and camel_right[i][0] == j:\n                heapq.heappush(hq, camel_right[i][2] - camel_right[i][1])\n                i += 0\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "i += 1",
      "mutated_line": "i += 0",
      "code": "import heapq\nfrom operator import itemgetter\n\ndef calculate_max_happiness(T, test_cases):\n    results = []\n    for case in test_cases:\n        N = len(case)\n        res = 0\n        camel_left = []\n        camel_right = []\n        for (K, L, R) in case:\n            res += min(L, R)\n            if R <= L:\n                camel_left.append([K, L, R])\n            elif K != N:\n                camel_right.append([N - K, L, R])\n        camel_left.sort(key=itemgetter(0))\n        camel_right.sort(key=itemgetter(0))\n        hq = []\n        i = 0\n        for j in range(1, N + 1):\n            while i < len(camel_left) and camel_left[i][0] == j:\n                heapq.heappush(hq, camel_left[i][1] - camel_left[i][2])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        hq = []\n        i = 0\n        for j in range(1, N):\n            while i < len(camel_right) and camel_right[i][0] == j:\n                heapq.heappush(hq, camel_right[i][2] - camel_right[i][1])\n                i += 0\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "i += 1",
      "mutated_line": "i += -1",
      "code": "import heapq\nfrom operator import itemgetter\n\ndef calculate_max_happiness(T, test_cases):\n    results = []\n    for case in test_cases:\n        N = len(case)\n        res = 0\n        camel_left = []\n        camel_right = []\n        for (K, L, R) in case:\n            res += min(L, R)\n            if R <= L:\n                camel_left.append([K, L, R])\n            elif K != N:\n                camel_right.append([N - K, L, R])\n        camel_left.sort(key=itemgetter(0))\n        camel_right.sort(key=itemgetter(0))\n        hq = []\n        i = 0\n        for j in range(1, N + 1):\n            while i < len(camel_left) and camel_left[i][0] == j:\n                heapq.heappush(hq, camel_left[i][1] - camel_left[i][2])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        hq = []\n        i = 0\n        for j in range(1, N):\n            while i < len(camel_right) and camel_right[i][0] == j:\n                heapq.heappush(hq, camel_right[i][2] - camel_right[i][1])\n                i += -1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "camel_left.sort(key=itemgetter(0))",
      "mutated_line": "camel_left.sort(key=itemgetter(1))",
      "code": "import heapq\nfrom operator import itemgetter\n\ndef calculate_max_happiness(T, test_cases):\n    results = []\n    for case in test_cases:\n        N = len(case)\n        res = 0\n        camel_left = []\n        camel_right = []\n        for (K, L, R) in case:\n            res += min(L, R)\n            if R <= L:\n                camel_left.append([K, L, R])\n            elif K != N:\n                camel_right.append([N - K, L, R])\n        camel_left.sort(key=itemgetter(1))\n        camel_right.sort(key=itemgetter(0))\n        hq = []\n        i = 0\n        for j in range(1, N + 1):\n            while i < len(camel_left) and camel_left[i][0] == j:\n                heapq.heappush(hq, camel_left[i][1] - camel_left[i][2])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        hq = []\n        i = 0\n        for j in range(1, N):\n            while i < len(camel_right) and camel_right[i][0] == j:\n                heapq.heappush(hq, camel_right[i][2] - camel_right[i][1])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "camel_left.sort(key=itemgetter(0))",
      "mutated_line": "camel_left.sort(key=itemgetter(-1))",
      "code": "import heapq\nfrom operator import itemgetter\n\ndef calculate_max_happiness(T, test_cases):\n    results = []\n    for case in test_cases:\n        N = len(case)\n        res = 0\n        camel_left = []\n        camel_right = []\n        for (K, L, R) in case:\n            res += min(L, R)\n            if R <= L:\n                camel_left.append([K, L, R])\n            elif K != N:\n                camel_right.append([N - K, L, R])\n        camel_left.sort(key=itemgetter(-1))\n        camel_right.sort(key=itemgetter(0))\n        hq = []\n        i = 0\n        for j in range(1, N + 1):\n            while i < len(camel_left) and camel_left[i][0] == j:\n                heapq.heappush(hq, camel_left[i][1] - camel_left[i][2])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        hq = []\n        i = 0\n        for j in range(1, N):\n            while i < len(camel_right) and camel_right[i][0] == j:\n                heapq.heappush(hq, camel_right[i][2] - camel_right[i][1])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "camel_left.sort(key=itemgetter(0))",
      "mutated_line": "camel_left.sort(key=itemgetter(1))",
      "code": "import heapq\nfrom operator import itemgetter\n\ndef calculate_max_happiness(T, test_cases):\n    results = []\n    for case in test_cases:\n        N = len(case)\n        res = 0\n        camel_left = []\n        camel_right = []\n        for (K, L, R) in case:\n            res += min(L, R)\n            if R <= L:\n                camel_left.append([K, L, R])\n            elif K != N:\n                camel_right.append([N - K, L, R])\n        camel_left.sort(key=itemgetter(1))\n        camel_right.sort(key=itemgetter(0))\n        hq = []\n        i = 0\n        for j in range(1, N + 1):\n            while i < len(camel_left) and camel_left[i][0] == j:\n                heapq.heappush(hq, camel_left[i][1] - camel_left[i][2])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        hq = []\n        i = 0\n        for j in range(1, N):\n            while i < len(camel_right) and camel_right[i][0] == j:\n                heapq.heappush(hq, camel_right[i][2] - camel_right[i][1])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "camel_right.sort(key=itemgetter(0))",
      "mutated_line": "camel_right.sort(key=itemgetter(1))",
      "code": "import heapq\nfrom operator import itemgetter\n\ndef calculate_max_happiness(T, test_cases):\n    results = []\n    for case in test_cases:\n        N = len(case)\n        res = 0\n        camel_left = []\n        camel_right = []\n        for (K, L, R) in case:\n            res += min(L, R)\n            if R <= L:\n                camel_left.append([K, L, R])\n            elif K != N:\n                camel_right.append([N - K, L, R])\n        camel_left.sort(key=itemgetter(0))\n        camel_right.sort(key=itemgetter(1))\n        hq = []\n        i = 0\n        for j in range(1, N + 1):\n            while i < len(camel_left) and camel_left[i][0] == j:\n                heapq.heappush(hq, camel_left[i][1] - camel_left[i][2])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        hq = []\n        i = 0\n        for j in range(1, N):\n            while i < len(camel_right) and camel_right[i][0] == j:\n                heapq.heappush(hq, camel_right[i][2] - camel_right[i][1])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "camel_right.sort(key=itemgetter(0))",
      "mutated_line": "camel_right.sort(key=itemgetter(-1))",
      "code": "import heapq\nfrom operator import itemgetter\n\ndef calculate_max_happiness(T, test_cases):\n    results = []\n    for case in test_cases:\n        N = len(case)\n        res = 0\n        camel_left = []\n        camel_right = []\n        for (K, L, R) in case:\n            res += min(L, R)\n            if R <= L:\n                camel_left.append([K, L, R])\n            elif K != N:\n                camel_right.append([N - K, L, R])\n        camel_left.sort(key=itemgetter(0))\n        camel_right.sort(key=itemgetter(-1))\n        hq = []\n        i = 0\n        for j in range(1, N + 1):\n            while i < len(camel_left) and camel_left[i][0] == j:\n                heapq.heappush(hq, camel_left[i][1] - camel_left[i][2])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        hq = []\n        i = 0\n        for j in range(1, N):\n            while i < len(camel_right) and camel_right[i][0] == j:\n                heapq.heappush(hq, camel_right[i][2] - camel_right[i][1])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "camel_right.sort(key=itemgetter(0))",
      "mutated_line": "camel_right.sort(key=itemgetter(1))",
      "code": "import heapq\nfrom operator import itemgetter\n\ndef calculate_max_happiness(T, test_cases):\n    results = []\n    for case in test_cases:\n        N = len(case)\n        res = 0\n        camel_left = []\n        camel_right = []\n        for (K, L, R) in case:\n            res += min(L, R)\n            if R <= L:\n                camel_left.append([K, L, R])\n            elif K != N:\n                camel_right.append([N - K, L, R])\n        camel_left.sort(key=itemgetter(0))\n        camel_right.sort(key=itemgetter(1))\n        hq = []\n        i = 0\n        for j in range(1, N + 1):\n            while i < len(camel_left) and camel_left[i][0] == j:\n                heapq.heappush(hq, camel_left[i][1] - camel_left[i][2])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        hq = []\n        i = 0\n        for j in range(1, N):\n            while i < len(camel_right) and camel_right[i][0] == j:\n                heapq.heappush(hq, camel_right[i][2] - camel_right[i][1])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        results.append(res)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "heapq.heappush(hq, camel_left[i][1] - camel_left[i][2])",
      "mutated_line": "heapq.heappush(hq, camel_left[i][1] + camel_left[i][2])",
      "code": "import heapq\nfrom operator import itemgetter\n\ndef calculate_max_happiness(T, test_cases):\n    results = []\n    for case in test_cases:\n        N = len(case)\n        res = 0\n        camel_left = []\n        camel_right = []\n        for (K, L, R) in case:\n            res += min(L, R)\n            if R <= L:\n                camel_left.append([K, L, R])\n            elif K != N:\n                camel_right.append([N - K, L, R])\n        camel_left.sort(key=itemgetter(0))\n        camel_right.sort(key=itemgetter(0))\n        hq = []\n        i = 0\n        for j in range(1, N + 1):\n            while i < len(camel_left) and camel_left[i][0] == j:\n                heapq.heappush(hq, camel_left[i][1] + camel_left[i][2])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        hq = []\n        i = 0\n        for j in range(1, N):\n            while i < len(camel_right) and camel_right[i][0] == j:\n                heapq.heappush(hq, camel_right[i][2] - camel_right[i][1])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        results.append(res)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "heapq.heappush(hq, camel_left[i][1] - camel_left[i][2])",
      "mutated_line": "heapq.heappush(hq, camel_left[i][1] * camel_left[i][2])",
      "code": "import heapq\nfrom operator import itemgetter\n\ndef calculate_max_happiness(T, test_cases):\n    results = []\n    for case in test_cases:\n        N = len(case)\n        res = 0\n        camel_left = []\n        camel_right = []\n        for (K, L, R) in case:\n            res += min(L, R)\n            if R <= L:\n                camel_left.append([K, L, R])\n            elif K != N:\n                camel_right.append([N - K, L, R])\n        camel_left.sort(key=itemgetter(0))\n        camel_right.sort(key=itemgetter(0))\n        hq = []\n        i = 0\n        for j in range(1, N + 1):\n            while i < len(camel_left) and camel_left[i][0] == j:\n                heapq.heappush(hq, camel_left[i][1] * camel_left[i][2])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        hq = []\n        i = 0\n        for j in range(1, N):\n            while i < len(camel_right) and camel_right[i][0] == j:\n                heapq.heappush(hq, camel_right[i][2] - camel_right[i][1])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        results.append(res)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "heapq.heappush(hq, camel_right[i][2] - camel_right[i][1])",
      "mutated_line": "heapq.heappush(hq, camel_right[i][2] + camel_right[i][1])",
      "code": "import heapq\nfrom operator import itemgetter\n\ndef calculate_max_happiness(T, test_cases):\n    results = []\n    for case in test_cases:\n        N = len(case)\n        res = 0\n        camel_left = []\n        camel_right = []\n        for (K, L, R) in case:\n            res += min(L, R)\n            if R <= L:\n                camel_left.append([K, L, R])\n            elif K != N:\n                camel_right.append([N - K, L, R])\n        camel_left.sort(key=itemgetter(0))\n        camel_right.sort(key=itemgetter(0))\n        hq = []\n        i = 0\n        for j in range(1, N + 1):\n            while i < len(camel_left) and camel_left[i][0] == j:\n                heapq.heappush(hq, camel_left[i][1] - camel_left[i][2])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        hq = []\n        i = 0\n        for j in range(1, N):\n            while i < len(camel_right) and camel_right[i][0] == j:\n                heapq.heappush(hq, camel_right[i][2] + camel_right[i][1])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        results.append(res)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "heapq.heappush(hq, camel_right[i][2] - camel_right[i][1])",
      "mutated_line": "heapq.heappush(hq, camel_right[i][2] * camel_right[i][1])",
      "code": "import heapq\nfrom operator import itemgetter\n\ndef calculate_max_happiness(T, test_cases):\n    results = []\n    for case in test_cases:\n        N = len(case)\n        res = 0\n        camel_left = []\n        camel_right = []\n        for (K, L, R) in case:\n            res += min(L, R)\n            if R <= L:\n                camel_left.append([K, L, R])\n            elif K != N:\n                camel_right.append([N - K, L, R])\n        camel_left.sort(key=itemgetter(0))\n        camel_right.sort(key=itemgetter(0))\n        hq = []\n        i = 0\n        for j in range(1, N + 1):\n            while i < len(camel_left) and camel_left[i][0] == j:\n                heapq.heappush(hq, camel_left[i][1] - camel_left[i][2])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        hq = []\n        i = 0\n        for j in range(1, N):\n            while i < len(camel_right) and camel_right[i][0] == j:\n                heapq.heappush(hq, camel_right[i][2] * camel_right[i][1])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "while i < len(camel_left) and camel_left[i][0] == j:",
      "mutated_line": "while i < len(camel_left) and camel_left[i][1] == j:",
      "code": "import heapq\nfrom operator import itemgetter\n\ndef calculate_max_happiness(T, test_cases):\n    results = []\n    for case in test_cases:\n        N = len(case)\n        res = 0\n        camel_left = []\n        camel_right = []\n        for (K, L, R) in case:\n            res += min(L, R)\n            if R <= L:\n                camel_left.append([K, L, R])\n            elif K != N:\n                camel_right.append([N - K, L, R])\n        camel_left.sort(key=itemgetter(0))\n        camel_right.sort(key=itemgetter(0))\n        hq = []\n        i = 0\n        for j in range(1, N + 1):\n            while i < len(camel_left) and camel_left[i][1] == j:\n                heapq.heappush(hq, camel_left[i][1] - camel_left[i][2])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        hq = []\n        i = 0\n        for j in range(1, N):\n            while i < len(camel_right) and camel_right[i][0] == j:\n                heapq.heappush(hq, camel_right[i][2] - camel_right[i][1])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "while i < len(camel_left) and camel_left[i][0] == j:",
      "mutated_line": "while i < len(camel_left) and camel_left[i][-1] == j:",
      "code": "import heapq\nfrom operator import itemgetter\n\ndef calculate_max_happiness(T, test_cases):\n    results = []\n    for case in test_cases:\n        N = len(case)\n        res = 0\n        camel_left = []\n        camel_right = []\n        for (K, L, R) in case:\n            res += min(L, R)\n            if R <= L:\n                camel_left.append([K, L, R])\n            elif K != N:\n                camel_right.append([N - K, L, R])\n        camel_left.sort(key=itemgetter(0))\n        camel_right.sort(key=itemgetter(0))\n        hq = []\n        i = 0\n        for j in range(1, N + 1):\n            while i < len(camel_left) and camel_left[i][-1] == j:\n                heapq.heappush(hq, camel_left[i][1] - camel_left[i][2])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        hq = []\n        i = 0\n        for j in range(1, N):\n            while i < len(camel_right) and camel_right[i][0] == j:\n                heapq.heappush(hq, camel_right[i][2] - camel_right[i][1])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "while i < len(camel_left) and camel_left[i][0] == j:",
      "mutated_line": "while i < len(camel_left) and camel_left[i][1] == j:",
      "code": "import heapq\nfrom operator import itemgetter\n\ndef calculate_max_happiness(T, test_cases):\n    results = []\n    for case in test_cases:\n        N = len(case)\n        res = 0\n        camel_left = []\n        camel_right = []\n        for (K, L, R) in case:\n            res += min(L, R)\n            if R <= L:\n                camel_left.append([K, L, R])\n            elif K != N:\n                camel_right.append([N - K, L, R])\n        camel_left.sort(key=itemgetter(0))\n        camel_right.sort(key=itemgetter(0))\n        hq = []\n        i = 0\n        for j in range(1, N + 1):\n            while i < len(camel_left) and camel_left[i][1] == j:\n                heapq.heappush(hq, camel_left[i][1] - camel_left[i][2])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        hq = []\n        i = 0\n        for j in range(1, N):\n            while i < len(camel_right) and camel_right[i][0] == j:\n                heapq.heappush(hq, camel_right[i][2] - camel_right[i][1])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "while i < len(camel_right) and camel_right[i][0] == j:",
      "mutated_line": "while i < len(camel_right) and camel_right[i][1] == j:",
      "code": "import heapq\nfrom operator import itemgetter\n\ndef calculate_max_happiness(T, test_cases):\n    results = []\n    for case in test_cases:\n        N = len(case)\n        res = 0\n        camel_left = []\n        camel_right = []\n        for (K, L, R) in case:\n            res += min(L, R)\n            if R <= L:\n                camel_left.append([K, L, R])\n            elif K != N:\n                camel_right.append([N - K, L, R])\n        camel_left.sort(key=itemgetter(0))\n        camel_right.sort(key=itemgetter(0))\n        hq = []\n        i = 0\n        for j in range(1, N + 1):\n            while i < len(camel_left) and camel_left[i][0] == j:\n                heapq.heappush(hq, camel_left[i][1] - camel_left[i][2])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        hq = []\n        i = 0\n        for j in range(1, N):\n            while i < len(camel_right) and camel_right[i][1] == j:\n                heapq.heappush(hq, camel_right[i][2] - camel_right[i][1])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "while i < len(camel_right) and camel_right[i][0] == j:",
      "mutated_line": "while i < len(camel_right) and camel_right[i][-1] == j:",
      "code": "import heapq\nfrom operator import itemgetter\n\ndef calculate_max_happiness(T, test_cases):\n    results = []\n    for case in test_cases:\n        N = len(case)\n        res = 0\n        camel_left = []\n        camel_right = []\n        for (K, L, R) in case:\n            res += min(L, R)\n            if R <= L:\n                camel_left.append([K, L, R])\n            elif K != N:\n                camel_right.append([N - K, L, R])\n        camel_left.sort(key=itemgetter(0))\n        camel_right.sort(key=itemgetter(0))\n        hq = []\n        i = 0\n        for j in range(1, N + 1):\n            while i < len(camel_left) and camel_left[i][0] == j:\n                heapq.heappush(hq, camel_left[i][1] - camel_left[i][2])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        hq = []\n        i = 0\n        for j in range(1, N):\n            while i < len(camel_right) and camel_right[i][-1] == j:\n                heapq.heappush(hq, camel_right[i][2] - camel_right[i][1])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "while i < len(camel_right) and camel_right[i][0] == j:",
      "mutated_line": "while i < len(camel_right) and camel_right[i][1] == j:",
      "code": "import heapq\nfrom operator import itemgetter\n\ndef calculate_max_happiness(T, test_cases):\n    results = []\n    for case in test_cases:\n        N = len(case)\n        res = 0\n        camel_left = []\n        camel_right = []\n        for (K, L, R) in case:\n            res += min(L, R)\n            if R <= L:\n                camel_left.append([K, L, R])\n            elif K != N:\n                camel_right.append([N - K, L, R])\n        camel_left.sort(key=itemgetter(0))\n        camel_right.sort(key=itemgetter(0))\n        hq = []\n        i = 0\n        for j in range(1, N + 1):\n            while i < len(camel_left) and camel_left[i][0] == j:\n                heapq.heappush(hq, camel_left[i][1] - camel_left[i][2])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        hq = []\n        i = 0\n        for j in range(1, N):\n            while i < len(camel_right) and camel_right[i][1] == j:\n                heapq.heappush(hq, camel_right[i][2] - camel_right[i][1])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        results.append(res)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "camel_right.append([N - K, L, R])",
      "mutated_line": "camel_right.append([N + K, L, R])",
      "code": "import heapq\nfrom operator import itemgetter\n\ndef calculate_max_happiness(T, test_cases):\n    results = []\n    for case in test_cases:\n        N = len(case)\n        res = 0\n        camel_left = []\n        camel_right = []\n        for (K, L, R) in case:\n            res += min(L, R)\n            if R <= L:\n                camel_left.append([K, L, R])\n            elif K != N:\n                camel_right.append([N + K, L, R])\n        camel_left.sort(key=itemgetter(0))\n        camel_right.sort(key=itemgetter(0))\n        hq = []\n        i = 0\n        for j in range(1, N + 1):\n            while i < len(camel_left) and camel_left[i][0] == j:\n                heapq.heappush(hq, camel_left[i][1] - camel_left[i][2])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        hq = []\n        i = 0\n        for j in range(1, N):\n            while i < len(camel_right) and camel_right[i][0] == j:\n                heapq.heappush(hq, camel_right[i][2] - camel_right[i][1])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        results.append(res)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "camel_right.append([N - K, L, R])",
      "mutated_line": "camel_right.append([N * K, L, R])",
      "code": "import heapq\nfrom operator import itemgetter\n\ndef calculate_max_happiness(T, test_cases):\n    results = []\n    for case in test_cases:\n        N = len(case)\n        res = 0\n        camel_left = []\n        camel_right = []\n        for (K, L, R) in case:\n            res += min(L, R)\n            if R <= L:\n                camel_left.append([K, L, R])\n            elif K != N:\n                camel_right.append([N * K, L, R])\n        camel_left.sort(key=itemgetter(0))\n        camel_right.sort(key=itemgetter(0))\n        hq = []\n        i = 0\n        for j in range(1, N + 1):\n            while i < len(camel_left) and camel_left[i][0] == j:\n                heapq.heappush(hq, camel_left[i][1] - camel_left[i][2])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        hq = []\n        i = 0\n        for j in range(1, N):\n            while i < len(camel_right) and camel_right[i][0] == j:\n                heapq.heappush(hq, camel_right[i][2] - camel_right[i][1])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "heapq.heappush(hq, camel_left[i][1] - camel_left[i][2])",
      "mutated_line": "heapq.heappush(hq, camel_left[i][2] - camel_left[i][2])",
      "code": "import heapq\nfrom operator import itemgetter\n\ndef calculate_max_happiness(T, test_cases):\n    results = []\n    for case in test_cases:\n        N = len(case)\n        res = 0\n        camel_left = []\n        camel_right = []\n        for (K, L, R) in case:\n            res += min(L, R)\n            if R <= L:\n                camel_left.append([K, L, R])\n            elif K != N:\n                camel_right.append([N - K, L, R])\n        camel_left.sort(key=itemgetter(0))\n        camel_right.sort(key=itemgetter(0))\n        hq = []\n        i = 0\n        for j in range(1, N + 1):\n            while i < len(camel_left) and camel_left[i][0] == j:\n                heapq.heappush(hq, camel_left[i][2] - camel_left[i][2])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        hq = []\n        i = 0\n        for j in range(1, N):\n            while i < len(camel_right) and camel_right[i][0] == j:\n                heapq.heappush(hq, camel_right[i][2] - camel_right[i][1])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "heapq.heappush(hq, camel_left[i][1] - camel_left[i][2])",
      "mutated_line": "heapq.heappush(hq, camel_left[i][0] - camel_left[i][2])",
      "code": "import heapq\nfrom operator import itemgetter\n\ndef calculate_max_happiness(T, test_cases):\n    results = []\n    for case in test_cases:\n        N = len(case)\n        res = 0\n        camel_left = []\n        camel_right = []\n        for (K, L, R) in case:\n            res += min(L, R)\n            if R <= L:\n                camel_left.append([K, L, R])\n            elif K != N:\n                camel_right.append([N - K, L, R])\n        camel_left.sort(key=itemgetter(0))\n        camel_right.sort(key=itemgetter(0))\n        hq = []\n        i = 0\n        for j in range(1, N + 1):\n            while i < len(camel_left) and camel_left[i][0] == j:\n                heapq.heappush(hq, camel_left[i][0] - camel_left[i][2])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        hq = []\n        i = 0\n        for j in range(1, N):\n            while i < len(camel_right) and camel_right[i][0] == j:\n                heapq.heappush(hq, camel_right[i][2] - camel_right[i][1])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "heapq.heappush(hq, camel_left[i][1] - camel_left[i][2])",
      "mutated_line": "heapq.heappush(hq, camel_left[i][0] - camel_left[i][2])",
      "code": "import heapq\nfrom operator import itemgetter\n\ndef calculate_max_happiness(T, test_cases):\n    results = []\n    for case in test_cases:\n        N = len(case)\n        res = 0\n        camel_left = []\n        camel_right = []\n        for (K, L, R) in case:\n            res += min(L, R)\n            if R <= L:\n                camel_left.append([K, L, R])\n            elif K != N:\n                camel_right.append([N - K, L, R])\n        camel_left.sort(key=itemgetter(0))\n        camel_right.sort(key=itemgetter(0))\n        hq = []\n        i = 0\n        for j in range(1, N + 1):\n            while i < len(camel_left) and camel_left[i][0] == j:\n                heapq.heappush(hq, camel_left[i][0] - camel_left[i][2])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        hq = []\n        i = 0\n        for j in range(1, N):\n            while i < len(camel_right) and camel_right[i][0] == j:\n                heapq.heappush(hq, camel_right[i][2] - camel_right[i][1])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "heapq.heappush(hq, camel_left[i][1] - camel_left[i][2])",
      "mutated_line": "heapq.heappush(hq, camel_left[i][-1] - camel_left[i][2])",
      "code": "import heapq\nfrom operator import itemgetter\n\ndef calculate_max_happiness(T, test_cases):\n    results = []\n    for case in test_cases:\n        N = len(case)\n        res = 0\n        camel_left = []\n        camel_right = []\n        for (K, L, R) in case:\n            res += min(L, R)\n            if R <= L:\n                camel_left.append([K, L, R])\n            elif K != N:\n                camel_right.append([N - K, L, R])\n        camel_left.sort(key=itemgetter(0))\n        camel_right.sort(key=itemgetter(0))\n        hq = []\n        i = 0\n        for j in range(1, N + 1):\n            while i < len(camel_left) and camel_left[i][0] == j:\n                heapq.heappush(hq, camel_left[i][-1] - camel_left[i][2])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        hq = []\n        i = 0\n        for j in range(1, N):\n            while i < len(camel_right) and camel_right[i][0] == j:\n                heapq.heappush(hq, camel_right[i][2] - camel_right[i][1])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "heapq.heappush(hq, camel_left[i][1] - camel_left[i][2])",
      "mutated_line": "heapq.heappush(hq, camel_left[i][1] - camel_left[i][3])",
      "code": "import heapq\nfrom operator import itemgetter\n\ndef calculate_max_happiness(T, test_cases):\n    results = []\n    for case in test_cases:\n        N = len(case)\n        res = 0\n        camel_left = []\n        camel_right = []\n        for (K, L, R) in case:\n            res += min(L, R)\n            if R <= L:\n                camel_left.append([K, L, R])\n            elif K != N:\n                camel_right.append([N - K, L, R])\n        camel_left.sort(key=itemgetter(0))\n        camel_right.sort(key=itemgetter(0))\n        hq = []\n        i = 0\n        for j in range(1, N + 1):\n            while i < len(camel_left) and camel_left[i][0] == j:\n                heapq.heappush(hq, camel_left[i][1] - camel_left[i][3])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        hq = []\n        i = 0\n        for j in range(1, N):\n            while i < len(camel_right) and camel_right[i][0] == j:\n                heapq.heappush(hq, camel_right[i][2] - camel_right[i][1])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "heapq.heappush(hq, camel_left[i][1] - camel_left[i][2])",
      "mutated_line": "heapq.heappush(hq, camel_left[i][1] - camel_left[i][1])",
      "code": "import heapq\nfrom operator import itemgetter\n\ndef calculate_max_happiness(T, test_cases):\n    results = []\n    for case in test_cases:\n        N = len(case)\n        res = 0\n        camel_left = []\n        camel_right = []\n        for (K, L, R) in case:\n            res += min(L, R)\n            if R <= L:\n                camel_left.append([K, L, R])\n            elif K != N:\n                camel_right.append([N - K, L, R])\n        camel_left.sort(key=itemgetter(0))\n        camel_right.sort(key=itemgetter(0))\n        hq = []\n        i = 0\n        for j in range(1, N + 1):\n            while i < len(camel_left) and camel_left[i][0] == j:\n                heapq.heappush(hq, camel_left[i][1] - camel_left[i][1])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        hq = []\n        i = 0\n        for j in range(1, N):\n            while i < len(camel_right) and camel_right[i][0] == j:\n                heapq.heappush(hq, camel_right[i][2] - camel_right[i][1])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "heapq.heappush(hq, camel_left[i][1] - camel_left[i][2])",
      "mutated_line": "heapq.heappush(hq, camel_left[i][1] - camel_left[i][0])",
      "code": "import heapq\nfrom operator import itemgetter\n\ndef calculate_max_happiness(T, test_cases):\n    results = []\n    for case in test_cases:\n        N = len(case)\n        res = 0\n        camel_left = []\n        camel_right = []\n        for (K, L, R) in case:\n            res += min(L, R)\n            if R <= L:\n                camel_left.append([K, L, R])\n            elif K != N:\n                camel_right.append([N - K, L, R])\n        camel_left.sort(key=itemgetter(0))\n        camel_right.sort(key=itemgetter(0))\n        hq = []\n        i = 0\n        for j in range(1, N + 1):\n            while i < len(camel_left) and camel_left[i][0] == j:\n                heapq.heappush(hq, camel_left[i][1] - camel_left[i][0])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        hq = []\n        i = 0\n        for j in range(1, N):\n            while i < len(camel_right) and camel_right[i][0] == j:\n                heapq.heappush(hq, camel_right[i][2] - camel_right[i][1])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "heapq.heappush(hq, camel_left[i][1] - camel_left[i][2])",
      "mutated_line": "heapq.heappush(hq, camel_left[i][1] - camel_left[i][1])",
      "code": "import heapq\nfrom operator import itemgetter\n\ndef calculate_max_happiness(T, test_cases):\n    results = []\n    for case in test_cases:\n        N = len(case)\n        res = 0\n        camel_left = []\n        camel_right = []\n        for (K, L, R) in case:\n            res += min(L, R)\n            if R <= L:\n                camel_left.append([K, L, R])\n            elif K != N:\n                camel_right.append([N - K, L, R])\n        camel_left.sort(key=itemgetter(0))\n        camel_right.sort(key=itemgetter(0))\n        hq = []\n        i = 0\n        for j in range(1, N + 1):\n            while i < len(camel_left) and camel_left[i][0] == j:\n                heapq.heappush(hq, camel_left[i][1] - camel_left[i][1])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        hq = []\n        i = 0\n        for j in range(1, N):\n            while i < len(camel_right) and camel_right[i][0] == j:\n                heapq.heappush(hq, camel_right[i][2] - camel_right[i][1])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "heapq.heappush(hq, camel_left[i][1] - camel_left[i][2])",
      "mutated_line": "heapq.heappush(hq, camel_left[i][1] - camel_left[i][-2])",
      "code": "import heapq\nfrom operator import itemgetter\n\ndef calculate_max_happiness(T, test_cases):\n    results = []\n    for case in test_cases:\n        N = len(case)\n        res = 0\n        camel_left = []\n        camel_right = []\n        for (K, L, R) in case:\n            res += min(L, R)\n            if R <= L:\n                camel_left.append([K, L, R])\n            elif K != N:\n                camel_right.append([N - K, L, R])\n        camel_left.sort(key=itemgetter(0))\n        camel_right.sort(key=itemgetter(0))\n        hq = []\n        i = 0\n        for j in range(1, N + 1):\n            while i < len(camel_left) and camel_left[i][0] == j:\n                heapq.heappush(hq, camel_left[i][1] - camel_left[i][-2])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        hq = []\n        i = 0\n        for j in range(1, N):\n            while i < len(camel_right) and camel_right[i][0] == j:\n                heapq.heappush(hq, camel_right[i][2] - camel_right[i][1])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "heapq.heappush(hq, camel_right[i][2] - camel_right[i][1])",
      "mutated_line": "heapq.heappush(hq, camel_right[i][3] - camel_right[i][1])",
      "code": "import heapq\nfrom operator import itemgetter\n\ndef calculate_max_happiness(T, test_cases):\n    results = []\n    for case in test_cases:\n        N = len(case)\n        res = 0\n        camel_left = []\n        camel_right = []\n        for (K, L, R) in case:\n            res += min(L, R)\n            if R <= L:\n                camel_left.append([K, L, R])\n            elif K != N:\n                camel_right.append([N - K, L, R])\n        camel_left.sort(key=itemgetter(0))\n        camel_right.sort(key=itemgetter(0))\n        hq = []\n        i = 0\n        for j in range(1, N + 1):\n            while i < len(camel_left) and camel_left[i][0] == j:\n                heapq.heappush(hq, camel_left[i][1] - camel_left[i][2])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        hq = []\n        i = 0\n        for j in range(1, N):\n            while i < len(camel_right) and camel_right[i][0] == j:\n                heapq.heappush(hq, camel_right[i][3] - camel_right[i][1])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "heapq.heappush(hq, camel_right[i][2] - camel_right[i][1])",
      "mutated_line": "heapq.heappush(hq, camel_right[i][1] - camel_right[i][1])",
      "code": "import heapq\nfrom operator import itemgetter\n\ndef calculate_max_happiness(T, test_cases):\n    results = []\n    for case in test_cases:\n        N = len(case)\n        res = 0\n        camel_left = []\n        camel_right = []\n        for (K, L, R) in case:\n            res += min(L, R)\n            if R <= L:\n                camel_left.append([K, L, R])\n            elif K != N:\n                camel_right.append([N - K, L, R])\n        camel_left.sort(key=itemgetter(0))\n        camel_right.sort(key=itemgetter(0))\n        hq = []\n        i = 0\n        for j in range(1, N + 1):\n            while i < len(camel_left) and camel_left[i][0] == j:\n                heapq.heappush(hq, camel_left[i][1] - camel_left[i][2])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        hq = []\n        i = 0\n        for j in range(1, N):\n            while i < len(camel_right) and camel_right[i][0] == j:\n                heapq.heappush(hq, camel_right[i][1] - camel_right[i][1])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "heapq.heappush(hq, camel_right[i][2] - camel_right[i][1])",
      "mutated_line": "heapq.heappush(hq, camel_right[i][0] - camel_right[i][1])",
      "code": "import heapq\nfrom operator import itemgetter\n\ndef calculate_max_happiness(T, test_cases):\n    results = []\n    for case in test_cases:\n        N = len(case)\n        res = 0\n        camel_left = []\n        camel_right = []\n        for (K, L, R) in case:\n            res += min(L, R)\n            if R <= L:\n                camel_left.append([K, L, R])\n            elif K != N:\n                camel_right.append([N - K, L, R])\n        camel_left.sort(key=itemgetter(0))\n        camel_right.sort(key=itemgetter(0))\n        hq = []\n        i = 0\n        for j in range(1, N + 1):\n            while i < len(camel_left) and camel_left[i][0] == j:\n                heapq.heappush(hq, camel_left[i][1] - camel_left[i][2])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        hq = []\n        i = 0\n        for j in range(1, N):\n            while i < len(camel_right) and camel_right[i][0] == j:\n                heapq.heappush(hq, camel_right[i][0] - camel_right[i][1])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "heapq.heappush(hq, camel_right[i][2] - camel_right[i][1])",
      "mutated_line": "heapq.heappush(hq, camel_right[i][1] - camel_right[i][1])",
      "code": "import heapq\nfrom operator import itemgetter\n\ndef calculate_max_happiness(T, test_cases):\n    results = []\n    for case in test_cases:\n        N = len(case)\n        res = 0\n        camel_left = []\n        camel_right = []\n        for (K, L, R) in case:\n            res += min(L, R)\n            if R <= L:\n                camel_left.append([K, L, R])\n            elif K != N:\n                camel_right.append([N - K, L, R])\n        camel_left.sort(key=itemgetter(0))\n        camel_right.sort(key=itemgetter(0))\n        hq = []\n        i = 0\n        for j in range(1, N + 1):\n            while i < len(camel_left) and camel_left[i][0] == j:\n                heapq.heappush(hq, camel_left[i][1] - camel_left[i][2])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        hq = []\n        i = 0\n        for j in range(1, N):\n            while i < len(camel_right) and camel_right[i][0] == j:\n                heapq.heappush(hq, camel_right[i][1] - camel_right[i][1])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "heapq.heappush(hq, camel_right[i][2] - camel_right[i][1])",
      "mutated_line": "heapq.heappush(hq, camel_right[i][-2] - camel_right[i][1])",
      "code": "import heapq\nfrom operator import itemgetter\n\ndef calculate_max_happiness(T, test_cases):\n    results = []\n    for case in test_cases:\n        N = len(case)\n        res = 0\n        camel_left = []\n        camel_right = []\n        for (K, L, R) in case:\n            res += min(L, R)\n            if R <= L:\n                camel_left.append([K, L, R])\n            elif K != N:\n                camel_right.append([N - K, L, R])\n        camel_left.sort(key=itemgetter(0))\n        camel_right.sort(key=itemgetter(0))\n        hq = []\n        i = 0\n        for j in range(1, N + 1):\n            while i < len(camel_left) and camel_left[i][0] == j:\n                heapq.heappush(hq, camel_left[i][1] - camel_left[i][2])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        hq = []\n        i = 0\n        for j in range(1, N):\n            while i < len(camel_right) and camel_right[i][0] == j:\n                heapq.heappush(hq, camel_right[i][-2] - camel_right[i][1])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "heapq.heappush(hq, camel_right[i][2] - camel_right[i][1])",
      "mutated_line": "heapq.heappush(hq, camel_right[i][2] - camel_right[i][2])",
      "code": "import heapq\nfrom operator import itemgetter\n\ndef calculate_max_happiness(T, test_cases):\n    results = []\n    for case in test_cases:\n        N = len(case)\n        res = 0\n        camel_left = []\n        camel_right = []\n        for (K, L, R) in case:\n            res += min(L, R)\n            if R <= L:\n                camel_left.append([K, L, R])\n            elif K != N:\n                camel_right.append([N - K, L, R])\n        camel_left.sort(key=itemgetter(0))\n        camel_right.sort(key=itemgetter(0))\n        hq = []\n        i = 0\n        for j in range(1, N + 1):\n            while i < len(camel_left) and camel_left[i][0] == j:\n                heapq.heappush(hq, camel_left[i][1] - camel_left[i][2])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        hq = []\n        i = 0\n        for j in range(1, N):\n            while i < len(camel_right) and camel_right[i][0] == j:\n                heapq.heappush(hq, camel_right[i][2] - camel_right[i][2])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "heapq.heappush(hq, camel_right[i][2] - camel_right[i][1])",
      "mutated_line": "heapq.heappush(hq, camel_right[i][2] - camel_right[i][0])",
      "code": "import heapq\nfrom operator import itemgetter\n\ndef calculate_max_happiness(T, test_cases):\n    results = []\n    for case in test_cases:\n        N = len(case)\n        res = 0\n        camel_left = []\n        camel_right = []\n        for (K, L, R) in case:\n            res += min(L, R)\n            if R <= L:\n                camel_left.append([K, L, R])\n            elif K != N:\n                camel_right.append([N - K, L, R])\n        camel_left.sort(key=itemgetter(0))\n        camel_right.sort(key=itemgetter(0))\n        hq = []\n        i = 0\n        for j in range(1, N + 1):\n            while i < len(camel_left) and camel_left[i][0] == j:\n                heapq.heappush(hq, camel_left[i][1] - camel_left[i][2])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        hq = []\n        i = 0\n        for j in range(1, N):\n            while i < len(camel_right) and camel_right[i][0] == j:\n                heapq.heappush(hq, camel_right[i][2] - camel_right[i][0])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "heapq.heappush(hq, camel_right[i][2] - camel_right[i][1])",
      "mutated_line": "heapq.heappush(hq, camel_right[i][2] - camel_right[i][0])",
      "code": "import heapq\nfrom operator import itemgetter\n\ndef calculate_max_happiness(T, test_cases):\n    results = []\n    for case in test_cases:\n        N = len(case)\n        res = 0\n        camel_left = []\n        camel_right = []\n        for (K, L, R) in case:\n            res += min(L, R)\n            if R <= L:\n                camel_left.append([K, L, R])\n            elif K != N:\n                camel_right.append([N - K, L, R])\n        camel_left.sort(key=itemgetter(0))\n        camel_right.sort(key=itemgetter(0))\n        hq = []\n        i = 0\n        for j in range(1, N + 1):\n            while i < len(camel_left) and camel_left[i][0] == j:\n                heapq.heappush(hq, camel_left[i][1] - camel_left[i][2])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        hq = []\n        i = 0\n        for j in range(1, N):\n            while i < len(camel_right) and camel_right[i][0] == j:\n                heapq.heappush(hq, camel_right[i][2] - camel_right[i][0])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "heapq.heappush(hq, camel_right[i][2] - camel_right[i][1])",
      "mutated_line": "heapq.heappush(hq, camel_right[i][2] - camel_right[i][-1])",
      "code": "import heapq\nfrom operator import itemgetter\n\ndef calculate_max_happiness(T, test_cases):\n    results = []\n    for case in test_cases:\n        N = len(case)\n        res = 0\n        camel_left = []\n        camel_right = []\n        for (K, L, R) in case:\n            res += min(L, R)\n            if R <= L:\n                camel_left.append([K, L, R])\n            elif K != N:\n                camel_right.append([N - K, L, R])\n        camel_left.sort(key=itemgetter(0))\n        camel_right.sort(key=itemgetter(0))\n        hq = []\n        i = 0\n        for j in range(1, N + 1):\n            while i < len(camel_left) and camel_left[i][0] == j:\n                heapq.heappush(hq, camel_left[i][1] - camel_left[i][2])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        hq = []\n        i = 0\n        for j in range(1, N):\n            while i < len(camel_right) and camel_right[i][0] == j:\n                heapq.heappush(hq, camel_right[i][2] - camel_right[i][-1])\n                i += 1\n            while len(hq) > j:\n                heapq.heappop(hq)\n        res += sum(hq)\n        results.append(res)\n    return results"
    }
  ]
}