{
  "task_id": "taco_2182",
  "entry_point": "calculate_edge_values",
  "mutant_count": 114,
  "mutants": [
    {
      "operator": "ASR",
      "lineno": 7,
      "original_line": "total[color] += 1",
      "mutated_line": "total[color] -= 1",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] -= 1\n    child = [[] for _ in range(n + 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] * (n - 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 1] not in d:\n            d[colors[p - 1]] = 1\n            if total[colors[p - 1]] > 1:\n                nextvalue += colors[p - 1]\n        else:\n            d[colors[p - 1]] += 1\n            if d[colors[p - 1]] == total[colors[p - 1]]:\n                nextvalue -= colors[p - 1]\n        return [d, nextvalue]\n    dfs(1, -1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "ans = [0] * (n - 1)",
      "mutated_line": "",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 1\n    child = [[] for _ in range(n + 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] / (n - 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 1] not in d:\n            d[colors[p - 1]] = 1\n            if total[colors[p - 1]] > 1:\n                nextvalue += colors[p - 1]\n        else:\n            d[colors[p - 1]] += 1\n            if d[colors[p - 1]] == total[colors[p - 1]]:\n                nextvalue -= colors[p - 1]\n        return [d, nextvalue]\n    dfs(1, -1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "ans = [0] * (n - 1)",
      "mutated_line": "",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 1\n    child = [[] for _ in range(n + 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] + (n - 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 1] not in d:\n            d[colors[p - 1]] = 1\n            if total[colors[p - 1]] > 1:\n                nextvalue += colors[p - 1]\n        else:\n            d[colors[p - 1]] += 1\n            if d[colors[p - 1]] == total[colors[p - 1]]:\n                nextvalue -= colors[p - 1]\n        return [d, nextvalue]\n    dfs(1, -1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "ans = [0] * (n - 1)",
      "mutated_line": "",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 1\n    child = [[] for _ in range(n + 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] ** (n - 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 1] not in d:\n            d[colors[p - 1]] = 1\n            if total[colors[p - 1]] > 1:\n                nextvalue += colors[p - 1]\n        else:\n            d[colors[p - 1]] += 1\n            if d[colors[p - 1]] == total[colors[p - 1]]:\n                nextvalue -= colors[p - 1]\n        return [d, nextvalue]\n    dfs(1, -1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "total[color] += 1",
      "mutated_line": "total[color] += 2",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 2\n    child = [[] for _ in range(n + 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] * (n - 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 1] not in d:\n            d[colors[p - 1]] = 1\n            if total[colors[p - 1]] > 1:\n                nextvalue += colors[p - 1]\n        else:\n            d[colors[p - 1]] += 1\n            if d[colors[p - 1]] == total[colors[p - 1]]:\n                nextvalue -= colors[p - 1]\n        return [d, nextvalue]\n    dfs(1, -1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "total[color] += 1",
      "mutated_line": "total[color] += 0",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 0\n    child = [[] for _ in range(n + 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] * (n - 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 1] not in d:\n            d[colors[p - 1]] = 1\n            if total[colors[p - 1]] > 1:\n                nextvalue += colors[p - 1]\n        else:\n            d[colors[p - 1]] += 1\n            if d[colors[p - 1]] == total[colors[p - 1]]:\n                nextvalue -= colors[p - 1]\n        return [d, nextvalue]\n    dfs(1, -1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "total[color] += 1",
      "mutated_line": "total[color] += 0",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 0\n    child = [[] for _ in range(n + 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] * (n - 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 1] not in d:\n            d[colors[p - 1]] = 1\n            if total[colors[p - 1]] > 1:\n                nextvalue += colors[p - 1]\n        else:\n            d[colors[p - 1]] += 1\n            if d[colors[p - 1]] == total[colors[p - 1]]:\n                nextvalue -= colors[p - 1]\n        return [d, nextvalue]\n    dfs(1, -1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "total[color] += 1",
      "mutated_line": "total[color] += -1",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += -1\n    child = [[] for _ in range(n + 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] * (n - 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 1] not in d:\n            d[colors[p - 1]] = 1\n            if total[colors[p - 1]] > 1:\n                nextvalue += colors[p - 1]\n        else:\n            d[colors[p - 1]] += 1\n            if d[colors[p - 1]] == total[colors[p - 1]]:\n                nextvalue -= colors[p - 1]\n        return [d, nextvalue]\n    dfs(1, -1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "ans = [0] * (n - 1)",
      "mutated_line": "",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 1\n    child = [[] for _ in range(n + 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] * (n + 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 1] not in d:\n            d[colors[p - 1]] = 1\n            if total[colors[p - 1]] > 1:\n                nextvalue += colors[p - 1]\n        else:\n            d[colors[p - 1]] += 1\n            if d[colors[p - 1]] == total[colors[p - 1]]:\n                nextvalue -= colors[p - 1]\n        return [d, nextvalue]\n    dfs(1, -1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "ans = [0] * (n - 1)",
      "mutated_line": "",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 1\n    child = [[] for _ in range(n + 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] * (n * 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 1] not in d:\n            d[colors[p - 1]] = 1\n            if total[colors[p - 1]] > 1:\n                nextvalue += colors[p - 1]\n        else:\n            d[colors[p - 1]] += 1\n            if d[colors[p - 1]] == total[colors[p - 1]]:\n                nextvalue -= colors[p - 1]\n        return [d, nextvalue]\n    dfs(1, -1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "nextvalue = 0",
      "mutated_line": "nextvalue = 1",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 1\n    child = [[] for _ in range(n + 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] * (n - 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 1\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 1] not in d:\n            d[colors[p - 1]] = 1\n            if total[colors[p - 1]] > 1:\n                nextvalue += colors[p - 1]\n        else:\n            d[colors[p - 1]] += 1\n            if d[colors[p - 1]] == total[colors[p - 1]]:\n                nextvalue -= colors[p - 1]\n        return [d, nextvalue]\n    dfs(1, -1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "nextvalue = 0",
      "mutated_line": "nextvalue = -1",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 1\n    child = [[] for _ in range(n + 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] * (n - 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = -1\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 1] not in d:\n            d[colors[p - 1]] = 1\n            if total[colors[p - 1]] > 1:\n                nextvalue += colors[p - 1]\n        else:\n            d[colors[p - 1]] += 1\n            if d[colors[p - 1]] == total[colors[p - 1]]:\n                nextvalue -= colors[p - 1]\n        return [d, nextvalue]\n    dfs(1, -1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "nextvalue = 0",
      "mutated_line": "nextvalue = 1",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 1\n    child = [[] for _ in range(n + 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] * (n - 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 1\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 1] not in d:\n            d[colors[p - 1]] = 1\n            if total[colors[p - 1]] > 1:\n                nextvalue += colors[p - 1]\n        else:\n            d[colors[p - 1]] += 1\n            if d[colors[p - 1]] == total[colors[p - 1]]:\n                nextvalue -= colors[p - 1]\n        return [d, nextvalue]\n    dfs(1, -1)\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 35,
      "original_line": "nextvalue += value",
      "mutated_line": "nextvalue -= value",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 1\n    child = [[] for _ in range(n + 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] * (n - 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue -= value\n        if colors[p - 1] not in d:\n            d[colors[p - 1]] = 1\n            if total[colors[p - 1]] > 1:\n                nextvalue += colors[p - 1]\n        else:\n            d[colors[p - 1]] += 1\n            if d[colors[p - 1]] == total[colors[p - 1]]:\n                nextvalue -= colors[p - 1]\n        return [d, nextvalue]\n    dfs(1, -1)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if colors[p - 1] not in d:",
      "mutated_line": "if colors[p - 1] in d:",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 1\n    child = [[] for _ in range(n + 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] * (n - 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 1] in d:\n            d[colors[p - 1]] = 1\n            if total[colors[p - 1]] > 1:\n                nextvalue += colors[p - 1]\n        else:\n            d[colors[p - 1]] += 1\n            if d[colors[p - 1]] == total[colors[p - 1]]:\n                nextvalue -= colors[p - 1]\n        return [d, nextvalue]\n    dfs(1, -1)\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 41,
      "original_line": "d[colors[p - 1]] += 1",
      "mutated_line": "d[colors[p - 1]] -= 1",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 1\n    child = [[] for _ in range(n + 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] * (n - 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 1] not in d:\n            d[colors[p - 1]] = 1\n            if total[colors[p - 1]] > 1:\n                nextvalue += colors[p - 1]\n        else:\n            d[colors[p - 1]] -= 1\n            if d[colors[p - 1]] == total[colors[p - 1]]:\n                nextvalue -= colors[p - 1]\n        return [d, nextvalue]\n    dfs(1, -1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "dfs(1, -1)",
      "mutated_line": "dfs(2, -1)",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 1\n    child = [[] for _ in range(n + 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] * (n - 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 1] not in d:\n            d[colors[p - 1]] = 1\n            if total[colors[p - 1]] > 1:\n                nextvalue += colors[p - 1]\n        else:\n            d[colors[p - 1]] += 1\n            if d[colors[p - 1]] == total[colors[p - 1]]:\n                nextvalue -= colors[p - 1]\n        return [d, nextvalue]\n    dfs(2, -1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "dfs(1, -1)",
      "mutated_line": "dfs(0, -1)",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 1\n    child = [[] for _ in range(n + 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] * (n - 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 1] not in d:\n            d[colors[p - 1]] = 1\n            if total[colors[p - 1]] > 1:\n                nextvalue += colors[p - 1]\n        else:\n            d[colors[p - 1]] += 1\n            if d[colors[p - 1]] == total[colors[p - 1]]:\n                nextvalue -= colors[p - 1]\n        return [d, nextvalue]\n    dfs(0, -1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "dfs(1, -1)",
      "mutated_line": "dfs(0, -1)",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 1\n    child = [[] for _ in range(n + 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] * (n - 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 1] not in d:\n            d[colors[p - 1]] = 1\n            if total[colors[p - 1]] > 1:\n                nextvalue += colors[p - 1]\n        else:\n            d[colors[p - 1]] += 1\n            if d[colors[p - 1]] == total[colors[p - 1]]:\n                nextvalue -= colors[p - 1]\n        return [d, nextvalue]\n    dfs(0, -1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "dfs(1, -1)",
      "mutated_line": "dfs(-1, -1)",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 1\n    child = [[] for _ in range(n + 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] * (n - 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 1] not in d:\n            d[colors[p - 1]] = 1\n            if total[colors[p - 1]] > 1:\n                nextvalue += colors[p - 1]\n        else:\n            d[colors[p - 1]] += 1\n            if d[colors[p - 1]] == total[colors[p - 1]]:\n                nextvalue -= colors[p - 1]\n        return [d, nextvalue]\n    dfs(-1, -1)\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 46,
      "original_line": "dfs(1, -1)",
      "mutated_line": "dfs(1, +1)",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 1\n    child = [[] for _ in range(n + 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] * (n - 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 1] not in d:\n            d[colors[p - 1]] = 1\n            if total[colors[p - 1]] > 1:\n                nextvalue += colors[p - 1]\n        else:\n            d[colors[p - 1]] += 1\n            if d[colors[p - 1]] == total[colors[p - 1]]:\n                nextvalue -= colors[p - 1]\n        return [d, nextvalue]\n    dfs(1, +1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ans = [0] * (n - 1)",
      "mutated_line": "",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 1\n    child = [[] for _ in range(n + 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [1] * (n - 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 1] not in d:\n            d[colors[p - 1]] = 1\n            if total[colors[p - 1]] > 1:\n                nextvalue += colors[p - 1]\n        else:\n            d[colors[p - 1]] += 1\n            if d[colors[p - 1]] == total[colors[p - 1]]:\n                nextvalue -= colors[p - 1]\n        return [d, nextvalue]\n    dfs(1, -1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ans = [0] * (n - 1)",
      "mutated_line": "",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 1\n    child = [[] for _ in range(n + 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [-1] * (n - 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 1] not in d:\n            d[colors[p - 1]] = 1\n            if total[colors[p - 1]] > 1:\n                nextvalue += colors[p - 1]\n        else:\n            d[colors[p - 1]] += 1\n            if d[colors[p - 1]] == total[colors[p - 1]]:\n                nextvalue -= colors[p - 1]\n        return [d, nextvalue]\n    dfs(1, -1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ans = [0] * (n - 1)",
      "mutated_line": "",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 1\n    child = [[] for _ in range(n + 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [1] * (n - 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 1] not in d:\n            d[colors[p - 1]] = 1\n            if total[colors[p - 1]] > 1:\n                nextvalue += colors[p - 1]\n        else:\n            d[colors[p - 1]] += 1\n            if d[colors[p - 1]] == total[colors[p - 1]]:\n                nextvalue -= colors[p - 1]\n        return [d, nextvalue]\n    dfs(1, -1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ans = [0] * (n - 1)",
      "mutated_line": "",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 1\n    child = [[] for _ in range(n + 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] * (n - 2)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 1] not in d:\n            d[colors[p - 1]] = 1\n            if total[colors[p - 1]] > 1:\n                nextvalue += colors[p - 1]\n        else:\n            d[colors[p - 1]] += 1\n            if d[colors[p - 1]] == total[colors[p - 1]]:\n                nextvalue -= colors[p - 1]\n        return [d, nextvalue]\n    dfs(1, -1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ans = [0] * (n - 1)",
      "mutated_line": "",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 1\n    child = [[] for _ in range(n + 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] * (n - 0)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 1] not in d:\n            d[colors[p - 1]] = 1\n            if total[colors[p - 1]] > 1:\n                nextvalue += colors[p - 1]\n        else:\n            d[colors[p - 1]] += 1\n            if d[colors[p - 1]] == total[colors[p - 1]]:\n                nextvalue -= colors[p - 1]\n        return [d, nextvalue]\n    dfs(1, -1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ans = [0] * (n - 1)",
      "mutated_line": "",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 1\n    child = [[] for _ in range(n + 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] * (n - 0)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 1] not in d:\n            d[colors[p - 1]] = 1\n            if total[colors[p - 1]] > 1:\n                nextvalue += colors[p - 1]\n        else:\n            d[colors[p - 1]] += 1\n            if d[colors[p - 1]] == total[colors[p - 1]]:\n                nextvalue -= colors[p - 1]\n        return [d, nextvalue]\n    dfs(1, -1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ans = [0] * (n - 1)",
      "mutated_line": "",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 1\n    child = [[] for _ in range(n + 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] * (n - -1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 1] not in d:\n            d[colors[p - 1]] = 1\n            if total[colors[p - 1]] > 1:\n                nextvalue += colors[p - 1]\n        else:\n            d[colors[p - 1]] += 1\n            if d[colors[p - 1]] == total[colors[p - 1]]:\n                nextvalue -= colors[p - 1]\n        return [d, nextvalue]\n    dfs(1, -1)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if prev == u:",
      "mutated_line": "if prev != u:",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 1\n    child = [[] for _ in range(n + 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] * (n - 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev != u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 1] not in d:\n            d[colors[p - 1]] = 1\n            if total[colors[p - 1]] > 1:\n                nextvalue += colors[p - 1]\n        else:\n            d[colors[p - 1]] += 1\n            if d[colors[p - 1]] == total[colors[p - 1]]:\n                nextvalue -= colors[p - 1]\n        return [d, nextvalue]\n    dfs(1, -1)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if len(take) > len(d):",
      "mutated_line": "if len(take) >= len(d):",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 1\n    child = [[] for _ in range(n + 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] * (n - 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) >= len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 1] not in d:\n            d[colors[p - 1]] = 1\n            if total[colors[p - 1]] > 1:\n                nextvalue += colors[p - 1]\n        else:\n            d[colors[p - 1]] += 1\n            if d[colors[p - 1]] == total[colors[p - 1]]:\n                nextvalue -= colors[p - 1]\n        return [d, nextvalue]\n    dfs(1, -1)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if len(take) > len(d):",
      "mutated_line": "if len(take) <= len(d):",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 1\n    child = [[] for _ in range(n + 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] * (n - 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) <= len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 1] not in d:\n            d[colors[p - 1]] = 1\n            if total[colors[p - 1]] > 1:\n                nextvalue += colors[p - 1]\n        else:\n            d[colors[p - 1]] += 1\n            if d[colors[p - 1]] == total[colors[p - 1]]:\n                nextvalue -= colors[p - 1]\n        return [d, nextvalue]\n    dfs(1, -1)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if len(take) > len(d):",
      "mutated_line": "if len(take) != len(d):",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 1\n    child = [[] for _ in range(n + 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] * (n - 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) != len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 1] not in d:\n            d[colors[p - 1]] = 1\n            if total[colors[p - 1]] > 1:\n                nextvalue += colors[p - 1]\n        else:\n            d[colors[p - 1]] += 1\n            if d[colors[p - 1]] == total[colors[p - 1]]:\n                nextvalue -= colors[p - 1]\n        return [d, nextvalue]\n    dfs(1, -1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "d[colors[p - 1]] = 1",
      "mutated_line": "d[colors[p - 1]] = 2",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 1\n    child = [[] for _ in range(n + 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] * (n - 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 1] not in d:\n            d[colors[p - 1]] = 2\n            if total[colors[p - 1]] > 1:\n                nextvalue += colors[p - 1]\n        else:\n            d[colors[p - 1]] += 1\n            if d[colors[p - 1]] == total[colors[p - 1]]:\n                nextvalue -= colors[p - 1]\n        return [d, nextvalue]\n    dfs(1, -1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "d[colors[p - 1]] = 1",
      "mutated_line": "d[colors[p - 1]] = 0",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 1\n    child = [[] for _ in range(n + 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] * (n - 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 1] not in d:\n            d[colors[p - 1]] = 0\n            if total[colors[p - 1]] > 1:\n                nextvalue += colors[p - 1]\n        else:\n            d[colors[p - 1]] += 1\n            if d[colors[p - 1]] == total[colors[p - 1]]:\n                nextvalue -= colors[p - 1]\n        return [d, nextvalue]\n    dfs(1, -1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "d[colors[p - 1]] = 1",
      "mutated_line": "d[colors[p - 1]] = 0",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 1\n    child = [[] for _ in range(n + 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] * (n - 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 1] not in d:\n            d[colors[p - 1]] = 0\n            if total[colors[p - 1]] > 1:\n                nextvalue += colors[p - 1]\n        else:\n            d[colors[p - 1]] += 1\n            if d[colors[p - 1]] == total[colors[p - 1]]:\n                nextvalue -= colors[p - 1]\n        return [d, nextvalue]\n    dfs(1, -1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "d[colors[p - 1]] = 1",
      "mutated_line": "d[colors[p - 1]] = -1",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 1\n    child = [[] for _ in range(n + 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] * (n - 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 1] not in d:\n            d[colors[p - 1]] = -1\n            if total[colors[p - 1]] > 1:\n                nextvalue += colors[p - 1]\n        else:\n            d[colors[p - 1]] += 1\n            if d[colors[p - 1]] == total[colors[p - 1]]:\n                nextvalue -= colors[p - 1]\n        return [d, nextvalue]\n    dfs(1, -1)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if total[colors[p - 1]] > 1:",
      "mutated_line": "if total[colors[p - 1]] >= 1:",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 1\n    child = [[] for _ in range(n + 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] * (n - 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 1] not in d:\n            d[colors[p - 1]] = 1\n            if total[colors[p - 1]] >= 1:\n                nextvalue += colors[p - 1]\n        else:\n            d[colors[p - 1]] += 1\n            if d[colors[p - 1]] == total[colors[p - 1]]:\n                nextvalue -= colors[p - 1]\n        return [d, nextvalue]\n    dfs(1, -1)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if total[colors[p - 1]] > 1:",
      "mutated_line": "if total[colors[p - 1]] <= 1:",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 1\n    child = [[] for _ in range(n + 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] * (n - 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 1] not in d:\n            d[colors[p - 1]] = 1\n            if total[colors[p - 1]] <= 1:\n                nextvalue += colors[p - 1]\n        else:\n            d[colors[p - 1]] += 1\n            if d[colors[p - 1]] == total[colors[p - 1]]:\n                nextvalue -= colors[p - 1]\n        return [d, nextvalue]\n    dfs(1, -1)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if total[colors[p - 1]] > 1:",
      "mutated_line": "if total[colors[p - 1]] != 1:",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 1\n    child = [[] for _ in range(n + 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] * (n - 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 1] not in d:\n            d[colors[p - 1]] = 1\n            if total[colors[p - 1]] != 1:\n                nextvalue += colors[p - 1]\n        else:\n            d[colors[p - 1]] += 1\n            if d[colors[p - 1]] == total[colors[p - 1]]:\n                nextvalue -= colors[p - 1]\n        return [d, nextvalue]\n    dfs(1, -1)\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 39,
      "original_line": "nextvalue += colors[p - 1]",
      "mutated_line": "nextvalue -= colors[p - 1]",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 1\n    child = [[] for _ in range(n + 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] * (n - 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 1] not in d:\n            d[colors[p - 1]] = 1\n            if total[colors[p - 1]] > 1:\n                nextvalue -= colors[p - 1]\n        else:\n            d[colors[p - 1]] += 1\n            if d[colors[p - 1]] == total[colors[p - 1]]:\n                nextvalue -= colors[p - 1]\n        return [d, nextvalue]\n    dfs(1, -1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "d[colors[p - 1]] += 1",
      "mutated_line": "d[colors[p - 1]] += 2",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 1\n    child = [[] for _ in range(n + 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] * (n - 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 1] not in d:\n            d[colors[p - 1]] = 1\n            if total[colors[p - 1]] > 1:\n                nextvalue += colors[p - 1]\n        else:\n            d[colors[p - 1]] += 2\n            if d[colors[p - 1]] == total[colors[p - 1]]:\n                nextvalue -= colors[p - 1]\n        return [d, nextvalue]\n    dfs(1, -1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "d[colors[p - 1]] += 1",
      "mutated_line": "d[colors[p - 1]] += 0",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 1\n    child = [[] for _ in range(n + 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] * (n - 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 1] not in d:\n            d[colors[p - 1]] = 1\n            if total[colors[p - 1]] > 1:\n                nextvalue += colors[p - 1]\n        else:\n            d[colors[p - 1]] += 0\n            if d[colors[p - 1]] == total[colors[p - 1]]:\n                nextvalue -= colors[p - 1]\n        return [d, nextvalue]\n    dfs(1, -1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "d[colors[p - 1]] += 1",
      "mutated_line": "d[colors[p - 1]] += 0",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 1\n    child = [[] for _ in range(n + 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] * (n - 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 1] not in d:\n            d[colors[p - 1]] = 1\n            if total[colors[p - 1]] > 1:\n                nextvalue += colors[p - 1]\n        else:\n            d[colors[p - 1]] += 0\n            if d[colors[p - 1]] == total[colors[p - 1]]:\n                nextvalue -= colors[p - 1]\n        return [d, nextvalue]\n    dfs(1, -1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "d[colors[p - 1]] += 1",
      "mutated_line": "d[colors[p - 1]] += -1",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 1\n    child = [[] for _ in range(n + 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] * (n - 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 1] not in d:\n            d[colors[p - 1]] = 1\n            if total[colors[p - 1]] > 1:\n                nextvalue += colors[p - 1]\n        else:\n            d[colors[p - 1]] += -1\n            if d[colors[p - 1]] == total[colors[p - 1]]:\n                nextvalue -= colors[p - 1]\n        return [d, nextvalue]\n    dfs(1, -1)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if d[colors[p - 1]] == total[colors[p - 1]]:",
      "mutated_line": "if d[colors[p - 1]] != total[colors[p - 1]]:",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 1\n    child = [[] for _ in range(n + 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] * (n - 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 1] not in d:\n            d[colors[p - 1]] = 1\n            if total[colors[p - 1]] > 1:\n                nextvalue += colors[p - 1]\n        else:\n            d[colors[p - 1]] += 1\n            if d[colors[p - 1]] != total[colors[p - 1]]:\n                nextvalue -= colors[p - 1]\n        return [d, nextvalue]\n    dfs(1, -1)\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 43,
      "original_line": "nextvalue -= colors[p - 1]",
      "mutated_line": "nextvalue += colors[p - 1]",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 1\n    child = [[] for _ in range(n + 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] * (n - 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 1] not in d:\n            d[colors[p - 1]] = 1\n            if total[colors[p - 1]] > 1:\n                nextvalue += colors[p - 1]\n        else:\n            d[colors[p - 1]] += 1\n            if d[colors[p - 1]] == total[colors[p - 1]]:\n                nextvalue += colors[p - 1]\n        return [d, nextvalue]\n    dfs(1, -1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "dfs(1, -1)",
      "mutated_line": "dfs(1, -2)",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 1\n    child = [[] for _ in range(n + 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] * (n - 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 1] not in d:\n            d[colors[p - 1]] = 1\n            if total[colors[p - 1]] > 1:\n                nextvalue += colors[p - 1]\n        else:\n            d[colors[p - 1]] += 1\n            if d[colors[p - 1]] == total[colors[p - 1]]:\n                nextvalue -= colors[p - 1]\n        return [d, nextvalue]\n    dfs(1, -2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "dfs(1, -1)",
      "mutated_line": "dfs(1, -0)",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 1\n    child = [[] for _ in range(n + 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] * (n - 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 1] not in d:\n            d[colors[p - 1]] = 1\n            if total[colors[p - 1]] > 1:\n                nextvalue += colors[p - 1]\n        else:\n            d[colors[p - 1]] += 1\n            if d[colors[p - 1]] == total[colors[p - 1]]:\n                nextvalue -= colors[p - 1]\n        return [d, nextvalue]\n    dfs(1, -0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "dfs(1, -1)",
      "mutated_line": "dfs(1, -0)",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 1\n    child = [[] for _ in range(n + 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] * (n - 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 1] not in d:\n            d[colors[p - 1]] = 1\n            if total[colors[p - 1]] > 1:\n                nextvalue += colors[p - 1]\n        else:\n            d[colors[p - 1]] += 1\n            if d[colors[p - 1]] == total[colors[p - 1]]:\n                nextvalue -= colors[p - 1]\n        return [d, nextvalue]\n    dfs(1, -0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "dfs(1, -1)",
      "mutated_line": "dfs(1, --1)",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 1\n    child = [[] for _ in range(n + 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] * (n - 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 1] not in d:\n            d[colors[p - 1]] = 1\n            if total[colors[p - 1]] > 1:\n                nextvalue += colors[p - 1]\n        else:\n            d[colors[p - 1]] += 1\n            if d[colors[p - 1]] == total[colors[p - 1]]:\n                nextvalue -= colors[p - 1]\n        return [d, nextvalue]\n    dfs(1, --1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "child = [[] for _ in range(n + 1)]",
      "mutated_line": "for (i, (u, v)) in enumerate(edges):",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 1\n    child = [[] for _ in range(n - 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] * (n - 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 1] not in d:\n            d[colors[p - 1]] = 1\n            if total[colors[p - 1]] > 1:\n                nextvalue += colors[p - 1]\n        else:\n            d[colors[p - 1]] += 1\n            if d[colors[p - 1]] == total[colors[p - 1]]:\n                nextvalue -= colors[p - 1]\n        return [d, nextvalue]\n    dfs(1, -1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "child = [[] for _ in range(n + 1)]",
      "mutated_line": "for (i, (u, v)) in enumerate(edges):",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 1\n    child = [[] for _ in range(n * 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] * (n - 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 1] not in d:\n            d[colors[p - 1]] = 1\n            if total[colors[p - 1]] > 1:\n                nextvalue += colors[p - 1]\n        else:\n            d[colors[p - 1]] += 1\n            if d[colors[p - 1]] == total[colors[p - 1]]:\n                nextvalue -= colors[p - 1]\n        return [d, nextvalue]\n    dfs(1, -1)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if x in d:",
      "mutated_line": "if x not in d:",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 1\n    child = [[] for _ in range(n + 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] * (n - 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x not in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 1] not in d:\n            d[colors[p - 1]] = 1\n            if total[colors[p - 1]] > 1:\n                nextvalue += colors[p - 1]\n        else:\n            d[colors[p - 1]] += 1\n            if d[colors[p - 1]] == total[colors[p - 1]]:\n                nextvalue -= colors[p - 1]\n        return [d, nextvalue]\n    dfs(1, -1)\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 28,
      "original_line": "d[x] += take[x]",
      "mutated_line": "d[x] -= take[x]",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 1\n    child = [[] for _ in range(n + 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] * (n - 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] -= take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 1] not in d:\n            d[colors[p - 1]] = 1\n            if total[colors[p - 1]] > 1:\n                nextvalue += colors[p - 1]\n        else:\n            d[colors[p - 1]] += 1\n            if d[colors[p - 1]] == total[colors[p - 1]]:\n                nextvalue -= colors[p - 1]\n        return [d, nextvalue]\n    dfs(1, -1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "if colors[p - 1] not in d:",
      "mutated_line": "if colors[p + 1] not in d:",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 1\n    child = [[] for _ in range(n + 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] * (n - 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p + 1] not in d:\n            d[colors[p - 1]] = 1\n            if total[colors[p - 1]] > 1:\n                nextvalue += colors[p - 1]\n        else:\n            d[colors[p - 1]] += 1\n            if d[colors[p - 1]] == total[colors[p - 1]]:\n                nextvalue -= colors[p - 1]\n        return [d, nextvalue]\n    dfs(1, -1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "if colors[p - 1] not in d:",
      "mutated_line": "if colors[p * 1] not in d:",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 1\n    child = [[] for _ in range(n + 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] * (n - 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p * 1] not in d:\n            d[colors[p - 1]] = 1\n            if total[colors[p - 1]] > 1:\n                nextvalue += colors[p - 1]\n        else:\n            d[colors[p - 1]] += 1\n            if d[colors[p - 1]] == total[colors[p - 1]]:\n                nextvalue -= colors[p - 1]\n        return [d, nextvalue]\n    dfs(1, -1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if total[colors[p - 1]] > 1:",
      "mutated_line": "if total[colors[p - 1]] > 2:",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 1\n    child = [[] for _ in range(n + 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] * (n - 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 1] not in d:\n            d[colors[p - 1]] = 1\n            if total[colors[p - 1]] > 2:\n                nextvalue += colors[p - 1]\n        else:\n            d[colors[p - 1]] += 1\n            if d[colors[p - 1]] == total[colors[p - 1]]:\n                nextvalue -= colors[p - 1]\n        return [d, nextvalue]\n    dfs(1, -1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if total[colors[p - 1]] > 1:",
      "mutated_line": "if total[colors[p - 1]] > 0:",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 1\n    child = [[] for _ in range(n + 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] * (n - 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 1] not in d:\n            d[colors[p - 1]] = 1\n            if total[colors[p - 1]] > 0:\n                nextvalue += colors[p - 1]\n        else:\n            d[colors[p - 1]] += 1\n            if d[colors[p - 1]] == total[colors[p - 1]]:\n                nextvalue -= colors[p - 1]\n        return [d, nextvalue]\n    dfs(1, -1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if total[colors[p - 1]] > 1:",
      "mutated_line": "if total[colors[p - 1]] > 0:",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 1\n    child = [[] for _ in range(n + 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] * (n - 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 1] not in d:\n            d[colors[p - 1]] = 1\n            if total[colors[p - 1]] > 0:\n                nextvalue += colors[p - 1]\n        else:\n            d[colors[p - 1]] += 1\n            if d[colors[p - 1]] == total[colors[p - 1]]:\n                nextvalue -= colors[p - 1]\n        return [d, nextvalue]\n    dfs(1, -1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if total[colors[p - 1]] > 1:",
      "mutated_line": "if total[colors[p - 1]] > -1:",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 1\n    child = [[] for _ in range(n + 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] * (n - 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 1] not in d:\n            d[colors[p - 1]] = 1\n            if total[colors[p - 1]] > -1:\n                nextvalue += colors[p - 1]\n        else:\n            d[colors[p - 1]] += 1\n            if d[colors[p - 1]] == total[colors[p - 1]]:\n                nextvalue -= colors[p - 1]\n        return [d, nextvalue]\n    dfs(1, -1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "child = [[] for _ in range(n + 1)]",
      "mutated_line": "for (i, (u, v)) in enumerate(edges):",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 1\n    child = [[] for _ in range(n + 2)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] * (n - 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 1] not in d:\n            d[colors[p - 1]] = 1\n            if total[colors[p - 1]] > 1:\n                nextvalue += colors[p - 1]\n        else:\n            d[colors[p - 1]] += 1\n            if d[colors[p - 1]] == total[colors[p - 1]]:\n                nextvalue -= colors[p - 1]\n        return [d, nextvalue]\n    dfs(1, -1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "child = [[] for _ in range(n + 1)]",
      "mutated_line": "for (i, (u, v)) in enumerate(edges):",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 1\n    child = [[] for _ in range(n + 0)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] * (n - 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 1] not in d:\n            d[colors[p - 1]] = 1\n            if total[colors[p - 1]] > 1:\n                nextvalue += colors[p - 1]\n        else:\n            d[colors[p - 1]] += 1\n            if d[colors[p - 1]] == total[colors[p - 1]]:\n                nextvalue -= colors[p - 1]\n        return [d, nextvalue]\n    dfs(1, -1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "child = [[] for _ in range(n + 1)]",
      "mutated_line": "for (i, (u, v)) in enumerate(edges):",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 1\n    child = [[] for _ in range(n + 0)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] * (n - 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 1] not in d:\n            d[colors[p - 1]] = 1\n            if total[colors[p - 1]] > 1:\n                nextvalue += colors[p - 1]\n        else:\n            d[colors[p - 1]] += 1\n            if d[colors[p - 1]] == total[colors[p - 1]]:\n                nextvalue -= colors[p - 1]\n        return [d, nextvalue]\n    dfs(1, -1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "child = [[] for _ in range(n + 1)]",
      "mutated_line": "for (i, (u, v)) in enumerate(edges):",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 1\n    child = [[] for _ in range(n + -1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] * (n - 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 1] not in d:\n            d[colors[p - 1]] = 1\n            if total[colors[p - 1]] > 1:\n                nextvalue += colors[p - 1]\n        else:\n            d[colors[p - 1]] += 1\n            if d[colors[p - 1]] == total[colors[p - 1]]:\n                nextvalue -= colors[p - 1]\n        return [d, nextvalue]\n    dfs(1, -1)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if take[x] != total[x]:",
      "mutated_line": "if take[x] == total[x]:",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 1\n    child = [[] for _ in range(n + 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] * (n - 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] == total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 1] not in d:\n            d[colors[p - 1]] = 1\n            if total[colors[p - 1]] > 1:\n                nextvalue += colors[p - 1]\n        else:\n            d[colors[p - 1]] += 1\n            if d[colors[p - 1]] == total[colors[p - 1]]:\n                nextvalue -= colors[p - 1]\n        return [d, nextvalue]\n    dfs(1, -1)\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 30,
      "original_line": "nextvalue -= x",
      "mutated_line": "nextvalue += x",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 1\n    child = [[] for _ in range(n + 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] * (n - 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue += x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 1] not in d:\n            d[colors[p - 1]] = 1\n            if total[colors[p - 1]] > 1:\n                nextvalue += colors[p - 1]\n        else:\n            d[colors[p - 1]] += 1\n            if d[colors[p - 1]] == total[colors[p - 1]]:\n                nextvalue -= colors[p - 1]\n        return [d, nextvalue]\n    dfs(1, -1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if colors[p - 1] not in d:",
      "mutated_line": "if colors[p - 2] not in d:",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 1\n    child = [[] for _ in range(n + 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] * (n - 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 2] not in d:\n            d[colors[p - 1]] = 1\n            if total[colors[p - 1]] > 1:\n                nextvalue += colors[p - 1]\n        else:\n            d[colors[p - 1]] += 1\n            if d[colors[p - 1]] == total[colors[p - 1]]:\n                nextvalue -= colors[p - 1]\n        return [d, nextvalue]\n    dfs(1, -1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if colors[p - 1] not in d:",
      "mutated_line": "if colors[p - 0] not in d:",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 1\n    child = [[] for _ in range(n + 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] * (n - 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 0] not in d:\n            d[colors[p - 1]] = 1\n            if total[colors[p - 1]] > 1:\n                nextvalue += colors[p - 1]\n        else:\n            d[colors[p - 1]] += 1\n            if d[colors[p - 1]] == total[colors[p - 1]]:\n                nextvalue -= colors[p - 1]\n        return [d, nextvalue]\n    dfs(1, -1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if colors[p - 1] not in d:",
      "mutated_line": "if colors[p - 0] not in d:",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 1\n    child = [[] for _ in range(n + 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] * (n - 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 0] not in d:\n            d[colors[p - 1]] = 1\n            if total[colors[p - 1]] > 1:\n                nextvalue += colors[p - 1]\n        else:\n            d[colors[p - 1]] += 1\n            if d[colors[p - 1]] == total[colors[p - 1]]:\n                nextvalue -= colors[p - 1]\n        return [d, nextvalue]\n    dfs(1, -1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if colors[p - 1] not in d:",
      "mutated_line": "if colors[p - -1] not in d:",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 1\n    child = [[] for _ in range(n + 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] * (n - 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - -1] not in d:\n            d[colors[p - 1]] = 1\n            if total[colors[p - 1]] > 1:\n                nextvalue += colors[p - 1]\n        else:\n            d[colors[p - 1]] += 1\n            if d[colors[p - 1]] == total[colors[p - 1]]:\n                nextvalue -= colors[p - 1]\n        return [d, nextvalue]\n    dfs(1, -1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "d[colors[p - 1]] = 1",
      "mutated_line": "d[colors[p + 1]] = 1",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 1\n    child = [[] for _ in range(n + 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] * (n - 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 1] not in d:\n            d[colors[p + 1]] = 1\n            if total[colors[p - 1]] > 1:\n                nextvalue += colors[p - 1]\n        else:\n            d[colors[p - 1]] += 1\n            if d[colors[p - 1]] == total[colors[p - 1]]:\n                nextvalue -= colors[p - 1]\n        return [d, nextvalue]\n    dfs(1, -1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "d[colors[p - 1]] = 1",
      "mutated_line": "d[colors[p * 1]] = 1",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 1\n    child = [[] for _ in range(n + 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] * (n - 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 1] not in d:\n            d[colors[p * 1]] = 1\n            if total[colors[p - 1]] > 1:\n                nextvalue += colors[p - 1]\n        else:\n            d[colors[p - 1]] += 1\n            if d[colors[p - 1]] == total[colors[p - 1]]:\n                nextvalue -= colors[p - 1]\n        return [d, nextvalue]\n    dfs(1, -1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "nextvalue += colors[p - 1]",
      "mutated_line": "nextvalue += colors[p + 1]",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 1\n    child = [[] for _ in range(n + 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] * (n - 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 1] not in d:\n            d[colors[p - 1]] = 1\n            if total[colors[p - 1]] > 1:\n                nextvalue += colors[p + 1]\n        else:\n            d[colors[p - 1]] += 1\n            if d[colors[p - 1]] == total[colors[p - 1]]:\n                nextvalue -= colors[p - 1]\n        return [d, nextvalue]\n    dfs(1, -1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "nextvalue += colors[p - 1]",
      "mutated_line": "nextvalue += colors[p * 1]",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 1\n    child = [[] for _ in range(n + 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] * (n - 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 1] not in d:\n            d[colors[p - 1]] = 1\n            if total[colors[p - 1]] > 1:\n                nextvalue += colors[p * 1]\n        else:\n            d[colors[p - 1]] += 1\n            if d[colors[p - 1]] == total[colors[p - 1]]:\n                nextvalue -= colors[p - 1]\n        return [d, nextvalue]\n    dfs(1, -1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "d[colors[p - 1]] += 1",
      "mutated_line": "d[colors[p + 1]] += 1",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 1\n    child = [[] for _ in range(n + 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] * (n - 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 1] not in d:\n            d[colors[p - 1]] = 1\n            if total[colors[p - 1]] > 1:\n                nextvalue += colors[p - 1]\n        else:\n            d[colors[p + 1]] += 1\n            if d[colors[p - 1]] == total[colors[p - 1]]:\n                nextvalue -= colors[p - 1]\n        return [d, nextvalue]\n    dfs(1, -1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "d[colors[p - 1]] += 1",
      "mutated_line": "d[colors[p * 1]] += 1",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 1\n    child = [[] for _ in range(n + 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] * (n - 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 1] not in d:\n            d[colors[p - 1]] = 1\n            if total[colors[p - 1]] > 1:\n                nextvalue += colors[p - 1]\n        else:\n            d[colors[p * 1]] += 1\n            if d[colors[p - 1]] == total[colors[p - 1]]:\n                nextvalue -= colors[p - 1]\n        return [d, nextvalue]\n    dfs(1, -1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "nextvalue -= colors[p - 1]",
      "mutated_line": "nextvalue -= colors[p + 1]",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 1\n    child = [[] for _ in range(n + 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] * (n - 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 1] not in d:\n            d[colors[p - 1]] = 1\n            if total[colors[p - 1]] > 1:\n                nextvalue += colors[p - 1]\n        else:\n            d[colors[p - 1]] += 1\n            if d[colors[p - 1]] == total[colors[p - 1]]:\n                nextvalue -= colors[p + 1]\n        return [d, nextvalue]\n    dfs(1, -1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "nextvalue -= colors[p - 1]",
      "mutated_line": "nextvalue -= colors[p * 1]",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 1\n    child = [[] for _ in range(n + 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] * (n - 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 1] not in d:\n            d[colors[p - 1]] = 1\n            if total[colors[p - 1]] > 1:\n                nextvalue += colors[p - 1]\n        else:\n            d[colors[p - 1]] += 1\n            if d[colors[p - 1]] == total[colors[p - 1]]:\n                nextvalue -= colors[p * 1]\n        return [d, nextvalue]\n    dfs(1, -1)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if d[x] == total[x]:",
      "mutated_line": "if d[x] != total[x]:",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 1\n    child = [[] for _ in range(n + 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] * (n - 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] != total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 1] not in d:\n            d[colors[p - 1]] = 1\n            if total[colors[p - 1]] > 1:\n                nextvalue += colors[p - 1]\n        else:\n            d[colors[p - 1]] += 1\n            if d[colors[p - 1]] == total[colors[p - 1]]:\n                nextvalue -= colors[p - 1]\n        return [d, nextvalue]\n    dfs(1, -1)\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 32,
      "original_line": "nextvalue -= x",
      "mutated_line": "nextvalue += x",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 1\n    child = [[] for _ in range(n + 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] * (n - 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue += x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 1] not in d:\n            d[colors[p - 1]] = 1\n            if total[colors[p - 1]] > 1:\n                nextvalue += colors[p - 1]\n        else:\n            d[colors[p - 1]] += 1\n            if d[colors[p - 1]] == total[colors[p - 1]]:\n                nextvalue -= colors[p - 1]\n        return [d, nextvalue]\n    dfs(1, -1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "d[colors[p - 1]] = 1",
      "mutated_line": "d[colors[p - 2]] = 1",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 1\n    child = [[] for _ in range(n + 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] * (n - 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 1] not in d:\n            d[colors[p - 2]] = 1\n            if total[colors[p - 1]] > 1:\n                nextvalue += colors[p - 1]\n        else:\n            d[colors[p - 1]] += 1\n            if d[colors[p - 1]] == total[colors[p - 1]]:\n                nextvalue -= colors[p - 1]\n        return [d, nextvalue]\n    dfs(1, -1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "d[colors[p - 1]] = 1",
      "mutated_line": "d[colors[p - 0]] = 1",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 1\n    child = [[] for _ in range(n + 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] * (n - 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 1] not in d:\n            d[colors[p - 0]] = 1\n            if total[colors[p - 1]] > 1:\n                nextvalue += colors[p - 1]\n        else:\n            d[colors[p - 1]] += 1\n            if d[colors[p - 1]] == total[colors[p - 1]]:\n                nextvalue -= colors[p - 1]\n        return [d, nextvalue]\n    dfs(1, -1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "d[colors[p - 1]] = 1",
      "mutated_line": "d[colors[p - 0]] = 1",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 1\n    child = [[] for _ in range(n + 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] * (n - 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 1] not in d:\n            d[colors[p - 0]] = 1\n            if total[colors[p - 1]] > 1:\n                nextvalue += colors[p - 1]\n        else:\n            d[colors[p - 1]] += 1\n            if d[colors[p - 1]] == total[colors[p - 1]]:\n                nextvalue -= colors[p - 1]\n        return [d, nextvalue]\n    dfs(1, -1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "d[colors[p - 1]] = 1",
      "mutated_line": "d[colors[p - -1]] = 1",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 1\n    child = [[] for _ in range(n + 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] * (n - 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 1] not in d:\n            d[colors[p - -1]] = 1\n            if total[colors[p - 1]] > 1:\n                nextvalue += colors[p - 1]\n        else:\n            d[colors[p - 1]] += 1\n            if d[colors[p - 1]] == total[colors[p - 1]]:\n                nextvalue -= colors[p - 1]\n        return [d, nextvalue]\n    dfs(1, -1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "if total[colors[p - 1]] > 1:",
      "mutated_line": "if total[colors[p + 1]] > 1:",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 1\n    child = [[] for _ in range(n + 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] * (n - 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 1] not in d:\n            d[colors[p - 1]] = 1\n            if total[colors[p + 1]] > 1:\n                nextvalue += colors[p - 1]\n        else:\n            d[colors[p - 1]] += 1\n            if d[colors[p - 1]] == total[colors[p - 1]]:\n                nextvalue -= colors[p - 1]\n        return [d, nextvalue]\n    dfs(1, -1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "if total[colors[p - 1]] > 1:",
      "mutated_line": "if total[colors[p * 1]] > 1:",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 1\n    child = [[] for _ in range(n + 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] * (n - 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 1] not in d:\n            d[colors[p - 1]] = 1\n            if total[colors[p * 1]] > 1:\n                nextvalue += colors[p - 1]\n        else:\n            d[colors[p - 1]] += 1\n            if d[colors[p - 1]] == total[colors[p - 1]]:\n                nextvalue -= colors[p - 1]\n        return [d, nextvalue]\n    dfs(1, -1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "nextvalue += colors[p - 1]",
      "mutated_line": "nextvalue += colors[p - 2]",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 1\n    child = [[] for _ in range(n + 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] * (n - 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 1] not in d:\n            d[colors[p - 1]] = 1\n            if total[colors[p - 1]] > 1:\n                nextvalue += colors[p - 2]\n        else:\n            d[colors[p - 1]] += 1\n            if d[colors[p - 1]] == total[colors[p - 1]]:\n                nextvalue -= colors[p - 1]\n        return [d, nextvalue]\n    dfs(1, -1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "nextvalue += colors[p - 1]",
      "mutated_line": "nextvalue += colors[p - 0]",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 1\n    child = [[] for _ in range(n + 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] * (n - 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 1] not in d:\n            d[colors[p - 1]] = 1\n            if total[colors[p - 1]] > 1:\n                nextvalue += colors[p - 0]\n        else:\n            d[colors[p - 1]] += 1\n            if d[colors[p - 1]] == total[colors[p - 1]]:\n                nextvalue -= colors[p - 1]\n        return [d, nextvalue]\n    dfs(1, -1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "nextvalue += colors[p - 1]",
      "mutated_line": "nextvalue += colors[p - 0]",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 1\n    child = [[] for _ in range(n + 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] * (n - 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 1] not in d:\n            d[colors[p - 1]] = 1\n            if total[colors[p - 1]] > 1:\n                nextvalue += colors[p - 0]\n        else:\n            d[colors[p - 1]] += 1\n            if d[colors[p - 1]] == total[colors[p - 1]]:\n                nextvalue -= colors[p - 1]\n        return [d, nextvalue]\n    dfs(1, -1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "nextvalue += colors[p - 1]",
      "mutated_line": "nextvalue += colors[p - -1]",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 1\n    child = [[] for _ in range(n + 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] * (n - 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 1] not in d:\n            d[colors[p - 1]] = 1\n            if total[colors[p - 1]] > 1:\n                nextvalue += colors[p - -1]\n        else:\n            d[colors[p - 1]] += 1\n            if d[colors[p - 1]] == total[colors[p - 1]]:\n                nextvalue -= colors[p - 1]\n        return [d, nextvalue]\n    dfs(1, -1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "d[colors[p - 1]] += 1",
      "mutated_line": "d[colors[p - 2]] += 1",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 1\n    child = [[] for _ in range(n + 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] * (n - 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 1] not in d:\n            d[colors[p - 1]] = 1\n            if total[colors[p - 1]] > 1:\n                nextvalue += colors[p - 1]\n        else:\n            d[colors[p - 2]] += 1\n            if d[colors[p - 1]] == total[colors[p - 1]]:\n                nextvalue -= colors[p - 1]\n        return [d, nextvalue]\n    dfs(1, -1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "d[colors[p - 1]] += 1",
      "mutated_line": "d[colors[p - 0]] += 1",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 1\n    child = [[] for _ in range(n + 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] * (n - 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 1] not in d:\n            d[colors[p - 1]] = 1\n            if total[colors[p - 1]] > 1:\n                nextvalue += colors[p - 1]\n        else:\n            d[colors[p - 0]] += 1\n            if d[colors[p - 1]] == total[colors[p - 1]]:\n                nextvalue -= colors[p - 1]\n        return [d, nextvalue]\n    dfs(1, -1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "d[colors[p - 1]] += 1",
      "mutated_line": "d[colors[p - 0]] += 1",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 1\n    child = [[] for _ in range(n + 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] * (n - 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 1] not in d:\n            d[colors[p - 1]] = 1\n            if total[colors[p - 1]] > 1:\n                nextvalue += colors[p - 1]\n        else:\n            d[colors[p - 0]] += 1\n            if d[colors[p - 1]] == total[colors[p - 1]]:\n                nextvalue -= colors[p - 1]\n        return [d, nextvalue]\n    dfs(1, -1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "d[colors[p - 1]] += 1",
      "mutated_line": "d[colors[p - -1]] += 1",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 1\n    child = [[] for _ in range(n + 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] * (n - 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 1] not in d:\n            d[colors[p - 1]] = 1\n            if total[colors[p - 1]] > 1:\n                nextvalue += colors[p - 1]\n        else:\n            d[colors[p - -1]] += 1\n            if d[colors[p - 1]] == total[colors[p - 1]]:\n                nextvalue -= colors[p - 1]\n        return [d, nextvalue]\n    dfs(1, -1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "if d[colors[p - 1]] == total[colors[p - 1]]:",
      "mutated_line": "if d[colors[p + 1]] == total[colors[p - 1]]:",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 1\n    child = [[] for _ in range(n + 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] * (n - 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 1] not in d:\n            d[colors[p - 1]] = 1\n            if total[colors[p - 1]] > 1:\n                nextvalue += colors[p - 1]\n        else:\n            d[colors[p - 1]] += 1\n            if d[colors[p + 1]] == total[colors[p - 1]]:\n                nextvalue -= colors[p - 1]\n        return [d, nextvalue]\n    dfs(1, -1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "if d[colors[p - 1]] == total[colors[p - 1]]:",
      "mutated_line": "if d[colors[p * 1]] == total[colors[p - 1]]:",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 1\n    child = [[] for _ in range(n + 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] * (n - 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 1] not in d:\n            d[colors[p - 1]] = 1\n            if total[colors[p - 1]] > 1:\n                nextvalue += colors[p - 1]\n        else:\n            d[colors[p - 1]] += 1\n            if d[colors[p * 1]] == total[colors[p - 1]]:\n                nextvalue -= colors[p - 1]\n        return [d, nextvalue]\n    dfs(1, -1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "if d[colors[p - 1]] == total[colors[p - 1]]:",
      "mutated_line": "if d[colors[p - 1]] == total[colors[p + 1]]:",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 1\n    child = [[] for _ in range(n + 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] * (n - 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 1] not in d:\n            d[colors[p - 1]] = 1\n            if total[colors[p - 1]] > 1:\n                nextvalue += colors[p - 1]\n        else:\n            d[colors[p - 1]] += 1\n            if d[colors[p - 1]] == total[colors[p + 1]]:\n                nextvalue -= colors[p - 1]\n        return [d, nextvalue]\n    dfs(1, -1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "if d[colors[p - 1]] == total[colors[p - 1]]:",
      "mutated_line": "if d[colors[p - 1]] == total[colors[p * 1]]:",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 1\n    child = [[] for _ in range(n + 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] * (n - 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 1] not in d:\n            d[colors[p - 1]] = 1\n            if total[colors[p - 1]] > 1:\n                nextvalue += colors[p - 1]\n        else:\n            d[colors[p - 1]] += 1\n            if d[colors[p - 1]] == total[colors[p * 1]]:\n                nextvalue -= colors[p - 1]\n        return [d, nextvalue]\n    dfs(1, -1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "nextvalue -= colors[p - 1]",
      "mutated_line": "nextvalue -= colors[p - 2]",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 1\n    child = [[] for _ in range(n + 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] * (n - 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 1] not in d:\n            d[colors[p - 1]] = 1\n            if total[colors[p - 1]] > 1:\n                nextvalue += colors[p - 1]\n        else:\n            d[colors[p - 1]] += 1\n            if d[colors[p - 1]] == total[colors[p - 1]]:\n                nextvalue -= colors[p - 2]\n        return [d, nextvalue]\n    dfs(1, -1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "nextvalue -= colors[p - 1]",
      "mutated_line": "nextvalue -= colors[p - 0]",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 1\n    child = [[] for _ in range(n + 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] * (n - 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 1] not in d:\n            d[colors[p - 1]] = 1\n            if total[colors[p - 1]] > 1:\n                nextvalue += colors[p - 1]\n        else:\n            d[colors[p - 1]] += 1\n            if d[colors[p - 1]] == total[colors[p - 1]]:\n                nextvalue -= colors[p - 0]\n        return [d, nextvalue]\n    dfs(1, -1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "nextvalue -= colors[p - 1]",
      "mutated_line": "nextvalue -= colors[p - 0]",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 1\n    child = [[] for _ in range(n + 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] * (n - 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 1] not in d:\n            d[colors[p - 1]] = 1\n            if total[colors[p - 1]] > 1:\n                nextvalue += colors[p - 1]\n        else:\n            d[colors[p - 1]] += 1\n            if d[colors[p - 1]] == total[colors[p - 1]]:\n                nextvalue -= colors[p - 0]\n        return [d, nextvalue]\n    dfs(1, -1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "nextvalue -= colors[p - 1]",
      "mutated_line": "nextvalue -= colors[p - -1]",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 1\n    child = [[] for _ in range(n + 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] * (n - 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 1] not in d:\n            d[colors[p - 1]] = 1\n            if total[colors[p - 1]] > 1:\n                nextvalue += colors[p - 1]\n        else:\n            d[colors[p - 1]] += 1\n            if d[colors[p - 1]] == total[colors[p - 1]]:\n                nextvalue -= colors[p - -1]\n        return [d, nextvalue]\n    dfs(1, -1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if total[colors[p - 1]] > 1:",
      "mutated_line": "if total[colors[p - 2]] > 1:",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 1\n    child = [[] for _ in range(n + 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] * (n - 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 1] not in d:\n            d[colors[p - 1]] = 1\n            if total[colors[p - 2]] > 1:\n                nextvalue += colors[p - 1]\n        else:\n            d[colors[p - 1]] += 1\n            if d[colors[p - 1]] == total[colors[p - 1]]:\n                nextvalue -= colors[p - 1]\n        return [d, nextvalue]\n    dfs(1, -1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if total[colors[p - 1]] > 1:",
      "mutated_line": "if total[colors[p - 0]] > 1:",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 1\n    child = [[] for _ in range(n + 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] * (n - 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 1] not in d:\n            d[colors[p - 1]] = 1\n            if total[colors[p - 0]] > 1:\n                nextvalue += colors[p - 1]\n        else:\n            d[colors[p - 1]] += 1\n            if d[colors[p - 1]] == total[colors[p - 1]]:\n                nextvalue -= colors[p - 1]\n        return [d, nextvalue]\n    dfs(1, -1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if total[colors[p - 1]] > 1:",
      "mutated_line": "if total[colors[p - 0]] > 1:",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 1\n    child = [[] for _ in range(n + 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] * (n - 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 1] not in d:\n            d[colors[p - 1]] = 1\n            if total[colors[p - 0]] > 1:\n                nextvalue += colors[p - 1]\n        else:\n            d[colors[p - 1]] += 1\n            if d[colors[p - 1]] == total[colors[p - 1]]:\n                nextvalue -= colors[p - 1]\n        return [d, nextvalue]\n    dfs(1, -1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if total[colors[p - 1]] > 1:",
      "mutated_line": "if total[colors[p - -1]] > 1:",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 1\n    child = [[] for _ in range(n + 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] * (n - 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 1] not in d:\n            d[colors[p - 1]] = 1\n            if total[colors[p - -1]] > 1:\n                nextvalue += colors[p - 1]\n        else:\n            d[colors[p - 1]] += 1\n            if d[colors[p - 1]] == total[colors[p - 1]]:\n                nextvalue -= colors[p - 1]\n        return [d, nextvalue]\n    dfs(1, -1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if d[colors[p - 1]] == total[colors[p - 1]]:",
      "mutated_line": "if d[colors[p - 2]] == total[colors[p - 1]]:",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 1\n    child = [[] for _ in range(n + 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] * (n - 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 1] not in d:\n            d[colors[p - 1]] = 1\n            if total[colors[p - 1]] > 1:\n                nextvalue += colors[p - 1]\n        else:\n            d[colors[p - 1]] += 1\n            if d[colors[p - 2]] == total[colors[p - 1]]:\n                nextvalue -= colors[p - 1]\n        return [d, nextvalue]\n    dfs(1, -1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if d[colors[p - 1]] == total[colors[p - 1]]:",
      "mutated_line": "if d[colors[p - 0]] == total[colors[p - 1]]:",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 1\n    child = [[] for _ in range(n + 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] * (n - 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 1] not in d:\n            d[colors[p - 1]] = 1\n            if total[colors[p - 1]] > 1:\n                nextvalue += colors[p - 1]\n        else:\n            d[colors[p - 1]] += 1\n            if d[colors[p - 0]] == total[colors[p - 1]]:\n                nextvalue -= colors[p - 1]\n        return [d, nextvalue]\n    dfs(1, -1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if d[colors[p - 1]] == total[colors[p - 1]]:",
      "mutated_line": "if d[colors[p - 0]] == total[colors[p - 1]]:",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 1\n    child = [[] for _ in range(n + 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] * (n - 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 1] not in d:\n            d[colors[p - 1]] = 1\n            if total[colors[p - 1]] > 1:\n                nextvalue += colors[p - 1]\n        else:\n            d[colors[p - 1]] += 1\n            if d[colors[p - 0]] == total[colors[p - 1]]:\n                nextvalue -= colors[p - 1]\n        return [d, nextvalue]\n    dfs(1, -1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if d[colors[p - 1]] == total[colors[p - 1]]:",
      "mutated_line": "if d[colors[p - -1]] == total[colors[p - 1]]:",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 1\n    child = [[] for _ in range(n + 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] * (n - 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 1] not in d:\n            d[colors[p - 1]] = 1\n            if total[colors[p - 1]] > 1:\n                nextvalue += colors[p - 1]\n        else:\n            d[colors[p - 1]] += 1\n            if d[colors[p - -1]] == total[colors[p - 1]]:\n                nextvalue -= colors[p - 1]\n        return [d, nextvalue]\n    dfs(1, -1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if d[colors[p - 1]] == total[colors[p - 1]]:",
      "mutated_line": "if d[colors[p - 1]] == total[colors[p - 2]]:",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 1\n    child = [[] for _ in range(n + 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] * (n - 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 1] not in d:\n            d[colors[p - 1]] = 1\n            if total[colors[p - 1]] > 1:\n                nextvalue += colors[p - 1]\n        else:\n            d[colors[p - 1]] += 1\n            if d[colors[p - 1]] == total[colors[p - 2]]:\n                nextvalue -= colors[p - 1]\n        return [d, nextvalue]\n    dfs(1, -1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if d[colors[p - 1]] == total[colors[p - 1]]:",
      "mutated_line": "if d[colors[p - 1]] == total[colors[p - 0]]:",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 1\n    child = [[] for _ in range(n + 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] * (n - 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 1] not in d:\n            d[colors[p - 1]] = 1\n            if total[colors[p - 1]] > 1:\n                nextvalue += colors[p - 1]\n        else:\n            d[colors[p - 1]] += 1\n            if d[colors[p - 1]] == total[colors[p - 0]]:\n                nextvalue -= colors[p - 1]\n        return [d, nextvalue]\n    dfs(1, -1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if d[colors[p - 1]] == total[colors[p - 1]]:",
      "mutated_line": "if d[colors[p - 1]] == total[colors[p - 0]]:",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 1\n    child = [[] for _ in range(n + 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] * (n - 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 1] not in d:\n            d[colors[p - 1]] = 1\n            if total[colors[p - 1]] > 1:\n                nextvalue += colors[p - 1]\n        else:\n            d[colors[p - 1]] += 1\n            if d[colors[p - 1]] == total[colors[p - 0]]:\n                nextvalue -= colors[p - 1]\n        return [d, nextvalue]\n    dfs(1, -1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if d[colors[p - 1]] == total[colors[p - 1]]:",
      "mutated_line": "if d[colors[p - 1]] == total[colors[p - -1]]:",
      "code": "def calculate_edge_values(n, colors, edges):\n    from collections import defaultdict\n    total = defaultdict(int)\n    for color in colors:\n        total[color] += 1\n    child = [[] for _ in range(n + 1)]\n    for (i, (u, v)) in enumerate(edges):\n        child[u].append([v, i])\n        child[v].append([u, i])\n    ans = [0] * (n - 1)\n\n    def dfs(p, prev):\n        d = defaultdict(int)\n        nextvalue = 0\n        for [u, i] in child[p]:\n            if prev == u:\n                continue\n            (take, value) = dfs(u, p)\n            ans[i] = value\n            if len(take) > len(d):\n                (d, take) = (take, d)\n            for x in take.keys():\n                if x in d:\n                    d[x] += take[x]\n                    if take[x] != total[x]:\n                        nextvalue -= x\n                        if d[x] == total[x]:\n                            nextvalue -= x\n                else:\n                    d[x] = take[x]\n            nextvalue += value\n        if colors[p - 1] not in d:\n            d[colors[p - 1]] = 1\n            if total[colors[p - 1]] > 1:\n                nextvalue += colors[p - 1]\n        else:\n            d[colors[p - 1]] += 1\n            if d[colors[p - 1]] == total[colors[p - -1]]:\n                nextvalue -= colors[p - 1]\n        return [d, nextvalue]\n    dfs(1, -1)\n    return ans"
    }
  ]
}