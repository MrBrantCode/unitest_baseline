{
  "task_id": "taco_2892",
  "entry_point": "find_palindromic_permutation",
  "mutant_count": 105,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "odds = 0",
      "mutated_line": "odds = 1",
      "code": "from typing import List\nfrom collections import Counter\n\ndef find_palindromic_permutation(s: str) -> List[int]:\n    n = len(s)\n    counts = Counter(s)\n    odds = 1\n    for count in counts.values():\n        if count & 1:\n            odds += 1\n    if n & 1 and odds > 1 or (not n & 1 and odds > 0):\n        return [-1]\n    inds = {i: [] for i in s}\n    for i in range(n):\n        inds[s[i]].append(i + 1)\n    res = [-1] * n\n    if n & 1:\n        for (key, val) in counts.items():\n            if val & 1:\n                let = key\n                poses = inds[key]\n                del inds[key]\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n        for x in poses:\n            res[i] = x\n            i += 1\n    else:\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "odds = 0",
      "mutated_line": "odds = -1",
      "code": "from typing import List\nfrom collections import Counter\n\ndef find_palindromic_permutation(s: str) -> List[int]:\n    n = len(s)\n    counts = Counter(s)\n    odds = -1\n    for count in counts.values():\n        if count & 1:\n            odds += 1\n    if n & 1 and odds > 1 or (not n & 1 and odds > 0):\n        return [-1]\n    inds = {i: [] for i in s}\n    for i in range(n):\n        inds[s[i]].append(i + 1)\n    res = [-1] * n\n    if n & 1:\n        for (key, val) in counts.items():\n            if val & 1:\n                let = key\n                poses = inds[key]\n                del inds[key]\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n        for x in poses:\n            res[i] = x\n            i += 1\n    else:\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "odds = 0",
      "mutated_line": "odds = 1",
      "code": "from typing import List\nfrom collections import Counter\n\ndef find_palindromic_permutation(s: str) -> List[int]:\n    n = len(s)\n    counts = Counter(s)\n    odds = 1\n    for count in counts.values():\n        if count & 1:\n            odds += 1\n    if n & 1 and odds > 1 or (not n & 1 and odds > 0):\n        return [-1]\n    inds = {i: [] for i in s}\n    for i in range(n):\n        inds[s[i]].append(i + 1)\n    res = [-1] * n\n    if n & 1:\n        for (key, val) in counts.items():\n            if val & 1:\n                let = key\n                poses = inds[key]\n                del inds[key]\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n        for x in poses:\n            res[i] = x\n            i += 1\n    else:\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n    return res"
    },
    {
      "operator": "LCR",
      "lineno": 11,
      "original_line": "if n & 1 and odds > 1 or (not n & 1 and odds > 0):",
      "mutated_line": "if (n & 1 and odds > 1) and (not n & 1 and odds > 0):",
      "code": "from typing import List\nfrom collections import Counter\n\ndef find_palindromic_permutation(s: str) -> List[int]:\n    n = len(s)\n    counts = Counter(s)\n    odds = 0\n    for count in counts.values():\n        if count & 1:\n            odds += 1\n    if (n & 1 and odds > 1) and (not n & 1 and odds > 0):\n        return [-1]\n    inds = {i: [] for i in s}\n    for i in range(n):\n        inds[s[i]].append(i + 1)\n    res = [-1] * n\n    if n & 1:\n        for (key, val) in counts.items():\n            if val & 1:\n                let = key\n                poses = inds[key]\n                del inds[key]\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n        for x in poses:\n            res[i] = x\n            i += 1\n    else:\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "res = [-1] * n",
      "mutated_line": "res = [-1] / n",
      "code": "from typing import List\nfrom collections import Counter\n\ndef find_palindromic_permutation(s: str) -> List[int]:\n    n = len(s)\n    counts = Counter(s)\n    odds = 0\n    for count in counts.values():\n        if count & 1:\n            odds += 1\n    if n & 1 and odds > 1 or (not n & 1 and odds > 0):\n        return [-1]\n    inds = {i: [] for i in s}\n    for i in range(n):\n        inds[s[i]].append(i + 1)\n    res = [-1] / n\n    if n & 1:\n        for (key, val) in counts.items():\n            if val & 1:\n                let = key\n                poses = inds[key]\n                del inds[key]\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n        for x in poses:\n            res[i] = x\n            i += 1\n    else:\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "res = [-1] * n",
      "mutated_line": "res = [-1] + n",
      "code": "from typing import List\nfrom collections import Counter\n\ndef find_palindromic_permutation(s: str) -> List[int]:\n    n = len(s)\n    counts = Counter(s)\n    odds = 0\n    for count in counts.values():\n        if count & 1:\n            odds += 1\n    if n & 1 and odds > 1 or (not n & 1 and odds > 0):\n        return [-1]\n    inds = {i: [] for i in s}\n    for i in range(n):\n        inds[s[i]].append(i + 1)\n    res = [-1] + n\n    if n & 1:\n        for (key, val) in counts.items():\n            if val & 1:\n                let = key\n                poses = inds[key]\n                del inds[key]\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n        for x in poses:\n            res[i] = x\n            i += 1\n    else:\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "res = [-1] * n",
      "mutated_line": "res = [-1] ** n",
      "code": "from typing import List\nfrom collections import Counter\n\ndef find_palindromic_permutation(s: str) -> List[int]:\n    n = len(s)\n    counts = Counter(s)\n    odds = 0\n    for count in counts.values():\n        if count & 1:\n            odds += 1\n    if n & 1 and odds > 1 or (not n & 1 and odds > 0):\n        return [-1]\n    inds = {i: [] for i in s}\n    for i in range(n):\n        inds[s[i]].append(i + 1)\n    res = [-1] ** n\n    if n & 1:\n        for (key, val) in counts.items():\n            if val & 1:\n                let = key\n                poses = inds[key]\n                del inds[key]\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n        for x in poses:\n            res[i] = x\n            i += 1\n    else:\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "if n & 1:",
      "mutated_line": "if n | 1:",
      "code": "from typing import List\nfrom collections import Counter\n\ndef find_palindromic_permutation(s: str) -> List[int]:\n    n = len(s)\n    counts = Counter(s)\n    odds = 0\n    for count in counts.values():\n        if count & 1:\n            odds += 1\n    if n & 1 and odds > 1 or (not n & 1 and odds > 0):\n        return [-1]\n    inds = {i: [] for i in s}\n    for i in range(n):\n        inds[s[i]].append(i + 1)\n    res = [-1] * n\n    if n | 1:\n        for (key, val) in counts.items():\n            if val & 1:\n                let = key\n                poses = inds[key]\n                del inds[key]\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n        for x in poses:\n            res[i] = x\n            i += 1\n    else:\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "if count & 1:",
      "mutated_line": "if count | 1:",
      "code": "from typing import List\nfrom collections import Counter\n\ndef find_palindromic_permutation(s: str) -> List[int]:\n    n = len(s)\n    counts = Counter(s)\n    odds = 0\n    for count in counts.values():\n        if count | 1:\n            odds += 1\n    if n & 1 and odds > 1 or (not n & 1 and odds > 0):\n        return [-1]\n    inds = {i: [] for i in s}\n    for i in range(n):\n        inds[s[i]].append(i + 1)\n    res = [-1] * n\n    if n & 1:\n        for (key, val) in counts.items():\n            if val & 1:\n                let = key\n                poses = inds[key]\n                del inds[key]\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n        for x in poses:\n            res[i] = x\n            i += 1\n    else:\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n    return res"
    },
    {
      "operator": "ASR",
      "lineno": 10,
      "original_line": "odds += 1",
      "mutated_line": "odds -= 1",
      "code": "from typing import List\nfrom collections import Counter\n\ndef find_palindromic_permutation(s: str) -> List[int]:\n    n = len(s)\n    counts = Counter(s)\n    odds = 0\n    for count in counts.values():\n        if count & 1:\n            odds -= 1\n    if n & 1 and odds > 1 or (not n & 1 and odds > 0):\n        return [-1]\n    inds = {i: [] for i in s}\n    for i in range(n):\n        inds[s[i]].append(i + 1)\n    res = [-1] * n\n    if n & 1:\n        for (key, val) in counts.items():\n            if val & 1:\n                let = key\n                poses = inds[key]\n                del inds[key]\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n        for x in poses:\n            res[i] = x\n            i += 1\n    else:\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n    return res"
    },
    {
      "operator": "LCR",
      "lineno": 11,
      "original_line": "if n & 1 and odds > 1 or (not n & 1 and odds > 0):",
      "mutated_line": "if (n & 1 or odds > 1) or (not n & 1 and odds > 0):",
      "code": "from typing import List\nfrom collections import Counter\n\ndef find_palindromic_permutation(s: str) -> List[int]:\n    n = len(s)\n    counts = Counter(s)\n    odds = 0\n    for count in counts.values():\n        if count & 1:\n            odds += 1\n    if (n & 1 or odds > 1) or (not n & 1 and odds > 0):\n        return [-1]\n    inds = {i: [] for i in s}\n    for i in range(n):\n        inds[s[i]].append(i + 1)\n    res = [-1] * n\n    if n & 1:\n        for (key, val) in counts.items():\n            if val & 1:\n                let = key\n                poses = inds[key]\n                del inds[key]\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n        for x in poses:\n            res[i] = x\n            i += 1\n    else:\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n    return res"
    },
    {
      "operator": "LCR",
      "lineno": 11,
      "original_line": "if n & 1 and odds > 1 or (not n & 1 and odds > 0):",
      "mutated_line": "if n & 1 and odds > 1 or (not n & 1 or odds > 0):",
      "code": "from typing import List\nfrom collections import Counter\n\ndef find_palindromic_permutation(s: str) -> List[int]:\n    n = len(s)\n    counts = Counter(s)\n    odds = 0\n    for count in counts.values():\n        if count & 1:\n            odds += 1\n    if n & 1 and odds > 1 or (not n & 1 or odds > 0):\n        return [-1]\n    inds = {i: [] for i in s}\n    for i in range(n):\n        inds[s[i]].append(i + 1)\n    res = [-1] * n\n    if n & 1:\n        for (key, val) in counts.items():\n            if val & 1:\n                let = key\n                poses = inds[key]\n                del inds[key]\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n        for x in poses:\n            res[i] = x\n            i += 1\n    else:\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if n & 1:",
      "mutated_line": "if n & 2:",
      "code": "from typing import List\nfrom collections import Counter\n\ndef find_palindromic_permutation(s: str) -> List[int]:\n    n = len(s)\n    counts = Counter(s)\n    odds = 0\n    for count in counts.values():\n        if count & 1:\n            odds += 1\n    if n & 1 and odds > 1 or (not n & 1 and odds > 0):\n        return [-1]\n    inds = {i: [] for i in s}\n    for i in range(n):\n        inds[s[i]].append(i + 1)\n    res = [-1] * n\n    if n & 2:\n        for (key, val) in counts.items():\n            if val & 1:\n                let = key\n                poses = inds[key]\n                del inds[key]\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n        for x in poses:\n            res[i] = x\n            i += 1\n    else:\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if n & 1:",
      "mutated_line": "if n & 0:",
      "code": "from typing import List\nfrom collections import Counter\n\ndef find_palindromic_permutation(s: str) -> List[int]:\n    n = len(s)\n    counts = Counter(s)\n    odds = 0\n    for count in counts.values():\n        if count & 1:\n            odds += 1\n    if n & 1 and odds > 1 or (not n & 1 and odds > 0):\n        return [-1]\n    inds = {i: [] for i in s}\n    for i in range(n):\n        inds[s[i]].append(i + 1)\n    res = [-1] * n\n    if n & 0:\n        for (key, val) in counts.items():\n            if val & 1:\n                let = key\n                poses = inds[key]\n                del inds[key]\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n        for x in poses:\n            res[i] = x\n            i += 1\n    else:\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if n & 1:",
      "mutated_line": "if n & 0:",
      "code": "from typing import List\nfrom collections import Counter\n\ndef find_palindromic_permutation(s: str) -> List[int]:\n    n = len(s)\n    counts = Counter(s)\n    odds = 0\n    for count in counts.values():\n        if count & 1:\n            odds += 1\n    if n & 1 and odds > 1 or (not n & 1 and odds > 0):\n        return [-1]\n    inds = {i: [] for i in s}\n    for i in range(n):\n        inds[s[i]].append(i + 1)\n    res = [-1] * n\n    if n & 0:\n        for (key, val) in counts.items():\n            if val & 1:\n                let = key\n                poses = inds[key]\n                del inds[key]\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n        for x in poses:\n            res[i] = x\n            i += 1\n    else:\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if n & 1:",
      "mutated_line": "if n & -1:",
      "code": "from typing import List\nfrom collections import Counter\n\ndef find_palindromic_permutation(s: str) -> List[int]:\n    n = len(s)\n    counts = Counter(s)\n    odds = 0\n    for count in counts.values():\n        if count & 1:\n            odds += 1\n    if n & 1 and odds > 1 or (not n & 1 and odds > 0):\n        return [-1]\n    inds = {i: [] for i in s}\n    for i in range(n):\n        inds[s[i]].append(i + 1)\n    res = [-1] * n\n    if n & -1:\n        for (key, val) in counts.items():\n            if val & 1:\n                let = key\n                poses = inds[key]\n                del inds[key]\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n        for x in poses:\n            res[i] = x\n            i += 1\n    else:\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "i = 0",
      "mutated_line": "i = 1",
      "code": "from typing import List\nfrom collections import Counter\n\ndef find_palindromic_permutation(s: str) -> List[int]:\n    n = len(s)\n    counts = Counter(s)\n    odds = 0\n    for count in counts.values():\n        if count & 1:\n            odds += 1\n    if n & 1 and odds > 1 or (not n & 1 and odds > 0):\n        return [-1]\n    inds = {i: [] for i in s}\n    for i in range(n):\n        inds[s[i]].append(i + 1)\n    res = [-1] * n\n    if n & 1:\n        for (key, val) in counts.items():\n            if val & 1:\n                let = key\n                poses = inds[key]\n                del inds[key]\n        i = 1\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n        for x in poses:\n            res[i] = x\n            i += 1\n    else:\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "i = 0",
      "mutated_line": "i = -1",
      "code": "from typing import List\nfrom collections import Counter\n\ndef find_palindromic_permutation(s: str) -> List[int]:\n    n = len(s)\n    counts = Counter(s)\n    odds = 0\n    for count in counts.values():\n        if count & 1:\n            odds += 1\n    if n & 1 and odds > 1 or (not n & 1 and odds > 0):\n        return [-1]\n    inds = {i: [] for i in s}\n    for i in range(n):\n        inds[s[i]].append(i + 1)\n    res = [-1] * n\n    if n & 1:\n        for (key, val) in counts.items():\n            if val & 1:\n                let = key\n                poses = inds[key]\n                del inds[key]\n        i = -1\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n        for x in poses:\n            res[i] = x\n            i += 1\n    else:\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "i = 0",
      "mutated_line": "i = 1",
      "code": "from typing import List\nfrom collections import Counter\n\ndef find_palindromic_permutation(s: str) -> List[int]:\n    n = len(s)\n    counts = Counter(s)\n    odds = 0\n    for count in counts.values():\n        if count & 1:\n            odds += 1\n    if n & 1 and odds > 1 or (not n & 1 and odds > 0):\n        return [-1]\n    inds = {i: [] for i in s}\n    for i in range(n):\n        inds[s[i]].append(i + 1)\n    res = [-1] * n\n    if n & 1:\n        for (key, val) in counts.items():\n            if val & 1:\n                let = key\n                poses = inds[key]\n                del inds[key]\n        i = 1\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n        for x in poses:\n            res[i] = x\n            i += 1\n    else:\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n    return res"
    },
    {
      "operator": "ASR",
      "lineno": 33,
      "original_line": "i += 1",
      "mutated_line": "i -= 1",
      "code": "from typing import List\nfrom collections import Counter\n\ndef find_palindromic_permutation(s: str) -> List[int]:\n    n = len(s)\n    counts = Counter(s)\n    odds = 0\n    for count in counts.values():\n        if count & 1:\n            odds += 1\n    if n & 1 and odds > 1 or (not n & 1 and odds > 0):\n        return [-1]\n    inds = {i: [] for i in s}\n    for i in range(n):\n        inds[s[i]].append(i + 1)\n    res = [-1] * n\n    if n & 1:\n        for (key, val) in counts.items():\n            if val & 1:\n                let = key\n                poses = inds[key]\n                del inds[key]\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n        for x in poses:\n            res[i] = x\n            i -= 1\n    else:\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "i = 0",
      "mutated_line": "i = 1",
      "code": "from typing import List\nfrom collections import Counter\n\ndef find_palindromic_permutation(s: str) -> List[int]:\n    n = len(s)\n    counts = Counter(s)\n    odds = 0\n    for count in counts.values():\n        if count & 1:\n            odds += 1\n    if n & 1 and odds > 1 or (not n & 1 and odds > 0):\n        return [-1]\n    inds = {i: [] for i in s}\n    for i in range(n):\n        inds[s[i]].append(i + 1)\n    res = [-1] * n\n    if n & 1:\n        for (key, val) in counts.items():\n            if val & 1:\n                let = key\n                poses = inds[key]\n                del inds[key]\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n        for x in poses:\n            res[i] = x\n            i += 1\n    else:\n        i = 1\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "i = 0",
      "mutated_line": "i = -1",
      "code": "from typing import List\nfrom collections import Counter\n\ndef find_palindromic_permutation(s: str) -> List[int]:\n    n = len(s)\n    counts = Counter(s)\n    odds = 0\n    for count in counts.values():\n        if count & 1:\n            odds += 1\n    if n & 1 and odds > 1 or (not n & 1 and odds > 0):\n        return [-1]\n    inds = {i: [] for i in s}\n    for i in range(n):\n        inds[s[i]].append(i + 1)\n    res = [-1] * n\n    if n & 1:\n        for (key, val) in counts.items():\n            if val & 1:\n                let = key\n                poses = inds[key]\n                del inds[key]\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n        for x in poses:\n            res[i] = x\n            i += 1\n    else:\n        i = -1\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "i = 0",
      "mutated_line": "i = 1",
      "code": "from typing import List\nfrom collections import Counter\n\ndef find_palindromic_permutation(s: str) -> List[int]:\n    n = len(s)\n    counts = Counter(s)\n    odds = 0\n    for count in counts.values():\n        if count & 1:\n            odds += 1\n    if n & 1 and odds > 1 or (not n & 1 and odds > 0):\n        return [-1]\n    inds = {i: [] for i in s}\n    for i in range(n):\n        inds[s[i]].append(i + 1)\n    res = [-1] * n\n    if n & 1:\n        for (key, val) in counts.items():\n            if val & 1:\n                let = key\n                poses = inds[key]\n                del inds[key]\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n        for x in poses:\n            res[i] = x\n            i += 1\n    else:\n        i = 1\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if count & 1:",
      "mutated_line": "if count & 2:",
      "code": "from typing import List\nfrom collections import Counter\n\ndef find_palindromic_permutation(s: str) -> List[int]:\n    n = len(s)\n    counts = Counter(s)\n    odds = 0\n    for count in counts.values():\n        if count & 2:\n            odds += 1\n    if n & 1 and odds > 1 or (not n & 1 and odds > 0):\n        return [-1]\n    inds = {i: [] for i in s}\n    for i in range(n):\n        inds[s[i]].append(i + 1)\n    res = [-1] * n\n    if n & 1:\n        for (key, val) in counts.items():\n            if val & 1:\n                let = key\n                poses = inds[key]\n                del inds[key]\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n        for x in poses:\n            res[i] = x\n            i += 1\n    else:\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if count & 1:",
      "mutated_line": "if count & 0:",
      "code": "from typing import List\nfrom collections import Counter\n\ndef find_palindromic_permutation(s: str) -> List[int]:\n    n = len(s)\n    counts = Counter(s)\n    odds = 0\n    for count in counts.values():\n        if count & 0:\n            odds += 1\n    if n & 1 and odds > 1 or (not n & 1 and odds > 0):\n        return [-1]\n    inds = {i: [] for i in s}\n    for i in range(n):\n        inds[s[i]].append(i + 1)\n    res = [-1] * n\n    if n & 1:\n        for (key, val) in counts.items():\n            if val & 1:\n                let = key\n                poses = inds[key]\n                del inds[key]\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n        for x in poses:\n            res[i] = x\n            i += 1\n    else:\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if count & 1:",
      "mutated_line": "if count & 0:",
      "code": "from typing import List\nfrom collections import Counter\n\ndef find_palindromic_permutation(s: str) -> List[int]:\n    n = len(s)\n    counts = Counter(s)\n    odds = 0\n    for count in counts.values():\n        if count & 0:\n            odds += 1\n    if n & 1 and odds > 1 or (not n & 1 and odds > 0):\n        return [-1]\n    inds = {i: [] for i in s}\n    for i in range(n):\n        inds[s[i]].append(i + 1)\n    res = [-1] * n\n    if n & 1:\n        for (key, val) in counts.items():\n            if val & 1:\n                let = key\n                poses = inds[key]\n                del inds[key]\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n        for x in poses:\n            res[i] = x\n            i += 1\n    else:\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if count & 1:",
      "mutated_line": "if count & -1:",
      "code": "from typing import List\nfrom collections import Counter\n\ndef find_palindromic_permutation(s: str) -> List[int]:\n    n = len(s)\n    counts = Counter(s)\n    odds = 0\n    for count in counts.values():\n        if count & -1:\n            odds += 1\n    if n & 1 and odds > 1 or (not n & 1 and odds > 0):\n        return [-1]\n    inds = {i: [] for i in s}\n    for i in range(n):\n        inds[s[i]].append(i + 1)\n    res = [-1] * n\n    if n & 1:\n        for (key, val) in counts.items():\n            if val & 1:\n                let = key\n                poses = inds[key]\n                del inds[key]\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n        for x in poses:\n            res[i] = x\n            i += 1\n    else:\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "odds += 1",
      "mutated_line": "odds += 2",
      "code": "from typing import List\nfrom collections import Counter\n\ndef find_palindromic_permutation(s: str) -> List[int]:\n    n = len(s)\n    counts = Counter(s)\n    odds = 0\n    for count in counts.values():\n        if count & 1:\n            odds += 2\n    if n & 1 and odds > 1 or (not n & 1 and odds > 0):\n        return [-1]\n    inds = {i: [] for i in s}\n    for i in range(n):\n        inds[s[i]].append(i + 1)\n    res = [-1] * n\n    if n & 1:\n        for (key, val) in counts.items():\n            if val & 1:\n                let = key\n                poses = inds[key]\n                del inds[key]\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n        for x in poses:\n            res[i] = x\n            i += 1\n    else:\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "odds += 1",
      "mutated_line": "odds += 0",
      "code": "from typing import List\nfrom collections import Counter\n\ndef find_palindromic_permutation(s: str) -> List[int]:\n    n = len(s)\n    counts = Counter(s)\n    odds = 0\n    for count in counts.values():\n        if count & 1:\n            odds += 0\n    if n & 1 and odds > 1 or (not n & 1 and odds > 0):\n        return [-1]\n    inds = {i: [] for i in s}\n    for i in range(n):\n        inds[s[i]].append(i + 1)\n    res = [-1] * n\n    if n & 1:\n        for (key, val) in counts.items():\n            if val & 1:\n                let = key\n                poses = inds[key]\n                del inds[key]\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n        for x in poses:\n            res[i] = x\n            i += 1\n    else:\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "odds += 1",
      "mutated_line": "odds += 0",
      "code": "from typing import List\nfrom collections import Counter\n\ndef find_palindromic_permutation(s: str) -> List[int]:\n    n = len(s)\n    counts = Counter(s)\n    odds = 0\n    for count in counts.values():\n        if count & 1:\n            odds += 0\n    if n & 1 and odds > 1 or (not n & 1 and odds > 0):\n        return [-1]\n    inds = {i: [] for i in s}\n    for i in range(n):\n        inds[s[i]].append(i + 1)\n    res = [-1] * n\n    if n & 1:\n        for (key, val) in counts.items():\n            if val & 1:\n                let = key\n                poses = inds[key]\n                del inds[key]\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n        for x in poses:\n            res[i] = x\n            i += 1\n    else:\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "odds += 1",
      "mutated_line": "odds += -1",
      "code": "from typing import List\nfrom collections import Counter\n\ndef find_palindromic_permutation(s: str) -> List[int]:\n    n = len(s)\n    counts = Counter(s)\n    odds = 0\n    for count in counts.values():\n        if count & 1:\n            odds += -1\n    if n & 1 and odds > 1 or (not n & 1 and odds > 0):\n        return [-1]\n    inds = {i: [] for i in s}\n    for i in range(n):\n        inds[s[i]].append(i + 1)\n    res = [-1] * n\n    if n & 1:\n        for (key, val) in counts.items():\n            if val & 1:\n                let = key\n                poses = inds[key]\n                del inds[key]\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n        for x in poses:\n            res[i] = x\n            i += 1\n    else:\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "if n & 1 and odds > 1 or (not n & 1 and odds > 0):",
      "mutated_line": "if n | 1 and odds > 1 or (not n & 1 and odds > 0):",
      "code": "from typing import List\nfrom collections import Counter\n\ndef find_palindromic_permutation(s: str) -> List[int]:\n    n = len(s)\n    counts = Counter(s)\n    odds = 0\n    for count in counts.values():\n        if count & 1:\n            odds += 1\n    if n | 1 and odds > 1 or (not n & 1 and odds > 0):\n        return [-1]\n    inds = {i: [] for i in s}\n    for i in range(n):\n        inds[s[i]].append(i + 1)\n    res = [-1] * n\n    if n & 1:\n        for (key, val) in counts.items():\n            if val & 1:\n                let = key\n                poses = inds[key]\n                del inds[key]\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n        for x in poses:\n            res[i] = x\n            i += 1\n    else:\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if n & 1 and odds > 1 or (not n & 1 and odds > 0):",
      "mutated_line": "if n & 1 and odds >= 1 or (not n & 1 and odds > 0):",
      "code": "from typing import List\nfrom collections import Counter\n\ndef find_palindromic_permutation(s: str) -> List[int]:\n    n = len(s)\n    counts = Counter(s)\n    odds = 0\n    for count in counts.values():\n        if count & 1:\n            odds += 1\n    if n & 1 and odds >= 1 or (not n & 1 and odds > 0):\n        return [-1]\n    inds = {i: [] for i in s}\n    for i in range(n):\n        inds[s[i]].append(i + 1)\n    res = [-1] * n\n    if n & 1:\n        for (key, val) in counts.items():\n            if val & 1:\n                let = key\n                poses = inds[key]\n                del inds[key]\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n        for x in poses:\n            res[i] = x\n            i += 1\n    else:\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if n & 1 and odds > 1 or (not n & 1 and odds > 0):",
      "mutated_line": "if n & 1 and odds <= 1 or (not n & 1 and odds > 0):",
      "code": "from typing import List\nfrom collections import Counter\n\ndef find_palindromic_permutation(s: str) -> List[int]:\n    n = len(s)\n    counts = Counter(s)\n    odds = 0\n    for count in counts.values():\n        if count & 1:\n            odds += 1\n    if n & 1 and odds <= 1 or (not n & 1 and odds > 0):\n        return [-1]\n    inds = {i: [] for i in s}\n    for i in range(n):\n        inds[s[i]].append(i + 1)\n    res = [-1] * n\n    if n & 1:\n        for (key, val) in counts.items():\n            if val & 1:\n                let = key\n                poses = inds[key]\n                del inds[key]\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n        for x in poses:\n            res[i] = x\n            i += 1\n    else:\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if n & 1 and odds > 1 or (not n & 1 and odds > 0):",
      "mutated_line": "if n & 1 and odds != 1 or (not n & 1 and odds > 0):",
      "code": "from typing import List\nfrom collections import Counter\n\ndef find_palindromic_permutation(s: str) -> List[int]:\n    n = len(s)\n    counts = Counter(s)\n    odds = 0\n    for count in counts.values():\n        if count & 1:\n            odds += 1\n    if n & 1 and odds != 1 or (not n & 1 and odds > 0):\n        return [-1]\n    inds = {i: [] for i in s}\n    for i in range(n):\n        inds[s[i]].append(i + 1)\n    res = [-1] * n\n    if n & 1:\n        for (key, val) in counts.items():\n            if val & 1:\n                let = key\n                poses = inds[key]\n                del inds[key]\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n        for x in poses:\n            res[i] = x\n            i += 1\n    else:\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if n & 1 and odds > 1 or (not n & 1 and odds > 0):",
      "mutated_line": "if n & 1 and odds > 1 or (not n & 1 and odds >= 0):",
      "code": "from typing import List\nfrom collections import Counter\n\ndef find_palindromic_permutation(s: str) -> List[int]:\n    n = len(s)\n    counts = Counter(s)\n    odds = 0\n    for count in counts.values():\n        if count & 1:\n            odds += 1\n    if n & 1 and odds > 1 or (not n & 1 and odds >= 0):\n        return [-1]\n    inds = {i: [] for i in s}\n    for i in range(n):\n        inds[s[i]].append(i + 1)\n    res = [-1] * n\n    if n & 1:\n        for (key, val) in counts.items():\n            if val & 1:\n                let = key\n                poses = inds[key]\n                del inds[key]\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n        for x in poses:\n            res[i] = x\n            i += 1\n    else:\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if n & 1 and odds > 1 or (not n & 1 and odds > 0):",
      "mutated_line": "if n & 1 and odds > 1 or (not n & 1 and odds <= 0):",
      "code": "from typing import List\nfrom collections import Counter\n\ndef find_palindromic_permutation(s: str) -> List[int]:\n    n = len(s)\n    counts = Counter(s)\n    odds = 0\n    for count in counts.values():\n        if count & 1:\n            odds += 1\n    if n & 1 and odds > 1 or (not n & 1 and odds <= 0):\n        return [-1]\n    inds = {i: [] for i in s}\n    for i in range(n):\n        inds[s[i]].append(i + 1)\n    res = [-1] * n\n    if n & 1:\n        for (key, val) in counts.items():\n            if val & 1:\n                let = key\n                poses = inds[key]\n                del inds[key]\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n        for x in poses:\n            res[i] = x\n            i += 1\n    else:\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if n & 1 and odds > 1 or (not n & 1 and odds > 0):",
      "mutated_line": "if n & 1 and odds > 1 or (not n & 1 and odds != 0):",
      "code": "from typing import List\nfrom collections import Counter\n\ndef find_palindromic_permutation(s: str) -> List[int]:\n    n = len(s)\n    counts = Counter(s)\n    odds = 0\n    for count in counts.values():\n        if count & 1:\n            odds += 1\n    if n & 1 and odds > 1 or (not n & 1 and odds != 0):\n        return [-1]\n    inds = {i: [] for i in s}\n    for i in range(n):\n        inds[s[i]].append(i + 1)\n    res = [-1] * n\n    if n & 1:\n        for (key, val) in counts.items():\n            if val & 1:\n                let = key\n                poses = inds[key]\n                del inds[key]\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n        for x in poses:\n            res[i] = x\n            i += 1\n    else:\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n    return res"
    },
    {
      "operator": "UOI",
      "lineno": 12,
      "original_line": "return [-1]",
      "mutated_line": "return [+1]",
      "code": "from typing import List\nfrom collections import Counter\n\ndef find_palindromic_permutation(s: str) -> List[int]:\n    n = len(s)\n    counts = Counter(s)\n    odds = 0\n    for count in counts.values():\n        if count & 1:\n            odds += 1\n    if n & 1 and odds > 1 or (not n & 1 and odds > 0):\n        return [+1]\n    inds = {i: [] for i in s}\n    for i in range(n):\n        inds[s[i]].append(i + 1)\n    res = [-1] * n\n    if n & 1:\n        for (key, val) in counts.items():\n            if val & 1:\n                let = key\n                poses = inds[key]\n                del inds[key]\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n        for x in poses:\n            res[i] = x\n            i += 1\n    else:\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "inds[s[i]].append(i + 1)",
      "mutated_line": "inds[s[i]].append(i - 1)",
      "code": "from typing import List\nfrom collections import Counter\n\ndef find_palindromic_permutation(s: str) -> List[int]:\n    n = len(s)\n    counts = Counter(s)\n    odds = 0\n    for count in counts.values():\n        if count & 1:\n            odds += 1\n    if n & 1 and odds > 1 or (not n & 1 and odds > 0):\n        return [-1]\n    inds = {i: [] for i in s}\n    for i in range(n):\n        inds[s[i]].append(i - 1)\n    res = [-1] * n\n    if n & 1:\n        for (key, val) in counts.items():\n            if val & 1:\n                let = key\n                poses = inds[key]\n                del inds[key]\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n        for x in poses:\n            res[i] = x\n            i += 1\n    else:\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "inds[s[i]].append(i + 1)",
      "mutated_line": "inds[s[i]].append(i * 1)",
      "code": "from typing import List\nfrom collections import Counter\n\ndef find_palindromic_permutation(s: str) -> List[int]:\n    n = len(s)\n    counts = Counter(s)\n    odds = 0\n    for count in counts.values():\n        if count & 1:\n            odds += 1\n    if n & 1 and odds > 1 or (not n & 1 and odds > 0):\n        return [-1]\n    inds = {i: [] for i in s}\n    for i in range(n):\n        inds[s[i]].append(i * 1)\n    res = [-1] * n\n    if n & 1:\n        for (key, val) in counts.items():\n            if val & 1:\n                let = key\n                poses = inds[key]\n                del inds[key]\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n        for x in poses:\n            res[i] = x\n            i += 1\n    else:\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n    return res"
    },
    {
      "operator": "UOI",
      "lineno": 18,
      "original_line": "res = [-1] * n",
      "mutated_line": "res = [+1] * n",
      "code": "from typing import List\nfrom collections import Counter\n\ndef find_palindromic_permutation(s: str) -> List[int]:\n    n = len(s)\n    counts = Counter(s)\n    odds = 0\n    for count in counts.values():\n        if count & 1:\n            odds += 1\n    if n & 1 and odds > 1 or (not n & 1 and odds > 0):\n        return [-1]\n    inds = {i: [] for i in s}\n    for i in range(n):\n        inds[s[i]].append(i + 1)\n    res = [+1] * n\n    if n & 1:\n        for (key, val) in counts.items():\n            if val & 1:\n                let = key\n                poses = inds[key]\n                del inds[key]\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n        for x in poses:\n            res[i] = x\n            i += 1\n    else:\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "if val & 1:",
      "mutated_line": "if val | 1:",
      "code": "from typing import List\nfrom collections import Counter\n\ndef find_palindromic_permutation(s: str) -> List[int]:\n    n = len(s)\n    counts = Counter(s)\n    odds = 0\n    for count in counts.values():\n        if count & 1:\n            odds += 1\n    if n & 1 and odds > 1 or (not n & 1 and odds > 0):\n        return [-1]\n    inds = {i: [] for i in s}\n    for i in range(n):\n        inds[s[i]].append(i + 1)\n    res = [-1] * n\n    if n & 1:\n        for (key, val) in counts.items():\n            if val | 1:\n                let = key\n                poses = inds[key]\n                del inds[key]\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n        for x in poses:\n            res[i] = x\n            i += 1\n    else:\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n    return res"
    },
    {
      "operator": "ASR",
      "lineno": 30,
      "original_line": "i += 1",
      "mutated_line": "i -= 1",
      "code": "from typing import List\nfrom collections import Counter\n\ndef find_palindromic_permutation(s: str) -> List[int]:\n    n = len(s)\n    counts = Counter(s)\n    odds = 0\n    for count in counts.values():\n        if count & 1:\n            odds += 1\n    if n & 1 and odds > 1 or (not n & 1 and odds > 0):\n        return [-1]\n    inds = {i: [] for i in s}\n    for i in range(n):\n        inds[s[i]].append(i + 1)\n    res = [-1] * n\n    if n & 1:\n        for (key, val) in counts.items():\n            if val & 1:\n                let = key\n                poses = inds[key]\n                del inds[key]\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i -= 1\n        for x in poses:\n            res[i] = x\n            i += 1\n    else:\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "i += 1",
      "mutated_line": "i += 2",
      "code": "from typing import List\nfrom collections import Counter\n\ndef find_palindromic_permutation(s: str) -> List[int]:\n    n = len(s)\n    counts = Counter(s)\n    odds = 0\n    for count in counts.values():\n        if count & 1:\n            odds += 1\n    if n & 1 and odds > 1 or (not n & 1 and odds > 0):\n        return [-1]\n    inds = {i: [] for i in s}\n    for i in range(n):\n        inds[s[i]].append(i + 1)\n    res = [-1] * n\n    if n & 1:\n        for (key, val) in counts.items():\n            if val & 1:\n                let = key\n                poses = inds[key]\n                del inds[key]\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n        for x in poses:\n            res[i] = x\n            i += 2\n    else:\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "i += 1",
      "mutated_line": "i += 0",
      "code": "from typing import List\nfrom collections import Counter\n\ndef find_palindromic_permutation(s: str) -> List[int]:\n    n = len(s)\n    counts = Counter(s)\n    odds = 0\n    for count in counts.values():\n        if count & 1:\n            odds += 1\n    if n & 1 and odds > 1 or (not n & 1 and odds > 0):\n        return [-1]\n    inds = {i: [] for i in s}\n    for i in range(n):\n        inds[s[i]].append(i + 1)\n    res = [-1] * n\n    if n & 1:\n        for (key, val) in counts.items():\n            if val & 1:\n                let = key\n                poses = inds[key]\n                del inds[key]\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n        for x in poses:\n            res[i] = x\n            i += 0\n    else:\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "i += 1",
      "mutated_line": "i += 0",
      "code": "from typing import List\nfrom collections import Counter\n\ndef find_palindromic_permutation(s: str) -> List[int]:\n    n = len(s)\n    counts = Counter(s)\n    odds = 0\n    for count in counts.values():\n        if count & 1:\n            odds += 1\n    if n & 1 and odds > 1 or (not n & 1 and odds > 0):\n        return [-1]\n    inds = {i: [] for i in s}\n    for i in range(n):\n        inds[s[i]].append(i + 1)\n    res = [-1] * n\n    if n & 1:\n        for (key, val) in counts.items():\n            if val & 1:\n                let = key\n                poses = inds[key]\n                del inds[key]\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n        for x in poses:\n            res[i] = x\n            i += 0\n    else:\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "i += 1",
      "mutated_line": "i += -1",
      "code": "from typing import List\nfrom collections import Counter\n\ndef find_palindromic_permutation(s: str) -> List[int]:\n    n = len(s)\n    counts = Counter(s)\n    odds = 0\n    for count in counts.values():\n        if count & 1:\n            odds += 1\n    if n & 1 and odds > 1 or (not n & 1 and odds > 0):\n        return [-1]\n    inds = {i: [] for i in s}\n    for i in range(n):\n        inds[s[i]].append(i + 1)\n    res = [-1] * n\n    if n & 1:\n        for (key, val) in counts.items():\n            if val & 1:\n                let = key\n                poses = inds[key]\n                del inds[key]\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n        for x in poses:\n            res[i] = x\n            i += -1\n    else:\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n    return res"
    },
    {
      "operator": "ASR",
      "lineno": 40,
      "original_line": "i += 1",
      "mutated_line": "i -= 1",
      "code": "from typing import List\nfrom collections import Counter\n\ndef find_palindromic_permutation(s: str) -> List[int]:\n    n = len(s)\n    counts = Counter(s)\n    odds = 0\n    for count in counts.values():\n        if count & 1:\n            odds += 1\n    if n & 1 and odds > 1 or (not n & 1 and odds > 0):\n        return [-1]\n    inds = {i: [] for i in s}\n    for i in range(n):\n        inds[s[i]].append(i + 1)\n    res = [-1] * n\n    if n & 1:\n        for (key, val) in counts.items():\n            if val & 1:\n                let = key\n                poses = inds[key]\n                del inds[key]\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n        for x in poses:\n            res[i] = x\n            i += 1\n    else:\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i -= 1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if n & 1 and odds > 1 or (not n & 1 and odds > 0):",
      "mutated_line": "if n & 2 and odds > 1 or (not n & 1 and odds > 0):",
      "code": "from typing import List\nfrom collections import Counter\n\ndef find_palindromic_permutation(s: str) -> List[int]:\n    n = len(s)\n    counts = Counter(s)\n    odds = 0\n    for count in counts.values():\n        if count & 1:\n            odds += 1\n    if n & 2 and odds > 1 or (not n & 1 and odds > 0):\n        return [-1]\n    inds = {i: [] for i in s}\n    for i in range(n):\n        inds[s[i]].append(i + 1)\n    res = [-1] * n\n    if n & 1:\n        for (key, val) in counts.items():\n            if val & 1:\n                let = key\n                poses = inds[key]\n                del inds[key]\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n        for x in poses:\n            res[i] = x\n            i += 1\n    else:\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if n & 1 and odds > 1 or (not n & 1 and odds > 0):",
      "mutated_line": "if n & 0 and odds > 1 or (not n & 1 and odds > 0):",
      "code": "from typing import List\nfrom collections import Counter\n\ndef find_palindromic_permutation(s: str) -> List[int]:\n    n = len(s)\n    counts = Counter(s)\n    odds = 0\n    for count in counts.values():\n        if count & 1:\n            odds += 1\n    if n & 0 and odds > 1 or (not n & 1 and odds > 0):\n        return [-1]\n    inds = {i: [] for i in s}\n    for i in range(n):\n        inds[s[i]].append(i + 1)\n    res = [-1] * n\n    if n & 1:\n        for (key, val) in counts.items():\n            if val & 1:\n                let = key\n                poses = inds[key]\n                del inds[key]\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n        for x in poses:\n            res[i] = x\n            i += 1\n    else:\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if n & 1 and odds > 1 or (not n & 1 and odds > 0):",
      "mutated_line": "if n & 0 and odds > 1 or (not n & 1 and odds > 0):",
      "code": "from typing import List\nfrom collections import Counter\n\ndef find_palindromic_permutation(s: str) -> List[int]:\n    n = len(s)\n    counts = Counter(s)\n    odds = 0\n    for count in counts.values():\n        if count & 1:\n            odds += 1\n    if n & 0 and odds > 1 or (not n & 1 and odds > 0):\n        return [-1]\n    inds = {i: [] for i in s}\n    for i in range(n):\n        inds[s[i]].append(i + 1)\n    res = [-1] * n\n    if n & 1:\n        for (key, val) in counts.items():\n            if val & 1:\n                let = key\n                poses = inds[key]\n                del inds[key]\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n        for x in poses:\n            res[i] = x\n            i += 1\n    else:\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if n & 1 and odds > 1 or (not n & 1 and odds > 0):",
      "mutated_line": "if n & -1 and odds > 1 or (not n & 1 and odds > 0):",
      "code": "from typing import List\nfrom collections import Counter\n\ndef find_palindromic_permutation(s: str) -> List[int]:\n    n = len(s)\n    counts = Counter(s)\n    odds = 0\n    for count in counts.values():\n        if count & 1:\n            odds += 1\n    if n & -1 and odds > 1 or (not n & 1 and odds > 0):\n        return [-1]\n    inds = {i: [] for i in s}\n    for i in range(n):\n        inds[s[i]].append(i + 1)\n    res = [-1] * n\n    if n & 1:\n        for (key, val) in counts.items():\n            if val & 1:\n                let = key\n                poses = inds[key]\n                del inds[key]\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n        for x in poses:\n            res[i] = x\n            i += 1\n    else:\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if n & 1 and odds > 1 or (not n & 1 and odds > 0):",
      "mutated_line": "if n & 1 and odds > 2 or (not n & 1 and odds > 0):",
      "code": "from typing import List\nfrom collections import Counter\n\ndef find_palindromic_permutation(s: str) -> List[int]:\n    n = len(s)\n    counts = Counter(s)\n    odds = 0\n    for count in counts.values():\n        if count & 1:\n            odds += 1\n    if n & 1 and odds > 2 or (not n & 1 and odds > 0):\n        return [-1]\n    inds = {i: [] for i in s}\n    for i in range(n):\n        inds[s[i]].append(i + 1)\n    res = [-1] * n\n    if n & 1:\n        for (key, val) in counts.items():\n            if val & 1:\n                let = key\n                poses = inds[key]\n                del inds[key]\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n        for x in poses:\n            res[i] = x\n            i += 1\n    else:\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if n & 1 and odds > 1 or (not n & 1 and odds > 0):",
      "mutated_line": "if n & 1 and odds > 0 or (not n & 1 and odds > 0):",
      "code": "from typing import List\nfrom collections import Counter\n\ndef find_palindromic_permutation(s: str) -> List[int]:\n    n = len(s)\n    counts = Counter(s)\n    odds = 0\n    for count in counts.values():\n        if count & 1:\n            odds += 1\n    if n & 1 and odds > 0 or (not n & 1 and odds > 0):\n        return [-1]\n    inds = {i: [] for i in s}\n    for i in range(n):\n        inds[s[i]].append(i + 1)\n    res = [-1] * n\n    if n & 1:\n        for (key, val) in counts.items():\n            if val & 1:\n                let = key\n                poses = inds[key]\n                del inds[key]\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n        for x in poses:\n            res[i] = x\n            i += 1\n    else:\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if n & 1 and odds > 1 or (not n & 1 and odds > 0):",
      "mutated_line": "if n & 1 and odds > 0 or (not n & 1 and odds > 0):",
      "code": "from typing import List\nfrom collections import Counter\n\ndef find_palindromic_permutation(s: str) -> List[int]:\n    n = len(s)\n    counts = Counter(s)\n    odds = 0\n    for count in counts.values():\n        if count & 1:\n            odds += 1\n    if n & 1 and odds > 0 or (not n & 1 and odds > 0):\n        return [-1]\n    inds = {i: [] for i in s}\n    for i in range(n):\n        inds[s[i]].append(i + 1)\n    res = [-1] * n\n    if n & 1:\n        for (key, val) in counts.items():\n            if val & 1:\n                let = key\n                poses = inds[key]\n                del inds[key]\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n        for x in poses:\n            res[i] = x\n            i += 1\n    else:\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if n & 1 and odds > 1 or (not n & 1 and odds > 0):",
      "mutated_line": "if n & 1 and odds > -1 or (not n & 1 and odds > 0):",
      "code": "from typing import List\nfrom collections import Counter\n\ndef find_palindromic_permutation(s: str) -> List[int]:\n    n = len(s)\n    counts = Counter(s)\n    odds = 0\n    for count in counts.values():\n        if count & 1:\n            odds += 1\n    if n & 1 and odds > -1 or (not n & 1 and odds > 0):\n        return [-1]\n    inds = {i: [] for i in s}\n    for i in range(n):\n        inds[s[i]].append(i + 1)\n    res = [-1] * n\n    if n & 1:\n        for (key, val) in counts.items():\n            if val & 1:\n                let = key\n                poses = inds[key]\n                del inds[key]\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n        for x in poses:\n            res[i] = x\n            i += 1\n    else:\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "if n & 1 and odds > 1 or (not n & 1 and odds > 0):",
      "mutated_line": "if n & 1 and odds > 1 or (not n | 1 and odds > 0):",
      "code": "from typing import List\nfrom collections import Counter\n\ndef find_palindromic_permutation(s: str) -> List[int]:\n    n = len(s)\n    counts = Counter(s)\n    odds = 0\n    for count in counts.values():\n        if count & 1:\n            odds += 1\n    if n & 1 and odds > 1 or (not n | 1 and odds > 0):\n        return [-1]\n    inds = {i: [] for i in s}\n    for i in range(n):\n        inds[s[i]].append(i + 1)\n    res = [-1] * n\n    if n & 1:\n        for (key, val) in counts.items():\n            if val & 1:\n                let = key\n                poses = inds[key]\n                del inds[key]\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n        for x in poses:\n            res[i] = x\n            i += 1\n    else:\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if n & 1 and odds > 1 or (not n & 1 and odds > 0):",
      "mutated_line": "if n & 1 and odds > 1 or (not n & 1 and odds > 1):",
      "code": "from typing import List\nfrom collections import Counter\n\ndef find_palindromic_permutation(s: str) -> List[int]:\n    n = len(s)\n    counts = Counter(s)\n    odds = 0\n    for count in counts.values():\n        if count & 1:\n            odds += 1\n    if n & 1 and odds > 1 or (not n & 1 and odds > 1):\n        return [-1]\n    inds = {i: [] for i in s}\n    for i in range(n):\n        inds[s[i]].append(i + 1)\n    res = [-1] * n\n    if n & 1:\n        for (key, val) in counts.items():\n            if val & 1:\n                let = key\n                poses = inds[key]\n                del inds[key]\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n        for x in poses:\n            res[i] = x\n            i += 1\n    else:\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if n & 1 and odds > 1 or (not n & 1 and odds > 0):",
      "mutated_line": "if n & 1 and odds > 1 or (not n & 1 and odds > -1):",
      "code": "from typing import List\nfrom collections import Counter\n\ndef find_palindromic_permutation(s: str) -> List[int]:\n    n = len(s)\n    counts = Counter(s)\n    odds = 0\n    for count in counts.values():\n        if count & 1:\n            odds += 1\n    if n & 1 and odds > 1 or (not n & 1 and odds > -1):\n        return [-1]\n    inds = {i: [] for i in s}\n    for i in range(n):\n        inds[s[i]].append(i + 1)\n    res = [-1] * n\n    if n & 1:\n        for (key, val) in counts.items():\n            if val & 1:\n                let = key\n                poses = inds[key]\n                del inds[key]\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n        for x in poses:\n            res[i] = x\n            i += 1\n    else:\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if n & 1 and odds > 1 or (not n & 1 and odds > 0):",
      "mutated_line": "if n & 1 and odds > 1 or (not n & 1 and odds > 1):",
      "code": "from typing import List\nfrom collections import Counter\n\ndef find_palindromic_permutation(s: str) -> List[int]:\n    n = len(s)\n    counts = Counter(s)\n    odds = 0\n    for count in counts.values():\n        if count & 1:\n            odds += 1\n    if n & 1 and odds > 1 or (not n & 1 and odds > 1):\n        return [-1]\n    inds = {i: [] for i in s}\n    for i in range(n):\n        inds[s[i]].append(i + 1)\n    res = [-1] * n\n    if n & 1:\n        for (key, val) in counts.items():\n            if val & 1:\n                let = key\n                poses = inds[key]\n                del inds[key]\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n        for x in poses:\n            res[i] = x\n            i += 1\n    else:\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return [-1]",
      "mutated_line": "return [-2]",
      "code": "from typing import List\nfrom collections import Counter\n\ndef find_palindromic_permutation(s: str) -> List[int]:\n    n = len(s)\n    counts = Counter(s)\n    odds = 0\n    for count in counts.values():\n        if count & 1:\n            odds += 1\n    if n & 1 and odds > 1 or (not n & 1 and odds > 0):\n        return [-2]\n    inds = {i: [] for i in s}\n    for i in range(n):\n        inds[s[i]].append(i + 1)\n    res = [-1] * n\n    if n & 1:\n        for (key, val) in counts.items():\n            if val & 1:\n                let = key\n                poses = inds[key]\n                del inds[key]\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n        for x in poses:\n            res[i] = x\n            i += 1\n    else:\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return [-1]",
      "mutated_line": "return [-0]",
      "code": "from typing import List\nfrom collections import Counter\n\ndef find_palindromic_permutation(s: str) -> List[int]:\n    n = len(s)\n    counts = Counter(s)\n    odds = 0\n    for count in counts.values():\n        if count & 1:\n            odds += 1\n    if n & 1 and odds > 1 or (not n & 1 and odds > 0):\n        return [-0]\n    inds = {i: [] for i in s}\n    for i in range(n):\n        inds[s[i]].append(i + 1)\n    res = [-1] * n\n    if n & 1:\n        for (key, val) in counts.items():\n            if val & 1:\n                let = key\n                poses = inds[key]\n                del inds[key]\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n        for x in poses:\n            res[i] = x\n            i += 1\n    else:\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return [-1]",
      "mutated_line": "return [-0]",
      "code": "from typing import List\nfrom collections import Counter\n\ndef find_palindromic_permutation(s: str) -> List[int]:\n    n = len(s)\n    counts = Counter(s)\n    odds = 0\n    for count in counts.values():\n        if count & 1:\n            odds += 1\n    if n & 1 and odds > 1 or (not n & 1 and odds > 0):\n        return [-0]\n    inds = {i: [] for i in s}\n    for i in range(n):\n        inds[s[i]].append(i + 1)\n    res = [-1] * n\n    if n & 1:\n        for (key, val) in counts.items():\n            if val & 1:\n                let = key\n                poses = inds[key]\n                del inds[key]\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n        for x in poses:\n            res[i] = x\n            i += 1\n    else:\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return [-1]",
      "mutated_line": "return [--1]",
      "code": "from typing import List\nfrom collections import Counter\n\ndef find_palindromic_permutation(s: str) -> List[int]:\n    n = len(s)\n    counts = Counter(s)\n    odds = 0\n    for count in counts.values():\n        if count & 1:\n            odds += 1\n    if n & 1 and odds > 1 or (not n & 1 and odds > 0):\n        return [--1]\n    inds = {i: [] for i in s}\n    for i in range(n):\n        inds[s[i]].append(i + 1)\n    res = [-1] * n\n    if n & 1:\n        for (key, val) in counts.items():\n            if val & 1:\n                let = key\n                poses = inds[key]\n                del inds[key]\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n        for x in poses:\n            res[i] = x\n            i += 1\n    else:\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "inds[s[i]].append(i + 1)",
      "mutated_line": "inds[s[i]].append(i + 2)",
      "code": "from typing import List\nfrom collections import Counter\n\ndef find_palindromic_permutation(s: str) -> List[int]:\n    n = len(s)\n    counts = Counter(s)\n    odds = 0\n    for count in counts.values():\n        if count & 1:\n            odds += 1\n    if n & 1 and odds > 1 or (not n & 1 and odds > 0):\n        return [-1]\n    inds = {i: [] for i in s}\n    for i in range(n):\n        inds[s[i]].append(i + 2)\n    res = [-1] * n\n    if n & 1:\n        for (key, val) in counts.items():\n            if val & 1:\n                let = key\n                poses = inds[key]\n                del inds[key]\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n        for x in poses:\n            res[i] = x\n            i += 1\n    else:\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "inds[s[i]].append(i + 1)",
      "mutated_line": "inds[s[i]].append(i + 0)",
      "code": "from typing import List\nfrom collections import Counter\n\ndef find_palindromic_permutation(s: str) -> List[int]:\n    n = len(s)\n    counts = Counter(s)\n    odds = 0\n    for count in counts.values():\n        if count & 1:\n            odds += 1\n    if n & 1 and odds > 1 or (not n & 1 and odds > 0):\n        return [-1]\n    inds = {i: [] for i in s}\n    for i in range(n):\n        inds[s[i]].append(i + 0)\n    res = [-1] * n\n    if n & 1:\n        for (key, val) in counts.items():\n            if val & 1:\n                let = key\n                poses = inds[key]\n                del inds[key]\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n        for x in poses:\n            res[i] = x\n            i += 1\n    else:\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "inds[s[i]].append(i + 1)",
      "mutated_line": "inds[s[i]].append(i + 0)",
      "code": "from typing import List\nfrom collections import Counter\n\ndef find_palindromic_permutation(s: str) -> List[int]:\n    n = len(s)\n    counts = Counter(s)\n    odds = 0\n    for count in counts.values():\n        if count & 1:\n            odds += 1\n    if n & 1 and odds > 1 or (not n & 1 and odds > 0):\n        return [-1]\n    inds = {i: [] for i in s}\n    for i in range(n):\n        inds[s[i]].append(i + 0)\n    res = [-1] * n\n    if n & 1:\n        for (key, val) in counts.items():\n            if val & 1:\n                let = key\n                poses = inds[key]\n                del inds[key]\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n        for x in poses:\n            res[i] = x\n            i += 1\n    else:\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "inds[s[i]].append(i + 1)",
      "mutated_line": "inds[s[i]].append(i + -1)",
      "code": "from typing import List\nfrom collections import Counter\n\ndef find_palindromic_permutation(s: str) -> List[int]:\n    n = len(s)\n    counts = Counter(s)\n    odds = 0\n    for count in counts.values():\n        if count & 1:\n            odds += 1\n    if n & 1 and odds > 1 or (not n & 1 and odds > 0):\n        return [-1]\n    inds = {i: [] for i in s}\n    for i in range(n):\n        inds[s[i]].append(i + -1)\n    res = [-1] * n\n    if n & 1:\n        for (key, val) in counts.items():\n            if val & 1:\n                let = key\n                poses = inds[key]\n                del inds[key]\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n        for x in poses:\n            res[i] = x\n            i += 1\n    else:\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "res = [-1] * n",
      "mutated_line": "res = [-2] * n",
      "code": "from typing import List\nfrom collections import Counter\n\ndef find_palindromic_permutation(s: str) -> List[int]:\n    n = len(s)\n    counts = Counter(s)\n    odds = 0\n    for count in counts.values():\n        if count & 1:\n            odds += 1\n    if n & 1 and odds > 1 or (not n & 1 and odds > 0):\n        return [-1]\n    inds = {i: [] for i in s}\n    for i in range(n):\n        inds[s[i]].append(i + 1)\n    res = [-2] * n\n    if n & 1:\n        for (key, val) in counts.items():\n            if val & 1:\n                let = key\n                poses = inds[key]\n                del inds[key]\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n        for x in poses:\n            res[i] = x\n            i += 1\n    else:\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "res = [-1] * n",
      "mutated_line": "res = [-0] * n",
      "code": "from typing import List\nfrom collections import Counter\n\ndef find_palindromic_permutation(s: str) -> List[int]:\n    n = len(s)\n    counts = Counter(s)\n    odds = 0\n    for count in counts.values():\n        if count & 1:\n            odds += 1\n    if n & 1 and odds > 1 or (not n & 1 and odds > 0):\n        return [-1]\n    inds = {i: [] for i in s}\n    for i in range(n):\n        inds[s[i]].append(i + 1)\n    res = [-0] * n\n    if n & 1:\n        for (key, val) in counts.items():\n            if val & 1:\n                let = key\n                poses = inds[key]\n                del inds[key]\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n        for x in poses:\n            res[i] = x\n            i += 1\n    else:\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "res = [-1] * n",
      "mutated_line": "res = [-0] * n",
      "code": "from typing import List\nfrom collections import Counter\n\ndef find_palindromic_permutation(s: str) -> List[int]:\n    n = len(s)\n    counts = Counter(s)\n    odds = 0\n    for count in counts.values():\n        if count & 1:\n            odds += 1\n    if n & 1 and odds > 1 or (not n & 1 and odds > 0):\n        return [-1]\n    inds = {i: [] for i in s}\n    for i in range(n):\n        inds[s[i]].append(i + 1)\n    res = [-0] * n\n    if n & 1:\n        for (key, val) in counts.items():\n            if val & 1:\n                let = key\n                poses = inds[key]\n                del inds[key]\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n        for x in poses:\n            res[i] = x\n            i += 1\n    else:\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "res = [-1] * n",
      "mutated_line": "res = [--1] * n",
      "code": "from typing import List\nfrom collections import Counter\n\ndef find_palindromic_permutation(s: str) -> List[int]:\n    n = len(s)\n    counts = Counter(s)\n    odds = 0\n    for count in counts.values():\n        if count & 1:\n            odds += 1\n    if n & 1 and odds > 1 or (not n & 1 and odds > 0):\n        return [-1]\n    inds = {i: [] for i in s}\n    for i in range(n):\n        inds[s[i]].append(i + 1)\n    res = [--1] * n\n    if n & 1:\n        for (key, val) in counts.items():\n            if val & 1:\n                let = key\n                poses = inds[key]\n                del inds[key]\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n        for x in poses:\n            res[i] = x\n            i += 1\n    else:\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if val & 1:",
      "mutated_line": "if val & 2:",
      "code": "from typing import List\nfrom collections import Counter\n\ndef find_palindromic_permutation(s: str) -> List[int]:\n    n = len(s)\n    counts = Counter(s)\n    odds = 0\n    for count in counts.values():\n        if count & 1:\n            odds += 1\n    if n & 1 and odds > 1 or (not n & 1 and odds > 0):\n        return [-1]\n    inds = {i: [] for i in s}\n    for i in range(n):\n        inds[s[i]].append(i + 1)\n    res = [-1] * n\n    if n & 1:\n        for (key, val) in counts.items():\n            if val & 2:\n                let = key\n                poses = inds[key]\n                del inds[key]\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n        for x in poses:\n            res[i] = x\n            i += 1\n    else:\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if val & 1:",
      "mutated_line": "if val & 0:",
      "code": "from typing import List\nfrom collections import Counter\n\ndef find_palindromic_permutation(s: str) -> List[int]:\n    n = len(s)\n    counts = Counter(s)\n    odds = 0\n    for count in counts.values():\n        if count & 1:\n            odds += 1\n    if n & 1 and odds > 1 or (not n & 1 and odds > 0):\n        return [-1]\n    inds = {i: [] for i in s}\n    for i in range(n):\n        inds[s[i]].append(i + 1)\n    res = [-1] * n\n    if n & 1:\n        for (key, val) in counts.items():\n            if val & 0:\n                let = key\n                poses = inds[key]\n                del inds[key]\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n        for x in poses:\n            res[i] = x\n            i += 1\n    else:\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if val & 1:",
      "mutated_line": "if val & 0:",
      "code": "from typing import List\nfrom collections import Counter\n\ndef find_palindromic_permutation(s: str) -> List[int]:\n    n = len(s)\n    counts = Counter(s)\n    odds = 0\n    for count in counts.values():\n        if count & 1:\n            odds += 1\n    if n & 1 and odds > 1 or (not n & 1 and odds > 0):\n        return [-1]\n    inds = {i: [] for i in s}\n    for i in range(n):\n        inds[s[i]].append(i + 1)\n    res = [-1] * n\n    if n & 1:\n        for (key, val) in counts.items():\n            if val & 0:\n                let = key\n                poses = inds[key]\n                del inds[key]\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n        for x in poses:\n            res[i] = x\n            i += 1\n    else:\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if val & 1:",
      "mutated_line": "if val & -1:",
      "code": "from typing import List\nfrom collections import Counter\n\ndef find_palindromic_permutation(s: str) -> List[int]:\n    n = len(s)\n    counts = Counter(s)\n    odds = 0\n    for count in counts.values():\n        if count & 1:\n            odds += 1\n    if n & 1 and odds > 1 or (not n & 1 and odds > 0):\n        return [-1]\n    inds = {i: [] for i in s}\n    for i in range(n):\n        inds[s[i]].append(i + 1)\n    res = [-1] * n\n    if n & 1:\n        for (key, val) in counts.items():\n            if val & -1:\n                let = key\n                poses = inds[key]\n                del inds[key]\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n        for x in poses:\n            res[i] = x\n            i += 1\n    else:\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "i += 1",
      "mutated_line": "i += 2",
      "code": "from typing import List\nfrom collections import Counter\n\ndef find_palindromic_permutation(s: str) -> List[int]:\n    n = len(s)\n    counts = Counter(s)\n    odds = 0\n    for count in counts.values():\n        if count & 1:\n            odds += 1\n    if n & 1 and odds > 1 or (not n & 1 and odds > 0):\n        return [-1]\n    inds = {i: [] for i in s}\n    for i in range(n):\n        inds[s[i]].append(i + 1)\n    res = [-1] * n\n    if n & 1:\n        for (key, val) in counts.items():\n            if val & 1:\n                let = key\n                poses = inds[key]\n                del inds[key]\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 2\n        for x in poses:\n            res[i] = x\n            i += 1\n    else:\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "i += 1",
      "mutated_line": "i += 0",
      "code": "from typing import List\nfrom collections import Counter\n\ndef find_palindromic_permutation(s: str) -> List[int]:\n    n = len(s)\n    counts = Counter(s)\n    odds = 0\n    for count in counts.values():\n        if count & 1:\n            odds += 1\n    if n & 1 and odds > 1 or (not n & 1 and odds > 0):\n        return [-1]\n    inds = {i: [] for i in s}\n    for i in range(n):\n        inds[s[i]].append(i + 1)\n    res = [-1] * n\n    if n & 1:\n        for (key, val) in counts.items():\n            if val & 1:\n                let = key\n                poses = inds[key]\n                del inds[key]\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 0\n        for x in poses:\n            res[i] = x\n            i += 1\n    else:\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "i += 1",
      "mutated_line": "i += 0",
      "code": "from typing import List\nfrom collections import Counter\n\ndef find_palindromic_permutation(s: str) -> List[int]:\n    n = len(s)\n    counts = Counter(s)\n    odds = 0\n    for count in counts.values():\n        if count & 1:\n            odds += 1\n    if n & 1 and odds > 1 or (not n & 1 and odds > 0):\n        return [-1]\n    inds = {i: [] for i in s}\n    for i in range(n):\n        inds[s[i]].append(i + 1)\n    res = [-1] * n\n    if n & 1:\n        for (key, val) in counts.items():\n            if val & 1:\n                let = key\n                poses = inds[key]\n                del inds[key]\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 0\n        for x in poses:\n            res[i] = x\n            i += 1\n    else:\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "i += 1",
      "mutated_line": "i += -1",
      "code": "from typing import List\nfrom collections import Counter\n\ndef find_palindromic_permutation(s: str) -> List[int]:\n    n = len(s)\n    counts = Counter(s)\n    odds = 0\n    for count in counts.values():\n        if count & 1:\n            odds += 1\n    if n & 1 and odds > 1 or (not n & 1 and odds > 0):\n        return [-1]\n    inds = {i: [] for i in s}\n    for i in range(n):\n        inds[s[i]].append(i + 1)\n    res = [-1] * n\n    if n & 1:\n        for (key, val) in counts.items():\n            if val & 1:\n                let = key\n                poses = inds[key]\n                del inds[key]\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += -1\n        for x in poses:\n            res[i] = x\n            i += 1\n    else:\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "i += 1",
      "mutated_line": "i += 2",
      "code": "from typing import List\nfrom collections import Counter\n\ndef find_palindromic_permutation(s: str) -> List[int]:\n    n = len(s)\n    counts = Counter(s)\n    odds = 0\n    for count in counts.values():\n        if count & 1:\n            odds += 1\n    if n & 1 and odds > 1 or (not n & 1 and odds > 0):\n        return [-1]\n    inds = {i: [] for i in s}\n    for i in range(n):\n        inds[s[i]].append(i + 1)\n    res = [-1] * n\n    if n & 1:\n        for (key, val) in counts.items():\n            if val & 1:\n                let = key\n                poses = inds[key]\n                del inds[key]\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n        for x in poses:\n            res[i] = x\n            i += 1\n    else:\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 2\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "i += 1",
      "mutated_line": "i += 0",
      "code": "from typing import List\nfrom collections import Counter\n\ndef find_palindromic_permutation(s: str) -> List[int]:\n    n = len(s)\n    counts = Counter(s)\n    odds = 0\n    for count in counts.values():\n        if count & 1:\n            odds += 1\n    if n & 1 and odds > 1 or (not n & 1 and odds > 0):\n        return [-1]\n    inds = {i: [] for i in s}\n    for i in range(n):\n        inds[s[i]].append(i + 1)\n    res = [-1] * n\n    if n & 1:\n        for (key, val) in counts.items():\n            if val & 1:\n                let = key\n                poses = inds[key]\n                del inds[key]\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n        for x in poses:\n            res[i] = x\n            i += 1\n    else:\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 0\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "i += 1",
      "mutated_line": "i += 0",
      "code": "from typing import List\nfrom collections import Counter\n\ndef find_palindromic_permutation(s: str) -> List[int]:\n    n = len(s)\n    counts = Counter(s)\n    odds = 0\n    for count in counts.values():\n        if count & 1:\n            odds += 1\n    if n & 1 and odds > 1 or (not n & 1 and odds > 0):\n        return [-1]\n    inds = {i: [] for i in s}\n    for i in range(n):\n        inds[s[i]].append(i + 1)\n    res = [-1] * n\n    if n & 1:\n        for (key, val) in counts.items():\n            if val & 1:\n                let = key\n                poses = inds[key]\n                del inds[key]\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n        for x in poses:\n            res[i] = x\n            i += 1\n    else:\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 0\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "i += 1",
      "mutated_line": "i += -1",
      "code": "from typing import List\nfrom collections import Counter\n\ndef find_palindromic_permutation(s: str) -> List[int]:\n    n = len(s)\n    counts = Counter(s)\n    odds = 0\n    for count in counts.values():\n        if count & 1:\n            odds += 1\n    if n & 1 and odds > 1 or (not n & 1 and odds > 0):\n        return [-1]\n    inds = {i: [] for i in s}\n    for i in range(n):\n        inds[s[i]].append(i + 1)\n    res = [-1] * n\n    if n & 1:\n        for (key, val) in counts.items():\n            if val & 1:\n                let = key\n                poses = inds[key]\n                del inds[key]\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n        for x in poses:\n            res[i] = x\n            i += 1\n    else:\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += -1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if n & 1 and odds > 1 or (not n & 1 and odds > 0):",
      "mutated_line": "if n & 1 and odds > 1 or (not n & 2 and odds > 0):",
      "code": "from typing import List\nfrom collections import Counter\n\ndef find_palindromic_permutation(s: str) -> List[int]:\n    n = len(s)\n    counts = Counter(s)\n    odds = 0\n    for count in counts.values():\n        if count & 1:\n            odds += 1\n    if n & 1 and odds > 1 or (not n & 2 and odds > 0):\n        return [-1]\n    inds = {i: [] for i in s}\n    for i in range(n):\n        inds[s[i]].append(i + 1)\n    res = [-1] * n\n    if n & 1:\n        for (key, val) in counts.items():\n            if val & 1:\n                let = key\n                poses = inds[key]\n                del inds[key]\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n        for x in poses:\n            res[i] = x\n            i += 1\n    else:\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if n & 1 and odds > 1 or (not n & 1 and odds > 0):",
      "mutated_line": "if n & 1 and odds > 1 or (not n & 0 and odds > 0):",
      "code": "from typing import List\nfrom collections import Counter\n\ndef find_palindromic_permutation(s: str) -> List[int]:\n    n = len(s)\n    counts = Counter(s)\n    odds = 0\n    for count in counts.values():\n        if count & 1:\n            odds += 1\n    if n & 1 and odds > 1 or (not n & 0 and odds > 0):\n        return [-1]\n    inds = {i: [] for i in s}\n    for i in range(n):\n        inds[s[i]].append(i + 1)\n    res = [-1] * n\n    if n & 1:\n        for (key, val) in counts.items():\n            if val & 1:\n                let = key\n                poses = inds[key]\n                del inds[key]\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n        for x in poses:\n            res[i] = x\n            i += 1\n    else:\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if n & 1 and odds > 1 or (not n & 1 and odds > 0):",
      "mutated_line": "if n & 1 and odds > 1 or (not n & 0 and odds > 0):",
      "code": "from typing import List\nfrom collections import Counter\n\ndef find_palindromic_permutation(s: str) -> List[int]:\n    n = len(s)\n    counts = Counter(s)\n    odds = 0\n    for count in counts.values():\n        if count & 1:\n            odds += 1\n    if n & 1 and odds > 1 or (not n & 0 and odds > 0):\n        return [-1]\n    inds = {i: [] for i in s}\n    for i in range(n):\n        inds[s[i]].append(i + 1)\n    res = [-1] * n\n    if n & 1:\n        for (key, val) in counts.items():\n            if val & 1:\n                let = key\n                poses = inds[key]\n                del inds[key]\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n        for x in poses:\n            res[i] = x\n            i += 1\n    else:\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if n & 1 and odds > 1 or (not n & 1 and odds > 0):",
      "mutated_line": "if n & 1 and odds > 1 or (not n & -1 and odds > 0):",
      "code": "from typing import List\nfrom collections import Counter\n\ndef find_palindromic_permutation(s: str) -> List[int]:\n    n = len(s)\n    counts = Counter(s)\n    odds = 0\n    for count in counts.values():\n        if count & 1:\n            odds += 1\n    if n & 1 and odds > 1 or (not n & -1 and odds > 0):\n        return [-1]\n    inds = {i: [] for i in s}\n    for i in range(n):\n        inds[s[i]].append(i + 1)\n    res = [-1] * n\n    if n & 1:\n        for (key, val) in counts.items():\n            if val & 1:\n                let = key\n                poses = inds[key]\n                del inds[key]\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n        for x in poses:\n            res[i] = x\n            i += 1\n    else:\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "res[n - i - 1] = pos.pop()",
      "mutated_line": "res[n - i + 1] = pos.pop()",
      "code": "from typing import List\nfrom collections import Counter\n\ndef find_palindromic_permutation(s: str) -> List[int]:\n    n = len(s)\n    counts = Counter(s)\n    odds = 0\n    for count in counts.values():\n        if count & 1:\n            odds += 1\n    if n & 1 and odds > 1 or (not n & 1 and odds > 0):\n        return [-1]\n    inds = {i: [] for i in s}\n    for i in range(n):\n        inds[s[i]].append(i + 1)\n    res = [-1] * n\n    if n & 1:\n        for (key, val) in counts.items():\n            if val & 1:\n                let = key\n                poses = inds[key]\n                del inds[key]\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i + 1] = pos.pop()\n                i += 1\n        for x in poses:\n            res[i] = x\n            i += 1\n    else:\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "res[n - i - 1] = pos.pop()",
      "mutated_line": "res[(n - i) * 1] = pos.pop()",
      "code": "from typing import List\nfrom collections import Counter\n\ndef find_palindromic_permutation(s: str) -> List[int]:\n    n = len(s)\n    counts = Counter(s)\n    odds = 0\n    for count in counts.values():\n        if count & 1:\n            odds += 1\n    if n & 1 and odds > 1 or (not n & 1 and odds > 0):\n        return [-1]\n    inds = {i: [] for i in s}\n    for i in range(n):\n        inds[s[i]].append(i + 1)\n    res = [-1] * n\n    if n & 1:\n        for (key, val) in counts.items():\n            if val & 1:\n                let = key\n                poses = inds[key]\n                del inds[key]\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[(n - i) * 1] = pos.pop()\n                i += 1\n        for x in poses:\n            res[i] = x\n            i += 1\n    else:\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "res[n - i - 1] = pos.pop()",
      "mutated_line": "res[n - i + 1] = pos.pop()",
      "code": "from typing import List\nfrom collections import Counter\n\ndef find_palindromic_permutation(s: str) -> List[int]:\n    n = len(s)\n    counts = Counter(s)\n    odds = 0\n    for count in counts.values():\n        if count & 1:\n            odds += 1\n    if n & 1 and odds > 1 or (not n & 1 and odds > 0):\n        return [-1]\n    inds = {i: [] for i in s}\n    for i in range(n):\n        inds[s[i]].append(i + 1)\n    res = [-1] * n\n    if n & 1:\n        for (key, val) in counts.items():\n            if val & 1:\n                let = key\n                poses = inds[key]\n                del inds[key]\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n        for x in poses:\n            res[i] = x\n            i += 1\n    else:\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i + 1] = pos.pop()\n                i += 1\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "res[n - i - 1] = pos.pop()",
      "mutated_line": "res[(n - i) * 1] = pos.pop()",
      "code": "from typing import List\nfrom collections import Counter\n\ndef find_palindromic_permutation(s: str) -> List[int]:\n    n = len(s)\n    counts = Counter(s)\n    odds = 0\n    for count in counts.values():\n        if count & 1:\n            odds += 1\n    if n & 1 and odds > 1 or (not n & 1 and odds > 0):\n        return [-1]\n    inds = {i: [] for i in s}\n    for i in range(n):\n        inds[s[i]].append(i + 1)\n    res = [-1] * n\n    if n & 1:\n        for (key, val) in counts.items():\n            if val & 1:\n                let = key\n                poses = inds[key]\n                del inds[key]\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n        for x in poses:\n            res[i] = x\n            i += 1\n    else:\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[(n - i) * 1] = pos.pop()\n                i += 1\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "res[n - i - 1] = pos.pop()",
      "mutated_line": "res[n + i - 1] = pos.pop()",
      "code": "from typing import List\nfrom collections import Counter\n\ndef find_palindromic_permutation(s: str) -> List[int]:\n    n = len(s)\n    counts = Counter(s)\n    odds = 0\n    for count in counts.values():\n        if count & 1:\n            odds += 1\n    if n & 1 and odds > 1 or (not n & 1 and odds > 0):\n        return [-1]\n    inds = {i: [] for i in s}\n    for i in range(n):\n        inds[s[i]].append(i + 1)\n    res = [-1] * n\n    if n & 1:\n        for (key, val) in counts.items():\n            if val & 1:\n                let = key\n                poses = inds[key]\n                del inds[key]\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n + i - 1] = pos.pop()\n                i += 1\n        for x in poses:\n            res[i] = x\n            i += 1\n    else:\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "res[n - i - 1] = pos.pop()",
      "mutated_line": "res[n * i - 1] = pos.pop()",
      "code": "from typing import List\nfrom collections import Counter\n\ndef find_palindromic_permutation(s: str) -> List[int]:\n    n = len(s)\n    counts = Counter(s)\n    odds = 0\n    for count in counts.values():\n        if count & 1:\n            odds += 1\n    if n & 1 and odds > 1 or (not n & 1 and odds > 0):\n        return [-1]\n    inds = {i: [] for i in s}\n    for i in range(n):\n        inds[s[i]].append(i + 1)\n    res = [-1] * n\n    if n & 1:\n        for (key, val) in counts.items():\n            if val & 1:\n                let = key\n                poses = inds[key]\n                del inds[key]\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n * i - 1] = pos.pop()\n                i += 1\n        for x in poses:\n            res[i] = x\n            i += 1\n    else:\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "res[n - i - 1] = pos.pop()",
      "mutated_line": "res[n - i - 2] = pos.pop()",
      "code": "from typing import List\nfrom collections import Counter\n\ndef find_palindromic_permutation(s: str) -> List[int]:\n    n = len(s)\n    counts = Counter(s)\n    odds = 0\n    for count in counts.values():\n        if count & 1:\n            odds += 1\n    if n & 1 and odds > 1 or (not n & 1 and odds > 0):\n        return [-1]\n    inds = {i: [] for i in s}\n    for i in range(n):\n        inds[s[i]].append(i + 1)\n    res = [-1] * n\n    if n & 1:\n        for (key, val) in counts.items():\n            if val & 1:\n                let = key\n                poses = inds[key]\n                del inds[key]\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 2] = pos.pop()\n                i += 1\n        for x in poses:\n            res[i] = x\n            i += 1\n    else:\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "res[n - i - 1] = pos.pop()",
      "mutated_line": "res[n - i - 0] = pos.pop()",
      "code": "from typing import List\nfrom collections import Counter\n\ndef find_palindromic_permutation(s: str) -> List[int]:\n    n = len(s)\n    counts = Counter(s)\n    odds = 0\n    for count in counts.values():\n        if count & 1:\n            odds += 1\n    if n & 1 and odds > 1 or (not n & 1 and odds > 0):\n        return [-1]\n    inds = {i: [] for i in s}\n    for i in range(n):\n        inds[s[i]].append(i + 1)\n    res = [-1] * n\n    if n & 1:\n        for (key, val) in counts.items():\n            if val & 1:\n                let = key\n                poses = inds[key]\n                del inds[key]\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 0] = pos.pop()\n                i += 1\n        for x in poses:\n            res[i] = x\n            i += 1\n    else:\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "res[n - i - 1] = pos.pop()",
      "mutated_line": "res[n - i - 0] = pos.pop()",
      "code": "from typing import List\nfrom collections import Counter\n\ndef find_palindromic_permutation(s: str) -> List[int]:\n    n = len(s)\n    counts = Counter(s)\n    odds = 0\n    for count in counts.values():\n        if count & 1:\n            odds += 1\n    if n & 1 and odds > 1 or (not n & 1 and odds > 0):\n        return [-1]\n    inds = {i: [] for i in s}\n    for i in range(n):\n        inds[s[i]].append(i + 1)\n    res = [-1] * n\n    if n & 1:\n        for (key, val) in counts.items():\n            if val & 1:\n                let = key\n                poses = inds[key]\n                del inds[key]\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 0] = pos.pop()\n                i += 1\n        for x in poses:\n            res[i] = x\n            i += 1\n    else:\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "res[n - i - 1] = pos.pop()",
      "mutated_line": "res[n - i - -1] = pos.pop()",
      "code": "from typing import List\nfrom collections import Counter\n\ndef find_palindromic_permutation(s: str) -> List[int]:\n    n = len(s)\n    counts = Counter(s)\n    odds = 0\n    for count in counts.values():\n        if count & 1:\n            odds += 1\n    if n & 1 and odds > 1 or (not n & 1 and odds > 0):\n        return [-1]\n    inds = {i: [] for i in s}\n    for i in range(n):\n        inds[s[i]].append(i + 1)\n    res = [-1] * n\n    if n & 1:\n        for (key, val) in counts.items():\n            if val & 1:\n                let = key\n                poses = inds[key]\n                del inds[key]\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - -1] = pos.pop()\n                i += 1\n        for x in poses:\n            res[i] = x\n            i += 1\n    else:\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "res[n - i - 1] = pos.pop()",
      "mutated_line": "res[n + i - 1] = pos.pop()",
      "code": "from typing import List\nfrom collections import Counter\n\ndef find_palindromic_permutation(s: str) -> List[int]:\n    n = len(s)\n    counts = Counter(s)\n    odds = 0\n    for count in counts.values():\n        if count & 1:\n            odds += 1\n    if n & 1 and odds > 1 or (not n & 1 and odds > 0):\n        return [-1]\n    inds = {i: [] for i in s}\n    for i in range(n):\n        inds[s[i]].append(i + 1)\n    res = [-1] * n\n    if n & 1:\n        for (key, val) in counts.items():\n            if val & 1:\n                let = key\n                poses = inds[key]\n                del inds[key]\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n        for x in poses:\n            res[i] = x\n            i += 1\n    else:\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n + i - 1] = pos.pop()\n                i += 1\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "res[n - i - 1] = pos.pop()",
      "mutated_line": "res[n * i - 1] = pos.pop()",
      "code": "from typing import List\nfrom collections import Counter\n\ndef find_palindromic_permutation(s: str) -> List[int]:\n    n = len(s)\n    counts = Counter(s)\n    odds = 0\n    for count in counts.values():\n        if count & 1:\n            odds += 1\n    if n & 1 and odds > 1 or (not n & 1 and odds > 0):\n        return [-1]\n    inds = {i: [] for i in s}\n    for i in range(n):\n        inds[s[i]].append(i + 1)\n    res = [-1] * n\n    if n & 1:\n        for (key, val) in counts.items():\n            if val & 1:\n                let = key\n                poses = inds[key]\n                del inds[key]\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n        for x in poses:\n            res[i] = x\n            i += 1\n    else:\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n * i - 1] = pos.pop()\n                i += 1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "res[n - i - 1] = pos.pop()",
      "mutated_line": "res[n - i - 2] = pos.pop()",
      "code": "from typing import List\nfrom collections import Counter\n\ndef find_palindromic_permutation(s: str) -> List[int]:\n    n = len(s)\n    counts = Counter(s)\n    odds = 0\n    for count in counts.values():\n        if count & 1:\n            odds += 1\n    if n & 1 and odds > 1 or (not n & 1 and odds > 0):\n        return [-1]\n    inds = {i: [] for i in s}\n    for i in range(n):\n        inds[s[i]].append(i + 1)\n    res = [-1] * n\n    if n & 1:\n        for (key, val) in counts.items():\n            if val & 1:\n                let = key\n                poses = inds[key]\n                del inds[key]\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n        for x in poses:\n            res[i] = x\n            i += 1\n    else:\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 2] = pos.pop()\n                i += 1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "res[n - i - 1] = pos.pop()",
      "mutated_line": "res[n - i - 0] = pos.pop()",
      "code": "from typing import List\nfrom collections import Counter\n\ndef find_palindromic_permutation(s: str) -> List[int]:\n    n = len(s)\n    counts = Counter(s)\n    odds = 0\n    for count in counts.values():\n        if count & 1:\n            odds += 1\n    if n & 1 and odds > 1 or (not n & 1 and odds > 0):\n        return [-1]\n    inds = {i: [] for i in s}\n    for i in range(n):\n        inds[s[i]].append(i + 1)\n    res = [-1] * n\n    if n & 1:\n        for (key, val) in counts.items():\n            if val & 1:\n                let = key\n                poses = inds[key]\n                del inds[key]\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n        for x in poses:\n            res[i] = x\n            i += 1\n    else:\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 0] = pos.pop()\n                i += 1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "res[n - i - 1] = pos.pop()",
      "mutated_line": "res[n - i - 0] = pos.pop()",
      "code": "from typing import List\nfrom collections import Counter\n\ndef find_palindromic_permutation(s: str) -> List[int]:\n    n = len(s)\n    counts = Counter(s)\n    odds = 0\n    for count in counts.values():\n        if count & 1:\n            odds += 1\n    if n & 1 and odds > 1 or (not n & 1 and odds > 0):\n        return [-1]\n    inds = {i: [] for i in s}\n    for i in range(n):\n        inds[s[i]].append(i + 1)\n    res = [-1] * n\n    if n & 1:\n        for (key, val) in counts.items():\n            if val & 1:\n                let = key\n                poses = inds[key]\n                del inds[key]\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n        for x in poses:\n            res[i] = x\n            i += 1\n    else:\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 0] = pos.pop()\n                i += 1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "res[n - i - 1] = pos.pop()",
      "mutated_line": "res[n - i - -1] = pos.pop()",
      "code": "from typing import List\nfrom collections import Counter\n\ndef find_palindromic_permutation(s: str) -> List[int]:\n    n = len(s)\n    counts = Counter(s)\n    odds = 0\n    for count in counts.values():\n        if count & 1:\n            odds += 1\n    if n & 1 and odds > 1 or (not n & 1 and odds > 0):\n        return [-1]\n    inds = {i: [] for i in s}\n    for i in range(n):\n        inds[s[i]].append(i + 1)\n    res = [-1] * n\n    if n & 1:\n        for (key, val) in counts.items():\n            if val & 1:\n                let = key\n                poses = inds[key]\n                del inds[key]\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - 1] = pos.pop()\n                i += 1\n        for x in poses:\n            res[i] = x\n            i += 1\n    else:\n        i = 0\n        for pos in inds.values():\n            while pos:\n                res[i] = pos.pop()\n                res[n - i - -1] = pos.pop()\n                i += 1\n    return res"
    }
  ]
}