{
  "task_id": "taco_5583",
  "entry_point": "min_operations_to_equal_elements",
  "mutant_count": 144,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "i = 0",
      "mutated_line": "i = 1",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 1\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "i = 0",
      "mutated_line": "i = -1",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = -1\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "i = 0",
      "mutated_line": "i = 1",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 1\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "UOI",
      "lineno": 13,
      "original_line": "i = -1",
      "mutated_line": "i = +1",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = +1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if adj[-1] == 0:",
      "mutated_line": "if adj[-1] != 0:",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] != 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "return len(arr) - main_count",
      "mutated_line": "return len(arr) + main_count",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) + main_count"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "return len(arr) - main_count",
      "mutated_line": "return len(arr) * main_count",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) * main_count"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "main_count = float('-inf')",
      "mutated_line": "main_count = float('')",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "main_number = float('inf')",
      "mutated_line": "main_number = float('')",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "big_fail = float('-inf')",
      "mutated_line": "big_fail = float('')",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "i = i + 1",
      "mutated_line": "i = i - 1",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i - 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "i = i + 1",
      "mutated_line": "i = i * 1",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i * 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "i = -1",
      "mutated_line": "i = -2",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -2\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "i = -1",
      "mutated_line": "i = -0",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -0\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "i = -1",
      "mutated_line": "i = -0",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -0\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "i = -1",
      "mutated_line": "i = --1",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = --1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if adj[-1] == 0:",
      "mutated_line": "if adj[-1] == 1:",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 1:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if adj[-1] == 0:",
      "mutated_line": "if adj[-1] == -1:",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == -1:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if adj[-1] == 0:",
      "mutated_line": "if adj[-1] == 1:",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 1:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if z > main_count:",
      "mutated_line": "if z >= main_count:",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z >= main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if z > main_count:",
      "mutated_line": "if z <= main_count:",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z <= main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if z > main_count:",
      "mutated_line": "if z != main_count:",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z != main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "ASR",
      "lineno": 22,
      "original_line": "i += 1",
      "mutated_line": "i -= 1",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i -= 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "adj.append(arr[0])",
      "mutated_line": "adj.append(arr[1])",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[1])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "adj.append(arr[0])",
      "mutated_line": "adj.append(arr[-1])",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[-1])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "adj.append(arr[0])",
      "mutated_line": "adj.append(arr[1])",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[1])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for x in arr[1:]:",
      "mutated_line": "for x in arr[2:]:",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[2:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for x in arr[1:]:",
      "mutated_line": "for x in arr[0:]:",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[0:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for x in arr[1:]:",
      "mutated_line": "for x in arr[0:]:",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[0:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for x in arr[1:]:",
      "mutated_line": "for x in arr[-1:]:",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[-1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "i = i + 1",
      "mutated_line": "i = i + 2",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 2\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "i = i + 1",
      "mutated_line": "i = i + 0",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 0\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "i = i + 1",
      "mutated_line": "i = i + 0",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 0\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "i = i + 1",
      "mutated_line": "i = i + -1",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + -1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "adj.append(adj[i - 1] + arr[i])",
      "mutated_line": "adj.append(adj[i - 1] - arr[i])",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] - arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "adj.append(adj[i - 1] + arr[i])",
      "mutated_line": "adj.append(adj[i - 1] * arr[i])",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] * arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "UOI",
      "lineno": 16,
      "original_line": "if adj[-1] == 0:",
      "mutated_line": "if adj[+1] == 0:",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[+1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "z = adj.count(0)",
      "mutated_line": "z = adj.count(1)",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(1)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "z = adj.count(0)",
      "mutated_line": "z = adj.count(-1)",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(-1)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "z = adj.count(0)",
      "mutated_line": "z = adj.count(1)",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(1)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "i += 1",
      "mutated_line": "i += 2",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 2\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "i += 1",
      "mutated_line": "i += 0",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 0\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "i += 1",
      "mutated_line": "i += 0",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 0\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "i += 1",
      "mutated_line": "i += -1",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += -1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "LCR",
      "lineno": 23,
      "original_line": "if x != 0 and (abs(x) > big_fail or len(adj) < 10000):",
      "mutated_line": "if x != 0 or (abs(x) > big_fail or len(adj) < 10000):",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 or (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if adj[-1] == 0:",
      "mutated_line": "if adj[-2] == 0:",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-2] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if adj[-1] == 0:",
      "mutated_line": "if adj[-0] == 0:",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-0] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if adj[-1] == 0:",
      "mutated_line": "if adj[-0] == 0:",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-0] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if adj[-1] == 0:",
      "mutated_line": "if adj[--1] == 0:",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[--1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if x != 0 and (abs(x) > big_fail or len(adj) < 10000):",
      "mutated_line": "if x == 0 and (abs(x) > big_fail or len(adj) < 10000):",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x == 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "LCR",
      "lineno": 23,
      "original_line": "if x != 0 and (abs(x) > big_fail or len(adj) < 10000):",
      "mutated_line": "if x != 0 and (abs(x) > big_fail and len(adj) < 10000):",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail and len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "LCR",
      "lineno": 24,
      "original_line": "if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):",
      "mutated_line": "if adj[-1] % x == 0 or adj[-1] / x > 0 or abs(x) < main_number or (abs(adj[-1]) // abs(x) <= l - i):",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 or adj[-1] / x > 0 or abs(x) < main_number or (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "adj.append(adj[i - 1] + arr[i])",
      "mutated_line": "adj.append(adj[i + 1] + arr[i])",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i + 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "adj.append(adj[i - 1] + arr[i])",
      "mutated_line": "adj.append(adj[i * 1] + arr[i])",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i * 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if x != 0 and (abs(x) > big_fail or len(adj) < 10000):",
      "mutated_line": "if x != 1 and (abs(x) > big_fail or len(adj) < 10000):",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 1 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if x != 0 and (abs(x) > big_fail or len(adj) < 10000):",
      "mutated_line": "if x != -1 and (abs(x) > big_fail or len(adj) < 10000):",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != -1 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if x != 0 and (abs(x) > big_fail or len(adj) < 10000):",
      "mutated_line": "if x != 1 and (abs(x) > big_fail or len(adj) < 10000):",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 1 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if x != 0 and (abs(x) > big_fail or len(adj) < 10000):",
      "mutated_line": "if x != 0 and (abs(x) >= big_fail or len(adj) < 10000):",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) >= big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if x != 0 and (abs(x) > big_fail or len(adj) < 10000):",
      "mutated_line": "if x != 0 and (abs(x) <= big_fail or len(adj) < 10000):",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) <= big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if x != 0 and (abs(x) > big_fail or len(adj) < 10000):",
      "mutated_line": "if x != 0 and (abs(x) != big_fail or len(adj) < 10000):",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) != big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if x != 0 and (abs(x) > big_fail or len(adj) < 10000):",
      "mutated_line": "if x != 0 and (abs(x) > big_fail or len(adj) <= 10000):",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) <= 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if x != 0 and (abs(x) > big_fail or len(adj) < 10000):",
      "mutated_line": "if x != 0 and (abs(x) > big_fail or len(adj) >= 10000):",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) >= 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if x != 0 and (abs(x) > big_fail or len(adj) < 10000):",
      "mutated_line": "if x != 0 and (abs(x) > big_fail or len(adj) != 10000):",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) != 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):",
      "mutated_line": "if adj[-1] % x != 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x != 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):",
      "mutated_line": "if adj[-1] % x == 0 and adj[-1] / x >= 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x >= 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):",
      "mutated_line": "if adj[-1] % x == 0 and adj[-1] / x <= 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x <= 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):",
      "mutated_line": "if adj[-1] % x == 0 and adj[-1] / x != 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x != 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):",
      "mutated_line": "if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) <= main_number) and (abs(adj[-1]) // abs(x) <= l - i):",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) <= main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):",
      "mutated_line": "if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) >= main_number) and (abs(adj[-1]) // abs(x) <= l - i):",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) >= main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):",
      "mutated_line": "if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) != main_number) and (abs(adj[-1]) // abs(x) <= l - i):",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) != main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):",
      "mutated_line": "if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) < l - i):",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) < l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):",
      "mutated_line": "if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) > l - i):",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) > l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):",
      "mutated_line": "if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) == l - i):",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) == l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "count = 1",
      "mutated_line": "count = 2",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 2\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "count = 1",
      "mutated_line": "count = 0",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 0\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "count = 1",
      "mutated_line": "count = 0",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 0\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "count = 1",
      "mutated_line": "count = -1",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = -1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if num == adj[-1]:",
      "mutated_line": "if num != adj[-1]:",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num != adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "adj.append(adj[i - 1] + arr[i])",
      "mutated_line": "adj.append(adj[i - 2] + arr[i])",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 2] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "adj.append(adj[i - 1] + arr[i])",
      "mutated_line": "adj.append(adj[i - 0] + arr[i])",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 0] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "adj.append(adj[i - 1] + arr[i])",
      "mutated_line": "adj.append(adj[i - 0] + arr[i])",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 0] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "adj.append(adj[i - 1] + arr[i])",
      "mutated_line": "adj.append(adj[i - -1] + arr[i])",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - -1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if x != 0 and (abs(x) > big_fail or len(adj) < 10000):",
      "mutated_line": "if x != 0 and (abs(x) > big_fail or len(adj) < 10001):",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10001):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if x != 0 and (abs(x) > big_fail or len(adj) < 10000):",
      "mutated_line": "if x != 0 and (abs(x) > big_fail or len(adj) < 9999):",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 9999):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if x != 0 and (abs(x) > big_fail or len(adj) < 10000):",
      "mutated_line": "if x != 0 and (abs(x) > big_fail or len(adj) < 0):",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 0):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if x != 0 and (abs(x) > big_fail or len(adj) < 10000):",
      "mutated_line": "if x != 0 and (abs(x) > big_fail or len(adj) < 1):",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 1):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if x != 0 and (abs(x) > big_fail or len(adj) < 10000):",
      "mutated_line": "if x != 0 and (abs(x) > big_fail or len(adj) < -10000):",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < -10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):",
      "mutated_line": "if adj[-1] * x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] * x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):",
      "mutated_line": "if adj[-1] + x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] + x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):",
      "mutated_line": "if adj[-1] % x == 1 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 1 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):",
      "mutated_line": "if adj[-1] % x == -1 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == -1 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):",
      "mutated_line": "if adj[-1] % x == 1 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 1 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):",
      "mutated_line": "if adj[-1] % x == 0 and adj[-1] * x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] * x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):",
      "mutated_line": "if adj[-1] % x == 0 and adj[-1] // x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] // x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):",
      "mutated_line": "if adj[-1] % x == 0 and adj[-1] / x > 1 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 1 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):",
      "mutated_line": "if adj[-1] % x == 0 and adj[-1] / x > -1 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > -1 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):",
      "mutated_line": "if adj[-1] % x == 0 and adj[-1] / x > 1 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 1 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):",
      "mutated_line": "if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) / abs(x) <= l - i):",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) / abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):",
      "mutated_line": "if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) * abs(x) <= l - i):",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) * abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):",
      "mutated_line": "if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l + i):",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l + i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):",
      "mutated_line": "if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l * i):",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l * i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if y - num == x:",
      "mutated_line": "if y - num != x:",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num != x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "ASR",
      "lineno": 29,
      "original_line": "count += 1",
      "mutated_line": "count -= 1",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count -= 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if count > main_count:",
      "mutated_line": "if count >= main_count:",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count >= main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if count > main_count:",
      "mutated_line": "if count <= main_count:",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count <= main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if count > main_count:",
      "mutated_line": "if count != main_count:",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count != main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "for y in adj[i + 1:]:",
      "mutated_line": "for y in adj[i - 1:]:",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i - 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "for y in adj[i + 1:]:",
      "mutated_line": "for y in adj[i * 1:]:",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i * 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if y - num == x:",
      "mutated_line": "if y + num == x:",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y + num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if y - num == x:",
      "mutated_line": "if y * num == x:",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y * num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "count += 1",
      "mutated_line": "count += 2",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 2\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "count += 1",
      "mutated_line": "count += 0",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 0\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "count += 1",
      "mutated_line": "count += 0",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 0\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "count += 1",
      "mutated_line": "count += -1",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += -1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if num == adj[-1]:",
      "mutated_line": "if num != adj[-1]:",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num != adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "UOI",
      "lineno": 33,
      "original_line": "if num == adj[-1]:",
      "mutated_line": "if num == adj[+1]:",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[+1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "UOI",
      "lineno": 24,
      "original_line": "if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):",
      "mutated_line": "if adj[+1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[+1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "UOI",
      "lineno": 24,
      "original_line": "if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):",
      "mutated_line": "if adj[-1] % x == 0 and adj[+1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[+1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for y in adj[i + 1:]:",
      "mutated_line": "for y in adj[i + 2:]:",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 2:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for y in adj[i + 1:]:",
      "mutated_line": "for y in adj[i + 0:]:",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 0:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for y in adj[i + 1:]:",
      "mutated_line": "for y in adj[i + 0:]:",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 0:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for y in adj[i + 1:]:",
      "mutated_line": "for y in adj[i + -1:]:",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + -1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if num == adj[-1]:",
      "mutated_line": "if num == adj[-2]:",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-2]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if num == adj[-1]:",
      "mutated_line": "if num == adj[-0]:",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-0]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if num == adj[-1]:",
      "mutated_line": "if num == adj[-0]:",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-0]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if num == adj[-1]:",
      "mutated_line": "if num == adj[--1]:",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[--1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):",
      "mutated_line": "if adj[-2] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-2] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):",
      "mutated_line": "if adj[-0] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-0] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):",
      "mutated_line": "if adj[-0] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-0] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):",
      "mutated_line": "if adj[--1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[--1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):",
      "mutated_line": "if adj[-1] % x == 0 and adj[-2] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-2] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):",
      "mutated_line": "if adj[-1] % x == 0 and adj[-0] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-0] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):",
      "mutated_line": "if adj[-1] % x == 0 and adj[-0] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-0] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):",
      "mutated_line": "if adj[-1] % x == 0 and adj[--1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[--1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "UOI",
      "lineno": 24,
      "original_line": "if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):",
      "mutated_line": "if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[+1]) // abs(x) <= l - i):",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[+1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "UOI",
      "lineno": 31,
      "original_line": "if num == adj[-1]:",
      "mutated_line": "if num == adj[+1]:",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[+1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):",
      "mutated_line": "if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-2]) // abs(x) <= l - i):",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-2]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):",
      "mutated_line": "if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-0]) // abs(x) <= l - i):",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-0]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):",
      "mutated_line": "if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-0]) // abs(x) <= l - i):",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-0]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):",
      "mutated_line": "if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[--1]) // abs(x) <= l - i):",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[--1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if num == adj[-1]:",
      "mutated_line": "if num == adj[-2]:",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-2]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if num == adj[-1]:",
      "mutated_line": "if num == adj[-0]:",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-0]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if num == adj[-1]:",
      "mutated_line": "if num == adj[-0]:",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[-0]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if num == adj[-1]:",
      "mutated_line": "if num == adj[--1]:",
      "code": "def min_operations_to_equal_elements(arr):\n    adj = []\n    main_count = float('-inf')\n    main_number = float('inf')\n    big_fail = float('-inf')\n    adj.append(arr[0])\n    i = 0\n    for x in arr[1:]:\n        i = i + 1\n        adj.append(adj[i - 1] + arr[i])\n    i = -1\n    l = len(adj)\n    if adj[-1] == 0:\n        z = adj.count(0)\n        if z > main_count:\n            main_count = z\n    else:\n        for x in adj:\n            i += 1\n            if x != 0 and (abs(x) > big_fail or len(adj) < 10000):\n                if adj[-1] % x == 0 and adj[-1] / x > 0 and (abs(x) < main_number) and (abs(adj[-1]) // abs(x) <= l - i):\n                    num = x\n                    count = 1\n                    for y in adj[i + 1:]:\n                        if y - num == x:\n                            count += 1\n                            num = y\n                            if num == adj[--1]:\n                                break\n                    if num == adj[-1]:\n                        if count > main_count:\n                            main_count = count\n                            main_number = abs(x)\n                    else:\n                        big_fail = abs(x)\n    return len(arr) - main_count"
    }
  ]
}