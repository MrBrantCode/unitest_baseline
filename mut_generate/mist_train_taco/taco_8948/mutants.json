{
  "task_id": "taco_8948",
  "entry_point": "construct_graph_from_mst",
  "mutant_count": 72,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "k = 2",
      "mutated_line": "k = 3",
      "code": "def construct_graph_from_mst(n, m, edges):\n    sorted_edges = sorted(edges, key=lambda e: (e[0], -e[2]))\n\n    def free_edge():\n        for y in range(3, n + 1):\n            for x in range(2, y):\n                yield [x, y]\n    f = free_edge()\n    k = 3\n    for e in sorted_edges:\n        if e[2]:\n            e += [1, k]\n            k += 1\n        else:\n            free = next(f)\n            if free[1] >= k:\n                return -1\n            else:\n                e += free\n    sorted_edges.sort(key=lambda e: e[1])\n    result_edges = [(e[3], e[4]) for e in sorted_edges]\n    return result_edges"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "k = 2",
      "mutated_line": "k = 1",
      "code": "def construct_graph_from_mst(n, m, edges):\n    sorted_edges = sorted(edges, key=lambda e: (e[0], -e[2]))\n\n    def free_edge():\n        for y in range(3, n + 1):\n            for x in range(2, y):\n                yield [x, y]\n    f = free_edge()\n    k = 1\n    for e in sorted_edges:\n        if e[2]:\n            e += [1, k]\n            k += 1\n        else:\n            free = next(f)\n            if free[1] >= k:\n                return -1\n            else:\n                e += free\n    sorted_edges.sort(key=lambda e: e[1])\n    result_edges = [(e[3], e[4]) for e in sorted_edges]\n    return result_edges"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "k = 2",
      "mutated_line": "k = 0",
      "code": "def construct_graph_from_mst(n, m, edges):\n    sorted_edges = sorted(edges, key=lambda e: (e[0], -e[2]))\n\n    def free_edge():\n        for y in range(3, n + 1):\n            for x in range(2, y):\n                yield [x, y]\n    f = free_edge()\n    k = 0\n    for e in sorted_edges:\n        if e[2]:\n            e += [1, k]\n            k += 1\n        else:\n            free = next(f)\n            if free[1] >= k:\n                return -1\n            else:\n                e += free\n    sorted_edges.sort(key=lambda e: e[1])\n    result_edges = [(e[3], e[4]) for e in sorted_edges]\n    return result_edges"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "k = 2",
      "mutated_line": "k = 1",
      "code": "def construct_graph_from_mst(n, m, edges):\n    sorted_edges = sorted(edges, key=lambda e: (e[0], -e[2]))\n\n    def free_edge():\n        for y in range(3, n + 1):\n            for x in range(2, y):\n                yield [x, y]\n    f = free_edge()\n    k = 1\n    for e in sorted_edges:\n        if e[2]:\n            e += [1, k]\n            k += 1\n        else:\n            free = next(f)\n            if free[1] >= k:\n                return -1\n            else:\n                e += free\n    sorted_edges.sort(key=lambda e: e[1])\n    result_edges = [(e[3], e[4]) for e in sorted_edges]\n    return result_edges"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "k = 2",
      "mutated_line": "k = -2",
      "code": "def construct_graph_from_mst(n, m, edges):\n    sorted_edges = sorted(edges, key=lambda e: (e[0], -e[2]))\n\n    def free_edge():\n        for y in range(3, n + 1):\n            for x in range(2, y):\n                yield [x, y]\n    f = free_edge()\n    k = -2\n    for e in sorted_edges:\n        if e[2]:\n            e += [1, k]\n            k += 1\n        else:\n            free = next(f)\n            if free[1] >= k:\n                return -1\n            else:\n                e += free\n    sorted_edges.sort(key=lambda e: e[1])\n    result_edges = [(e[3], e[4]) for e in sorted_edges]\n    return result_edges"
    },
    {
      "operator": "ASR",
      "lineno": 15,
      "original_line": "e += [1, k]",
      "mutated_line": "e -= [1, k]",
      "code": "def construct_graph_from_mst(n, m, edges):\n    sorted_edges = sorted(edges, key=lambda e: (e[0], -e[2]))\n\n    def free_edge():\n        for y in range(3, n + 1):\n            for x in range(2, y):\n                yield [x, y]\n    f = free_edge()\n    k = 2\n    for e in sorted_edges:\n        if e[2]:\n            e -= [1, k]\n            k += 1\n        else:\n            free = next(f)\n            if free[1] >= k:\n                return -1\n            else:\n                e += free\n    sorted_edges.sort(key=lambda e: e[1])\n    result_edges = [(e[3], e[4]) for e in sorted_edges]\n    return result_edges"
    },
    {
      "operator": "ASR",
      "lineno": 16,
      "original_line": "k += 1",
      "mutated_line": "k -= 1",
      "code": "def construct_graph_from_mst(n, m, edges):\n    sorted_edges = sorted(edges, key=lambda e: (e[0], -e[2]))\n\n    def free_edge():\n        for y in range(3, n + 1):\n            for x in range(2, y):\n                yield [x, y]\n    f = free_edge()\n    k = 2\n    for e in sorted_edges:\n        if e[2]:\n            e += [1, k]\n            k -= 1\n        else:\n            free = next(f)\n            if free[1] >= k:\n                return -1\n            else:\n                e += free\n    sorted_edges.sort(key=lambda e: e[1])\n    result_edges = [(e[3], e[4]) for e in sorted_edges]\n    return result_edges"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for y in range(3, n + 1):",
      "mutated_line": "for y in range(4, n + 1):",
      "code": "def construct_graph_from_mst(n, m, edges):\n    sorted_edges = sorted(edges, key=lambda e: (e[0], -e[2]))\n\n    def free_edge():\n        for y in range(4, n + 1):\n            for x in range(2, y):\n                yield [x, y]\n    f = free_edge()\n    k = 2\n    for e in sorted_edges:\n        if e[2]:\n            e += [1, k]\n            k += 1\n        else:\n            free = next(f)\n            if free[1] >= k:\n                return -1\n            else:\n                e += free\n    sorted_edges.sort(key=lambda e: e[1])\n    result_edges = [(e[3], e[4]) for e in sorted_edges]\n    return result_edges"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for y in range(3, n + 1):",
      "mutated_line": "for y in range(2, n + 1):",
      "code": "def construct_graph_from_mst(n, m, edges):\n    sorted_edges = sorted(edges, key=lambda e: (e[0], -e[2]))\n\n    def free_edge():\n        for y in range(2, n + 1):\n            for x in range(2, y):\n                yield [x, y]\n    f = free_edge()\n    k = 2\n    for e in sorted_edges:\n        if e[2]:\n            e += [1, k]\n            k += 1\n        else:\n            free = next(f)\n            if free[1] >= k:\n                return -1\n            else:\n                e += free\n    sorted_edges.sort(key=lambda e: e[1])\n    result_edges = [(e[3], e[4]) for e in sorted_edges]\n    return result_edges"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for y in range(3, n + 1):",
      "mutated_line": "for y in range(0, n + 1):",
      "code": "def construct_graph_from_mst(n, m, edges):\n    sorted_edges = sorted(edges, key=lambda e: (e[0], -e[2]))\n\n    def free_edge():\n        for y in range(0, n + 1):\n            for x in range(2, y):\n                yield [x, y]\n    f = free_edge()\n    k = 2\n    for e in sorted_edges:\n        if e[2]:\n            e += [1, k]\n            k += 1\n        else:\n            free = next(f)\n            if free[1] >= k:\n                return -1\n            else:\n                e += free\n    sorted_edges.sort(key=lambda e: e[1])\n    result_edges = [(e[3], e[4]) for e in sorted_edges]\n    return result_edges"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for y in range(3, n + 1):",
      "mutated_line": "for y in range(1, n + 1):",
      "code": "def construct_graph_from_mst(n, m, edges):\n    sorted_edges = sorted(edges, key=lambda e: (e[0], -e[2]))\n\n    def free_edge():\n        for y in range(1, n + 1):\n            for x in range(2, y):\n                yield [x, y]\n    f = free_edge()\n    k = 2\n    for e in sorted_edges:\n        if e[2]:\n            e += [1, k]\n            k += 1\n        else:\n            free = next(f)\n            if free[1] >= k:\n                return -1\n            else:\n                e += free\n    sorted_edges.sort(key=lambda e: e[1])\n    result_edges = [(e[3], e[4]) for e in sorted_edges]\n    return result_edges"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for y in range(3, n + 1):",
      "mutated_line": "for y in range(-3, n + 1):",
      "code": "def construct_graph_from_mst(n, m, edges):\n    sorted_edges = sorted(edges, key=lambda e: (e[0], -e[2]))\n\n    def free_edge():\n        for y in range(-3, n + 1):\n            for x in range(2, y):\n                yield [x, y]\n    f = free_edge()\n    k = 2\n    for e in sorted_edges:\n        if e[2]:\n            e += [1, k]\n            k += 1\n        else:\n            free = next(f)\n            if free[1] >= k:\n                return -1\n            else:\n                e += free\n    sorted_edges.sort(key=lambda e: e[1])\n    result_edges = [(e[3], e[4]) for e in sorted_edges]\n    return result_edges"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "for y in range(3, n + 1):",
      "mutated_line": "for y in range(3, n - 1):",
      "code": "def construct_graph_from_mst(n, m, edges):\n    sorted_edges = sorted(edges, key=lambda e: (e[0], -e[2]))\n\n    def free_edge():\n        for y in range(3, n - 1):\n            for x in range(2, y):\n                yield [x, y]\n    f = free_edge()\n    k = 2\n    for e in sorted_edges:\n        if e[2]:\n            e += [1, k]\n            k += 1\n        else:\n            free = next(f)\n            if free[1] >= k:\n                return -1\n            else:\n                e += free\n    sorted_edges.sort(key=lambda e: e[1])\n    result_edges = [(e[3], e[4]) for e in sorted_edges]\n    return result_edges"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "for y in range(3, n + 1):",
      "mutated_line": "for y in range(3, n * 1):",
      "code": "def construct_graph_from_mst(n, m, edges):\n    sorted_edges = sorted(edges, key=lambda e: (e[0], -e[2]))\n\n    def free_edge():\n        for y in range(3, n * 1):\n            for x in range(2, y):\n                yield [x, y]\n    f = free_edge()\n    k = 2\n    for e in sorted_edges:\n        if e[2]:\n            e += [1, k]\n            k += 1\n        else:\n            free = next(f)\n            if free[1] >= k:\n                return -1\n            else:\n                e += free\n    sorted_edges.sort(key=lambda e: e[1])\n    result_edges = [(e[3], e[4]) for e in sorted_edges]\n    return result_edges"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if e[2]:",
      "mutated_line": "if e[3]:",
      "code": "def construct_graph_from_mst(n, m, edges):\n    sorted_edges = sorted(edges, key=lambda e: (e[0], -e[2]))\n\n    def free_edge():\n        for y in range(3, n + 1):\n            for x in range(2, y):\n                yield [x, y]\n    f = free_edge()\n    k = 2\n    for e in sorted_edges:\n        if e[3]:\n            e += [1, k]\n            k += 1\n        else:\n            free = next(f)\n            if free[1] >= k:\n                return -1\n            else:\n                e += free\n    sorted_edges.sort(key=lambda e: e[1])\n    result_edges = [(e[3], e[4]) for e in sorted_edges]\n    return result_edges"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if e[2]:",
      "mutated_line": "if e[1]:",
      "code": "def construct_graph_from_mst(n, m, edges):\n    sorted_edges = sorted(edges, key=lambda e: (e[0], -e[2]))\n\n    def free_edge():\n        for y in range(3, n + 1):\n            for x in range(2, y):\n                yield [x, y]\n    f = free_edge()\n    k = 2\n    for e in sorted_edges:\n        if e[1]:\n            e += [1, k]\n            k += 1\n        else:\n            free = next(f)\n            if free[1] >= k:\n                return -1\n            else:\n                e += free\n    sorted_edges.sort(key=lambda e: e[1])\n    result_edges = [(e[3], e[4]) for e in sorted_edges]\n    return result_edges"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if e[2]:",
      "mutated_line": "if e[0]:",
      "code": "def construct_graph_from_mst(n, m, edges):\n    sorted_edges = sorted(edges, key=lambda e: (e[0], -e[2]))\n\n    def free_edge():\n        for y in range(3, n + 1):\n            for x in range(2, y):\n                yield [x, y]\n    f = free_edge()\n    k = 2\n    for e in sorted_edges:\n        if e[0]:\n            e += [1, k]\n            k += 1\n        else:\n            free = next(f)\n            if free[1] >= k:\n                return -1\n            else:\n                e += free\n    sorted_edges.sort(key=lambda e: e[1])\n    result_edges = [(e[3], e[4]) for e in sorted_edges]\n    return result_edges"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if e[2]:",
      "mutated_line": "if e[1]:",
      "code": "def construct_graph_from_mst(n, m, edges):\n    sorted_edges = sorted(edges, key=lambda e: (e[0], -e[2]))\n\n    def free_edge():\n        for y in range(3, n + 1):\n            for x in range(2, y):\n                yield [x, y]\n    f = free_edge()\n    k = 2\n    for e in sorted_edges:\n        if e[1]:\n            e += [1, k]\n            k += 1\n        else:\n            free = next(f)\n            if free[1] >= k:\n                return -1\n            else:\n                e += free\n    sorted_edges.sort(key=lambda e: e[1])\n    result_edges = [(e[3], e[4]) for e in sorted_edges]\n    return result_edges"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if e[2]:",
      "mutated_line": "if e[-2]:",
      "code": "def construct_graph_from_mst(n, m, edges):\n    sorted_edges = sorted(edges, key=lambda e: (e[0], -e[2]))\n\n    def free_edge():\n        for y in range(3, n + 1):\n            for x in range(2, y):\n                yield [x, y]\n    f = free_edge()\n    k = 2\n    for e in sorted_edges:\n        if e[-2]:\n            e += [1, k]\n            k += 1\n        else:\n            free = next(f)\n            if free[1] >= k:\n                return -1\n            else:\n                e += free\n    sorted_edges.sort(key=lambda e: e[1])\n    result_edges = [(e[3], e[4]) for e in sorted_edges]\n    return result_edges"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "k += 1",
      "mutated_line": "k += 2",
      "code": "def construct_graph_from_mst(n, m, edges):\n    sorted_edges = sorted(edges, key=lambda e: (e[0], -e[2]))\n\n    def free_edge():\n        for y in range(3, n + 1):\n            for x in range(2, y):\n                yield [x, y]\n    f = free_edge()\n    k = 2\n    for e in sorted_edges:\n        if e[2]:\n            e += [1, k]\n            k += 2\n        else:\n            free = next(f)\n            if free[1] >= k:\n                return -1\n            else:\n                e += free\n    sorted_edges.sort(key=lambda e: e[1])\n    result_edges = [(e[3], e[4]) for e in sorted_edges]\n    return result_edges"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "k += 1",
      "mutated_line": "k += 0",
      "code": "def construct_graph_from_mst(n, m, edges):\n    sorted_edges = sorted(edges, key=lambda e: (e[0], -e[2]))\n\n    def free_edge():\n        for y in range(3, n + 1):\n            for x in range(2, y):\n                yield [x, y]\n    f = free_edge()\n    k = 2\n    for e in sorted_edges:\n        if e[2]:\n            e += [1, k]\n            k += 0\n        else:\n            free = next(f)\n            if free[1] >= k:\n                return -1\n            else:\n                e += free\n    sorted_edges.sort(key=lambda e: e[1])\n    result_edges = [(e[3], e[4]) for e in sorted_edges]\n    return result_edges"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "k += 1",
      "mutated_line": "k += 0",
      "code": "def construct_graph_from_mst(n, m, edges):\n    sorted_edges = sorted(edges, key=lambda e: (e[0], -e[2]))\n\n    def free_edge():\n        for y in range(3, n + 1):\n            for x in range(2, y):\n                yield [x, y]\n    f = free_edge()\n    k = 2\n    for e in sorted_edges:\n        if e[2]:\n            e += [1, k]\n            k += 0\n        else:\n            free = next(f)\n            if free[1] >= k:\n                return -1\n            else:\n                e += free\n    sorted_edges.sort(key=lambda e: e[1])\n    result_edges = [(e[3], e[4]) for e in sorted_edges]\n    return result_edges"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "k += 1",
      "mutated_line": "k += -1",
      "code": "def construct_graph_from_mst(n, m, edges):\n    sorted_edges = sorted(edges, key=lambda e: (e[0], -e[2]))\n\n    def free_edge():\n        for y in range(3, n + 1):\n            for x in range(2, y):\n                yield [x, y]\n    f = free_edge()\n    k = 2\n    for e in sorted_edges:\n        if e[2]:\n            e += [1, k]\n            k += -1\n        else:\n            free = next(f)\n            if free[1] >= k:\n                return -1\n            else:\n                e += free\n    sorted_edges.sort(key=lambda e: e[1])\n    result_edges = [(e[3], e[4]) for e in sorted_edges]\n    return result_edges"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if free[1] >= k:",
      "mutated_line": "if free[1] > k:",
      "code": "def construct_graph_from_mst(n, m, edges):\n    sorted_edges = sorted(edges, key=lambda e: (e[0], -e[2]))\n\n    def free_edge():\n        for y in range(3, n + 1):\n            for x in range(2, y):\n                yield [x, y]\n    f = free_edge()\n    k = 2\n    for e in sorted_edges:\n        if e[2]:\n            e += [1, k]\n            k += 1\n        else:\n            free = next(f)\n            if free[1] > k:\n                return -1\n            else:\n                e += free\n    sorted_edges.sort(key=lambda e: e[1])\n    result_edges = [(e[3], e[4]) for e in sorted_edges]\n    return result_edges"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if free[1] >= k:",
      "mutated_line": "if free[1] < k:",
      "code": "def construct_graph_from_mst(n, m, edges):\n    sorted_edges = sorted(edges, key=lambda e: (e[0], -e[2]))\n\n    def free_edge():\n        for y in range(3, n + 1):\n            for x in range(2, y):\n                yield [x, y]\n    f = free_edge()\n    k = 2\n    for e in sorted_edges:\n        if e[2]:\n            e += [1, k]\n            k += 1\n        else:\n            free = next(f)\n            if free[1] < k:\n                return -1\n            else:\n                e += free\n    sorted_edges.sort(key=lambda e: e[1])\n    result_edges = [(e[3], e[4]) for e in sorted_edges]\n    return result_edges"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if free[1] >= k:",
      "mutated_line": "if free[1] == k:",
      "code": "def construct_graph_from_mst(n, m, edges):\n    sorted_edges = sorted(edges, key=lambda e: (e[0], -e[2]))\n\n    def free_edge():\n        for y in range(3, n + 1):\n            for x in range(2, y):\n                yield [x, y]\n    f = free_edge()\n    k = 2\n    for e in sorted_edges:\n        if e[2]:\n            e += [1, k]\n            k += 1\n        else:\n            free = next(f)\n            if free[1] == k:\n                return -1\n            else:\n                e += free\n    sorted_edges.sort(key=lambda e: e[1])\n    result_edges = [(e[3], e[4]) for e in sorted_edges]\n    return result_edges"
    },
    {
      "operator": "ASR",
      "lineno": 22,
      "original_line": "e += free",
      "mutated_line": "e -= free",
      "code": "def construct_graph_from_mst(n, m, edges):\n    sorted_edges = sorted(edges, key=lambda e: (e[0], -e[2]))\n\n    def free_edge():\n        for y in range(3, n + 1):\n            for x in range(2, y):\n                yield [x, y]\n    f = free_edge()\n    k = 2\n    for e in sorted_edges:\n        if e[2]:\n            e += [1, k]\n            k += 1\n        else:\n            free = next(f)\n            if free[1] >= k:\n                return -1\n            else:\n                e -= free\n    sorted_edges.sort(key=lambda e: e[1])\n    result_edges = [(e[3], e[4]) for e in sorted_edges]\n    return result_edges"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for y in range(3, n + 1):",
      "mutated_line": "for y in range(3, n + 2):",
      "code": "def construct_graph_from_mst(n, m, edges):\n    sorted_edges = sorted(edges, key=lambda e: (e[0], -e[2]))\n\n    def free_edge():\n        for y in range(3, n + 2):\n            for x in range(2, y):\n                yield [x, y]\n    f = free_edge()\n    k = 2\n    for e in sorted_edges:\n        if e[2]:\n            e += [1, k]\n            k += 1\n        else:\n            free = next(f)\n            if free[1] >= k:\n                return -1\n            else:\n                e += free\n    sorted_edges.sort(key=lambda e: e[1])\n    result_edges = [(e[3], e[4]) for e in sorted_edges]\n    return result_edges"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for y in range(3, n + 1):",
      "mutated_line": "for y in range(3, n + 0):",
      "code": "def construct_graph_from_mst(n, m, edges):\n    sorted_edges = sorted(edges, key=lambda e: (e[0], -e[2]))\n\n    def free_edge():\n        for y in range(3, n + 0):\n            for x in range(2, y):\n                yield [x, y]\n    f = free_edge()\n    k = 2\n    for e in sorted_edges:\n        if e[2]:\n            e += [1, k]\n            k += 1\n        else:\n            free = next(f)\n            if free[1] >= k:\n                return -1\n            else:\n                e += free\n    sorted_edges.sort(key=lambda e: e[1])\n    result_edges = [(e[3], e[4]) for e in sorted_edges]\n    return result_edges"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for y in range(3, n + 1):",
      "mutated_line": "for y in range(3, n + 0):",
      "code": "def construct_graph_from_mst(n, m, edges):\n    sorted_edges = sorted(edges, key=lambda e: (e[0], -e[2]))\n\n    def free_edge():\n        for y in range(3, n + 0):\n            for x in range(2, y):\n                yield [x, y]\n    f = free_edge()\n    k = 2\n    for e in sorted_edges:\n        if e[2]:\n            e += [1, k]\n            k += 1\n        else:\n            free = next(f)\n            if free[1] >= k:\n                return -1\n            else:\n                e += free\n    sorted_edges.sort(key=lambda e: e[1])\n    result_edges = [(e[3], e[4]) for e in sorted_edges]\n    return result_edges"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for y in range(3, n + 1):",
      "mutated_line": "for y in range(3, n + -1):",
      "code": "def construct_graph_from_mst(n, m, edges):\n    sorted_edges = sorted(edges, key=lambda e: (e[0], -e[2]))\n\n    def free_edge():\n        for y in range(3, n + -1):\n            for x in range(2, y):\n                yield [x, y]\n    f = free_edge()\n    k = 2\n    for e in sorted_edges:\n        if e[2]:\n            e += [1, k]\n            k += 1\n        else:\n            free = next(f)\n            if free[1] >= k:\n                return -1\n            else:\n                e += free\n    sorted_edges.sort(key=lambda e: e[1])\n    result_edges = [(e[3], e[4]) for e in sorted_edges]\n    return result_edges"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for x in range(2, y):",
      "mutated_line": "for x in range(3, y):",
      "code": "def construct_graph_from_mst(n, m, edges):\n    sorted_edges = sorted(edges, key=lambda e: (e[0], -e[2]))\n\n    def free_edge():\n        for y in range(3, n + 1):\n            for x in range(3, y):\n                yield [x, y]\n    f = free_edge()\n    k = 2\n    for e in sorted_edges:\n        if e[2]:\n            e += [1, k]\n            k += 1\n        else:\n            free = next(f)\n            if free[1] >= k:\n                return -1\n            else:\n                e += free\n    sorted_edges.sort(key=lambda e: e[1])\n    result_edges = [(e[3], e[4]) for e in sorted_edges]\n    return result_edges"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for x in range(2, y):",
      "mutated_line": "for x in range(1, y):",
      "code": "def construct_graph_from_mst(n, m, edges):\n    sorted_edges = sorted(edges, key=lambda e: (e[0], -e[2]))\n\n    def free_edge():\n        for y in range(3, n + 1):\n            for x in range(1, y):\n                yield [x, y]\n    f = free_edge()\n    k = 2\n    for e in sorted_edges:\n        if e[2]:\n            e += [1, k]\n            k += 1\n        else:\n            free = next(f)\n            if free[1] >= k:\n                return -1\n            else:\n                e += free\n    sorted_edges.sort(key=lambda e: e[1])\n    result_edges = [(e[3], e[4]) for e in sorted_edges]\n    return result_edges"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for x in range(2, y):",
      "mutated_line": "for x in range(0, y):",
      "code": "def construct_graph_from_mst(n, m, edges):\n    sorted_edges = sorted(edges, key=lambda e: (e[0], -e[2]))\n\n    def free_edge():\n        for y in range(3, n + 1):\n            for x in range(0, y):\n                yield [x, y]\n    f = free_edge()\n    k = 2\n    for e in sorted_edges:\n        if e[2]:\n            e += [1, k]\n            k += 1\n        else:\n            free = next(f)\n            if free[1] >= k:\n                return -1\n            else:\n                e += free\n    sorted_edges.sort(key=lambda e: e[1])\n    result_edges = [(e[3], e[4]) for e in sorted_edges]\n    return result_edges"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for x in range(2, y):",
      "mutated_line": "for x in range(1, y):",
      "code": "def construct_graph_from_mst(n, m, edges):\n    sorted_edges = sorted(edges, key=lambda e: (e[0], -e[2]))\n\n    def free_edge():\n        for y in range(3, n + 1):\n            for x in range(1, y):\n                yield [x, y]\n    f = free_edge()\n    k = 2\n    for e in sorted_edges:\n        if e[2]:\n            e += [1, k]\n            k += 1\n        else:\n            free = next(f)\n            if free[1] >= k:\n                return -1\n            else:\n                e += free\n    sorted_edges.sort(key=lambda e: e[1])\n    result_edges = [(e[3], e[4]) for e in sorted_edges]\n    return result_edges"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for x in range(2, y):",
      "mutated_line": "for x in range(-2, y):",
      "code": "def construct_graph_from_mst(n, m, edges):\n    sorted_edges = sorted(edges, key=lambda e: (e[0], -e[2]))\n\n    def free_edge():\n        for y in range(3, n + 1):\n            for x in range(-2, y):\n                yield [x, y]\n    f = free_edge()\n    k = 2\n    for e in sorted_edges:\n        if e[2]:\n            e += [1, k]\n            k += 1\n        else:\n            free = next(f)\n            if free[1] >= k:\n                return -1\n            else:\n                e += free\n    sorted_edges.sort(key=lambda e: e[1])\n    result_edges = [(e[3], e[4]) for e in sorted_edges]\n    return result_edges"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "e += [1, k]",
      "mutated_line": "e += [2, k]",
      "code": "def construct_graph_from_mst(n, m, edges):\n    sorted_edges = sorted(edges, key=lambda e: (e[0], -e[2]))\n\n    def free_edge():\n        for y in range(3, n + 1):\n            for x in range(2, y):\n                yield [x, y]\n    f = free_edge()\n    k = 2\n    for e in sorted_edges:\n        if e[2]:\n            e += [2, k]\n            k += 1\n        else:\n            free = next(f)\n            if free[1] >= k:\n                return -1\n            else:\n                e += free\n    sorted_edges.sort(key=lambda e: e[1])\n    result_edges = [(e[3], e[4]) for e in sorted_edges]\n    return result_edges"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "e += [1, k]",
      "mutated_line": "e += [0, k]",
      "code": "def construct_graph_from_mst(n, m, edges):\n    sorted_edges = sorted(edges, key=lambda e: (e[0], -e[2]))\n\n    def free_edge():\n        for y in range(3, n + 1):\n            for x in range(2, y):\n                yield [x, y]\n    f = free_edge()\n    k = 2\n    for e in sorted_edges:\n        if e[2]:\n            e += [0, k]\n            k += 1\n        else:\n            free = next(f)\n            if free[1] >= k:\n                return -1\n            else:\n                e += free\n    sorted_edges.sort(key=lambda e: e[1])\n    result_edges = [(e[3], e[4]) for e in sorted_edges]\n    return result_edges"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "e += [1, k]",
      "mutated_line": "e += [0, k]",
      "code": "def construct_graph_from_mst(n, m, edges):\n    sorted_edges = sorted(edges, key=lambda e: (e[0], -e[2]))\n\n    def free_edge():\n        for y in range(3, n + 1):\n            for x in range(2, y):\n                yield [x, y]\n    f = free_edge()\n    k = 2\n    for e in sorted_edges:\n        if e[2]:\n            e += [0, k]\n            k += 1\n        else:\n            free = next(f)\n            if free[1] >= k:\n                return -1\n            else:\n                e += free\n    sorted_edges.sort(key=lambda e: e[1])\n    result_edges = [(e[3], e[4]) for e in sorted_edges]\n    return result_edges"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "e += [1, k]",
      "mutated_line": "e += [-1, k]",
      "code": "def construct_graph_from_mst(n, m, edges):\n    sorted_edges = sorted(edges, key=lambda e: (e[0], -e[2]))\n\n    def free_edge():\n        for y in range(3, n + 1):\n            for x in range(2, y):\n                yield [x, y]\n    f = free_edge()\n    k = 2\n    for e in sorted_edges:\n        if e[2]:\n            e += [-1, k]\n            k += 1\n        else:\n            free = next(f)\n            if free[1] >= k:\n                return -1\n            else:\n                e += free\n    sorted_edges.sort(key=lambda e: e[1])\n    result_edges = [(e[3], e[4]) for e in sorted_edges]\n    return result_edges"
    },
    {
      "operator": "UOI",
      "lineno": 20,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "def construct_graph_from_mst(n, m, edges):\n    sorted_edges = sorted(edges, key=lambda e: (e[0], -e[2]))\n\n    def free_edge():\n        for y in range(3, n + 1):\n            for x in range(2, y):\n                yield [x, y]\n    f = free_edge()\n    k = 2\n    for e in sorted_edges:\n        if e[2]:\n            e += [1, k]\n            k += 1\n        else:\n            free = next(f)\n            if free[1] >= k:\n                return +1\n            else:\n                e += free\n    sorted_edges.sort(key=lambda e: e[1])\n    result_edges = [(e[3], e[4]) for e in sorted_edges]\n    return result_edges"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "result_edges = [(e[3], e[4]) for e in sorted_edges]",
      "mutated_line": "result_edges = [(e[4], e[4]) for e in sorted_edges]",
      "code": "def construct_graph_from_mst(n, m, edges):\n    sorted_edges = sorted(edges, key=lambda e: (e[0], -e[2]))\n\n    def free_edge():\n        for y in range(3, n + 1):\n            for x in range(2, y):\n                yield [x, y]\n    f = free_edge()\n    k = 2\n    for e in sorted_edges:\n        if e[2]:\n            e += [1, k]\n            k += 1\n        else:\n            free = next(f)\n            if free[1] >= k:\n                return -1\n            else:\n                e += free\n    sorted_edges.sort(key=lambda e: e[1])\n    result_edges = [(e[4], e[4]) for e in sorted_edges]\n    return result_edges"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "result_edges = [(e[3], e[4]) for e in sorted_edges]",
      "mutated_line": "result_edges = [(e[2], e[4]) for e in sorted_edges]",
      "code": "def construct_graph_from_mst(n, m, edges):\n    sorted_edges = sorted(edges, key=lambda e: (e[0], -e[2]))\n\n    def free_edge():\n        for y in range(3, n + 1):\n            for x in range(2, y):\n                yield [x, y]\n    f = free_edge()\n    k = 2\n    for e in sorted_edges:\n        if e[2]:\n            e += [1, k]\n            k += 1\n        else:\n            free = next(f)\n            if free[1] >= k:\n                return -1\n            else:\n                e += free\n    sorted_edges.sort(key=lambda e: e[1])\n    result_edges = [(e[2], e[4]) for e in sorted_edges]\n    return result_edges"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "result_edges = [(e[3], e[4]) for e in sorted_edges]",
      "mutated_line": "result_edges = [(e[0], e[4]) for e in sorted_edges]",
      "code": "def construct_graph_from_mst(n, m, edges):\n    sorted_edges = sorted(edges, key=lambda e: (e[0], -e[2]))\n\n    def free_edge():\n        for y in range(3, n + 1):\n            for x in range(2, y):\n                yield [x, y]\n    f = free_edge()\n    k = 2\n    for e in sorted_edges:\n        if e[2]:\n            e += [1, k]\n            k += 1\n        else:\n            free = next(f)\n            if free[1] >= k:\n                return -1\n            else:\n                e += free\n    sorted_edges.sort(key=lambda e: e[1])\n    result_edges = [(e[0], e[4]) for e in sorted_edges]\n    return result_edges"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "result_edges = [(e[3], e[4]) for e in sorted_edges]",
      "mutated_line": "result_edges = [(e[1], e[4]) for e in sorted_edges]",
      "code": "def construct_graph_from_mst(n, m, edges):\n    sorted_edges = sorted(edges, key=lambda e: (e[0], -e[2]))\n\n    def free_edge():\n        for y in range(3, n + 1):\n            for x in range(2, y):\n                yield [x, y]\n    f = free_edge()\n    k = 2\n    for e in sorted_edges:\n        if e[2]:\n            e += [1, k]\n            k += 1\n        else:\n            free = next(f)\n            if free[1] >= k:\n                return -1\n            else:\n                e += free\n    sorted_edges.sort(key=lambda e: e[1])\n    result_edges = [(e[1], e[4]) for e in sorted_edges]\n    return result_edges"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "result_edges = [(e[3], e[4]) for e in sorted_edges]",
      "mutated_line": "result_edges = [(e[-3], e[4]) for e in sorted_edges]",
      "code": "def construct_graph_from_mst(n, m, edges):\n    sorted_edges = sorted(edges, key=lambda e: (e[0], -e[2]))\n\n    def free_edge():\n        for y in range(3, n + 1):\n            for x in range(2, y):\n                yield [x, y]\n    f = free_edge()\n    k = 2\n    for e in sorted_edges:\n        if e[2]:\n            e += [1, k]\n            k += 1\n        else:\n            free = next(f)\n            if free[1] >= k:\n                return -1\n            else:\n                e += free\n    sorted_edges.sort(key=lambda e: e[1])\n    result_edges = [(e[-3], e[4]) for e in sorted_edges]\n    return result_edges"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "result_edges = [(e[3], e[4]) for e in sorted_edges]",
      "mutated_line": "result_edges = [(e[3], e[5]) for e in sorted_edges]",
      "code": "def construct_graph_from_mst(n, m, edges):\n    sorted_edges = sorted(edges, key=lambda e: (e[0], -e[2]))\n\n    def free_edge():\n        for y in range(3, n + 1):\n            for x in range(2, y):\n                yield [x, y]\n    f = free_edge()\n    k = 2\n    for e in sorted_edges:\n        if e[2]:\n            e += [1, k]\n            k += 1\n        else:\n            free = next(f)\n            if free[1] >= k:\n                return -1\n            else:\n                e += free\n    sorted_edges.sort(key=lambda e: e[1])\n    result_edges = [(e[3], e[5]) for e in sorted_edges]\n    return result_edges"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "result_edges = [(e[3], e[4]) for e in sorted_edges]",
      "mutated_line": "result_edges = [(e[3], e[3]) for e in sorted_edges]",
      "code": "def construct_graph_from_mst(n, m, edges):\n    sorted_edges = sorted(edges, key=lambda e: (e[0], -e[2]))\n\n    def free_edge():\n        for y in range(3, n + 1):\n            for x in range(2, y):\n                yield [x, y]\n    f = free_edge()\n    k = 2\n    for e in sorted_edges:\n        if e[2]:\n            e += [1, k]\n            k += 1\n        else:\n            free = next(f)\n            if free[1] >= k:\n                return -1\n            else:\n                e += free\n    sorted_edges.sort(key=lambda e: e[1])\n    result_edges = [(e[3], e[3]) for e in sorted_edges]\n    return result_edges"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "result_edges = [(e[3], e[4]) for e in sorted_edges]",
      "mutated_line": "result_edges = [(e[3], e[0]) for e in sorted_edges]",
      "code": "def construct_graph_from_mst(n, m, edges):\n    sorted_edges = sorted(edges, key=lambda e: (e[0], -e[2]))\n\n    def free_edge():\n        for y in range(3, n + 1):\n            for x in range(2, y):\n                yield [x, y]\n    f = free_edge()\n    k = 2\n    for e in sorted_edges:\n        if e[2]:\n            e += [1, k]\n            k += 1\n        else:\n            free = next(f)\n            if free[1] >= k:\n                return -1\n            else:\n                e += free\n    sorted_edges.sort(key=lambda e: e[1])\n    result_edges = [(e[3], e[0]) for e in sorted_edges]\n    return result_edges"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "result_edges = [(e[3], e[4]) for e in sorted_edges]",
      "mutated_line": "result_edges = [(e[3], e[1]) for e in sorted_edges]",
      "code": "def construct_graph_from_mst(n, m, edges):\n    sorted_edges = sorted(edges, key=lambda e: (e[0], -e[2]))\n\n    def free_edge():\n        for y in range(3, n + 1):\n            for x in range(2, y):\n                yield [x, y]\n    f = free_edge()\n    k = 2\n    for e in sorted_edges:\n        if e[2]:\n            e += [1, k]\n            k += 1\n        else:\n            free = next(f)\n            if free[1] >= k:\n                return -1\n            else:\n                e += free\n    sorted_edges.sort(key=lambda e: e[1])\n    result_edges = [(e[3], e[1]) for e in sorted_edges]\n    return result_edges"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "result_edges = [(e[3], e[4]) for e in sorted_edges]",
      "mutated_line": "result_edges = [(e[3], e[-4]) for e in sorted_edges]",
      "code": "def construct_graph_from_mst(n, m, edges):\n    sorted_edges = sorted(edges, key=lambda e: (e[0], -e[2]))\n\n    def free_edge():\n        for y in range(3, n + 1):\n            for x in range(2, y):\n                yield [x, y]\n    f = free_edge()\n    k = 2\n    for e in sorted_edges:\n        if e[2]:\n            e += [1, k]\n            k += 1\n        else:\n            free = next(f)\n            if free[1] >= k:\n                return -1\n            else:\n                e += free\n    sorted_edges.sort(key=lambda e: e[1])\n    result_edges = [(e[3], e[-4]) for e in sorted_edges]\n    return result_edges"
    },
    {
      "operator": "UOI",
      "lineno": 3,
      "original_line": "sorted_edges = sorted(edges, key=lambda e: (e[0], -e[2]))",
      "mutated_line": "",
      "code": "def construct_graph_from_mst(n, m, edges):\n    sorted_edges = sorted(edges, key=lambda e: (e[0], +e[2]))\n\n    def free_edge():\n        for y in range(3, n + 1):\n            for x in range(2, y):\n                yield [x, y]\n    f = free_edge()\n    k = 2\n    for e in sorted_edges:\n        if e[2]:\n            e += [1, k]\n            k += 1\n        else:\n            free = next(f)\n            if free[1] >= k:\n                return -1\n            else:\n                e += free\n    sorted_edges.sort(key=lambda e: e[1])\n    result_edges = [(e[3], e[4]) for e in sorted_edges]\n    return result_edges"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if free[1] >= k:",
      "mutated_line": "if free[2] >= k:",
      "code": "def construct_graph_from_mst(n, m, edges):\n    sorted_edges = sorted(edges, key=lambda e: (e[0], -e[2]))\n\n    def free_edge():\n        for y in range(3, n + 1):\n            for x in range(2, y):\n                yield [x, y]\n    f = free_edge()\n    k = 2\n    for e in sorted_edges:\n        if e[2]:\n            e += [1, k]\n            k += 1\n        else:\n            free = next(f)\n            if free[2] >= k:\n                return -1\n            else:\n                e += free\n    sorted_edges.sort(key=lambda e: e[1])\n    result_edges = [(e[3], e[4]) for e in sorted_edges]\n    return result_edges"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if free[1] >= k:",
      "mutated_line": "if free[0] >= k:",
      "code": "def construct_graph_from_mst(n, m, edges):\n    sorted_edges = sorted(edges, key=lambda e: (e[0], -e[2]))\n\n    def free_edge():\n        for y in range(3, n + 1):\n            for x in range(2, y):\n                yield [x, y]\n    f = free_edge()\n    k = 2\n    for e in sorted_edges:\n        if e[2]:\n            e += [1, k]\n            k += 1\n        else:\n            free = next(f)\n            if free[0] >= k:\n                return -1\n            else:\n                e += free\n    sorted_edges.sort(key=lambda e: e[1])\n    result_edges = [(e[3], e[4]) for e in sorted_edges]\n    return result_edges"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if free[1] >= k:",
      "mutated_line": "if free[0] >= k:",
      "code": "def construct_graph_from_mst(n, m, edges):\n    sorted_edges = sorted(edges, key=lambda e: (e[0], -e[2]))\n\n    def free_edge():\n        for y in range(3, n + 1):\n            for x in range(2, y):\n                yield [x, y]\n    f = free_edge()\n    k = 2\n    for e in sorted_edges:\n        if e[2]:\n            e += [1, k]\n            k += 1\n        else:\n            free = next(f)\n            if free[0] >= k:\n                return -1\n            else:\n                e += free\n    sorted_edges.sort(key=lambda e: e[1])\n    result_edges = [(e[3], e[4]) for e in sorted_edges]\n    return result_edges"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if free[1] >= k:",
      "mutated_line": "if free[-1] >= k:",
      "code": "def construct_graph_from_mst(n, m, edges):\n    sorted_edges = sorted(edges, key=lambda e: (e[0], -e[2]))\n\n    def free_edge():\n        for y in range(3, n + 1):\n            for x in range(2, y):\n                yield [x, y]\n    f = free_edge()\n    k = 2\n    for e in sorted_edges:\n        if e[2]:\n            e += [1, k]\n            k += 1\n        else:\n            free = next(f)\n            if free[-1] >= k:\n                return -1\n            else:\n                e += free\n    sorted_edges.sort(key=lambda e: e[1])\n    result_edges = [(e[3], e[4]) for e in sorted_edges]\n    return result_edges"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "def construct_graph_from_mst(n, m, edges):\n    sorted_edges = sorted(edges, key=lambda e: (e[0], -e[2]))\n\n    def free_edge():\n        for y in range(3, n + 1):\n            for x in range(2, y):\n                yield [x, y]\n    f = free_edge()\n    k = 2\n    for e in sorted_edges:\n        if e[2]:\n            e += [1, k]\n            k += 1\n        else:\n            free = next(f)\n            if free[1] >= k:\n                return -2\n            else:\n                e += free\n    sorted_edges.sort(key=lambda e: e[1])\n    result_edges = [(e[3], e[4]) for e in sorted_edges]\n    return result_edges"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def construct_graph_from_mst(n, m, edges):\n    sorted_edges = sorted(edges, key=lambda e: (e[0], -e[2]))\n\n    def free_edge():\n        for y in range(3, n + 1):\n            for x in range(2, y):\n                yield [x, y]\n    f = free_edge()\n    k = 2\n    for e in sorted_edges:\n        if e[2]:\n            e += [1, k]\n            k += 1\n        else:\n            free = next(f)\n            if free[1] >= k:\n                return -0\n            else:\n                e += free\n    sorted_edges.sort(key=lambda e: e[1])\n    result_edges = [(e[3], e[4]) for e in sorted_edges]\n    return result_edges"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def construct_graph_from_mst(n, m, edges):\n    sorted_edges = sorted(edges, key=lambda e: (e[0], -e[2]))\n\n    def free_edge():\n        for y in range(3, n + 1):\n            for x in range(2, y):\n                yield [x, y]\n    f = free_edge()\n    k = 2\n    for e in sorted_edges:\n        if e[2]:\n            e += [1, k]\n            k += 1\n        else:\n            free = next(f)\n            if free[1] >= k:\n                return -0\n            else:\n                e += free\n    sorted_edges.sort(key=lambda e: e[1])\n    result_edges = [(e[3], e[4]) for e in sorted_edges]\n    return result_edges"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "def construct_graph_from_mst(n, m, edges):\n    sorted_edges = sorted(edges, key=lambda e: (e[0], -e[2]))\n\n    def free_edge():\n        for y in range(3, n + 1):\n            for x in range(2, y):\n                yield [x, y]\n    f = free_edge()\n    k = 2\n    for e in sorted_edges:\n        if e[2]:\n            e += [1, k]\n            k += 1\n        else:\n            free = next(f)\n            if free[1] >= k:\n                return --1\n            else:\n                e += free\n    sorted_edges.sort(key=lambda e: e[1])\n    result_edges = [(e[3], e[4]) for e in sorted_edges]\n    return result_edges"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "sorted_edges.sort(key=lambda e: e[1])",
      "mutated_line": "sorted_edges.sort(key=lambda e: e[2])",
      "code": "def construct_graph_from_mst(n, m, edges):\n    sorted_edges = sorted(edges, key=lambda e: (e[0], -e[2]))\n\n    def free_edge():\n        for y in range(3, n + 1):\n            for x in range(2, y):\n                yield [x, y]\n    f = free_edge()\n    k = 2\n    for e in sorted_edges:\n        if e[2]:\n            e += [1, k]\n            k += 1\n        else:\n            free = next(f)\n            if free[1] >= k:\n                return -1\n            else:\n                e += free\n    sorted_edges.sort(key=lambda e: e[2])\n    result_edges = [(e[3], e[4]) for e in sorted_edges]\n    return result_edges"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "sorted_edges.sort(key=lambda e: e[1])",
      "mutated_line": "sorted_edges.sort(key=lambda e: e[0])",
      "code": "def construct_graph_from_mst(n, m, edges):\n    sorted_edges = sorted(edges, key=lambda e: (e[0], -e[2]))\n\n    def free_edge():\n        for y in range(3, n + 1):\n            for x in range(2, y):\n                yield [x, y]\n    f = free_edge()\n    k = 2\n    for e in sorted_edges:\n        if e[2]:\n            e += [1, k]\n            k += 1\n        else:\n            free = next(f)\n            if free[1] >= k:\n                return -1\n            else:\n                e += free\n    sorted_edges.sort(key=lambda e: e[0])\n    result_edges = [(e[3], e[4]) for e in sorted_edges]\n    return result_edges"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "sorted_edges.sort(key=lambda e: e[1])",
      "mutated_line": "sorted_edges.sort(key=lambda e: e[0])",
      "code": "def construct_graph_from_mst(n, m, edges):\n    sorted_edges = sorted(edges, key=lambda e: (e[0], -e[2]))\n\n    def free_edge():\n        for y in range(3, n + 1):\n            for x in range(2, y):\n                yield [x, y]\n    f = free_edge()\n    k = 2\n    for e in sorted_edges:\n        if e[2]:\n            e += [1, k]\n            k += 1\n        else:\n            free = next(f)\n            if free[1] >= k:\n                return -1\n            else:\n                e += free\n    sorted_edges.sort(key=lambda e: e[0])\n    result_edges = [(e[3], e[4]) for e in sorted_edges]\n    return result_edges"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "sorted_edges.sort(key=lambda e: e[1])",
      "mutated_line": "sorted_edges.sort(key=lambda e: e[-1])",
      "code": "def construct_graph_from_mst(n, m, edges):\n    sorted_edges = sorted(edges, key=lambda e: (e[0], -e[2]))\n\n    def free_edge():\n        for y in range(3, n + 1):\n            for x in range(2, y):\n                yield [x, y]\n    f = free_edge()\n    k = 2\n    for e in sorted_edges:\n        if e[2]:\n            e += [1, k]\n            k += 1\n        else:\n            free = next(f)\n            if free[1] >= k:\n                return -1\n            else:\n                e += free\n    sorted_edges.sort(key=lambda e: e[-1])\n    result_edges = [(e[3], e[4]) for e in sorted_edges]\n    return result_edges"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "sorted_edges = sorted(edges, key=lambda e: (e[0], -e[2]))",
      "mutated_line": "",
      "code": "def construct_graph_from_mst(n, m, edges):\n    sorted_edges = sorted(edges, key=lambda e: (e[1], -e[2]))\n\n    def free_edge():\n        for y in range(3, n + 1):\n            for x in range(2, y):\n                yield [x, y]\n    f = free_edge()\n    k = 2\n    for e in sorted_edges:\n        if e[2]:\n            e += [1, k]\n            k += 1\n        else:\n            free = next(f)\n            if free[1] >= k:\n                return -1\n            else:\n                e += free\n    sorted_edges.sort(key=lambda e: e[1])\n    result_edges = [(e[3], e[4]) for e in sorted_edges]\n    return result_edges"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "sorted_edges = sorted(edges, key=lambda e: (e[0], -e[2]))",
      "mutated_line": "",
      "code": "def construct_graph_from_mst(n, m, edges):\n    sorted_edges = sorted(edges, key=lambda e: (e[-1], -e[2]))\n\n    def free_edge():\n        for y in range(3, n + 1):\n            for x in range(2, y):\n                yield [x, y]\n    f = free_edge()\n    k = 2\n    for e in sorted_edges:\n        if e[2]:\n            e += [1, k]\n            k += 1\n        else:\n            free = next(f)\n            if free[1] >= k:\n                return -1\n            else:\n                e += free\n    sorted_edges.sort(key=lambda e: e[1])\n    result_edges = [(e[3], e[4]) for e in sorted_edges]\n    return result_edges"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "sorted_edges = sorted(edges, key=lambda e: (e[0], -e[2]))",
      "mutated_line": "",
      "code": "def construct_graph_from_mst(n, m, edges):\n    sorted_edges = sorted(edges, key=lambda e: (e[1], -e[2]))\n\n    def free_edge():\n        for y in range(3, n + 1):\n            for x in range(2, y):\n                yield [x, y]\n    f = free_edge()\n    k = 2\n    for e in sorted_edges:\n        if e[2]:\n            e += [1, k]\n            k += 1\n        else:\n            free = next(f)\n            if free[1] >= k:\n                return -1\n            else:\n                e += free\n    sorted_edges.sort(key=lambda e: e[1])\n    result_edges = [(e[3], e[4]) for e in sorted_edges]\n    return result_edges"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "sorted_edges = sorted(edges, key=lambda e: (e[0], -e[2]))",
      "mutated_line": "",
      "code": "def construct_graph_from_mst(n, m, edges):\n    sorted_edges = sorted(edges, key=lambda e: (e[0], -e[3]))\n\n    def free_edge():\n        for y in range(3, n + 1):\n            for x in range(2, y):\n                yield [x, y]\n    f = free_edge()\n    k = 2\n    for e in sorted_edges:\n        if e[2]:\n            e += [1, k]\n            k += 1\n        else:\n            free = next(f)\n            if free[1] >= k:\n                return -1\n            else:\n                e += free\n    sorted_edges.sort(key=lambda e: e[1])\n    result_edges = [(e[3], e[4]) for e in sorted_edges]\n    return result_edges"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "sorted_edges = sorted(edges, key=lambda e: (e[0], -e[2]))",
      "mutated_line": "",
      "code": "def construct_graph_from_mst(n, m, edges):\n    sorted_edges = sorted(edges, key=lambda e: (e[0], -e[1]))\n\n    def free_edge():\n        for y in range(3, n + 1):\n            for x in range(2, y):\n                yield [x, y]\n    f = free_edge()\n    k = 2\n    for e in sorted_edges:\n        if e[2]:\n            e += [1, k]\n            k += 1\n        else:\n            free = next(f)\n            if free[1] >= k:\n                return -1\n            else:\n                e += free\n    sorted_edges.sort(key=lambda e: e[1])\n    result_edges = [(e[3], e[4]) for e in sorted_edges]\n    return result_edges"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "sorted_edges = sorted(edges, key=lambda e: (e[0], -e[2]))",
      "mutated_line": "",
      "code": "def construct_graph_from_mst(n, m, edges):\n    sorted_edges = sorted(edges, key=lambda e: (e[0], -e[0]))\n\n    def free_edge():\n        for y in range(3, n + 1):\n            for x in range(2, y):\n                yield [x, y]\n    f = free_edge()\n    k = 2\n    for e in sorted_edges:\n        if e[2]:\n            e += [1, k]\n            k += 1\n        else:\n            free = next(f)\n            if free[1] >= k:\n                return -1\n            else:\n                e += free\n    sorted_edges.sort(key=lambda e: e[1])\n    result_edges = [(e[3], e[4]) for e in sorted_edges]\n    return result_edges"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "sorted_edges = sorted(edges, key=lambda e: (e[0], -e[2]))",
      "mutated_line": "",
      "code": "def construct_graph_from_mst(n, m, edges):\n    sorted_edges = sorted(edges, key=lambda e: (e[0], -e[1]))\n\n    def free_edge():\n        for y in range(3, n + 1):\n            for x in range(2, y):\n                yield [x, y]\n    f = free_edge()\n    k = 2\n    for e in sorted_edges:\n        if e[2]:\n            e += [1, k]\n            k += 1\n        else:\n            free = next(f)\n            if free[1] >= k:\n                return -1\n            else:\n                e += free\n    sorted_edges.sort(key=lambda e: e[1])\n    result_edges = [(e[3], e[4]) for e in sorted_edges]\n    return result_edges"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "sorted_edges = sorted(edges, key=lambda e: (e[0], -e[2]))",
      "mutated_line": "",
      "code": "def construct_graph_from_mst(n, m, edges):\n    sorted_edges = sorted(edges, key=lambda e: (e[0], -e[-2]))\n\n    def free_edge():\n        for y in range(3, n + 1):\n            for x in range(2, y):\n                yield [x, y]\n    f = free_edge()\n    k = 2\n    for e in sorted_edges:\n        if e[2]:\n            e += [1, k]\n            k += 1\n        else:\n            free = next(f)\n            if free[1] >= k:\n                return -1\n            else:\n                e += free\n    sorted_edges.sort(key=lambda e: e[1])\n    result_edges = [(e[3], e[4]) for e in sorted_edges]\n    return result_edges"
    }
  ]
}