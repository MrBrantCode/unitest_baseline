{
  "task_id": "taco_15343",
  "entry_point": "calculate_minimum_stones_to_move",
  "mutant_count": 147,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "INF = 10 ** 13",
      "mutated_line": "INF = 10 * 13",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 * 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "INF = 10 ** 13",
      "mutated_line": "INF = 10 + 13",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 + 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "xor = 0",
      "mutated_line": "xor = 1",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 1\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "xor = 0",
      "mutated_line": "xor = -1",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = -1\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "xor = 0",
      "mutated_line": "xor = 1",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 1\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if x >= a:",
      "mutated_line": "if x > a:",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x > a:\n        return -1\n    return x"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if x >= a:",
      "mutated_line": "if x < a:",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x < a:\n        return -1\n    return x"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if x >= a:",
      "mutated_line": "if x == a:",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x == a:\n        return -1\n    return x"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "INF = 10 ** 13",
      "mutated_line": "INF = 11 ** 13",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 11 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "INF = 10 ** 13",
      "mutated_line": "INF = 9 ** 13",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 9 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "INF = 10 ** 13",
      "mutated_line": "INF = 0 ** 13",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 0 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "INF = 10 ** 13",
      "mutated_line": "INF = 1 ** 13",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 1 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "INF = 10 ** 13",
      "mutated_line": "INF = -10 ** 13",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = -10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "INF = 10 ** 13",
      "mutated_line": "INF = 10 ** 14",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 14\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "INF = 10 ** 13",
      "mutated_line": "INF = 10 ** 12",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 12\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "INF = 10 ** 13",
      "mutated_line": "INF = 10 ** 0",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 0\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "INF = 10 ** 13",
      "mutated_line": "INF = 10 ** 1",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 1\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "INF = 10 ** 13",
      "mutated_line": "INF = 10 ** -13",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** -13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if a & 1 ^ b & 1 != xor & 1:",
      "mutated_line": "if a & 1 ^ b & 1 == xor & 1:",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 == xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if xor == 0:",
      "mutated_line": "if xor != 0:",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor != 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "x = 2 * F(a // 2, b // 2, xor // 2)",
      "mutated_line": "x = 2 / F(a // 2, b // 2, xor // 2)",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 / F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "x = 2 * F(a // 2, b // 2, xor // 2)",
      "mutated_line": "x = 2 + F(a // 2, b // 2, xor // 2)",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 + F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "x = 2 * F(a // 2, b // 2, xor // 2)",
      "mutated_line": "x = 2 ** F(a // 2, b // 2, xor // 2)",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 ** F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1",
      "mutated_line": "y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) - 1",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) - 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1",
      "mutated_line": "y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) * 1",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) * 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if x >= INF:",
      "mutated_line": "if x > INF:",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x > INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if x >= INF:",
      "mutated_line": "if x < INF:",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x < INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if x >= INF:",
      "mutated_line": "if x == INF:",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x == INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "UOI",
      "lineno": 26,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return +1\n    return x"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "if a & 1 ^ b & 1 != xor & 1:",
      "mutated_line": "if a & 1 | b & 1 != xor & 1:",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 | b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "if a & 1 ^ b & 1 != xor & 1:",
      "mutated_line": "if a & 1 ^ b & 1 != xor | 1:",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor | 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if xor == 0:",
      "mutated_line": "if xor == 1:",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 1:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if xor == 0:",
      "mutated_line": "if xor == -1:",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == -1:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if xor == 0:",
      "mutated_line": "if xor == 1:",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 1:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "x = 2 * F(a // 2, b // 2, xor // 2)",
      "mutated_line": "x = 3 * F(a // 2, b // 2, xor // 2)",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 3 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "x = 2 * F(a // 2, b // 2, xor // 2)",
      "mutated_line": "x = 1 * F(a // 2, b // 2, xor // 2)",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 1 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "x = 2 * F(a // 2, b // 2, xor // 2)",
      "mutated_line": "x = 0 * F(a // 2, b // 2, xor // 2)",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 0 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "x = 2 * F(a // 2, b // 2, xor // 2)",
      "mutated_line": "x = 1 * F(a // 2, b // 2, xor // 2)",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 1 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "x = 2 * F(a // 2, b // 2, xor // 2)",
      "mutated_line": "x = -2 * F(a // 2, b // 2, xor // 2)",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = -2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1",
      "mutated_line": "y = 2 / F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 / F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1",
      "mutated_line": "y = 2 + F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 + F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1",
      "mutated_line": "y = 2 ** F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 ** F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1",
      "mutated_line": "y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 2",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 2\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1",
      "mutated_line": "y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 0",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 0\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1",
      "mutated_line": "y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 0",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 0\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1",
      "mutated_line": "y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + -1",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + -1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "a, b = A[0], A[1]",
      "mutated_line": "(a, b) = (A[1], A[1])",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[1], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "a, b = A[0], A[1]",
      "mutated_line": "(a, b) = (A[-1], A[1])",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[-1], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "a, b = A[0], A[1]",
      "mutated_line": "(a, b) = (A[1], A[1])",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[1], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "a, b = A[0], A[1]",
      "mutated_line": "(a, b) = (A[0], A[2])",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[2])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "a, b = A[0], A[1]",
      "mutated_line": "(a, b) = (A[0], A[0])",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[0])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "a, b = A[0], A[1]",
      "mutated_line": "(a, b) = (A[0], A[0])",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[0])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "a, b = A[0], A[1]",
      "mutated_line": "(a, b) = (A[0], A[-1])",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[-1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for x in A[2:]:",
      "mutated_line": "for x in A[3:]:",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[3:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for x in A[2:]:",
      "mutated_line": "for x in A[1:]:",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[1:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for x in A[2:]:",
      "mutated_line": "for x in A[0:]:",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[0:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for x in A[2:]:",
      "mutated_line": "for x in A[1:]:",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[1:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for x in A[2:]:",
      "mutated_line": "for x in A[-2:]:",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[-2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -2\n    return x"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -0\n    return x"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -0\n    return x"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return --1\n    return x"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "if a & 1 ^ b & 1 != xor & 1:",
      "mutated_line": "if (a | 1) ^ b & 1 != xor & 1:",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if (a | 1) ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "if a & 1 ^ b & 1 != xor & 1:",
      "mutated_line": "if a & 1 ^ (b | 1) != xor & 1:",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ (b | 1) != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if a & 1 ^ b & 1 != xor & 1:",
      "mutated_line": "if a & 1 ^ b & 1 != xor & 2:",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 2:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if a & 1 ^ b & 1 != xor & 1:",
      "mutated_line": "if a & 1 ^ b & 1 != xor & 0:",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 0:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if a & 1 ^ b & 1 != xor & 1:",
      "mutated_line": "if a & 1 ^ b & 1 != xor & 0:",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 0:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if a & 1 ^ b & 1 != xor & 1:",
      "mutated_line": "if a & 1 ^ b & 1 != xor & -1:",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & -1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "return INF if a < b else (a - b) // 2",
      "mutated_line": "return INF if a <= b else (a - b) // 2",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a <= b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "return INF if a < b else (a - b) // 2",
      "mutated_line": "return INF if a >= b else (a - b) // 2",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a >= b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "return INF if a < b else (a - b) // 2",
      "mutated_line": "return INF if a != b else (a - b) // 2",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a != b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return INF if a < b else (a - b) // 2",
      "mutated_line": "return INF if a < b else (a - b) / 2",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) / 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return INF if a < b else (a - b) // 2",
      "mutated_line": "return INF if a < b else (a - b) * 2",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) * 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "x = 2 * F(a // 2, b // 2, xor // 2)",
      "mutated_line": "x = 2 * F(a / 2, b // 2, xor // 2)",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a / 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "x = 2 * F(a // 2, b // 2, xor // 2)",
      "mutated_line": "x = 2 * F(a * 2, b // 2, xor // 2)",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a * 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "x = 2 * F(a // 2, b // 2, xor // 2)",
      "mutated_line": "x = 2 * F(a // 2, b / 2, xor // 2)",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b / 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "x = 2 * F(a // 2, b // 2, xor // 2)",
      "mutated_line": "x = 2 * F(a // 2, b * 2, xor // 2)",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b * 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "x = 2 * F(a // 2, b // 2, xor // 2)",
      "mutated_line": "x = 2 * F(a // 2, b // 2, xor / 2)",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor / 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "x = 2 * F(a // 2, b // 2, xor // 2)",
      "mutated_line": "x = 2 * F(a // 2, b // 2, xor * 2)",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor * 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1",
      "mutated_line": "y = 3 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 3 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1",
      "mutated_line": "y = 1 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 1 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1",
      "mutated_line": "y = 0 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 0 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1",
      "mutated_line": "y = 1 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 1 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1",
      "mutated_line": "y = -2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = -2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if a & 1 ^ b & 1 != xor & 1:",
      "mutated_line": "if a & 2 ^ b & 1 != xor & 1:",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 2 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if a & 1 ^ b & 1 != xor & 1:",
      "mutated_line": "if a & 0 ^ b & 1 != xor & 1:",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 0 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if a & 1 ^ b & 1 != xor & 1:",
      "mutated_line": "if a & 0 ^ b & 1 != xor & 1:",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 0 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if a & 1 ^ b & 1 != xor & 1:",
      "mutated_line": "if a & -1 ^ b & 1 != xor & 1:",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & -1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if a & 1 ^ b & 1 != xor & 1:",
      "mutated_line": "if a & 1 ^ b & 2 != xor & 1:",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 2 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if a & 1 ^ b & 1 != xor & 1:",
      "mutated_line": "if a & 1 ^ b & 0 != xor & 1:",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 0 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if a & 1 ^ b & 1 != xor & 1:",
      "mutated_line": "if a & 1 ^ b & 0 != xor & 1:",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 0 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if a & 1 ^ b & 1 != xor & 1:",
      "mutated_line": "if a & 1 ^ b & -1 != xor & 1:",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & -1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return INF if a < b else (a - b) // 2",
      "mutated_line": "return INF if a < b else (a + b) // 2",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a + b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return INF if a < b else (a - b) // 2",
      "mutated_line": "return INF if a < b else a * b // 2",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else a * b // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return INF if a < b else (a - b) // 2",
      "mutated_line": "return INF if a < b else (a - b) // 3",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 3\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return INF if a < b else (a - b) // 2",
      "mutated_line": "return INF if a < b else (a - b) // 1",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 1\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return INF if a < b else (a - b) // 2",
      "mutated_line": "return INF if a < b else (a - b) // 0",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 0\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return INF if a < b else (a - b) // 2",
      "mutated_line": "return INF if a < b else (a - b) // 1",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 1\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return INF if a < b else (a - b) // 2",
      "mutated_line": "return INF if a < b else (a - b) // -2",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // -2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "x = 2 * F(a // 2, b // 2, xor // 2)",
      "mutated_line": "x = 2 * F(a // 3, b // 2, xor // 2)",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 3, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "x = 2 * F(a // 2, b // 2, xor // 2)",
      "mutated_line": "x = 2 * F(a // 1, b // 2, xor // 2)",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 1, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "x = 2 * F(a // 2, b // 2, xor // 2)",
      "mutated_line": "x = 2 * F(a // 0, b // 2, xor // 2)",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 0, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "x = 2 * F(a // 2, b // 2, xor // 2)",
      "mutated_line": "x = 2 * F(a // 1, b // 2, xor // 2)",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 1, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "x = 2 * F(a // 2, b // 2, xor // 2)",
      "mutated_line": "x = 2 * F(a // -2, b // 2, xor // 2)",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // -2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "x = 2 * F(a // 2, b // 2, xor // 2)",
      "mutated_line": "x = 2 * F(a // 2, b // 3, xor // 2)",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 3, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "x = 2 * F(a // 2, b // 2, xor // 2)",
      "mutated_line": "x = 2 * F(a // 2, b // 1, xor // 2)",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 1, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "x = 2 * F(a // 2, b // 2, xor // 2)",
      "mutated_line": "x = 2 * F(a // 2, b // 0, xor // 2)",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 0, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "x = 2 * F(a // 2, b // 2, xor // 2)",
      "mutated_line": "x = 2 * F(a // 2, b // 1, xor // 2)",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 1, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "x = 2 * F(a // 2, b // 2, xor // 2)",
      "mutated_line": "x = 2 * F(a // 2, b // -2, xor // 2)",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // -2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "x = 2 * F(a // 2, b // 2, xor // 2)",
      "mutated_line": "x = 2 * F(a // 2, b // 2, xor // 3)",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 3)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "x = 2 * F(a // 2, b // 2, xor // 2)",
      "mutated_line": "x = 2 * F(a // 2, b // 2, xor // 1)",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 1)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "x = 2 * F(a // 2, b // 2, xor // 2)",
      "mutated_line": "x = 2 * F(a // 2, b // 2, xor // 0)",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 0)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "x = 2 * F(a // 2, b // 2, xor // 2)",
      "mutated_line": "x = 2 * F(a // 2, b // 2, xor // 1)",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 1)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "x = 2 * F(a // 2, b // 2, xor // 2)",
      "mutated_line": "x = 2 * F(a // 2, b // 2, xor // -2)",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // -2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1",
      "mutated_line": "y = 2 * F((a - 1) / 2, (b + 1) // 2, xor // 2) + 1",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) / 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1",
      "mutated_line": "y = 2 * F((a - 1) * 2, (b + 1) // 2, xor // 2) + 1",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) * 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1",
      "mutated_line": "y = 2 * F((a - 1) // 2, (b + 1) / 2, xor // 2) + 1",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) / 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1",
      "mutated_line": "y = 2 * F((a - 1) // 2, (b + 1) * 2, xor // 2) + 1",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) * 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1",
      "mutated_line": "y = 2 * F((a - 1) // 2, (b + 1) // 2, xor / 2) + 1",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor / 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1",
      "mutated_line": "y = 2 * F((a - 1) // 2, (b + 1) // 2, xor * 2) + 1",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor * 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1",
      "mutated_line": "y = 2 * F((a + 1) // 2, (b + 1) // 2, xor // 2) + 1",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a + 1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1",
      "mutated_line": "y = 2 * F(a * 1 // 2, (b + 1) // 2, xor // 2) + 1",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F(a * 1 // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1",
      "mutated_line": "y = 2 * F((a - 1) // 3, (b + 1) // 2, xor // 2) + 1",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 3, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1",
      "mutated_line": "y = 2 * F((a - 1) // 1, (b + 1) // 2, xor // 2) + 1",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 1, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1",
      "mutated_line": "y = 2 * F((a - 1) // 0, (b + 1) // 2, xor // 2) + 1",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 0, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1",
      "mutated_line": "y = 2 * F((a - 1) // 1, (b + 1) // 2, xor // 2) + 1",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 1, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1",
      "mutated_line": "y = 2 * F((a - 1) // -2, (b + 1) // 2, xor // 2) + 1",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // -2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1",
      "mutated_line": "y = 2 * F((a - 1) // 2, (b - 1) // 2, xor // 2) + 1",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b - 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1",
      "mutated_line": "y = 2 * F((a - 1) // 2, b * 1 // 2, xor // 2) + 1",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, b * 1 // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1",
      "mutated_line": "y = 2 * F((a - 1) // 2, (b + 1) // 3, xor // 2) + 1",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 3, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1",
      "mutated_line": "y = 2 * F((a - 1) // 2, (b + 1) // 1, xor // 2) + 1",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 1, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1",
      "mutated_line": "y = 2 * F((a - 1) // 2, (b + 1) // 0, xor // 2) + 1",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 0, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1",
      "mutated_line": "y = 2 * F((a - 1) // 2, (b + 1) // 1, xor // 2) + 1",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 1, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1",
      "mutated_line": "y = 2 * F((a - 1) // 2, (b + 1) // -2, xor // 2) + 1",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // -2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1",
      "mutated_line": "y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 3) + 1",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 3) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1",
      "mutated_line": "y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 1) + 1",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 1) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1",
      "mutated_line": "y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 0) + 1",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 0) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1",
      "mutated_line": "y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 1) + 1",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 1) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1",
      "mutated_line": "y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // -2) + 1",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // -2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1",
      "mutated_line": "y = 2 * F((a - 2) // 2, (b + 1) // 2, xor // 2) + 1",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 2) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1",
      "mutated_line": "y = 2 * F((a - 0) // 2, (b + 1) // 2, xor // 2) + 1",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 0) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1",
      "mutated_line": "y = 2 * F((a - 0) // 2, (b + 1) // 2, xor // 2) + 1",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 0) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1",
      "mutated_line": "y = 2 * F((a - -1) // 2, (b + 1) // 2, xor // 2) + 1",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - -1) // 2, (b + 1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1",
      "mutated_line": "y = 2 * F((a - 1) // 2, (b + 2) // 2, xor // 2) + 1",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 2) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1",
      "mutated_line": "y = 2 * F((a - 1) // 2, (b + 0) // 2, xor // 2) + 1",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 0) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1",
      "mutated_line": "y = 2 * F((a - 1) // 2, (b + 0) // 2, xor // 2) + 1",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + 0) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "y = 2 * F((a - 1) // 2, (b + 1) // 2, xor // 2) + 1",
      "mutated_line": "y = 2 * F((a - 1) // 2, (b + -1) // 2, xor // 2) + 1",
      "code": "from functools import lru_cache\n\ndef calculate_minimum_stones_to_move(N, A):\n    INF = 10 ** 13\n\n    @lru_cache(None)\n    def F(a, b, xor):\n        if a & 1 ^ b & 1 != xor & 1:\n            return INF\n        if xor == 0:\n            return INF if a < b else (a - b) // 2\n        x = 2 * F(a // 2, b // 2, xor // 2)\n        y = 2 * F((a - 1) // 2, (b + -1) // 2, xor // 2) + 1\n        x = min(x, y)\n        if x >= INF:\n            x = INF\n        return x\n    (a, b) = (A[0], A[1])\n    xor = 0\n    for x in A[2:]:\n        xor ^= x\n    x = F(a, b, xor)\n    if x >= a:\n        return -1\n    return x"
    }
  ]
}