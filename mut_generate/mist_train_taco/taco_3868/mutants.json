{
  "task_id": "taco_3868",
  "entry_point": "minimum_moves_to_reach_target",
  "mutant_count": 245,
  "mutants": [
    {
      "operator": "UOI",
      "lineno": 39,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return +1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dists = {(0, 0, True): 0}",
      "mutated_line": "dists = {(0, 0, True): 1}",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 1}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dists = {(0, 0, True): 0}",
      "mutated_line": "dists = {(0, 0, True): -1}",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): -1}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dists = {(0, 0, True): 0}",
      "mutated_line": "dists = {(0, 0, True): 1}",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 1}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if (i, j) == (m - 1, n - 2):",
      "mutated_line": "if (i, j) != (m - 1, n - 2):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) != (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -2"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return --1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dists = {(0, 0, True): 0}",
      "mutated_line": "dists = {(1, 0, True): 0}",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(1, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dists = {(0, 0, True): 0}",
      "mutated_line": "dists = {(-1, 0, True): 0}",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(-1, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dists = {(0, 0, True): 0}",
      "mutated_line": "dists = {(1, 0, True): 0}",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(1, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dists = {(0, 0, True): 0}",
      "mutated_line": "dists = {(0, 1, True): 0}",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 1, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dists = {(0, 0, True): 0}",
      "mutated_line": "dists = {(0, -1, True): 0}",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, -1, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dists = {(0, 0, True): 0}",
      "mutated_line": "dists = {(0, 1, True): 0}",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 1, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dists = {(0, 0, True): 0}",
      "mutated_line": "dists = {(0, 0, False): 0}",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, False): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "LCR",
      "lineno": 15,
      "original_line": "if j + 2 < n and (not grid[i][j + 2]):",
      "mutated_line": "if j + 2 < n or not grid[i][j + 2]:",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n or not grid[i][j + 2]:\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "LCR",
      "lineno": 19,
      "original_line": "if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):",
      "mutated_line": "if i + 1 < m or not grid[i + 1][j] or (not grid[i + 1][j + 1]):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m or not grid[i + 1][j] or (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "LCR",
      "lineno": 27,
      "original_line": "if i + 2 < m and (not grid[i + 2][j]):",
      "mutated_line": "if i + 2 < m or not grid[i + 2][j]:",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m or not grid[i + 2][j]:\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "LCR",
      "lineno": 31,
      "original_line": "if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):",
      "mutated_line": "if j + 1 < n or not grid[i][j + 1] or (not grid[i + 1][j + 1]):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n or not grid[i][j + 1] or (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "(m, n) = (len(grid), len(grid[0]))",
      "mutated_line": "(m, n) = (len(grid), len(grid[1]))",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[1]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "(m, n) = (len(grid), len(grid[0]))",
      "mutated_line": "(m, n) = (len(grid), len(grid[-1]))",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[-1]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "(m, n) = (len(grid), len(grid[0]))",
      "mutated_line": "(m, n) = (len(grid), len(grid[1]))",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[1]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "queue = deque([(0, 0, True)])",
      "mutated_line": "queue = deque([(1, 0, True)])",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(1, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "queue = deque([(0, 0, True)])",
      "mutated_line": "queue = deque([(-1, 0, True)])",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(-1, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "queue = deque([(0, 0, True)])",
      "mutated_line": "queue = deque([(1, 0, True)])",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(1, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "queue = deque([(0, 0, True)])",
      "mutated_line": "queue = deque([(0, 1, True)])",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 1, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "queue = deque([(0, 0, True)])",
      "mutated_line": "queue = deque([(0, -1, True)])",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, -1, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "queue = deque([(0, 0, True)])",
      "mutated_line": "queue = deque([(0, 1, True)])",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 1, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "queue = deque([(0, 0, True)])",
      "mutated_line": "queue = deque([(0, 0, False)])",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, False)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "if (i, j) == (m - 1, n - 2):",
      "mutated_line": "if (i, j) == (m + 1, n - 2):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m + 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "if (i, j) == (m - 1, n - 2):",
      "mutated_line": "if (i, j) == (m * 1, n - 2):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m * 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "if (i, j) == (m - 1, n - 2):",
      "mutated_line": "if (i, j) == (m - 1, n + 2):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n + 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "if (i, j) == (m - 1, n - 2):",
      "mutated_line": "if (i, j) == (m - 1, n * 2):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n * 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if j + 2 < n and (not grid[i][j + 2]):",
      "mutated_line": "if j + 2 <= n and (not grid[i][j + 2]):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 <= n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if j + 2 < n and (not grid[i][j + 2]):",
      "mutated_line": "if j + 2 >= n and (not grid[i][j + 2]):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 >= n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if j + 2 < n and (not grid[i][j + 2]):",
      "mutated_line": "if j + 2 != n and (not grid[i][j + 2]):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 != n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if (i, j + 1, hor) not in dists:",
      "mutated_line": "if (i, j + 1, hor) in dists:",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):",
      "mutated_line": "if i + 1 <= m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 <= m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):",
      "mutated_line": "if i + 1 >= m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 >= m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):",
      "mutated_line": "if i + 1 != m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 != m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if (i + 1, j, hor) not in dists:",
      "mutated_line": "if (i + 1, j, hor) in dists:",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if (i, j, not hor) not in dists:",
      "mutated_line": "if (i, j, not hor) in dists:",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if i + 2 < m and (not grid[i + 2][j]):",
      "mutated_line": "if i + 2 <= m and (not grid[i + 2][j]):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 <= m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if i + 2 < m and (not grid[i + 2][j]):",
      "mutated_line": "if i + 2 >= m and (not grid[i + 2][j]):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 >= m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if i + 2 < m and (not grid[i + 2][j]):",
      "mutated_line": "if i + 2 != m and (not grid[i + 2][j]):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 != m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if (i + 1, j, hor) not in dists:",
      "mutated_line": "if (i + 1, j, hor) in dists:",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):",
      "mutated_line": "if j + 1 <= n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 <= n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):",
      "mutated_line": "if j + 1 >= n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 >= n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):",
      "mutated_line": "if j + 1 != n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 != n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if (i, j + 1, hor) not in dists:",
      "mutated_line": "if (i, j + 1, hor) in dists:",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if (i, j, not hor) not in dists:",
      "mutated_line": "if (i, j, not hor) in dists:",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if (i, j) == (m - 1, n - 2):",
      "mutated_line": "if (i, j) == (m - 2, n - 2):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 2, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if (i, j) == (m - 1, n - 2):",
      "mutated_line": "if (i, j) == (m - 0, n - 2):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 0, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if (i, j) == (m - 1, n - 2):",
      "mutated_line": "if (i, j) == (m - 0, n - 2):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 0, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if (i, j) == (m - 1, n - 2):",
      "mutated_line": "if (i, j) == (m - -1, n - 2):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - -1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if (i, j) == (m - 1, n - 2):",
      "mutated_line": "if (i, j) == (m - 1, n - 3):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 3):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if (i, j) == (m - 1, n - 2):",
      "mutated_line": "if (i, j) == (m - 1, n - 1):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 1):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if (i, j) == (m - 1, n - 2):",
      "mutated_line": "if (i, j) == (m - 1, n - 0):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 0):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if (i, j) == (m - 1, n - 2):",
      "mutated_line": "if (i, j) == (m - 1, n - 1):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 1):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if (i, j) == (m - 1, n - 2):",
      "mutated_line": "if (i, j) == (m - 1, n - -2):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - -2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "if j + 2 < n and (not grid[i][j + 2]):",
      "mutated_line": "if j - 2 < n and (not grid[i][j + 2]):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j - 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "if j + 2 < n and (not grid[i][j + 2]):",
      "mutated_line": "if j * 2 < n and (not grid[i][j + 2]):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j * 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "dists[i, j + 1, hor] = dists[i, j, hor] + 1",
      "mutated_line": "dists[i, j + 1, hor] = dists[i, j, hor] - 1",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] - 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "dists[i, j + 1, hor] = dists[i, j, hor] + 1",
      "mutated_line": "dists[i, j + 1, hor] = dists[i, j, hor] * 1",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] * 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):",
      "mutated_line": "if i - 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i - 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):",
      "mutated_line": "if i * 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i * 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "dists[i + 1, j, hor] = dists[i, j, hor] + 1",
      "mutated_line": "dists[i + 1, j, hor] = dists[i, j, hor] - 1",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] - 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "dists[i + 1, j, hor] = dists[i, j, hor] + 1",
      "mutated_line": "dists[i + 1, j, hor] = dists[i, j, hor] * 1",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] * 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "dists[i, j, not hor] = dists[i, j, hor] + 1",
      "mutated_line": "dists[i, j, not hor] = dists[i, j, hor] - 1",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] - 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "dists[i, j, not hor] = dists[i, j, hor] + 1",
      "mutated_line": "dists[i, j, not hor] = dists[i, j, hor] * 1",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] * 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "if i + 2 < m and (not grid[i + 2][j]):",
      "mutated_line": "if i - 2 < m and (not grid[i + 2][j]):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i - 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "if i + 2 < m and (not grid[i + 2][j]):",
      "mutated_line": "if i * 2 < m and (not grid[i + 2][j]):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i * 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "dists[i + 1, j, hor] = dists[i, j, hor] + 1",
      "mutated_line": "dists[i + 1, j, hor] = dists[i, j, hor] - 1",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] - 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "dists[i + 1, j, hor] = dists[i, j, hor] + 1",
      "mutated_line": "dists[i + 1, j, hor] = dists[i, j, hor] * 1",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] * 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):",
      "mutated_line": "if j - 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j - 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):",
      "mutated_line": "if j * 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j * 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "dists[i, j + 1, hor] = dists[i, j, hor] + 1",
      "mutated_line": "dists[i, j + 1, hor] = dists[i, j, hor] - 1",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] - 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "dists[i, j + 1, hor] = dists[i, j, hor] + 1",
      "mutated_line": "dists[i, j + 1, hor] = dists[i, j, hor] * 1",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] * 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "dists[i, j, not hor] = dists[i, j, hor] + 1",
      "mutated_line": "dists[i, j, not hor] = dists[i, j, hor] - 1",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] - 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "dists[i, j, not hor] = dists[i, j, hor] + 1",
      "mutated_line": "dists[i, j, not hor] = dists[i, j, hor] * 1",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] * 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if j + 2 < n and (not grid[i][j + 2]):",
      "mutated_line": "if j + 3 < n and (not grid[i][j + 2]):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 3 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if j + 2 < n and (not grid[i][j + 2]):",
      "mutated_line": "if j + 1 < n and (not grid[i][j + 2]):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 1 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if j + 2 < n and (not grid[i][j + 2]):",
      "mutated_line": "if j + 0 < n and (not grid[i][j + 2]):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 0 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if j + 2 < n and (not grid[i][j + 2]):",
      "mutated_line": "if j + 1 < n and (not grid[i][j + 2]):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 1 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if j + 2 < n and (not grid[i][j + 2]):",
      "mutated_line": "if j + -2 < n and (not grid[i][j + 2]):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + -2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "if j + 2 < n and (not grid[i][j + 2]):",
      "mutated_line": "if j + 2 < n and (not grid[i][j - 2]):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j - 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "if j + 2 < n and (not grid[i][j + 2]):",
      "mutated_line": "if j + 2 < n and (not grid[i][j * 2]):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j * 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if (i, j + 1, hor) not in dists:",
      "mutated_line": "if (i, j - 1, hor) not in dists:",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j - 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if (i, j + 1, hor) not in dists:",
      "mutated_line": "if (i, j * 1, hor) not in dists:",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j * 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dists[i, j + 1, hor] = dists[i, j, hor] + 1",
      "mutated_line": "dists[i, j + 1, hor] = dists[i, j, hor] + 2",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 2\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dists[i, j + 1, hor] = dists[i, j, hor] + 1",
      "mutated_line": "dists[i, j + 1, hor] = dists[i, j, hor] + 0",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 0\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dists[i, j + 1, hor] = dists[i, j, hor] + 1",
      "mutated_line": "dists[i, j + 1, hor] = dists[i, j, hor] + 0",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 0\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dists[i, j + 1, hor] = dists[i, j, hor] + 1",
      "mutated_line": "dists[i, j + 1, hor] = dists[i, j, hor] + -1",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + -1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):",
      "mutated_line": "if i + 2 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 2 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):",
      "mutated_line": "if i + 0 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 0 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):",
      "mutated_line": "if i + 0 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 0 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):",
      "mutated_line": "if i + -1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + -1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):",
      "mutated_line": "if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j - 1]):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j - 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):",
      "mutated_line": "if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j * 1]):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j * 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "if (i + 1, j, hor) not in dists:",
      "mutated_line": "if (i - 1, j, hor) not in dists:",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i - 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "if (i + 1, j, hor) not in dists:",
      "mutated_line": "if (i * 1, j, hor) not in dists:",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i * 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "dists[i + 1, j, hor] = dists[i, j, hor] + 1",
      "mutated_line": "dists[i + 1, j, hor] = dists[i, j, hor] + 2",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 2\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "dists[i + 1, j, hor] = dists[i, j, hor] + 1",
      "mutated_line": "dists[i + 1, j, hor] = dists[i, j, hor] + 0",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 0\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "dists[i + 1, j, hor] = dists[i, j, hor] + 1",
      "mutated_line": "dists[i + 1, j, hor] = dists[i, j, hor] + 0",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 0\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "dists[i + 1, j, hor] = dists[i, j, hor] + 1",
      "mutated_line": "dists[i + 1, j, hor] = dists[i, j, hor] + -1",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + -1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dists[i, j, not hor] = dists[i, j, hor] + 1",
      "mutated_line": "dists[i, j, not hor] = dists[i, j, hor] + 2",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 2\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dists[i, j, not hor] = dists[i, j, hor] + 1",
      "mutated_line": "dists[i, j, not hor] = dists[i, j, hor] + 0",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 0\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dists[i, j, not hor] = dists[i, j, hor] + 1",
      "mutated_line": "dists[i, j, not hor] = dists[i, j, hor] + 0",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 0\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dists[i, j, not hor] = dists[i, j, hor] + 1",
      "mutated_line": "dists[i, j, not hor] = dists[i, j, hor] + -1",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + -1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if i + 2 < m and (not grid[i + 2][j]):",
      "mutated_line": "if i + 3 < m and (not grid[i + 2][j]):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 3 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if i + 2 < m and (not grid[i + 2][j]):",
      "mutated_line": "if i + 1 < m and (not grid[i + 2][j]):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 1 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if i + 2 < m and (not grid[i + 2][j]):",
      "mutated_line": "if i + 0 < m and (not grid[i + 2][j]):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 0 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if i + 2 < m and (not grid[i + 2][j]):",
      "mutated_line": "if i + 1 < m and (not grid[i + 2][j]):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 1 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if i + 2 < m and (not grid[i + 2][j]):",
      "mutated_line": "if i + -2 < m and (not grid[i + 2][j]):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + -2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if (i + 1, j, hor) not in dists:",
      "mutated_line": "if (i - 1, j, hor) not in dists:",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i - 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if (i + 1, j, hor) not in dists:",
      "mutated_line": "if (i * 1, j, hor) not in dists:",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i * 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dists[i + 1, j, hor] = dists[i, j, hor] + 1",
      "mutated_line": "dists[i + 1, j, hor] = dists[i, j, hor] + 2",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 2\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dists[i + 1, j, hor] = dists[i, j, hor] + 1",
      "mutated_line": "dists[i + 1, j, hor] = dists[i, j, hor] + 0",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 0\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dists[i + 1, j, hor] = dists[i, j, hor] + 1",
      "mutated_line": "dists[i + 1, j, hor] = dists[i, j, hor] + 0",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 0\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dists[i + 1, j, hor] = dists[i, j, hor] + 1",
      "mutated_line": "dists[i + 1, j, hor] = dists[i, j, hor] + -1",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + -1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):",
      "mutated_line": "if j + 2 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 2 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):",
      "mutated_line": "if j + 0 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 0 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):",
      "mutated_line": "if j + 0 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 0 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):",
      "mutated_line": "if j + -1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + -1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):",
      "mutated_line": "if j + 1 < n and (not grid[i][j - 1]) and (not grid[i + 1][j + 1]):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j - 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):",
      "mutated_line": "if j + 1 < n and (not grid[i][j * 1]) and (not grid[i + 1][j + 1]):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j * 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):",
      "mutated_line": "if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j - 1]):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j - 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):",
      "mutated_line": "if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j * 1]):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j * 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "if (i, j + 1, hor) not in dists:",
      "mutated_line": "if (i, j - 1, hor) not in dists:",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j - 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "if (i, j + 1, hor) not in dists:",
      "mutated_line": "if (i, j * 1, hor) not in dists:",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j * 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "dists[i, j + 1, hor] = dists[i, j, hor] + 1",
      "mutated_line": "dists[i, j + 1, hor] = dists[i, j, hor] + 2",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 2\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "dists[i, j + 1, hor] = dists[i, j, hor] + 1",
      "mutated_line": "dists[i, j + 1, hor] = dists[i, j, hor] + 0",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 0\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "dists[i, j + 1, hor] = dists[i, j, hor] + 1",
      "mutated_line": "dists[i, j + 1, hor] = dists[i, j, hor] + 0",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 0\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "dists[i, j + 1, hor] = dists[i, j, hor] + 1",
      "mutated_line": "dists[i, j + 1, hor] = dists[i, j, hor] + -1",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + -1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "dists[i, j, not hor] = dists[i, j, hor] + 1",
      "mutated_line": "dists[i, j, not hor] = dists[i, j, hor] + 2",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 2\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "dists[i, j, not hor] = dists[i, j, hor] + 1",
      "mutated_line": "dists[i, j, not hor] = dists[i, j, hor] + 0",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 0\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "dists[i, j, not hor] = dists[i, j, hor] + 1",
      "mutated_line": "dists[i, j, not hor] = dists[i, j, hor] + 0",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 0\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "dists[i, j, not hor] = dists[i, j, hor] + 1",
      "mutated_line": "dists[i, j, not hor] = dists[i, j, hor] + -1",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + -1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if j + 2 < n and (not grid[i][j + 2]):",
      "mutated_line": "if j + 2 < n and (not grid[i][j + 3]):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 3]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if j + 2 < n and (not grid[i][j + 2]):",
      "mutated_line": "if j + 2 < n and (not grid[i][j + 1]):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if j + 2 < n and (not grid[i][j + 2]):",
      "mutated_line": "if j + 2 < n and (not grid[i][j + 0]):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 0]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if j + 2 < n and (not grid[i][j + 2]):",
      "mutated_line": "if j + 2 < n and (not grid[i][j + 1]):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if j + 2 < n and (not grid[i][j + 2]):",
      "mutated_line": "if j + 2 < n and (not grid[i][j + -2]):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + -2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (i, j + 1, hor) not in dists:",
      "mutated_line": "if (i, j + 2, hor) not in dists:",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 2, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (i, j + 1, hor) not in dists:",
      "mutated_line": "if (i, j + 0, hor) not in dists:",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 0, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (i, j + 1, hor) not in dists:",
      "mutated_line": "if (i, j + 0, hor) not in dists:",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 0, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (i, j + 1, hor) not in dists:",
      "mutated_line": "if (i, j + -1, hor) not in dists:",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + -1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "queue.append((i, j + 1, hor))",
      "mutated_line": "queue.append((i, j - 1, hor))",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j - 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "queue.append((i, j + 1, hor))",
      "mutated_line": "queue.append((i, j * 1, hor))",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j * 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "dists[i, j + 1, hor] = dists[i, j, hor] + 1",
      "mutated_line": "dists[i, j - 1, hor] = dists[i, j, hor] + 1",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j - 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "dists[i, j + 1, hor] = dists[i, j, hor] + 1",
      "mutated_line": "dists[i, j * 1, hor] = dists[i, j, hor] + 1",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j * 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):",
      "mutated_line": "if i + 1 < m and (not grid[i - 1][j]) and (not grid[i + 1][j + 1]):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i - 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):",
      "mutated_line": "if i + 1 < m and (not grid[i * 1][j]) and (not grid[i + 1][j + 1]):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i * 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):",
      "mutated_line": "if i + 1 < m and (not grid[i + 1][j]) and (not grid[i - 1][j + 1]):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i - 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):",
      "mutated_line": "if i + 1 < m and (not grid[i + 1][j]) and (not grid[i * 1][j + 1]):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i * 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):",
      "mutated_line": "if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 2]):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 2]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):",
      "mutated_line": "if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 0]):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 0]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):",
      "mutated_line": "if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 0]):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 0]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):",
      "mutated_line": "if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + -1]):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + -1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if (i + 1, j, hor) not in dists:",
      "mutated_line": "if (i + 2, j, hor) not in dists:",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 2, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if (i + 1, j, hor) not in dists:",
      "mutated_line": "if (i + 0, j, hor) not in dists:",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 0, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if (i + 1, j, hor) not in dists:",
      "mutated_line": "if (i + 0, j, hor) not in dists:",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 0, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if (i + 1, j, hor) not in dists:",
      "mutated_line": "if (i + -1, j, hor) not in dists:",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + -1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "queue.append((i + 1, j, hor))",
      "mutated_line": "queue.append((i - 1, j, hor))",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i - 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "queue.append((i + 1, j, hor))",
      "mutated_line": "queue.append((i * 1, j, hor))",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i * 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "dists[i + 1, j, hor] = dists[i, j, hor] + 1",
      "mutated_line": "dists[i - 1, j, hor] = dists[i, j, hor] + 1",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i - 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "dists[i + 1, j, hor] = dists[i, j, hor] + 1",
      "mutated_line": "dists[i * 1, j, hor] = dists[i, j, hor] + 1",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i * 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "if i + 2 < m and (not grid[i + 2][j]):",
      "mutated_line": "if i + 2 < m and (not grid[i - 2][j]):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i - 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "if i + 2 < m and (not grid[i + 2][j]):",
      "mutated_line": "if i + 2 < m and (not grid[i * 2][j]):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i * 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if (i + 1, j, hor) not in dists:",
      "mutated_line": "if (i + 2, j, hor) not in dists:",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 2, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if (i + 1, j, hor) not in dists:",
      "mutated_line": "if (i + 0, j, hor) not in dists:",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 0, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if (i + 1, j, hor) not in dists:",
      "mutated_line": "if (i + 0, j, hor) not in dists:",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 0, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if (i + 1, j, hor) not in dists:",
      "mutated_line": "if (i + -1, j, hor) not in dists:",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + -1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "queue.append((i + 1, j, hor))",
      "mutated_line": "queue.append((i - 1, j, hor))",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i - 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "queue.append((i + 1, j, hor))",
      "mutated_line": "queue.append((i * 1, j, hor))",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i * 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "dists[i + 1, j, hor] = dists[i, j, hor] + 1",
      "mutated_line": "dists[i - 1, j, hor] = dists[i, j, hor] + 1",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i - 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "dists[i + 1, j, hor] = dists[i, j, hor] + 1",
      "mutated_line": "dists[i * 1, j, hor] = dists[i, j, hor] + 1",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i * 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):",
      "mutated_line": "if j + 1 < n and (not grid[i][j + 2]) and (not grid[i + 1][j + 1]):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 2]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):",
      "mutated_line": "if j + 1 < n and (not grid[i][j + 0]) and (not grid[i + 1][j + 1]):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 0]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):",
      "mutated_line": "if j + 1 < n and (not grid[i][j + 0]) and (not grid[i + 1][j + 1]):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 0]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):",
      "mutated_line": "if j + 1 < n and (not grid[i][j + -1]) and (not grid[i + 1][j + 1]):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + -1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):",
      "mutated_line": "if j + 1 < n and (not grid[i][j + 1]) and (not grid[i - 1][j + 1]):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i - 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):",
      "mutated_line": "if j + 1 < n and (not grid[i][j + 1]) and (not grid[i * 1][j + 1]):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i * 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):",
      "mutated_line": "if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 2]):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):",
      "mutated_line": "if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 0]):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 0]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):",
      "mutated_line": "if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 0]):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 0]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):",
      "mutated_line": "if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + -1]):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + -1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if (i, j + 1, hor) not in dists:",
      "mutated_line": "if (i, j + 2, hor) not in dists:",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 2, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if (i, j + 1, hor) not in dists:",
      "mutated_line": "if (i, j + 0, hor) not in dists:",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 0, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if (i, j + 1, hor) not in dists:",
      "mutated_line": "if (i, j + 0, hor) not in dists:",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 0, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if (i, j + 1, hor) not in dists:",
      "mutated_line": "if (i, j + -1, hor) not in dists:",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + -1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "queue.append((i, j + 1, hor))",
      "mutated_line": "queue.append((i, j - 1, hor))",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j - 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "queue.append((i, j + 1, hor))",
      "mutated_line": "queue.append((i, j * 1, hor))",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j * 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "dists[i, j + 1, hor] = dists[i, j, hor] + 1",
      "mutated_line": "dists[i, j - 1, hor] = dists[i, j, hor] + 1",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j - 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "dists[i, j + 1, hor] = dists[i, j, hor] + 1",
      "mutated_line": "dists[i, j * 1, hor] = dists[i, j, hor] + 1",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j * 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "queue.append((i, j + 1, hor))",
      "mutated_line": "queue.append((i, j + 2, hor))",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 2, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "queue.append((i, j + 1, hor))",
      "mutated_line": "queue.append((i, j + 0, hor))",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 0, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "queue.append((i, j + 1, hor))",
      "mutated_line": "queue.append((i, j + 0, hor))",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 0, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "queue.append((i, j + 1, hor))",
      "mutated_line": "queue.append((i, j + -1, hor))",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + -1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dists[i, j + 1, hor] = dists[i, j, hor] + 1",
      "mutated_line": "dists[i, j + 2, hor] = dists[i, j, hor] + 1",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 2, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dists[i, j + 1, hor] = dists[i, j, hor] + 1",
      "mutated_line": "dists[i, j + 0, hor] = dists[i, j, hor] + 1",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 0, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dists[i, j + 1, hor] = dists[i, j, hor] + 1",
      "mutated_line": "dists[i, j + 0, hor] = dists[i, j, hor] + 1",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 0, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dists[i, j + 1, hor] = dists[i, j, hor] + 1",
      "mutated_line": "dists[i, j + -1, hor] = dists[i, j, hor] + 1",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + -1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):",
      "mutated_line": "if i + 1 < m and (not grid[i + 2][j]) and (not grid[i + 1][j + 1]):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 2][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):",
      "mutated_line": "if i + 1 < m and (not grid[i + 0][j]) and (not grid[i + 1][j + 1]):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 0][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):",
      "mutated_line": "if i + 1 < m and (not grid[i + 0][j]) and (not grid[i + 1][j + 1]):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 0][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):",
      "mutated_line": "if i + 1 < m and (not grid[i + -1][j]) and (not grid[i + 1][j + 1]):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + -1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):",
      "mutated_line": "if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 2][j + 1]):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 2][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):",
      "mutated_line": "if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 0][j + 1]):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 0][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):",
      "mutated_line": "if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 0][j + 1]):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 0][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):",
      "mutated_line": "if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + -1][j + 1]):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + -1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "queue.append((i + 1, j, hor))",
      "mutated_line": "queue.append((i + 2, j, hor))",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 2, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "queue.append((i + 1, j, hor))",
      "mutated_line": "queue.append((i + 0, j, hor))",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 0, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "queue.append((i + 1, j, hor))",
      "mutated_line": "queue.append((i + 0, j, hor))",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 0, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "queue.append((i + 1, j, hor))",
      "mutated_line": "queue.append((i + -1, j, hor))",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + -1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "dists[i + 1, j, hor] = dists[i, j, hor] + 1",
      "mutated_line": "dists[i + 2, j, hor] = dists[i, j, hor] + 1",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 2, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "dists[i + 1, j, hor] = dists[i, j, hor] + 1",
      "mutated_line": "dists[i + 0, j, hor] = dists[i, j, hor] + 1",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 0, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "dists[i + 1, j, hor] = dists[i, j, hor] + 1",
      "mutated_line": "dists[i + 0, j, hor] = dists[i, j, hor] + 1",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 0, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "dists[i + 1, j, hor] = dists[i, j, hor] + 1",
      "mutated_line": "dists[i + -1, j, hor] = dists[i, j, hor] + 1",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + -1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if i + 2 < m and (not grid[i + 2][j]):",
      "mutated_line": "if i + 2 < m and (not grid[i + 3][j]):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 3][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if i + 2 < m and (not grid[i + 2][j]):",
      "mutated_line": "if i + 2 < m and (not grid[i + 1][j]):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 1][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if i + 2 < m and (not grid[i + 2][j]):",
      "mutated_line": "if i + 2 < m and (not grid[i + 0][j]):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 0][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if i + 2 < m and (not grid[i + 2][j]):",
      "mutated_line": "if i + 2 < m and (not grid[i + 1][j]):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 1][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if i + 2 < m and (not grid[i + 2][j]):",
      "mutated_line": "if i + 2 < m and (not grid[i + -2][j]):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + -2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "queue.append((i + 1, j, hor))",
      "mutated_line": "queue.append((i + 2, j, hor))",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 2, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "queue.append((i + 1, j, hor))",
      "mutated_line": "queue.append((i + 0, j, hor))",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 0, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "queue.append((i + 1, j, hor))",
      "mutated_line": "queue.append((i + 0, j, hor))",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 0, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "queue.append((i + 1, j, hor))",
      "mutated_line": "queue.append((i + -1, j, hor))",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + -1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dists[i + 1, j, hor] = dists[i, j, hor] + 1",
      "mutated_line": "dists[i + 2, j, hor] = dists[i, j, hor] + 1",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 2, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dists[i + 1, j, hor] = dists[i, j, hor] + 1",
      "mutated_line": "dists[i + 0, j, hor] = dists[i, j, hor] + 1",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 0, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dists[i + 1, j, hor] = dists[i, j, hor] + 1",
      "mutated_line": "dists[i + 0, j, hor] = dists[i, j, hor] + 1",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 0, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dists[i + 1, j, hor] = dists[i, j, hor] + 1",
      "mutated_line": "dists[i + -1, j, hor] = dists[i, j, hor] + 1",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + -1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):",
      "mutated_line": "if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 2][j + 1]):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 2][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):",
      "mutated_line": "if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 0][j + 1]):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 0][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):",
      "mutated_line": "if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 0][j + 1]):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 0][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):",
      "mutated_line": "if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + -1][j + 1]):",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + -1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "queue.append((i, j + 1, hor))",
      "mutated_line": "queue.append((i, j + 2, hor))",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 2, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "queue.append((i, j + 1, hor))",
      "mutated_line": "queue.append((i, j + 0, hor))",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 0, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "queue.append((i, j + 1, hor))",
      "mutated_line": "queue.append((i, j + 0, hor))",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 0, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "queue.append((i, j + 1, hor))",
      "mutated_line": "queue.append((i, j + -1, hor))",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + -1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "dists[i, j + 1, hor] = dists[i, j, hor] + 1",
      "mutated_line": "dists[i, j + 2, hor] = dists[i, j, hor] + 1",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 2, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "dists[i, j + 1, hor] = dists[i, j, hor] + 1",
      "mutated_line": "dists[i, j + 0, hor] = dists[i, j, hor] + 1",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 0, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "dists[i, j + 1, hor] = dists[i, j, hor] + 1",
      "mutated_line": "dists[i, j + 0, hor] = dists[i, j, hor] + 1",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 0, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "dists[i, j + 1, hor] = dists[i, j, hor] + 1",
      "mutated_line": "dists[i, j + -1, hor] = dists[i, j, hor] + 1",
      "code": "from collections import deque\nfrom typing import List\n\ndef minimum_moves_to_reach_target(grid: List[List[int]]) -> int:\n    (m, n) = (len(grid), len(grid[0]))\n    queue = deque([(0, 0, True)])\n    dists = {(0, 0, True): 0}\n    while queue:\n        (i, j, hor) = queue.popleft()\n        if (i, j) == (m - 1, n - 2):\n            return dists[i, j, hor]\n        if hor:\n            if j + 2 < n and (not grid[i][j + 2]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + 1, hor] = dists[i, j, hor] + 1\n            if i + 1 < m and (not grid[i + 1][j]) and (not grid[i + 1][j + 1]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n        else:\n            if i + 2 < m and (not grid[i + 2][j]):\n                if (i + 1, j, hor) not in dists:\n                    queue.append((i + 1, j, hor))\n                    dists[i + 1, j, hor] = dists[i, j, hor] + 1\n            if j + 1 < n and (not grid[i][j + 1]) and (not grid[i + 1][j + 1]):\n                if (i, j + 1, hor) not in dists:\n                    queue.append((i, j + 1, hor))\n                    dists[i, j + -1, hor] = dists[i, j, hor] + 1\n                if (i, j, not hor) not in dists:\n                    queue.append((i, j, not hor))\n                    dists[i, j, not hor] = dists[i, j, hor] + 1\n    return -1"
    }
  ]
}