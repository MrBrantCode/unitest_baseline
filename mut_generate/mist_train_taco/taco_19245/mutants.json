{
  "task_id": "taco_19245",
  "entry_point": "getAffectedDiameter",
  "mutant_count": 61,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "affection = [False] * graph.node_cnt",
      "mutated_line": "affection = [False] / graph.node_cnt",
      "code": "import collections\n\nclass Graph:\n\n    def __init__(self, n, directed=False):\n        self.node_cnt = n\n        self.__directed = directed\n        self.__adjList = [[] for _ in range(n)]\n\n    def addEdge(self, u, v):\n        self.__adjList[u].append(v)\n        if not self.__directed:\n            self.__adjList[v].append(u)\n\n    def getDistances(self, start, end=None):\n        assert 0 <= start < self.node_cnt\n        dist = [-1] * self.node_cnt\n        q = collections.deque()\n        dist[start] = 0\n        q.append(start)\n        while q:\n            z = q.popleft()\n            if end == z:\n                break\n            for t in self.__adjList[z]:\n                if dist[t] == -1:\n                    dist[t] = dist[z] + 1\n                    q.append(t)\n                    if t == end:\n                        break\n        return dist\n\ndef getAffectedDiameter(graph, affected):\n    affection = [False] / graph.node_cnt\n    for x in affected:\n        affection[x] = True\n    dist0 = graph.getDistances(affected[0])\n    affect_1 = max(range(graph.node_cnt), key=lambda i: dist0[i] if affection[i] else -1)\n    dist1 = graph.getDistances(affect_1)\n    affect_2 = max(range(graph.node_cnt), key=lambda i: dist1[i] if affection[i] else -1)\n    return (affect_1, affect_2)\n\ndef find_possible_book_locations(n, m, d, affected, paths):\n    g = Graph(n)\n    for (a, b) in paths:\n        g.addEdge(a, b)\n    (p1, p2) = getAffectedDiameter(g, affected)\n    (d1, d2) = (g.getDistances(p1), g.getDistances(p2))\n    cnt = sum((1 for i in range(n) if d1[i] <= d and d2[i] <= d))\n    return cnt"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "affection = [False] * graph.node_cnt",
      "mutated_line": "affection = [False] + graph.node_cnt",
      "code": "import collections\n\nclass Graph:\n\n    def __init__(self, n, directed=False):\n        self.node_cnt = n\n        self.__directed = directed\n        self.__adjList = [[] for _ in range(n)]\n\n    def addEdge(self, u, v):\n        self.__adjList[u].append(v)\n        if not self.__directed:\n            self.__adjList[v].append(u)\n\n    def getDistances(self, start, end=None):\n        assert 0 <= start < self.node_cnt\n        dist = [-1] * self.node_cnt\n        q = collections.deque()\n        dist[start] = 0\n        q.append(start)\n        while q:\n            z = q.popleft()\n            if end == z:\n                break\n            for t in self.__adjList[z]:\n                if dist[t] == -1:\n                    dist[t] = dist[z] + 1\n                    q.append(t)\n                    if t == end:\n                        break\n        return dist\n\ndef getAffectedDiameter(graph, affected):\n    affection = [False] + graph.node_cnt\n    for x in affected:\n        affection[x] = True\n    dist0 = graph.getDistances(affected[0])\n    affect_1 = max(range(graph.node_cnt), key=lambda i: dist0[i] if affection[i] else -1)\n    dist1 = graph.getDistances(affect_1)\n    affect_2 = max(range(graph.node_cnt), key=lambda i: dist1[i] if affection[i] else -1)\n    return (affect_1, affect_2)\n\ndef find_possible_book_locations(n, m, d, affected, paths):\n    g = Graph(n)\n    for (a, b) in paths:\n        g.addEdge(a, b)\n    (p1, p2) = getAffectedDiameter(g, affected)\n    (d1, d2) = (g.getDistances(p1), g.getDistances(p2))\n    cnt = sum((1 for i in range(n) if d1[i] <= d and d2[i] <= d))\n    return cnt"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "affection = [False] * graph.node_cnt",
      "mutated_line": "affection = [False] ** graph.node_cnt",
      "code": "import collections\n\nclass Graph:\n\n    def __init__(self, n, directed=False):\n        self.node_cnt = n\n        self.__directed = directed\n        self.__adjList = [[] for _ in range(n)]\n\n    def addEdge(self, u, v):\n        self.__adjList[u].append(v)\n        if not self.__directed:\n            self.__adjList[v].append(u)\n\n    def getDistances(self, start, end=None):\n        assert 0 <= start < self.node_cnt\n        dist = [-1] * self.node_cnt\n        q = collections.deque()\n        dist[start] = 0\n        q.append(start)\n        while q:\n            z = q.popleft()\n            if end == z:\n                break\n            for t in self.__adjList[z]:\n                if dist[t] == -1:\n                    dist[t] = dist[z] + 1\n                    q.append(t)\n                    if t == end:\n                        break\n        return dist\n\ndef getAffectedDiameter(graph, affected):\n    affection = [False] ** graph.node_cnt\n    for x in affected:\n        affection[x] = True\n    dist0 = graph.getDistances(affected[0])\n    affect_1 = max(range(graph.node_cnt), key=lambda i: dist0[i] if affection[i] else -1)\n    dist1 = graph.getDistances(affect_1)\n    affect_2 = max(range(graph.node_cnt), key=lambda i: dist1[i] if affection[i] else -1)\n    return (affect_1, affect_2)\n\ndef find_possible_book_locations(n, m, d, affected, paths):\n    g = Graph(n)\n    for (a, b) in paths:\n        g.addEdge(a, b)\n    (p1, p2) = getAffectedDiameter(g, affected)\n    (d1, d2) = (g.getDistances(p1), g.getDistances(p2))\n    cnt = sum((1 for i in range(n) if d1[i] <= d and d2[i] <= d))\n    return cnt"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "def __init__(self, n, directed=False):",
      "mutated_line": "",
      "code": "import collections\n\nclass Graph:\n\n    def __init__(self, n, directed=True):\n        self.node_cnt = n\n        self.__directed = directed\n        self.__adjList = [[] for _ in range(n)]\n\n    def addEdge(self, u, v):\n        self.__adjList[u].append(v)\n        if not self.__directed:\n            self.__adjList[v].append(u)\n\n    def getDistances(self, start, end=None):\n        assert 0 <= start < self.node_cnt\n        dist = [-1] * self.node_cnt\n        q = collections.deque()\n        dist[start] = 0\n        q.append(start)\n        while q:\n            z = q.popleft()\n            if end == z:\n                break\n            for t in self.__adjList[z]:\n                if dist[t] == -1:\n                    dist[t] = dist[z] + 1\n                    q.append(t)\n                    if t == end:\n                        break\n        return dist\n\ndef getAffectedDiameter(graph, affected):\n    affection = [False] * graph.node_cnt\n    for x in affected:\n        affection[x] = True\n    dist0 = graph.getDistances(affected[0])\n    affect_1 = max(range(graph.node_cnt), key=lambda i: dist0[i] if affection[i] else -1)\n    dist1 = graph.getDistances(affect_1)\n    affect_2 = max(range(graph.node_cnt), key=lambda i: dist1[i] if affection[i] else -1)\n    return (affect_1, affect_2)\n\ndef find_possible_book_locations(n, m, d, affected, paths):\n    g = Graph(n)\n    for (a, b) in paths:\n        g.addEdge(a, b)\n    (p1, p2) = getAffectedDiameter(g, affected)\n    (d1, d2) = (g.getDistances(p1), g.getDistances(p2))\n    cnt = sum((1 for i in range(n) if d1[i] <= d and d2[i] <= d))\n    return cnt"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "assert 0 <= start < self.node_cnt",
      "mutated_line": "assert 0 < start < self.node_cnt",
      "code": "import collections\n\nclass Graph:\n\n    def __init__(self, n, directed=False):\n        self.node_cnt = n\n        self.__directed = directed\n        self.__adjList = [[] for _ in range(n)]\n\n    def addEdge(self, u, v):\n        self.__adjList[u].append(v)\n        if not self.__directed:\n            self.__adjList[v].append(u)\n\n    def getDistances(self, start, end=None):\n        assert 0 < start < self.node_cnt\n        dist = [-1] * self.node_cnt\n        q = collections.deque()\n        dist[start] = 0\n        q.append(start)\n        while q:\n            z = q.popleft()\n            if end == z:\n                break\n            for t in self.__adjList[z]:\n                if dist[t] == -1:\n                    dist[t] = dist[z] + 1\n                    q.append(t)\n                    if t == end:\n                        break\n        return dist\n\ndef getAffectedDiameter(graph, affected):\n    affection = [False] * graph.node_cnt\n    for x in affected:\n        affection[x] = True\n    dist0 = graph.getDistances(affected[0])\n    affect_1 = max(range(graph.node_cnt), key=lambda i: dist0[i] if affection[i] else -1)\n    dist1 = graph.getDistances(affect_1)\n    affect_2 = max(range(graph.node_cnt), key=lambda i: dist1[i] if affection[i] else -1)\n    return (affect_1, affect_2)\n\ndef find_possible_book_locations(n, m, d, affected, paths):\n    g = Graph(n)\n    for (a, b) in paths:\n        g.addEdge(a, b)\n    (p1, p2) = getAffectedDiameter(g, affected)\n    (d1, d2) = (g.getDistances(p1), g.getDistances(p2))\n    cnt = sum((1 for i in range(n) if d1[i] <= d and d2[i] <= d))\n    return cnt"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "assert 0 <= start < self.node_cnt",
      "mutated_line": "assert 0 > start < self.node_cnt",
      "code": "import collections\n\nclass Graph:\n\n    def __init__(self, n, directed=False):\n        self.node_cnt = n\n        self.__directed = directed\n        self.__adjList = [[] for _ in range(n)]\n\n    def addEdge(self, u, v):\n        self.__adjList[u].append(v)\n        if not self.__directed:\n            self.__adjList[v].append(u)\n\n    def getDistances(self, start, end=None):\n        assert 0 > start < self.node_cnt\n        dist = [-1] * self.node_cnt\n        q = collections.deque()\n        dist[start] = 0\n        q.append(start)\n        while q:\n            z = q.popleft()\n            if end == z:\n                break\n            for t in self.__adjList[z]:\n                if dist[t] == -1:\n                    dist[t] = dist[z] + 1\n                    q.append(t)\n                    if t == end:\n                        break\n        return dist\n\ndef getAffectedDiameter(graph, affected):\n    affection = [False] * graph.node_cnt\n    for x in affected:\n        affection[x] = True\n    dist0 = graph.getDistances(affected[0])\n    affect_1 = max(range(graph.node_cnt), key=lambda i: dist0[i] if affection[i] else -1)\n    dist1 = graph.getDistances(affect_1)\n    affect_2 = max(range(graph.node_cnt), key=lambda i: dist1[i] if affection[i] else -1)\n    return (affect_1, affect_2)\n\ndef find_possible_book_locations(n, m, d, affected, paths):\n    g = Graph(n)\n    for (a, b) in paths:\n        g.addEdge(a, b)\n    (p1, p2) = getAffectedDiameter(g, affected)\n    (d1, d2) = (g.getDistances(p1), g.getDistances(p2))\n    cnt = sum((1 for i in range(n) if d1[i] <= d and d2[i] <= d))\n    return cnt"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "assert 0 <= start < self.node_cnt",
      "mutated_line": "assert 0 == start < self.node_cnt",
      "code": "import collections\n\nclass Graph:\n\n    def __init__(self, n, directed=False):\n        self.node_cnt = n\n        self.__directed = directed\n        self.__adjList = [[] for _ in range(n)]\n\n    def addEdge(self, u, v):\n        self.__adjList[u].append(v)\n        if not self.__directed:\n            self.__adjList[v].append(u)\n\n    def getDistances(self, start, end=None):\n        assert 0 == start < self.node_cnt\n        dist = [-1] * self.node_cnt\n        q = collections.deque()\n        dist[start] = 0\n        q.append(start)\n        while q:\n            z = q.popleft()\n            if end == z:\n                break\n            for t in self.__adjList[z]:\n                if dist[t] == -1:\n                    dist[t] = dist[z] + 1\n                    q.append(t)\n                    if t == end:\n                        break\n        return dist\n\ndef getAffectedDiameter(graph, affected):\n    affection = [False] * graph.node_cnt\n    for x in affected:\n        affection[x] = True\n    dist0 = graph.getDistances(affected[0])\n    affect_1 = max(range(graph.node_cnt), key=lambda i: dist0[i] if affection[i] else -1)\n    dist1 = graph.getDistances(affect_1)\n    affect_2 = max(range(graph.node_cnt), key=lambda i: dist1[i] if affection[i] else -1)\n    return (affect_1, affect_2)\n\ndef find_possible_book_locations(n, m, d, affected, paths):\n    g = Graph(n)\n    for (a, b) in paths:\n        g.addEdge(a, b)\n    (p1, p2) = getAffectedDiameter(g, affected)\n    (d1, d2) = (g.getDistances(p1), g.getDistances(p2))\n    cnt = sum((1 for i in range(n) if d1[i] <= d and d2[i] <= d))\n    return cnt"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "dist = [-1] * self.node_cnt",
      "mutated_line": "dist = [-1] / self.node_cnt",
      "code": "import collections\n\nclass Graph:\n\n    def __init__(self, n, directed=False):\n        self.node_cnt = n\n        self.__directed = directed\n        self.__adjList = [[] for _ in range(n)]\n\n    def addEdge(self, u, v):\n        self.__adjList[u].append(v)\n        if not self.__directed:\n            self.__adjList[v].append(u)\n\n    def getDistances(self, start, end=None):\n        assert 0 <= start < self.node_cnt\n        dist = [-1] / self.node_cnt\n        q = collections.deque()\n        dist[start] = 0\n        q.append(start)\n        while q:\n            z = q.popleft()\n            if end == z:\n                break\n            for t in self.__adjList[z]:\n                if dist[t] == -1:\n                    dist[t] = dist[z] + 1\n                    q.append(t)\n                    if t == end:\n                        break\n        return dist\n\ndef getAffectedDiameter(graph, affected):\n    affection = [False] * graph.node_cnt\n    for x in affected:\n        affection[x] = True\n    dist0 = graph.getDistances(affected[0])\n    affect_1 = max(range(graph.node_cnt), key=lambda i: dist0[i] if affection[i] else -1)\n    dist1 = graph.getDistances(affect_1)\n    affect_2 = max(range(graph.node_cnt), key=lambda i: dist1[i] if affection[i] else -1)\n    return (affect_1, affect_2)\n\ndef find_possible_book_locations(n, m, d, affected, paths):\n    g = Graph(n)\n    for (a, b) in paths:\n        g.addEdge(a, b)\n    (p1, p2) = getAffectedDiameter(g, affected)\n    (d1, d2) = (g.getDistances(p1), g.getDistances(p2))\n    cnt = sum((1 for i in range(n) if d1[i] <= d and d2[i] <= d))\n    return cnt"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "dist = [-1] * self.node_cnt",
      "mutated_line": "dist = [-1] + self.node_cnt",
      "code": "import collections\n\nclass Graph:\n\n    def __init__(self, n, directed=False):\n        self.node_cnt = n\n        self.__directed = directed\n        self.__adjList = [[] for _ in range(n)]\n\n    def addEdge(self, u, v):\n        self.__adjList[u].append(v)\n        if not self.__directed:\n            self.__adjList[v].append(u)\n\n    def getDistances(self, start, end=None):\n        assert 0 <= start < self.node_cnt\n        dist = [-1] + self.node_cnt\n        q = collections.deque()\n        dist[start] = 0\n        q.append(start)\n        while q:\n            z = q.popleft()\n            if end == z:\n                break\n            for t in self.__adjList[z]:\n                if dist[t] == -1:\n                    dist[t] = dist[z] + 1\n                    q.append(t)\n                    if t == end:\n                        break\n        return dist\n\ndef getAffectedDiameter(graph, affected):\n    affection = [False] * graph.node_cnt\n    for x in affected:\n        affection[x] = True\n    dist0 = graph.getDistances(affected[0])\n    affect_1 = max(range(graph.node_cnt), key=lambda i: dist0[i] if affection[i] else -1)\n    dist1 = graph.getDistances(affect_1)\n    affect_2 = max(range(graph.node_cnt), key=lambda i: dist1[i] if affection[i] else -1)\n    return (affect_1, affect_2)\n\ndef find_possible_book_locations(n, m, d, affected, paths):\n    g = Graph(n)\n    for (a, b) in paths:\n        g.addEdge(a, b)\n    (p1, p2) = getAffectedDiameter(g, affected)\n    (d1, d2) = (g.getDistances(p1), g.getDistances(p2))\n    cnt = sum((1 for i in range(n) if d1[i] <= d and d2[i] <= d))\n    return cnt"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "dist = [-1] * self.node_cnt",
      "mutated_line": "dist = [-1] ** self.node_cnt",
      "code": "import collections\n\nclass Graph:\n\n    def __init__(self, n, directed=False):\n        self.node_cnt = n\n        self.__directed = directed\n        self.__adjList = [[] for _ in range(n)]\n\n    def addEdge(self, u, v):\n        self.__adjList[u].append(v)\n        if not self.__directed:\n            self.__adjList[v].append(u)\n\n    def getDistances(self, start, end=None):\n        assert 0 <= start < self.node_cnt\n        dist = [-1] ** self.node_cnt\n        q = collections.deque()\n        dist[start] = 0\n        q.append(start)\n        while q:\n            z = q.popleft()\n            if end == z:\n                break\n            for t in self.__adjList[z]:\n                if dist[t] == -1:\n                    dist[t] = dist[z] + 1\n                    q.append(t)\n                    if t == end:\n                        break\n        return dist\n\ndef getAffectedDiameter(graph, affected):\n    affection = [False] * graph.node_cnt\n    for x in affected:\n        affection[x] = True\n    dist0 = graph.getDistances(affected[0])\n    affect_1 = max(range(graph.node_cnt), key=lambda i: dist0[i] if affection[i] else -1)\n    dist1 = graph.getDistances(affect_1)\n    affect_2 = max(range(graph.node_cnt), key=lambda i: dist1[i] if affection[i] else -1)\n    return (affect_1, affect_2)\n\ndef find_possible_book_locations(n, m, d, affected, paths):\n    g = Graph(n)\n    for (a, b) in paths:\n        g.addEdge(a, b)\n    (p1, p2) = getAffectedDiameter(g, affected)\n    (d1, d2) = (g.getDistances(p1), g.getDistances(p2))\n    cnt = sum((1 for i in range(n) if d1[i] <= d and d2[i] <= d))\n    return cnt"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dist[start] = 0",
      "mutated_line": "dist[start] = 1",
      "code": "import collections\n\nclass Graph:\n\n    def __init__(self, n, directed=False):\n        self.node_cnt = n\n        self.__directed = directed\n        self.__adjList = [[] for _ in range(n)]\n\n    def addEdge(self, u, v):\n        self.__adjList[u].append(v)\n        if not self.__directed:\n            self.__adjList[v].append(u)\n\n    def getDistances(self, start, end=None):\n        assert 0 <= start < self.node_cnt\n        dist = [-1] * self.node_cnt\n        q = collections.deque()\n        dist[start] = 1\n        q.append(start)\n        while q:\n            z = q.popleft()\n            if end == z:\n                break\n            for t in self.__adjList[z]:\n                if dist[t] == -1:\n                    dist[t] = dist[z] + 1\n                    q.append(t)\n                    if t == end:\n                        break\n        return dist\n\ndef getAffectedDiameter(graph, affected):\n    affection = [False] * graph.node_cnt\n    for x in affected:\n        affection[x] = True\n    dist0 = graph.getDistances(affected[0])\n    affect_1 = max(range(graph.node_cnt), key=lambda i: dist0[i] if affection[i] else -1)\n    dist1 = graph.getDistances(affect_1)\n    affect_2 = max(range(graph.node_cnt), key=lambda i: dist1[i] if affection[i] else -1)\n    return (affect_1, affect_2)\n\ndef find_possible_book_locations(n, m, d, affected, paths):\n    g = Graph(n)\n    for (a, b) in paths:\n        g.addEdge(a, b)\n    (p1, p2) = getAffectedDiameter(g, affected)\n    (d1, d2) = (g.getDistances(p1), g.getDistances(p2))\n    cnt = sum((1 for i in range(n) if d1[i] <= d and d2[i] <= d))\n    return cnt"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dist[start] = 0",
      "mutated_line": "dist[start] = -1",
      "code": "import collections\n\nclass Graph:\n\n    def __init__(self, n, directed=False):\n        self.node_cnt = n\n        self.__directed = directed\n        self.__adjList = [[] for _ in range(n)]\n\n    def addEdge(self, u, v):\n        self.__adjList[u].append(v)\n        if not self.__directed:\n            self.__adjList[v].append(u)\n\n    def getDistances(self, start, end=None):\n        assert 0 <= start < self.node_cnt\n        dist = [-1] * self.node_cnt\n        q = collections.deque()\n        dist[start] = -1\n        q.append(start)\n        while q:\n            z = q.popleft()\n            if end == z:\n                break\n            for t in self.__adjList[z]:\n                if dist[t] == -1:\n                    dist[t] = dist[z] + 1\n                    q.append(t)\n                    if t == end:\n                        break\n        return dist\n\ndef getAffectedDiameter(graph, affected):\n    affection = [False] * graph.node_cnt\n    for x in affected:\n        affection[x] = True\n    dist0 = graph.getDistances(affected[0])\n    affect_1 = max(range(graph.node_cnt), key=lambda i: dist0[i] if affection[i] else -1)\n    dist1 = graph.getDistances(affect_1)\n    affect_2 = max(range(graph.node_cnt), key=lambda i: dist1[i] if affection[i] else -1)\n    return (affect_1, affect_2)\n\ndef find_possible_book_locations(n, m, d, affected, paths):\n    g = Graph(n)\n    for (a, b) in paths:\n        g.addEdge(a, b)\n    (p1, p2) = getAffectedDiameter(g, affected)\n    (d1, d2) = (g.getDistances(p1), g.getDistances(p2))\n    cnt = sum((1 for i in range(n) if d1[i] <= d and d2[i] <= d))\n    return cnt"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dist[start] = 0",
      "mutated_line": "dist[start] = 1",
      "code": "import collections\n\nclass Graph:\n\n    def __init__(self, n, directed=False):\n        self.node_cnt = n\n        self.__directed = directed\n        self.__adjList = [[] for _ in range(n)]\n\n    def addEdge(self, u, v):\n        self.__adjList[u].append(v)\n        if not self.__directed:\n            self.__adjList[v].append(u)\n\n    def getDistances(self, start, end=None):\n        assert 0 <= start < self.node_cnt\n        dist = [-1] * self.node_cnt\n        q = collections.deque()\n        dist[start] = 1\n        q.append(start)\n        while q:\n            z = q.popleft()\n            if end == z:\n                break\n            for t in self.__adjList[z]:\n                if dist[t] == -1:\n                    dist[t] = dist[z] + 1\n                    q.append(t)\n                    if t == end:\n                        break\n        return dist\n\ndef getAffectedDiameter(graph, affected):\n    affection = [False] * graph.node_cnt\n    for x in affected:\n        affection[x] = True\n    dist0 = graph.getDistances(affected[0])\n    affect_1 = max(range(graph.node_cnt), key=lambda i: dist0[i] if affection[i] else -1)\n    dist1 = graph.getDistances(affect_1)\n    affect_2 = max(range(graph.node_cnt), key=lambda i: dist1[i] if affection[i] else -1)\n    return (affect_1, affect_2)\n\ndef find_possible_book_locations(n, m, d, affected, paths):\n    g = Graph(n)\n    for (a, b) in paths:\n        g.addEdge(a, b)\n    (p1, p2) = getAffectedDiameter(g, affected)\n    (d1, d2) = (g.getDistances(p1), g.getDistances(p2))\n    cnt = sum((1 for i in range(n) if d1[i] <= d and d2[i] <= d))\n    return cnt"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "affection[x] = True",
      "mutated_line": "affection[x] = False",
      "code": "import collections\n\nclass Graph:\n\n    def __init__(self, n, directed=False):\n        self.node_cnt = n\n        self.__directed = directed\n        self.__adjList = [[] for _ in range(n)]\n\n    def addEdge(self, u, v):\n        self.__adjList[u].append(v)\n        if not self.__directed:\n            self.__adjList[v].append(u)\n\n    def getDistances(self, start, end=None):\n        assert 0 <= start < self.node_cnt\n        dist = [-1] * self.node_cnt\n        q = collections.deque()\n        dist[start] = 0\n        q.append(start)\n        while q:\n            z = q.popleft()\n            if end == z:\n                break\n            for t in self.__adjList[z]:\n                if dist[t] == -1:\n                    dist[t] = dist[z] + 1\n                    q.append(t)\n                    if t == end:\n                        break\n        return dist\n\ndef getAffectedDiameter(graph, affected):\n    affection = [False] * graph.node_cnt\n    for x in affected:\n        affection[x] = False\n    dist0 = graph.getDistances(affected[0])\n    affect_1 = max(range(graph.node_cnt), key=lambda i: dist0[i] if affection[i] else -1)\n    dist1 = graph.getDistances(affect_1)\n    affect_2 = max(range(graph.node_cnt), key=lambda i: dist1[i] if affection[i] else -1)\n    return (affect_1, affect_2)\n\ndef find_possible_book_locations(n, m, d, affected, paths):\n    g = Graph(n)\n    for (a, b) in paths:\n        g.addEdge(a, b)\n    (p1, p2) = getAffectedDiameter(g, affected)\n    (d1, d2) = (g.getDistances(p1), g.getDistances(p2))\n    cnt = sum((1 for i in range(n) if d1[i] <= d and d2[i] <= d))\n    return cnt"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "assert 0 <= start < self.node_cnt",
      "mutated_line": "assert 1 <= start < self.node_cnt",
      "code": "import collections\n\nclass Graph:\n\n    def __init__(self, n, directed=False):\n        self.node_cnt = n\n        self.__directed = directed\n        self.__adjList = [[] for _ in range(n)]\n\n    def addEdge(self, u, v):\n        self.__adjList[u].append(v)\n        if not self.__directed:\n            self.__adjList[v].append(u)\n\n    def getDistances(self, start, end=None):\n        assert 1 <= start < self.node_cnt\n        dist = [-1] * self.node_cnt\n        q = collections.deque()\n        dist[start] = 0\n        q.append(start)\n        while q:\n            z = q.popleft()\n            if end == z:\n                break\n            for t in self.__adjList[z]:\n                if dist[t] == -1:\n                    dist[t] = dist[z] + 1\n                    q.append(t)\n                    if t == end:\n                        break\n        return dist\n\ndef getAffectedDiameter(graph, affected):\n    affection = [False] * graph.node_cnt\n    for x in affected:\n        affection[x] = True\n    dist0 = graph.getDistances(affected[0])\n    affect_1 = max(range(graph.node_cnt), key=lambda i: dist0[i] if affection[i] else -1)\n    dist1 = graph.getDistances(affect_1)\n    affect_2 = max(range(graph.node_cnt), key=lambda i: dist1[i] if affection[i] else -1)\n    return (affect_1, affect_2)\n\ndef find_possible_book_locations(n, m, d, affected, paths):\n    g = Graph(n)\n    for (a, b) in paths:\n        g.addEdge(a, b)\n    (p1, p2) = getAffectedDiameter(g, affected)\n    (d1, d2) = (g.getDistances(p1), g.getDistances(p2))\n    cnt = sum((1 for i in range(n) if d1[i] <= d and d2[i] <= d))\n    return cnt"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "assert 0 <= start < self.node_cnt",
      "mutated_line": "assert -1 <= start < self.node_cnt",
      "code": "import collections\n\nclass Graph:\n\n    def __init__(self, n, directed=False):\n        self.node_cnt = n\n        self.__directed = directed\n        self.__adjList = [[] for _ in range(n)]\n\n    def addEdge(self, u, v):\n        self.__adjList[u].append(v)\n        if not self.__directed:\n            self.__adjList[v].append(u)\n\n    def getDistances(self, start, end=None):\n        assert -1 <= start < self.node_cnt\n        dist = [-1] * self.node_cnt\n        q = collections.deque()\n        dist[start] = 0\n        q.append(start)\n        while q:\n            z = q.popleft()\n            if end == z:\n                break\n            for t in self.__adjList[z]:\n                if dist[t] == -1:\n                    dist[t] = dist[z] + 1\n                    q.append(t)\n                    if t == end:\n                        break\n        return dist\n\ndef getAffectedDiameter(graph, affected):\n    affection = [False] * graph.node_cnt\n    for x in affected:\n        affection[x] = True\n    dist0 = graph.getDistances(affected[0])\n    affect_1 = max(range(graph.node_cnt), key=lambda i: dist0[i] if affection[i] else -1)\n    dist1 = graph.getDistances(affect_1)\n    affect_2 = max(range(graph.node_cnt), key=lambda i: dist1[i] if affection[i] else -1)\n    return (affect_1, affect_2)\n\ndef find_possible_book_locations(n, m, d, affected, paths):\n    g = Graph(n)\n    for (a, b) in paths:\n        g.addEdge(a, b)\n    (p1, p2) = getAffectedDiameter(g, affected)\n    (d1, d2) = (g.getDistances(p1), g.getDistances(p2))\n    cnt = sum((1 for i in range(n) if d1[i] <= d and d2[i] <= d))\n    return cnt"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "assert 0 <= start < self.node_cnt",
      "mutated_line": "assert 1 <= start < self.node_cnt",
      "code": "import collections\n\nclass Graph:\n\n    def __init__(self, n, directed=False):\n        self.node_cnt = n\n        self.__directed = directed\n        self.__adjList = [[] for _ in range(n)]\n\n    def addEdge(self, u, v):\n        self.__adjList[u].append(v)\n        if not self.__directed:\n            self.__adjList[v].append(u)\n\n    def getDistances(self, start, end=None):\n        assert 1 <= start < self.node_cnt\n        dist = [-1] * self.node_cnt\n        q = collections.deque()\n        dist[start] = 0\n        q.append(start)\n        while q:\n            z = q.popleft()\n            if end == z:\n                break\n            for t in self.__adjList[z]:\n                if dist[t] == -1:\n                    dist[t] = dist[z] + 1\n                    q.append(t)\n                    if t == end:\n                        break\n        return dist\n\ndef getAffectedDiameter(graph, affected):\n    affection = [False] * graph.node_cnt\n    for x in affected:\n        affection[x] = True\n    dist0 = graph.getDistances(affected[0])\n    affect_1 = max(range(graph.node_cnt), key=lambda i: dist0[i] if affection[i] else -1)\n    dist1 = graph.getDistances(affect_1)\n    affect_2 = max(range(graph.node_cnt), key=lambda i: dist1[i] if affection[i] else -1)\n    return (affect_1, affect_2)\n\ndef find_possible_book_locations(n, m, d, affected, paths):\n    g = Graph(n)\n    for (a, b) in paths:\n        g.addEdge(a, b)\n    (p1, p2) = getAffectedDiameter(g, affected)\n    (d1, d2) = (g.getDistances(p1), g.getDistances(p2))\n    cnt = sum((1 for i in range(n) if d1[i] <= d and d2[i] <= d))\n    return cnt"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if end == z:",
      "mutated_line": "if end != z:",
      "code": "import collections\n\nclass Graph:\n\n    def __init__(self, n, directed=False):\n        self.node_cnt = n\n        self.__directed = directed\n        self.__adjList = [[] for _ in range(n)]\n\n    def addEdge(self, u, v):\n        self.__adjList[u].append(v)\n        if not self.__directed:\n            self.__adjList[v].append(u)\n\n    def getDistances(self, start, end=None):\n        assert 0 <= start < self.node_cnt\n        dist = [-1] * self.node_cnt\n        q = collections.deque()\n        dist[start] = 0\n        q.append(start)\n        while q:\n            z = q.popleft()\n            if end != z:\n                break\n            for t in self.__adjList[z]:\n                if dist[t] == -1:\n                    dist[t] = dist[z] + 1\n                    q.append(t)\n                    if t == end:\n                        break\n        return dist\n\ndef getAffectedDiameter(graph, affected):\n    affection = [False] * graph.node_cnt\n    for x in affected:\n        affection[x] = True\n    dist0 = graph.getDistances(affected[0])\n    affect_1 = max(range(graph.node_cnt), key=lambda i: dist0[i] if affection[i] else -1)\n    dist1 = graph.getDistances(affect_1)\n    affect_2 = max(range(graph.node_cnt), key=lambda i: dist1[i] if affection[i] else -1)\n    return (affect_1, affect_2)\n\ndef find_possible_book_locations(n, m, d, affected, paths):\n    g = Graph(n)\n    for (a, b) in paths:\n        g.addEdge(a, b)\n    (p1, p2) = getAffectedDiameter(g, affected)\n    (d1, d2) = (g.getDistances(p1), g.getDistances(p2))\n    cnt = sum((1 for i in range(n) if d1[i] <= d and d2[i] <= d))\n    return cnt"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "affection = [False] * graph.node_cnt",
      "mutated_line": "affection = [True] * graph.node_cnt",
      "code": "import collections\n\nclass Graph:\n\n    def __init__(self, n, directed=False):\n        self.node_cnt = n\n        self.__directed = directed\n        self.__adjList = [[] for _ in range(n)]\n\n    def addEdge(self, u, v):\n        self.__adjList[u].append(v)\n        if not self.__directed:\n            self.__adjList[v].append(u)\n\n    def getDistances(self, start, end=None):\n        assert 0 <= start < self.node_cnt\n        dist = [-1] * self.node_cnt\n        q = collections.deque()\n        dist[start] = 0\n        q.append(start)\n        while q:\n            z = q.popleft()\n            if end == z:\n                break\n            for t in self.__adjList[z]:\n                if dist[t] == -1:\n                    dist[t] = dist[z] + 1\n                    q.append(t)\n                    if t == end:\n                        break\n        return dist\n\ndef getAffectedDiameter(graph, affected):\n    affection = [True] * graph.node_cnt\n    for x in affected:\n        affection[x] = True\n    dist0 = graph.getDistances(affected[0])\n    affect_1 = max(range(graph.node_cnt), key=lambda i: dist0[i] if affection[i] else -1)\n    dist1 = graph.getDistances(affect_1)\n    affect_2 = max(range(graph.node_cnt), key=lambda i: dist1[i] if affection[i] else -1)\n    return (affect_1, affect_2)\n\ndef find_possible_book_locations(n, m, d, affected, paths):\n    g = Graph(n)\n    for (a, b) in paths:\n        g.addEdge(a, b)\n    (p1, p2) = getAffectedDiameter(g, affected)\n    (d1, d2) = (g.getDistances(p1), g.getDistances(p2))\n    cnt = sum((1 for i in range(n) if d1[i] <= d and d2[i] <= d))\n    return cnt"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "dist0 = graph.getDistances(affected[0])",
      "mutated_line": "dist0 = graph.getDistances(affected[1])",
      "code": "import collections\n\nclass Graph:\n\n    def __init__(self, n, directed=False):\n        self.node_cnt = n\n        self.__directed = directed\n        self.__adjList = [[] for _ in range(n)]\n\n    def addEdge(self, u, v):\n        self.__adjList[u].append(v)\n        if not self.__directed:\n            self.__adjList[v].append(u)\n\n    def getDistances(self, start, end=None):\n        assert 0 <= start < self.node_cnt\n        dist = [-1] * self.node_cnt\n        q = collections.deque()\n        dist[start] = 0\n        q.append(start)\n        while q:\n            z = q.popleft()\n            if end == z:\n                break\n            for t in self.__adjList[z]:\n                if dist[t] == -1:\n                    dist[t] = dist[z] + 1\n                    q.append(t)\n                    if t == end:\n                        break\n        return dist\n\ndef getAffectedDiameter(graph, affected):\n    affection = [False] * graph.node_cnt\n    for x in affected:\n        affection[x] = True\n    dist0 = graph.getDistances(affected[1])\n    affect_1 = max(range(graph.node_cnt), key=lambda i: dist0[i] if affection[i] else -1)\n    dist1 = graph.getDistances(affect_1)\n    affect_2 = max(range(graph.node_cnt), key=lambda i: dist1[i] if affection[i] else -1)\n    return (affect_1, affect_2)\n\ndef find_possible_book_locations(n, m, d, affected, paths):\n    g = Graph(n)\n    for (a, b) in paths:\n        g.addEdge(a, b)\n    (p1, p2) = getAffectedDiameter(g, affected)\n    (d1, d2) = (g.getDistances(p1), g.getDistances(p2))\n    cnt = sum((1 for i in range(n) if d1[i] <= d and d2[i] <= d))\n    return cnt"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "dist0 = graph.getDistances(affected[0])",
      "mutated_line": "dist0 = graph.getDistances(affected[-1])",
      "code": "import collections\n\nclass Graph:\n\n    def __init__(self, n, directed=False):\n        self.node_cnt = n\n        self.__directed = directed\n        self.__adjList = [[] for _ in range(n)]\n\n    def addEdge(self, u, v):\n        self.__adjList[u].append(v)\n        if not self.__directed:\n            self.__adjList[v].append(u)\n\n    def getDistances(self, start, end=None):\n        assert 0 <= start < self.node_cnt\n        dist = [-1] * self.node_cnt\n        q = collections.deque()\n        dist[start] = 0\n        q.append(start)\n        while q:\n            z = q.popleft()\n            if end == z:\n                break\n            for t in self.__adjList[z]:\n                if dist[t] == -1:\n                    dist[t] = dist[z] + 1\n                    q.append(t)\n                    if t == end:\n                        break\n        return dist\n\ndef getAffectedDiameter(graph, affected):\n    affection = [False] * graph.node_cnt\n    for x in affected:\n        affection[x] = True\n    dist0 = graph.getDistances(affected[-1])\n    affect_1 = max(range(graph.node_cnt), key=lambda i: dist0[i] if affection[i] else -1)\n    dist1 = graph.getDistances(affect_1)\n    affect_2 = max(range(graph.node_cnt), key=lambda i: dist1[i] if affection[i] else -1)\n    return (affect_1, affect_2)\n\ndef find_possible_book_locations(n, m, d, affected, paths):\n    g = Graph(n)\n    for (a, b) in paths:\n        g.addEdge(a, b)\n    (p1, p2) = getAffectedDiameter(g, affected)\n    (d1, d2) = (g.getDistances(p1), g.getDistances(p2))\n    cnt = sum((1 for i in range(n) if d1[i] <= d and d2[i] <= d))\n    return cnt"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "dist0 = graph.getDistances(affected[0])",
      "mutated_line": "dist0 = graph.getDistances(affected[1])",
      "code": "import collections\n\nclass Graph:\n\n    def __init__(self, n, directed=False):\n        self.node_cnt = n\n        self.__directed = directed\n        self.__adjList = [[] for _ in range(n)]\n\n    def addEdge(self, u, v):\n        self.__adjList[u].append(v)\n        if not self.__directed:\n            self.__adjList[v].append(u)\n\n    def getDistances(self, start, end=None):\n        assert 0 <= start < self.node_cnt\n        dist = [-1] * self.node_cnt\n        q = collections.deque()\n        dist[start] = 0\n        q.append(start)\n        while q:\n            z = q.popleft()\n            if end == z:\n                break\n            for t in self.__adjList[z]:\n                if dist[t] == -1:\n                    dist[t] = dist[z] + 1\n                    q.append(t)\n                    if t == end:\n                        break\n        return dist\n\ndef getAffectedDiameter(graph, affected):\n    affection = [False] * graph.node_cnt\n    for x in affected:\n        affection[x] = True\n    dist0 = graph.getDistances(affected[1])\n    affect_1 = max(range(graph.node_cnt), key=lambda i: dist0[i] if affection[i] else -1)\n    dist1 = graph.getDistances(affect_1)\n    affect_2 = max(range(graph.node_cnt), key=lambda i: dist1[i] if affection[i] else -1)\n    return (affect_1, affect_2)\n\ndef find_possible_book_locations(n, m, d, affected, paths):\n    g = Graph(n)\n    for (a, b) in paths:\n        g.addEdge(a, b)\n    (p1, p2) = getAffectedDiameter(g, affected)\n    (d1, d2) = (g.getDistances(p1), g.getDistances(p2))\n    cnt = sum((1 for i in range(n) if d1[i] <= d and d2[i] <= d))\n    return cnt"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "cnt = sum(1 for i in range(n) if d1[i] <= d and d2[i] <= d)",
      "mutated_line": "cnt = sum((2 for i in range(n) if d1[i] <= d and d2[i] <= d))",
      "code": "import collections\n\nclass Graph:\n\n    def __init__(self, n, directed=False):\n        self.node_cnt = n\n        self.__directed = directed\n        self.__adjList = [[] for _ in range(n)]\n\n    def addEdge(self, u, v):\n        self.__adjList[u].append(v)\n        if not self.__directed:\n            self.__adjList[v].append(u)\n\n    def getDistances(self, start, end=None):\n        assert 0 <= start < self.node_cnt\n        dist = [-1] * self.node_cnt\n        q = collections.deque()\n        dist[start] = 0\n        q.append(start)\n        while q:\n            z = q.popleft()\n            if end == z:\n                break\n            for t in self.__adjList[z]:\n                if dist[t] == -1:\n                    dist[t] = dist[z] + 1\n                    q.append(t)\n                    if t == end:\n                        break\n        return dist\n\ndef getAffectedDiameter(graph, affected):\n    affection = [False] * graph.node_cnt\n    for x in affected:\n        affection[x] = True\n    dist0 = graph.getDistances(affected[0])\n    affect_1 = max(range(graph.node_cnt), key=lambda i: dist0[i] if affection[i] else -1)\n    dist1 = graph.getDistances(affect_1)\n    affect_2 = max(range(graph.node_cnt), key=lambda i: dist1[i] if affection[i] else -1)\n    return (affect_1, affect_2)\n\ndef find_possible_book_locations(n, m, d, affected, paths):\n    g = Graph(n)\n    for (a, b) in paths:\n        g.addEdge(a, b)\n    (p1, p2) = getAffectedDiameter(g, affected)\n    (d1, d2) = (g.getDistances(p1), g.getDistances(p2))\n    cnt = sum((2 for i in range(n) if d1[i] <= d and d2[i] <= d))\n    return cnt"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "cnt = sum(1 for i in range(n) if d1[i] <= d and d2[i] <= d)",
      "mutated_line": "cnt = sum((0 for i in range(n) if d1[i] <= d and d2[i] <= d))",
      "code": "import collections\n\nclass Graph:\n\n    def __init__(self, n, directed=False):\n        self.node_cnt = n\n        self.__directed = directed\n        self.__adjList = [[] for _ in range(n)]\n\n    def addEdge(self, u, v):\n        self.__adjList[u].append(v)\n        if not self.__directed:\n            self.__adjList[v].append(u)\n\n    def getDistances(self, start, end=None):\n        assert 0 <= start < self.node_cnt\n        dist = [-1] * self.node_cnt\n        q = collections.deque()\n        dist[start] = 0\n        q.append(start)\n        while q:\n            z = q.popleft()\n            if end == z:\n                break\n            for t in self.__adjList[z]:\n                if dist[t] == -1:\n                    dist[t] = dist[z] + 1\n                    q.append(t)\n                    if t == end:\n                        break\n        return dist\n\ndef getAffectedDiameter(graph, affected):\n    affection = [False] * graph.node_cnt\n    for x in affected:\n        affection[x] = True\n    dist0 = graph.getDistances(affected[0])\n    affect_1 = max(range(graph.node_cnt), key=lambda i: dist0[i] if affection[i] else -1)\n    dist1 = graph.getDistances(affect_1)\n    affect_2 = max(range(graph.node_cnt), key=lambda i: dist1[i] if affection[i] else -1)\n    return (affect_1, affect_2)\n\ndef find_possible_book_locations(n, m, d, affected, paths):\n    g = Graph(n)\n    for (a, b) in paths:\n        g.addEdge(a, b)\n    (p1, p2) = getAffectedDiameter(g, affected)\n    (d1, d2) = (g.getDistances(p1), g.getDistances(p2))\n    cnt = sum((0 for i in range(n) if d1[i] <= d and d2[i] <= d))\n    return cnt"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "cnt = sum(1 for i in range(n) if d1[i] <= d and d2[i] <= d)",
      "mutated_line": "cnt = sum((0 for i in range(n) if d1[i] <= d and d2[i] <= d))",
      "code": "import collections\n\nclass Graph:\n\n    def __init__(self, n, directed=False):\n        self.node_cnt = n\n        self.__directed = directed\n        self.__adjList = [[] for _ in range(n)]\n\n    def addEdge(self, u, v):\n        self.__adjList[u].append(v)\n        if not self.__directed:\n            self.__adjList[v].append(u)\n\n    def getDistances(self, start, end=None):\n        assert 0 <= start < self.node_cnt\n        dist = [-1] * self.node_cnt\n        q = collections.deque()\n        dist[start] = 0\n        q.append(start)\n        while q:\n            z = q.popleft()\n            if end == z:\n                break\n            for t in self.__adjList[z]:\n                if dist[t] == -1:\n                    dist[t] = dist[z] + 1\n                    q.append(t)\n                    if t == end:\n                        break\n        return dist\n\ndef getAffectedDiameter(graph, affected):\n    affection = [False] * graph.node_cnt\n    for x in affected:\n        affection[x] = True\n    dist0 = graph.getDistances(affected[0])\n    affect_1 = max(range(graph.node_cnt), key=lambda i: dist0[i] if affection[i] else -1)\n    dist1 = graph.getDistances(affect_1)\n    affect_2 = max(range(graph.node_cnt), key=lambda i: dist1[i] if affection[i] else -1)\n    return (affect_1, affect_2)\n\ndef find_possible_book_locations(n, m, d, affected, paths):\n    g = Graph(n)\n    for (a, b) in paths:\n        g.addEdge(a, b)\n    (p1, p2) = getAffectedDiameter(g, affected)\n    (d1, d2) = (g.getDistances(p1), g.getDistances(p2))\n    cnt = sum((0 for i in range(n) if d1[i] <= d and d2[i] <= d))\n    return cnt"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "cnt = sum(1 for i in range(n) if d1[i] <= d and d2[i] <= d)",
      "mutated_line": "cnt = sum((-1 for i in range(n) if d1[i] <= d and d2[i] <= d))",
      "code": "import collections\n\nclass Graph:\n\n    def __init__(self, n, directed=False):\n        self.node_cnt = n\n        self.__directed = directed\n        self.__adjList = [[] for _ in range(n)]\n\n    def addEdge(self, u, v):\n        self.__adjList[u].append(v)\n        if not self.__directed:\n            self.__adjList[v].append(u)\n\n    def getDistances(self, start, end=None):\n        assert 0 <= start < self.node_cnt\n        dist = [-1] * self.node_cnt\n        q = collections.deque()\n        dist[start] = 0\n        q.append(start)\n        while q:\n            z = q.popleft()\n            if end == z:\n                break\n            for t in self.__adjList[z]:\n                if dist[t] == -1:\n                    dist[t] = dist[z] + 1\n                    q.append(t)\n                    if t == end:\n                        break\n        return dist\n\ndef getAffectedDiameter(graph, affected):\n    affection = [False] * graph.node_cnt\n    for x in affected:\n        affection[x] = True\n    dist0 = graph.getDistances(affected[0])\n    affect_1 = max(range(graph.node_cnt), key=lambda i: dist0[i] if affection[i] else -1)\n    dist1 = graph.getDistances(affect_1)\n    affect_2 = max(range(graph.node_cnt), key=lambda i: dist1[i] if affection[i] else -1)\n    return (affect_1, affect_2)\n\ndef find_possible_book_locations(n, m, d, affected, paths):\n    g = Graph(n)\n    for (a, b) in paths:\n        g.addEdge(a, b)\n    (p1, p2) = getAffectedDiameter(g, affected)\n    (d1, d2) = (g.getDistances(p1), g.getDistances(p2))\n    cnt = sum((-1 for i in range(n) if d1[i] <= d and d2[i] <= d))\n    return cnt"
    },
    {
      "operator": "UOI",
      "lineno": 16,
      "original_line": "dist = [-1] * self.node_cnt",
      "mutated_line": "dist = [+1] * self.node_cnt",
      "code": "import collections\n\nclass Graph:\n\n    def __init__(self, n, directed=False):\n        self.node_cnt = n\n        self.__directed = directed\n        self.__adjList = [[] for _ in range(n)]\n\n    def addEdge(self, u, v):\n        self.__adjList[u].append(v)\n        if not self.__directed:\n            self.__adjList[v].append(u)\n\n    def getDistances(self, start, end=None):\n        assert 0 <= start < self.node_cnt\n        dist = [+1] * self.node_cnt\n        q = collections.deque()\n        dist[start] = 0\n        q.append(start)\n        while q:\n            z = q.popleft()\n            if end == z:\n                break\n            for t in self.__adjList[z]:\n                if dist[t] == -1:\n                    dist[t] = dist[z] + 1\n                    q.append(t)\n                    if t == end:\n                        break\n        return dist\n\ndef getAffectedDiameter(graph, affected):\n    affection = [False] * graph.node_cnt\n    for x in affected:\n        affection[x] = True\n    dist0 = graph.getDistances(affected[0])\n    affect_1 = max(range(graph.node_cnt), key=lambda i: dist0[i] if affection[i] else -1)\n    dist1 = graph.getDistances(affect_1)\n    affect_2 = max(range(graph.node_cnt), key=lambda i: dist1[i] if affection[i] else -1)\n    return (affect_1, affect_2)\n\ndef find_possible_book_locations(n, m, d, affected, paths):\n    g = Graph(n)\n    for (a, b) in paths:\n        g.addEdge(a, b)\n    (p1, p2) = getAffectedDiameter(g, affected)\n    (d1, d2) = (g.getDistances(p1), g.getDistances(p2))\n    cnt = sum((1 for i in range(n) if d1[i] <= d and d2[i] <= d))\n    return cnt"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if dist[t] == -1:",
      "mutated_line": "if dist[t] != -1:",
      "code": "import collections\n\nclass Graph:\n\n    def __init__(self, n, directed=False):\n        self.node_cnt = n\n        self.__directed = directed\n        self.__adjList = [[] for _ in range(n)]\n\n    def addEdge(self, u, v):\n        self.__adjList[u].append(v)\n        if not self.__directed:\n            self.__adjList[v].append(u)\n\n    def getDistances(self, start, end=None):\n        assert 0 <= start < self.node_cnt\n        dist = [-1] * self.node_cnt\n        q = collections.deque()\n        dist[start] = 0\n        q.append(start)\n        while q:\n            z = q.popleft()\n            if end == z:\n                break\n            for t in self.__adjList[z]:\n                if dist[t] != -1:\n                    dist[t] = dist[z] + 1\n                    q.append(t)\n                    if t == end:\n                        break\n        return dist\n\ndef getAffectedDiameter(graph, affected):\n    affection = [False] * graph.node_cnt\n    for x in affected:\n        affection[x] = True\n    dist0 = graph.getDistances(affected[0])\n    affect_1 = max(range(graph.node_cnt), key=lambda i: dist0[i] if affection[i] else -1)\n    dist1 = graph.getDistances(affect_1)\n    affect_2 = max(range(graph.node_cnt), key=lambda i: dist1[i] if affection[i] else -1)\n    return (affect_1, affect_2)\n\ndef find_possible_book_locations(n, m, d, affected, paths):\n    g = Graph(n)\n    for (a, b) in paths:\n        g.addEdge(a, b)\n    (p1, p2) = getAffectedDiameter(g, affected)\n    (d1, d2) = (g.getDistances(p1), g.getDistances(p2))\n    cnt = sum((1 for i in range(n) if d1[i] <= d and d2[i] <= d))\n    return cnt"
    },
    {
      "operator": "LCR",
      "lineno": 48,
      "original_line": "cnt = sum(1 for i in range(n) if d1[i] <= d and d2[i] <= d)",
      "mutated_line": "cnt = sum((1 for i in range(n) if d1[i] <= d or d2[i] <= d))",
      "code": "import collections\n\nclass Graph:\n\n    def __init__(self, n, directed=False):\n        self.node_cnt = n\n        self.__directed = directed\n        self.__adjList = [[] for _ in range(n)]\n\n    def addEdge(self, u, v):\n        self.__adjList[u].append(v)\n        if not self.__directed:\n            self.__adjList[v].append(u)\n\n    def getDistances(self, start, end=None):\n        assert 0 <= start < self.node_cnt\n        dist = [-1] * self.node_cnt\n        q = collections.deque()\n        dist[start] = 0\n        q.append(start)\n        while q:\n            z = q.popleft()\n            if end == z:\n                break\n            for t in self.__adjList[z]:\n                if dist[t] == -1:\n                    dist[t] = dist[z] + 1\n                    q.append(t)\n                    if t == end:\n                        break\n        return dist\n\ndef getAffectedDiameter(graph, affected):\n    affection = [False] * graph.node_cnt\n    for x in affected:\n        affection[x] = True\n    dist0 = graph.getDistances(affected[0])\n    affect_1 = max(range(graph.node_cnt), key=lambda i: dist0[i] if affection[i] else -1)\n    dist1 = graph.getDistances(affect_1)\n    affect_2 = max(range(graph.node_cnt), key=lambda i: dist1[i] if affection[i] else -1)\n    return (affect_1, affect_2)\n\ndef find_possible_book_locations(n, m, d, affected, paths):\n    g = Graph(n)\n    for (a, b) in paths:\n        g.addEdge(a, b)\n    (p1, p2) = getAffectedDiameter(g, affected)\n    (d1, d2) = (g.getDistances(p1), g.getDistances(p2))\n    cnt = sum((1 for i in range(n) if d1[i] <= d or d2[i] <= d))\n    return cnt"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dist = [-1] * self.node_cnt",
      "mutated_line": "dist = [-2] * self.node_cnt",
      "code": "import collections\n\nclass Graph:\n\n    def __init__(self, n, directed=False):\n        self.node_cnt = n\n        self.__directed = directed\n        self.__adjList = [[] for _ in range(n)]\n\n    def addEdge(self, u, v):\n        self.__adjList[u].append(v)\n        if not self.__directed:\n            self.__adjList[v].append(u)\n\n    def getDistances(self, start, end=None):\n        assert 0 <= start < self.node_cnt\n        dist = [-2] * self.node_cnt\n        q = collections.deque()\n        dist[start] = 0\n        q.append(start)\n        while q:\n            z = q.popleft()\n            if end == z:\n                break\n            for t in self.__adjList[z]:\n                if dist[t] == -1:\n                    dist[t] = dist[z] + 1\n                    q.append(t)\n                    if t == end:\n                        break\n        return dist\n\ndef getAffectedDiameter(graph, affected):\n    affection = [False] * graph.node_cnt\n    for x in affected:\n        affection[x] = True\n    dist0 = graph.getDistances(affected[0])\n    affect_1 = max(range(graph.node_cnt), key=lambda i: dist0[i] if affection[i] else -1)\n    dist1 = graph.getDistances(affect_1)\n    affect_2 = max(range(graph.node_cnt), key=lambda i: dist1[i] if affection[i] else -1)\n    return (affect_1, affect_2)\n\ndef find_possible_book_locations(n, m, d, affected, paths):\n    g = Graph(n)\n    for (a, b) in paths:\n        g.addEdge(a, b)\n    (p1, p2) = getAffectedDiameter(g, affected)\n    (d1, d2) = (g.getDistances(p1), g.getDistances(p2))\n    cnt = sum((1 for i in range(n) if d1[i] <= d and d2[i] <= d))\n    return cnt"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dist = [-1] * self.node_cnt",
      "mutated_line": "dist = [-0] * self.node_cnt",
      "code": "import collections\n\nclass Graph:\n\n    def __init__(self, n, directed=False):\n        self.node_cnt = n\n        self.__directed = directed\n        self.__adjList = [[] for _ in range(n)]\n\n    def addEdge(self, u, v):\n        self.__adjList[u].append(v)\n        if not self.__directed:\n            self.__adjList[v].append(u)\n\n    def getDistances(self, start, end=None):\n        assert 0 <= start < self.node_cnt\n        dist = [-0] * self.node_cnt\n        q = collections.deque()\n        dist[start] = 0\n        q.append(start)\n        while q:\n            z = q.popleft()\n            if end == z:\n                break\n            for t in self.__adjList[z]:\n                if dist[t] == -1:\n                    dist[t] = dist[z] + 1\n                    q.append(t)\n                    if t == end:\n                        break\n        return dist\n\ndef getAffectedDiameter(graph, affected):\n    affection = [False] * graph.node_cnt\n    for x in affected:\n        affection[x] = True\n    dist0 = graph.getDistances(affected[0])\n    affect_1 = max(range(graph.node_cnt), key=lambda i: dist0[i] if affection[i] else -1)\n    dist1 = graph.getDistances(affect_1)\n    affect_2 = max(range(graph.node_cnt), key=lambda i: dist1[i] if affection[i] else -1)\n    return (affect_1, affect_2)\n\ndef find_possible_book_locations(n, m, d, affected, paths):\n    g = Graph(n)\n    for (a, b) in paths:\n        g.addEdge(a, b)\n    (p1, p2) = getAffectedDiameter(g, affected)\n    (d1, d2) = (g.getDistances(p1), g.getDistances(p2))\n    cnt = sum((1 for i in range(n) if d1[i] <= d and d2[i] <= d))\n    return cnt"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dist = [-1] * self.node_cnt",
      "mutated_line": "dist = [-0] * self.node_cnt",
      "code": "import collections\n\nclass Graph:\n\n    def __init__(self, n, directed=False):\n        self.node_cnt = n\n        self.__directed = directed\n        self.__adjList = [[] for _ in range(n)]\n\n    def addEdge(self, u, v):\n        self.__adjList[u].append(v)\n        if not self.__directed:\n            self.__adjList[v].append(u)\n\n    def getDistances(self, start, end=None):\n        assert 0 <= start < self.node_cnt\n        dist = [-0] * self.node_cnt\n        q = collections.deque()\n        dist[start] = 0\n        q.append(start)\n        while q:\n            z = q.popleft()\n            if end == z:\n                break\n            for t in self.__adjList[z]:\n                if dist[t] == -1:\n                    dist[t] = dist[z] + 1\n                    q.append(t)\n                    if t == end:\n                        break\n        return dist\n\ndef getAffectedDiameter(graph, affected):\n    affection = [False] * graph.node_cnt\n    for x in affected:\n        affection[x] = True\n    dist0 = graph.getDistances(affected[0])\n    affect_1 = max(range(graph.node_cnt), key=lambda i: dist0[i] if affection[i] else -1)\n    dist1 = graph.getDistances(affect_1)\n    affect_2 = max(range(graph.node_cnt), key=lambda i: dist1[i] if affection[i] else -1)\n    return (affect_1, affect_2)\n\ndef find_possible_book_locations(n, m, d, affected, paths):\n    g = Graph(n)\n    for (a, b) in paths:\n        g.addEdge(a, b)\n    (p1, p2) = getAffectedDiameter(g, affected)\n    (d1, d2) = (g.getDistances(p1), g.getDistances(p2))\n    cnt = sum((1 for i in range(n) if d1[i] <= d and d2[i] <= d))\n    return cnt"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dist = [-1] * self.node_cnt",
      "mutated_line": "dist = [--1] * self.node_cnt",
      "code": "import collections\n\nclass Graph:\n\n    def __init__(self, n, directed=False):\n        self.node_cnt = n\n        self.__directed = directed\n        self.__adjList = [[] for _ in range(n)]\n\n    def addEdge(self, u, v):\n        self.__adjList[u].append(v)\n        if not self.__directed:\n            self.__adjList[v].append(u)\n\n    def getDistances(self, start, end=None):\n        assert 0 <= start < self.node_cnt\n        dist = [--1] * self.node_cnt\n        q = collections.deque()\n        dist[start] = 0\n        q.append(start)\n        while q:\n            z = q.popleft()\n            if end == z:\n                break\n            for t in self.__adjList[z]:\n                if dist[t] == -1:\n                    dist[t] = dist[z] + 1\n                    q.append(t)\n                    if t == end:\n                        break\n        return dist\n\ndef getAffectedDiameter(graph, affected):\n    affection = [False] * graph.node_cnt\n    for x in affected:\n        affection[x] = True\n    dist0 = graph.getDistances(affected[0])\n    affect_1 = max(range(graph.node_cnt), key=lambda i: dist0[i] if affection[i] else -1)\n    dist1 = graph.getDistances(affect_1)\n    affect_2 = max(range(graph.node_cnt), key=lambda i: dist1[i] if affection[i] else -1)\n    return (affect_1, affect_2)\n\ndef find_possible_book_locations(n, m, d, affected, paths):\n    g = Graph(n)\n    for (a, b) in paths:\n        g.addEdge(a, b)\n    (p1, p2) = getAffectedDiameter(g, affected)\n    (d1, d2) = (g.getDistances(p1), g.getDistances(p2))\n    cnt = sum((1 for i in range(n) if d1[i] <= d and d2[i] <= d))\n    return cnt"
    },
    {
      "operator": "UOI",
      "lineno": 25,
      "original_line": "if dist[t] == -1:",
      "mutated_line": "if dist[t] == +1:",
      "code": "import collections\n\nclass Graph:\n\n    def __init__(self, n, directed=False):\n        self.node_cnt = n\n        self.__directed = directed\n        self.__adjList = [[] for _ in range(n)]\n\n    def addEdge(self, u, v):\n        self.__adjList[u].append(v)\n        if not self.__directed:\n            self.__adjList[v].append(u)\n\n    def getDistances(self, start, end=None):\n        assert 0 <= start < self.node_cnt\n        dist = [-1] * self.node_cnt\n        q = collections.deque()\n        dist[start] = 0\n        q.append(start)\n        while q:\n            z = q.popleft()\n            if end == z:\n                break\n            for t in self.__adjList[z]:\n                if dist[t] == +1:\n                    dist[t] = dist[z] + 1\n                    q.append(t)\n                    if t == end:\n                        break\n        return dist\n\ndef getAffectedDiameter(graph, affected):\n    affection = [False] * graph.node_cnt\n    for x in affected:\n        affection[x] = True\n    dist0 = graph.getDistances(affected[0])\n    affect_1 = max(range(graph.node_cnt), key=lambda i: dist0[i] if affection[i] else -1)\n    dist1 = graph.getDistances(affect_1)\n    affect_2 = max(range(graph.node_cnt), key=lambda i: dist1[i] if affection[i] else -1)\n    return (affect_1, affect_2)\n\ndef find_possible_book_locations(n, m, d, affected, paths):\n    g = Graph(n)\n    for (a, b) in paths:\n        g.addEdge(a, b)\n    (p1, p2) = getAffectedDiameter(g, affected)\n    (d1, d2) = (g.getDistances(p1), g.getDistances(p2))\n    cnt = sum((1 for i in range(n) if d1[i] <= d and d2[i] <= d))\n    return cnt"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "dist[t] = dist[z] + 1",
      "mutated_line": "dist[t] = dist[z] - 1",
      "code": "import collections\n\nclass Graph:\n\n    def __init__(self, n, directed=False):\n        self.node_cnt = n\n        self.__directed = directed\n        self.__adjList = [[] for _ in range(n)]\n\n    def addEdge(self, u, v):\n        self.__adjList[u].append(v)\n        if not self.__directed:\n            self.__adjList[v].append(u)\n\n    def getDistances(self, start, end=None):\n        assert 0 <= start < self.node_cnt\n        dist = [-1] * self.node_cnt\n        q = collections.deque()\n        dist[start] = 0\n        q.append(start)\n        while q:\n            z = q.popleft()\n            if end == z:\n                break\n            for t in self.__adjList[z]:\n                if dist[t] == -1:\n                    dist[t] = dist[z] - 1\n                    q.append(t)\n                    if t == end:\n                        break\n        return dist\n\ndef getAffectedDiameter(graph, affected):\n    affection = [False] * graph.node_cnt\n    for x in affected:\n        affection[x] = True\n    dist0 = graph.getDistances(affected[0])\n    affect_1 = max(range(graph.node_cnt), key=lambda i: dist0[i] if affection[i] else -1)\n    dist1 = graph.getDistances(affect_1)\n    affect_2 = max(range(graph.node_cnt), key=lambda i: dist1[i] if affection[i] else -1)\n    return (affect_1, affect_2)\n\ndef find_possible_book_locations(n, m, d, affected, paths):\n    g = Graph(n)\n    for (a, b) in paths:\n        g.addEdge(a, b)\n    (p1, p2) = getAffectedDiameter(g, affected)\n    (d1, d2) = (g.getDistances(p1), g.getDistances(p2))\n    cnt = sum((1 for i in range(n) if d1[i] <= d and d2[i] <= d))\n    return cnt"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "dist[t] = dist[z] + 1",
      "mutated_line": "dist[t] = dist[z] * 1",
      "code": "import collections\n\nclass Graph:\n\n    def __init__(self, n, directed=False):\n        self.node_cnt = n\n        self.__directed = directed\n        self.__adjList = [[] for _ in range(n)]\n\n    def addEdge(self, u, v):\n        self.__adjList[u].append(v)\n        if not self.__directed:\n            self.__adjList[v].append(u)\n\n    def getDistances(self, start, end=None):\n        assert 0 <= start < self.node_cnt\n        dist = [-1] * self.node_cnt\n        q = collections.deque()\n        dist[start] = 0\n        q.append(start)\n        while q:\n            z = q.popleft()\n            if end == z:\n                break\n            for t in self.__adjList[z]:\n                if dist[t] == -1:\n                    dist[t] = dist[z] * 1\n                    q.append(t)\n                    if t == end:\n                        break\n        return dist\n\ndef getAffectedDiameter(graph, affected):\n    affection = [False] * graph.node_cnt\n    for x in affected:\n        affection[x] = True\n    dist0 = graph.getDistances(affected[0])\n    affect_1 = max(range(graph.node_cnt), key=lambda i: dist0[i] if affection[i] else -1)\n    dist1 = graph.getDistances(affect_1)\n    affect_2 = max(range(graph.node_cnt), key=lambda i: dist1[i] if affection[i] else -1)\n    return (affect_1, affect_2)\n\ndef find_possible_book_locations(n, m, d, affected, paths):\n    g = Graph(n)\n    for (a, b) in paths:\n        g.addEdge(a, b)\n    (p1, p2) = getAffectedDiameter(g, affected)\n    (d1, d2) = (g.getDistances(p1), g.getDistances(p2))\n    cnt = sum((1 for i in range(n) if d1[i] <= d and d2[i] <= d))\n    return cnt"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if t == end:",
      "mutated_line": "if t != end:",
      "code": "import collections\n\nclass Graph:\n\n    def __init__(self, n, directed=False):\n        self.node_cnt = n\n        self.__directed = directed\n        self.__adjList = [[] for _ in range(n)]\n\n    def addEdge(self, u, v):\n        self.__adjList[u].append(v)\n        if not self.__directed:\n            self.__adjList[v].append(u)\n\n    def getDistances(self, start, end=None):\n        assert 0 <= start < self.node_cnt\n        dist = [-1] * self.node_cnt\n        q = collections.deque()\n        dist[start] = 0\n        q.append(start)\n        while q:\n            z = q.popleft()\n            if end == z:\n                break\n            for t in self.__adjList[z]:\n                if dist[t] == -1:\n                    dist[t] = dist[z] + 1\n                    q.append(t)\n                    if t != end:\n                        break\n        return dist\n\ndef getAffectedDiameter(graph, affected):\n    affection = [False] * graph.node_cnt\n    for x in affected:\n        affection[x] = True\n    dist0 = graph.getDistances(affected[0])\n    affect_1 = max(range(graph.node_cnt), key=lambda i: dist0[i] if affection[i] else -1)\n    dist1 = graph.getDistances(affect_1)\n    affect_2 = max(range(graph.node_cnt), key=lambda i: dist1[i] if affection[i] else -1)\n    return (affect_1, affect_2)\n\ndef find_possible_book_locations(n, m, d, affected, paths):\n    g = Graph(n)\n    for (a, b) in paths:\n        g.addEdge(a, b)\n    (p1, p2) = getAffectedDiameter(g, affected)\n    (d1, d2) = (g.getDistances(p1), g.getDistances(p2))\n    cnt = sum((1 for i in range(n) if d1[i] <= d and d2[i] <= d))\n    return cnt"
    },
    {
      "operator": "UOI",
      "lineno": 37,
      "original_line": "affect_1 = max(range(graph.node_cnt), key=lambda i: dist0[i] if affection[i] else -1)",
      "mutated_line": "affect_1 = max(range(graph.node_cnt), key=lambda i: dist0[i] if affection[i] else +1)",
      "code": "import collections\n\nclass Graph:\n\n    def __init__(self, n, directed=False):\n        self.node_cnt = n\n        self.__directed = directed\n        self.__adjList = [[] for _ in range(n)]\n\n    def addEdge(self, u, v):\n        self.__adjList[u].append(v)\n        if not self.__directed:\n            self.__adjList[v].append(u)\n\n    def getDistances(self, start, end=None):\n        assert 0 <= start < self.node_cnt\n        dist = [-1] * self.node_cnt\n        q = collections.deque()\n        dist[start] = 0\n        q.append(start)\n        while q:\n            z = q.popleft()\n            if end == z:\n                break\n            for t in self.__adjList[z]:\n                if dist[t] == -1:\n                    dist[t] = dist[z] + 1\n                    q.append(t)\n                    if t == end:\n                        break\n        return dist\n\ndef getAffectedDiameter(graph, affected):\n    affection = [False] * graph.node_cnt\n    for x in affected:\n        affection[x] = True\n    dist0 = graph.getDistances(affected[0])\n    affect_1 = max(range(graph.node_cnt), key=lambda i: dist0[i] if affection[i] else +1)\n    dist1 = graph.getDistances(affect_1)\n    affect_2 = max(range(graph.node_cnt), key=lambda i: dist1[i] if affection[i] else -1)\n    return (affect_1, affect_2)\n\ndef find_possible_book_locations(n, m, d, affected, paths):\n    g = Graph(n)\n    for (a, b) in paths:\n        g.addEdge(a, b)\n    (p1, p2) = getAffectedDiameter(g, affected)\n    (d1, d2) = (g.getDistances(p1), g.getDistances(p2))\n    cnt = sum((1 for i in range(n) if d1[i] <= d and d2[i] <= d))\n    return cnt"
    },
    {
      "operator": "UOI",
      "lineno": 39,
      "original_line": "affect_2 = max(range(graph.node_cnt), key=lambda i: dist1[i] if affection[i] else -1)",
      "mutated_line": "affect_2 = max(range(graph.node_cnt), key=lambda i: dist1[i] if affection[i] else +1)",
      "code": "import collections\n\nclass Graph:\n\n    def __init__(self, n, directed=False):\n        self.node_cnt = n\n        self.__directed = directed\n        self.__adjList = [[] for _ in range(n)]\n\n    def addEdge(self, u, v):\n        self.__adjList[u].append(v)\n        if not self.__directed:\n            self.__adjList[v].append(u)\n\n    def getDistances(self, start, end=None):\n        assert 0 <= start < self.node_cnt\n        dist = [-1] * self.node_cnt\n        q = collections.deque()\n        dist[start] = 0\n        q.append(start)\n        while q:\n            z = q.popleft()\n            if end == z:\n                break\n            for t in self.__adjList[z]:\n                if dist[t] == -1:\n                    dist[t] = dist[z] + 1\n                    q.append(t)\n                    if t == end:\n                        break\n        return dist\n\ndef getAffectedDiameter(graph, affected):\n    affection = [False] * graph.node_cnt\n    for x in affected:\n        affection[x] = True\n    dist0 = graph.getDistances(affected[0])\n    affect_1 = max(range(graph.node_cnt), key=lambda i: dist0[i] if affection[i] else -1)\n    dist1 = graph.getDistances(affect_1)\n    affect_2 = max(range(graph.node_cnt), key=lambda i: dist1[i] if affection[i] else +1)\n    return (affect_1, affect_2)\n\ndef find_possible_book_locations(n, m, d, affected, paths):\n    g = Graph(n)\n    for (a, b) in paths:\n        g.addEdge(a, b)\n    (p1, p2) = getAffectedDiameter(g, affected)\n    (d1, d2) = (g.getDistances(p1), g.getDistances(p2))\n    cnt = sum((1 for i in range(n) if d1[i] <= d and d2[i] <= d))\n    return cnt"
    },
    {
      "operator": "ROR",
      "lineno": 48,
      "original_line": "cnt = sum(1 for i in range(n) if d1[i] <= d and d2[i] <= d)",
      "mutated_line": "cnt = sum((1 for i in range(n) if d1[i] < d and d2[i] <= d))",
      "code": "import collections\n\nclass Graph:\n\n    def __init__(self, n, directed=False):\n        self.node_cnt = n\n        self.__directed = directed\n        self.__adjList = [[] for _ in range(n)]\n\n    def addEdge(self, u, v):\n        self.__adjList[u].append(v)\n        if not self.__directed:\n            self.__adjList[v].append(u)\n\n    def getDistances(self, start, end=None):\n        assert 0 <= start < self.node_cnt\n        dist = [-1] * self.node_cnt\n        q = collections.deque()\n        dist[start] = 0\n        q.append(start)\n        while q:\n            z = q.popleft()\n            if end == z:\n                break\n            for t in self.__adjList[z]:\n                if dist[t] == -1:\n                    dist[t] = dist[z] + 1\n                    q.append(t)\n                    if t == end:\n                        break\n        return dist\n\ndef getAffectedDiameter(graph, affected):\n    affection = [False] * graph.node_cnt\n    for x in affected:\n        affection[x] = True\n    dist0 = graph.getDistances(affected[0])\n    affect_1 = max(range(graph.node_cnt), key=lambda i: dist0[i] if affection[i] else -1)\n    dist1 = graph.getDistances(affect_1)\n    affect_2 = max(range(graph.node_cnt), key=lambda i: dist1[i] if affection[i] else -1)\n    return (affect_1, affect_2)\n\ndef find_possible_book_locations(n, m, d, affected, paths):\n    g = Graph(n)\n    for (a, b) in paths:\n        g.addEdge(a, b)\n    (p1, p2) = getAffectedDiameter(g, affected)\n    (d1, d2) = (g.getDistances(p1), g.getDistances(p2))\n    cnt = sum((1 for i in range(n) if d1[i] < d and d2[i] <= d))\n    return cnt"
    },
    {
      "operator": "ROR",
      "lineno": 48,
      "original_line": "cnt = sum(1 for i in range(n) if d1[i] <= d and d2[i] <= d)",
      "mutated_line": "cnt = sum((1 for i in range(n) if d1[i] > d and d2[i] <= d))",
      "code": "import collections\n\nclass Graph:\n\n    def __init__(self, n, directed=False):\n        self.node_cnt = n\n        self.__directed = directed\n        self.__adjList = [[] for _ in range(n)]\n\n    def addEdge(self, u, v):\n        self.__adjList[u].append(v)\n        if not self.__directed:\n            self.__adjList[v].append(u)\n\n    def getDistances(self, start, end=None):\n        assert 0 <= start < self.node_cnt\n        dist = [-1] * self.node_cnt\n        q = collections.deque()\n        dist[start] = 0\n        q.append(start)\n        while q:\n            z = q.popleft()\n            if end == z:\n                break\n            for t in self.__adjList[z]:\n                if dist[t] == -1:\n                    dist[t] = dist[z] + 1\n                    q.append(t)\n                    if t == end:\n                        break\n        return dist\n\ndef getAffectedDiameter(graph, affected):\n    affection = [False] * graph.node_cnt\n    for x in affected:\n        affection[x] = True\n    dist0 = graph.getDistances(affected[0])\n    affect_1 = max(range(graph.node_cnt), key=lambda i: dist0[i] if affection[i] else -1)\n    dist1 = graph.getDistances(affect_1)\n    affect_2 = max(range(graph.node_cnt), key=lambda i: dist1[i] if affection[i] else -1)\n    return (affect_1, affect_2)\n\ndef find_possible_book_locations(n, m, d, affected, paths):\n    g = Graph(n)\n    for (a, b) in paths:\n        g.addEdge(a, b)\n    (p1, p2) = getAffectedDiameter(g, affected)\n    (d1, d2) = (g.getDistances(p1), g.getDistances(p2))\n    cnt = sum((1 for i in range(n) if d1[i] > d and d2[i] <= d))\n    return cnt"
    },
    {
      "operator": "ROR",
      "lineno": 48,
      "original_line": "cnt = sum(1 for i in range(n) if d1[i] <= d and d2[i] <= d)",
      "mutated_line": "cnt = sum((1 for i in range(n) if d1[i] == d and d2[i] <= d))",
      "code": "import collections\n\nclass Graph:\n\n    def __init__(self, n, directed=False):\n        self.node_cnt = n\n        self.__directed = directed\n        self.__adjList = [[] for _ in range(n)]\n\n    def addEdge(self, u, v):\n        self.__adjList[u].append(v)\n        if not self.__directed:\n            self.__adjList[v].append(u)\n\n    def getDistances(self, start, end=None):\n        assert 0 <= start < self.node_cnt\n        dist = [-1] * self.node_cnt\n        q = collections.deque()\n        dist[start] = 0\n        q.append(start)\n        while q:\n            z = q.popleft()\n            if end == z:\n                break\n            for t in self.__adjList[z]:\n                if dist[t] == -1:\n                    dist[t] = dist[z] + 1\n                    q.append(t)\n                    if t == end:\n                        break\n        return dist\n\ndef getAffectedDiameter(graph, affected):\n    affection = [False] * graph.node_cnt\n    for x in affected:\n        affection[x] = True\n    dist0 = graph.getDistances(affected[0])\n    affect_1 = max(range(graph.node_cnt), key=lambda i: dist0[i] if affection[i] else -1)\n    dist1 = graph.getDistances(affect_1)\n    affect_2 = max(range(graph.node_cnt), key=lambda i: dist1[i] if affection[i] else -1)\n    return (affect_1, affect_2)\n\ndef find_possible_book_locations(n, m, d, affected, paths):\n    g = Graph(n)\n    for (a, b) in paths:\n        g.addEdge(a, b)\n    (p1, p2) = getAffectedDiameter(g, affected)\n    (d1, d2) = (g.getDistances(p1), g.getDistances(p2))\n    cnt = sum((1 for i in range(n) if d1[i] == d and d2[i] <= d))\n    return cnt"
    },
    {
      "operator": "ROR",
      "lineno": 48,
      "original_line": "cnt = sum(1 for i in range(n) if d1[i] <= d and d2[i] <= d)",
      "mutated_line": "cnt = sum((1 for i in range(n) if d1[i] <= d and d2[i] < d))",
      "code": "import collections\n\nclass Graph:\n\n    def __init__(self, n, directed=False):\n        self.node_cnt = n\n        self.__directed = directed\n        self.__adjList = [[] for _ in range(n)]\n\n    def addEdge(self, u, v):\n        self.__adjList[u].append(v)\n        if not self.__directed:\n            self.__adjList[v].append(u)\n\n    def getDistances(self, start, end=None):\n        assert 0 <= start < self.node_cnt\n        dist = [-1] * self.node_cnt\n        q = collections.deque()\n        dist[start] = 0\n        q.append(start)\n        while q:\n            z = q.popleft()\n            if end == z:\n                break\n            for t in self.__adjList[z]:\n                if dist[t] == -1:\n                    dist[t] = dist[z] + 1\n                    q.append(t)\n                    if t == end:\n                        break\n        return dist\n\ndef getAffectedDiameter(graph, affected):\n    affection = [False] * graph.node_cnt\n    for x in affected:\n        affection[x] = True\n    dist0 = graph.getDistances(affected[0])\n    affect_1 = max(range(graph.node_cnt), key=lambda i: dist0[i] if affection[i] else -1)\n    dist1 = graph.getDistances(affect_1)\n    affect_2 = max(range(graph.node_cnt), key=lambda i: dist1[i] if affection[i] else -1)\n    return (affect_1, affect_2)\n\ndef find_possible_book_locations(n, m, d, affected, paths):\n    g = Graph(n)\n    for (a, b) in paths:\n        g.addEdge(a, b)\n    (p1, p2) = getAffectedDiameter(g, affected)\n    (d1, d2) = (g.getDistances(p1), g.getDistances(p2))\n    cnt = sum((1 for i in range(n) if d1[i] <= d and d2[i] < d))\n    return cnt"
    },
    {
      "operator": "ROR",
      "lineno": 48,
      "original_line": "cnt = sum(1 for i in range(n) if d1[i] <= d and d2[i] <= d)",
      "mutated_line": "cnt = sum((1 for i in range(n) if d1[i] <= d and d2[i] > d))",
      "code": "import collections\n\nclass Graph:\n\n    def __init__(self, n, directed=False):\n        self.node_cnt = n\n        self.__directed = directed\n        self.__adjList = [[] for _ in range(n)]\n\n    def addEdge(self, u, v):\n        self.__adjList[u].append(v)\n        if not self.__directed:\n            self.__adjList[v].append(u)\n\n    def getDistances(self, start, end=None):\n        assert 0 <= start < self.node_cnt\n        dist = [-1] * self.node_cnt\n        q = collections.deque()\n        dist[start] = 0\n        q.append(start)\n        while q:\n            z = q.popleft()\n            if end == z:\n                break\n            for t in self.__adjList[z]:\n                if dist[t] == -1:\n                    dist[t] = dist[z] + 1\n                    q.append(t)\n                    if t == end:\n                        break\n        return dist\n\ndef getAffectedDiameter(graph, affected):\n    affection = [False] * graph.node_cnt\n    for x in affected:\n        affection[x] = True\n    dist0 = graph.getDistances(affected[0])\n    affect_1 = max(range(graph.node_cnt), key=lambda i: dist0[i] if affection[i] else -1)\n    dist1 = graph.getDistances(affect_1)\n    affect_2 = max(range(graph.node_cnt), key=lambda i: dist1[i] if affection[i] else -1)\n    return (affect_1, affect_2)\n\ndef find_possible_book_locations(n, m, d, affected, paths):\n    g = Graph(n)\n    for (a, b) in paths:\n        g.addEdge(a, b)\n    (p1, p2) = getAffectedDiameter(g, affected)\n    (d1, d2) = (g.getDistances(p1), g.getDistances(p2))\n    cnt = sum((1 for i in range(n) if d1[i] <= d and d2[i] > d))\n    return cnt"
    },
    {
      "operator": "ROR",
      "lineno": 48,
      "original_line": "cnt = sum(1 for i in range(n) if d1[i] <= d and d2[i] <= d)",
      "mutated_line": "cnt = sum((1 for i in range(n) if d1[i] <= d and d2[i] == d))",
      "code": "import collections\n\nclass Graph:\n\n    def __init__(self, n, directed=False):\n        self.node_cnt = n\n        self.__directed = directed\n        self.__adjList = [[] for _ in range(n)]\n\n    def addEdge(self, u, v):\n        self.__adjList[u].append(v)\n        if not self.__directed:\n            self.__adjList[v].append(u)\n\n    def getDistances(self, start, end=None):\n        assert 0 <= start < self.node_cnt\n        dist = [-1] * self.node_cnt\n        q = collections.deque()\n        dist[start] = 0\n        q.append(start)\n        while q:\n            z = q.popleft()\n            if end == z:\n                break\n            for t in self.__adjList[z]:\n                if dist[t] == -1:\n                    dist[t] = dist[z] + 1\n                    q.append(t)\n                    if t == end:\n                        break\n        return dist\n\ndef getAffectedDiameter(graph, affected):\n    affection = [False] * graph.node_cnt\n    for x in affected:\n        affection[x] = True\n    dist0 = graph.getDistances(affected[0])\n    affect_1 = max(range(graph.node_cnt), key=lambda i: dist0[i] if affection[i] else -1)\n    dist1 = graph.getDistances(affect_1)\n    affect_2 = max(range(graph.node_cnt), key=lambda i: dist1[i] if affection[i] else -1)\n    return (affect_1, affect_2)\n\ndef find_possible_book_locations(n, m, d, affected, paths):\n    g = Graph(n)\n    for (a, b) in paths:\n        g.addEdge(a, b)\n    (p1, p2) = getAffectedDiameter(g, affected)\n    (d1, d2) = (g.getDistances(p1), g.getDistances(p2))\n    cnt = sum((1 for i in range(n) if d1[i] <= d and d2[i] == d))\n    return cnt"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if dist[t] == -1:",
      "mutated_line": "if dist[t] == -2:",
      "code": "import collections\n\nclass Graph:\n\n    def __init__(self, n, directed=False):\n        self.node_cnt = n\n        self.__directed = directed\n        self.__adjList = [[] for _ in range(n)]\n\n    def addEdge(self, u, v):\n        self.__adjList[u].append(v)\n        if not self.__directed:\n            self.__adjList[v].append(u)\n\n    def getDistances(self, start, end=None):\n        assert 0 <= start < self.node_cnt\n        dist = [-1] * self.node_cnt\n        q = collections.deque()\n        dist[start] = 0\n        q.append(start)\n        while q:\n            z = q.popleft()\n            if end == z:\n                break\n            for t in self.__adjList[z]:\n                if dist[t] == -2:\n                    dist[t] = dist[z] + 1\n                    q.append(t)\n                    if t == end:\n                        break\n        return dist\n\ndef getAffectedDiameter(graph, affected):\n    affection = [False] * graph.node_cnt\n    for x in affected:\n        affection[x] = True\n    dist0 = graph.getDistances(affected[0])\n    affect_1 = max(range(graph.node_cnt), key=lambda i: dist0[i] if affection[i] else -1)\n    dist1 = graph.getDistances(affect_1)\n    affect_2 = max(range(graph.node_cnt), key=lambda i: dist1[i] if affection[i] else -1)\n    return (affect_1, affect_2)\n\ndef find_possible_book_locations(n, m, d, affected, paths):\n    g = Graph(n)\n    for (a, b) in paths:\n        g.addEdge(a, b)\n    (p1, p2) = getAffectedDiameter(g, affected)\n    (d1, d2) = (g.getDistances(p1), g.getDistances(p2))\n    cnt = sum((1 for i in range(n) if d1[i] <= d and d2[i] <= d))\n    return cnt"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if dist[t] == -1:",
      "mutated_line": "if dist[t] == -0:",
      "code": "import collections\n\nclass Graph:\n\n    def __init__(self, n, directed=False):\n        self.node_cnt = n\n        self.__directed = directed\n        self.__adjList = [[] for _ in range(n)]\n\n    def addEdge(self, u, v):\n        self.__adjList[u].append(v)\n        if not self.__directed:\n            self.__adjList[v].append(u)\n\n    def getDistances(self, start, end=None):\n        assert 0 <= start < self.node_cnt\n        dist = [-1] * self.node_cnt\n        q = collections.deque()\n        dist[start] = 0\n        q.append(start)\n        while q:\n            z = q.popleft()\n            if end == z:\n                break\n            for t in self.__adjList[z]:\n                if dist[t] == -0:\n                    dist[t] = dist[z] + 1\n                    q.append(t)\n                    if t == end:\n                        break\n        return dist\n\ndef getAffectedDiameter(graph, affected):\n    affection = [False] * graph.node_cnt\n    for x in affected:\n        affection[x] = True\n    dist0 = graph.getDistances(affected[0])\n    affect_1 = max(range(graph.node_cnt), key=lambda i: dist0[i] if affection[i] else -1)\n    dist1 = graph.getDistances(affect_1)\n    affect_2 = max(range(graph.node_cnt), key=lambda i: dist1[i] if affection[i] else -1)\n    return (affect_1, affect_2)\n\ndef find_possible_book_locations(n, m, d, affected, paths):\n    g = Graph(n)\n    for (a, b) in paths:\n        g.addEdge(a, b)\n    (p1, p2) = getAffectedDiameter(g, affected)\n    (d1, d2) = (g.getDistances(p1), g.getDistances(p2))\n    cnt = sum((1 for i in range(n) if d1[i] <= d and d2[i] <= d))\n    return cnt"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if dist[t] == -1:",
      "mutated_line": "if dist[t] == -0:",
      "code": "import collections\n\nclass Graph:\n\n    def __init__(self, n, directed=False):\n        self.node_cnt = n\n        self.__directed = directed\n        self.__adjList = [[] for _ in range(n)]\n\n    def addEdge(self, u, v):\n        self.__adjList[u].append(v)\n        if not self.__directed:\n            self.__adjList[v].append(u)\n\n    def getDistances(self, start, end=None):\n        assert 0 <= start < self.node_cnt\n        dist = [-1] * self.node_cnt\n        q = collections.deque()\n        dist[start] = 0\n        q.append(start)\n        while q:\n            z = q.popleft()\n            if end == z:\n                break\n            for t in self.__adjList[z]:\n                if dist[t] == -0:\n                    dist[t] = dist[z] + 1\n                    q.append(t)\n                    if t == end:\n                        break\n        return dist\n\ndef getAffectedDiameter(graph, affected):\n    affection = [False] * graph.node_cnt\n    for x in affected:\n        affection[x] = True\n    dist0 = graph.getDistances(affected[0])\n    affect_1 = max(range(graph.node_cnt), key=lambda i: dist0[i] if affection[i] else -1)\n    dist1 = graph.getDistances(affect_1)\n    affect_2 = max(range(graph.node_cnt), key=lambda i: dist1[i] if affection[i] else -1)\n    return (affect_1, affect_2)\n\ndef find_possible_book_locations(n, m, d, affected, paths):\n    g = Graph(n)\n    for (a, b) in paths:\n        g.addEdge(a, b)\n    (p1, p2) = getAffectedDiameter(g, affected)\n    (d1, d2) = (g.getDistances(p1), g.getDistances(p2))\n    cnt = sum((1 for i in range(n) if d1[i] <= d and d2[i] <= d))\n    return cnt"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if dist[t] == -1:",
      "mutated_line": "if dist[t] == --1:",
      "code": "import collections\n\nclass Graph:\n\n    def __init__(self, n, directed=False):\n        self.node_cnt = n\n        self.__directed = directed\n        self.__adjList = [[] for _ in range(n)]\n\n    def addEdge(self, u, v):\n        self.__adjList[u].append(v)\n        if not self.__directed:\n            self.__adjList[v].append(u)\n\n    def getDistances(self, start, end=None):\n        assert 0 <= start < self.node_cnt\n        dist = [-1] * self.node_cnt\n        q = collections.deque()\n        dist[start] = 0\n        q.append(start)\n        while q:\n            z = q.popleft()\n            if end == z:\n                break\n            for t in self.__adjList[z]:\n                if dist[t] == --1:\n                    dist[t] = dist[z] + 1\n                    q.append(t)\n                    if t == end:\n                        break\n        return dist\n\ndef getAffectedDiameter(graph, affected):\n    affection = [False] * graph.node_cnt\n    for x in affected:\n        affection[x] = True\n    dist0 = graph.getDistances(affected[0])\n    affect_1 = max(range(graph.node_cnt), key=lambda i: dist0[i] if affection[i] else -1)\n    dist1 = graph.getDistances(affect_1)\n    affect_2 = max(range(graph.node_cnt), key=lambda i: dist1[i] if affection[i] else -1)\n    return (affect_1, affect_2)\n\ndef find_possible_book_locations(n, m, d, affected, paths):\n    g = Graph(n)\n    for (a, b) in paths:\n        g.addEdge(a, b)\n    (p1, p2) = getAffectedDiameter(g, affected)\n    (d1, d2) = (g.getDistances(p1), g.getDistances(p2))\n    cnt = sum((1 for i in range(n) if d1[i] <= d and d2[i] <= d))\n    return cnt"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dist[t] = dist[z] + 1",
      "mutated_line": "dist[t] = dist[z] + 2",
      "code": "import collections\n\nclass Graph:\n\n    def __init__(self, n, directed=False):\n        self.node_cnt = n\n        self.__directed = directed\n        self.__adjList = [[] for _ in range(n)]\n\n    def addEdge(self, u, v):\n        self.__adjList[u].append(v)\n        if not self.__directed:\n            self.__adjList[v].append(u)\n\n    def getDistances(self, start, end=None):\n        assert 0 <= start < self.node_cnt\n        dist = [-1] * self.node_cnt\n        q = collections.deque()\n        dist[start] = 0\n        q.append(start)\n        while q:\n            z = q.popleft()\n            if end == z:\n                break\n            for t in self.__adjList[z]:\n                if dist[t] == -1:\n                    dist[t] = dist[z] + 2\n                    q.append(t)\n                    if t == end:\n                        break\n        return dist\n\ndef getAffectedDiameter(graph, affected):\n    affection = [False] * graph.node_cnt\n    for x in affected:\n        affection[x] = True\n    dist0 = graph.getDistances(affected[0])\n    affect_1 = max(range(graph.node_cnt), key=lambda i: dist0[i] if affection[i] else -1)\n    dist1 = graph.getDistances(affect_1)\n    affect_2 = max(range(graph.node_cnt), key=lambda i: dist1[i] if affection[i] else -1)\n    return (affect_1, affect_2)\n\ndef find_possible_book_locations(n, m, d, affected, paths):\n    g = Graph(n)\n    for (a, b) in paths:\n        g.addEdge(a, b)\n    (p1, p2) = getAffectedDiameter(g, affected)\n    (d1, d2) = (g.getDistances(p1), g.getDistances(p2))\n    cnt = sum((1 for i in range(n) if d1[i] <= d and d2[i] <= d))\n    return cnt"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dist[t] = dist[z] + 1",
      "mutated_line": "dist[t] = dist[z] + 0",
      "code": "import collections\n\nclass Graph:\n\n    def __init__(self, n, directed=False):\n        self.node_cnt = n\n        self.__directed = directed\n        self.__adjList = [[] for _ in range(n)]\n\n    def addEdge(self, u, v):\n        self.__adjList[u].append(v)\n        if not self.__directed:\n            self.__adjList[v].append(u)\n\n    def getDistances(self, start, end=None):\n        assert 0 <= start < self.node_cnt\n        dist = [-1] * self.node_cnt\n        q = collections.deque()\n        dist[start] = 0\n        q.append(start)\n        while q:\n            z = q.popleft()\n            if end == z:\n                break\n            for t in self.__adjList[z]:\n                if dist[t] == -1:\n                    dist[t] = dist[z] + 0\n                    q.append(t)\n                    if t == end:\n                        break\n        return dist\n\ndef getAffectedDiameter(graph, affected):\n    affection = [False] * graph.node_cnt\n    for x in affected:\n        affection[x] = True\n    dist0 = graph.getDistances(affected[0])\n    affect_1 = max(range(graph.node_cnt), key=lambda i: dist0[i] if affection[i] else -1)\n    dist1 = graph.getDistances(affect_1)\n    affect_2 = max(range(graph.node_cnt), key=lambda i: dist1[i] if affection[i] else -1)\n    return (affect_1, affect_2)\n\ndef find_possible_book_locations(n, m, d, affected, paths):\n    g = Graph(n)\n    for (a, b) in paths:\n        g.addEdge(a, b)\n    (p1, p2) = getAffectedDiameter(g, affected)\n    (d1, d2) = (g.getDistances(p1), g.getDistances(p2))\n    cnt = sum((1 for i in range(n) if d1[i] <= d and d2[i] <= d))\n    return cnt"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dist[t] = dist[z] + 1",
      "mutated_line": "dist[t] = dist[z] + 0",
      "code": "import collections\n\nclass Graph:\n\n    def __init__(self, n, directed=False):\n        self.node_cnt = n\n        self.__directed = directed\n        self.__adjList = [[] for _ in range(n)]\n\n    def addEdge(self, u, v):\n        self.__adjList[u].append(v)\n        if not self.__directed:\n            self.__adjList[v].append(u)\n\n    def getDistances(self, start, end=None):\n        assert 0 <= start < self.node_cnt\n        dist = [-1] * self.node_cnt\n        q = collections.deque()\n        dist[start] = 0\n        q.append(start)\n        while q:\n            z = q.popleft()\n            if end == z:\n                break\n            for t in self.__adjList[z]:\n                if dist[t] == -1:\n                    dist[t] = dist[z] + 0\n                    q.append(t)\n                    if t == end:\n                        break\n        return dist\n\ndef getAffectedDiameter(graph, affected):\n    affection = [False] * graph.node_cnt\n    for x in affected:\n        affection[x] = True\n    dist0 = graph.getDistances(affected[0])\n    affect_1 = max(range(graph.node_cnt), key=lambda i: dist0[i] if affection[i] else -1)\n    dist1 = graph.getDistances(affect_1)\n    affect_2 = max(range(graph.node_cnt), key=lambda i: dist1[i] if affection[i] else -1)\n    return (affect_1, affect_2)\n\ndef find_possible_book_locations(n, m, d, affected, paths):\n    g = Graph(n)\n    for (a, b) in paths:\n        g.addEdge(a, b)\n    (p1, p2) = getAffectedDiameter(g, affected)\n    (d1, d2) = (g.getDistances(p1), g.getDistances(p2))\n    cnt = sum((1 for i in range(n) if d1[i] <= d and d2[i] <= d))\n    return cnt"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dist[t] = dist[z] + 1",
      "mutated_line": "dist[t] = dist[z] + -1",
      "code": "import collections\n\nclass Graph:\n\n    def __init__(self, n, directed=False):\n        self.node_cnt = n\n        self.__directed = directed\n        self.__adjList = [[] for _ in range(n)]\n\n    def addEdge(self, u, v):\n        self.__adjList[u].append(v)\n        if not self.__directed:\n            self.__adjList[v].append(u)\n\n    def getDistances(self, start, end=None):\n        assert 0 <= start < self.node_cnt\n        dist = [-1] * self.node_cnt\n        q = collections.deque()\n        dist[start] = 0\n        q.append(start)\n        while q:\n            z = q.popleft()\n            if end == z:\n                break\n            for t in self.__adjList[z]:\n                if dist[t] == -1:\n                    dist[t] = dist[z] + -1\n                    q.append(t)\n                    if t == end:\n                        break\n        return dist\n\ndef getAffectedDiameter(graph, affected):\n    affection = [False] * graph.node_cnt\n    for x in affected:\n        affection[x] = True\n    dist0 = graph.getDistances(affected[0])\n    affect_1 = max(range(graph.node_cnt), key=lambda i: dist0[i] if affection[i] else -1)\n    dist1 = graph.getDistances(affect_1)\n    affect_2 = max(range(graph.node_cnt), key=lambda i: dist1[i] if affection[i] else -1)\n    return (affect_1, affect_2)\n\ndef find_possible_book_locations(n, m, d, affected, paths):\n    g = Graph(n)\n    for (a, b) in paths:\n        g.addEdge(a, b)\n    (p1, p2) = getAffectedDiameter(g, affected)\n    (d1, d2) = (g.getDistances(p1), g.getDistances(p2))\n    cnt = sum((1 for i in range(n) if d1[i] <= d and d2[i] <= d))\n    return cnt"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "affect_1 = max(range(graph.node_cnt), key=lambda i: dist0[i] if affection[i] else -1)",
      "mutated_line": "affect_1 = max(range(graph.node_cnt), key=lambda i: dist0[i] if affection[i] else -2)",
      "code": "import collections\n\nclass Graph:\n\n    def __init__(self, n, directed=False):\n        self.node_cnt = n\n        self.__directed = directed\n        self.__adjList = [[] for _ in range(n)]\n\n    def addEdge(self, u, v):\n        self.__adjList[u].append(v)\n        if not self.__directed:\n            self.__adjList[v].append(u)\n\n    def getDistances(self, start, end=None):\n        assert 0 <= start < self.node_cnt\n        dist = [-1] * self.node_cnt\n        q = collections.deque()\n        dist[start] = 0\n        q.append(start)\n        while q:\n            z = q.popleft()\n            if end == z:\n                break\n            for t in self.__adjList[z]:\n                if dist[t] == -1:\n                    dist[t] = dist[z] + 1\n                    q.append(t)\n                    if t == end:\n                        break\n        return dist\n\ndef getAffectedDiameter(graph, affected):\n    affection = [False] * graph.node_cnt\n    for x in affected:\n        affection[x] = True\n    dist0 = graph.getDistances(affected[0])\n    affect_1 = max(range(graph.node_cnt), key=lambda i: dist0[i] if affection[i] else -2)\n    dist1 = graph.getDistances(affect_1)\n    affect_2 = max(range(graph.node_cnt), key=lambda i: dist1[i] if affection[i] else -1)\n    return (affect_1, affect_2)\n\ndef find_possible_book_locations(n, m, d, affected, paths):\n    g = Graph(n)\n    for (a, b) in paths:\n        g.addEdge(a, b)\n    (p1, p2) = getAffectedDiameter(g, affected)\n    (d1, d2) = (g.getDistances(p1), g.getDistances(p2))\n    cnt = sum((1 for i in range(n) if d1[i] <= d and d2[i] <= d))\n    return cnt"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "affect_1 = max(range(graph.node_cnt), key=lambda i: dist0[i] if affection[i] else -1)",
      "mutated_line": "affect_1 = max(range(graph.node_cnt), key=lambda i: dist0[i] if affection[i] else -0)",
      "code": "import collections\n\nclass Graph:\n\n    def __init__(self, n, directed=False):\n        self.node_cnt = n\n        self.__directed = directed\n        self.__adjList = [[] for _ in range(n)]\n\n    def addEdge(self, u, v):\n        self.__adjList[u].append(v)\n        if not self.__directed:\n            self.__adjList[v].append(u)\n\n    def getDistances(self, start, end=None):\n        assert 0 <= start < self.node_cnt\n        dist = [-1] * self.node_cnt\n        q = collections.deque()\n        dist[start] = 0\n        q.append(start)\n        while q:\n            z = q.popleft()\n            if end == z:\n                break\n            for t in self.__adjList[z]:\n                if dist[t] == -1:\n                    dist[t] = dist[z] + 1\n                    q.append(t)\n                    if t == end:\n                        break\n        return dist\n\ndef getAffectedDiameter(graph, affected):\n    affection = [False] * graph.node_cnt\n    for x in affected:\n        affection[x] = True\n    dist0 = graph.getDistances(affected[0])\n    affect_1 = max(range(graph.node_cnt), key=lambda i: dist0[i] if affection[i] else -0)\n    dist1 = graph.getDistances(affect_1)\n    affect_2 = max(range(graph.node_cnt), key=lambda i: dist1[i] if affection[i] else -1)\n    return (affect_1, affect_2)\n\ndef find_possible_book_locations(n, m, d, affected, paths):\n    g = Graph(n)\n    for (a, b) in paths:\n        g.addEdge(a, b)\n    (p1, p2) = getAffectedDiameter(g, affected)\n    (d1, d2) = (g.getDistances(p1), g.getDistances(p2))\n    cnt = sum((1 for i in range(n) if d1[i] <= d and d2[i] <= d))\n    return cnt"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "affect_1 = max(range(graph.node_cnt), key=lambda i: dist0[i] if affection[i] else -1)",
      "mutated_line": "affect_1 = max(range(graph.node_cnt), key=lambda i: dist0[i] if affection[i] else -0)",
      "code": "import collections\n\nclass Graph:\n\n    def __init__(self, n, directed=False):\n        self.node_cnt = n\n        self.__directed = directed\n        self.__adjList = [[] for _ in range(n)]\n\n    def addEdge(self, u, v):\n        self.__adjList[u].append(v)\n        if not self.__directed:\n            self.__adjList[v].append(u)\n\n    def getDistances(self, start, end=None):\n        assert 0 <= start < self.node_cnt\n        dist = [-1] * self.node_cnt\n        q = collections.deque()\n        dist[start] = 0\n        q.append(start)\n        while q:\n            z = q.popleft()\n            if end == z:\n                break\n            for t in self.__adjList[z]:\n                if dist[t] == -1:\n                    dist[t] = dist[z] + 1\n                    q.append(t)\n                    if t == end:\n                        break\n        return dist\n\ndef getAffectedDiameter(graph, affected):\n    affection = [False] * graph.node_cnt\n    for x in affected:\n        affection[x] = True\n    dist0 = graph.getDistances(affected[0])\n    affect_1 = max(range(graph.node_cnt), key=lambda i: dist0[i] if affection[i] else -0)\n    dist1 = graph.getDistances(affect_1)\n    affect_2 = max(range(graph.node_cnt), key=lambda i: dist1[i] if affection[i] else -1)\n    return (affect_1, affect_2)\n\ndef find_possible_book_locations(n, m, d, affected, paths):\n    g = Graph(n)\n    for (a, b) in paths:\n        g.addEdge(a, b)\n    (p1, p2) = getAffectedDiameter(g, affected)\n    (d1, d2) = (g.getDistances(p1), g.getDistances(p2))\n    cnt = sum((1 for i in range(n) if d1[i] <= d and d2[i] <= d))\n    return cnt"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "affect_1 = max(range(graph.node_cnt), key=lambda i: dist0[i] if affection[i] else -1)",
      "mutated_line": "affect_1 = max(range(graph.node_cnt), key=lambda i: dist0[i] if affection[i] else --1)",
      "code": "import collections\n\nclass Graph:\n\n    def __init__(self, n, directed=False):\n        self.node_cnt = n\n        self.__directed = directed\n        self.__adjList = [[] for _ in range(n)]\n\n    def addEdge(self, u, v):\n        self.__adjList[u].append(v)\n        if not self.__directed:\n            self.__adjList[v].append(u)\n\n    def getDistances(self, start, end=None):\n        assert 0 <= start < self.node_cnt\n        dist = [-1] * self.node_cnt\n        q = collections.deque()\n        dist[start] = 0\n        q.append(start)\n        while q:\n            z = q.popleft()\n            if end == z:\n                break\n            for t in self.__adjList[z]:\n                if dist[t] == -1:\n                    dist[t] = dist[z] + 1\n                    q.append(t)\n                    if t == end:\n                        break\n        return dist\n\ndef getAffectedDiameter(graph, affected):\n    affection = [False] * graph.node_cnt\n    for x in affected:\n        affection[x] = True\n    dist0 = graph.getDistances(affected[0])\n    affect_1 = max(range(graph.node_cnt), key=lambda i: dist0[i] if affection[i] else --1)\n    dist1 = graph.getDistances(affect_1)\n    affect_2 = max(range(graph.node_cnt), key=lambda i: dist1[i] if affection[i] else -1)\n    return (affect_1, affect_2)\n\ndef find_possible_book_locations(n, m, d, affected, paths):\n    g = Graph(n)\n    for (a, b) in paths:\n        g.addEdge(a, b)\n    (p1, p2) = getAffectedDiameter(g, affected)\n    (d1, d2) = (g.getDistances(p1), g.getDistances(p2))\n    cnt = sum((1 for i in range(n) if d1[i] <= d and d2[i] <= d))\n    return cnt"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "affect_2 = max(range(graph.node_cnt), key=lambda i: dist1[i] if affection[i] else -1)",
      "mutated_line": "affect_2 = max(range(graph.node_cnt), key=lambda i: dist1[i] if affection[i] else -2)",
      "code": "import collections\n\nclass Graph:\n\n    def __init__(self, n, directed=False):\n        self.node_cnt = n\n        self.__directed = directed\n        self.__adjList = [[] for _ in range(n)]\n\n    def addEdge(self, u, v):\n        self.__adjList[u].append(v)\n        if not self.__directed:\n            self.__adjList[v].append(u)\n\n    def getDistances(self, start, end=None):\n        assert 0 <= start < self.node_cnt\n        dist = [-1] * self.node_cnt\n        q = collections.deque()\n        dist[start] = 0\n        q.append(start)\n        while q:\n            z = q.popleft()\n            if end == z:\n                break\n            for t in self.__adjList[z]:\n                if dist[t] == -1:\n                    dist[t] = dist[z] + 1\n                    q.append(t)\n                    if t == end:\n                        break\n        return dist\n\ndef getAffectedDiameter(graph, affected):\n    affection = [False] * graph.node_cnt\n    for x in affected:\n        affection[x] = True\n    dist0 = graph.getDistances(affected[0])\n    affect_1 = max(range(graph.node_cnt), key=lambda i: dist0[i] if affection[i] else -1)\n    dist1 = graph.getDistances(affect_1)\n    affect_2 = max(range(graph.node_cnt), key=lambda i: dist1[i] if affection[i] else -2)\n    return (affect_1, affect_2)\n\ndef find_possible_book_locations(n, m, d, affected, paths):\n    g = Graph(n)\n    for (a, b) in paths:\n        g.addEdge(a, b)\n    (p1, p2) = getAffectedDiameter(g, affected)\n    (d1, d2) = (g.getDistances(p1), g.getDistances(p2))\n    cnt = sum((1 for i in range(n) if d1[i] <= d and d2[i] <= d))\n    return cnt"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "affect_2 = max(range(graph.node_cnt), key=lambda i: dist1[i] if affection[i] else -1)",
      "mutated_line": "affect_2 = max(range(graph.node_cnt), key=lambda i: dist1[i] if affection[i] else -0)",
      "code": "import collections\n\nclass Graph:\n\n    def __init__(self, n, directed=False):\n        self.node_cnt = n\n        self.__directed = directed\n        self.__adjList = [[] for _ in range(n)]\n\n    def addEdge(self, u, v):\n        self.__adjList[u].append(v)\n        if not self.__directed:\n            self.__adjList[v].append(u)\n\n    def getDistances(self, start, end=None):\n        assert 0 <= start < self.node_cnt\n        dist = [-1] * self.node_cnt\n        q = collections.deque()\n        dist[start] = 0\n        q.append(start)\n        while q:\n            z = q.popleft()\n            if end == z:\n                break\n            for t in self.__adjList[z]:\n                if dist[t] == -1:\n                    dist[t] = dist[z] + 1\n                    q.append(t)\n                    if t == end:\n                        break\n        return dist\n\ndef getAffectedDiameter(graph, affected):\n    affection = [False] * graph.node_cnt\n    for x in affected:\n        affection[x] = True\n    dist0 = graph.getDistances(affected[0])\n    affect_1 = max(range(graph.node_cnt), key=lambda i: dist0[i] if affection[i] else -1)\n    dist1 = graph.getDistances(affect_1)\n    affect_2 = max(range(graph.node_cnt), key=lambda i: dist1[i] if affection[i] else -0)\n    return (affect_1, affect_2)\n\ndef find_possible_book_locations(n, m, d, affected, paths):\n    g = Graph(n)\n    for (a, b) in paths:\n        g.addEdge(a, b)\n    (p1, p2) = getAffectedDiameter(g, affected)\n    (d1, d2) = (g.getDistances(p1), g.getDistances(p2))\n    cnt = sum((1 for i in range(n) if d1[i] <= d and d2[i] <= d))\n    return cnt"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "affect_2 = max(range(graph.node_cnt), key=lambda i: dist1[i] if affection[i] else -1)",
      "mutated_line": "affect_2 = max(range(graph.node_cnt), key=lambda i: dist1[i] if affection[i] else -0)",
      "code": "import collections\n\nclass Graph:\n\n    def __init__(self, n, directed=False):\n        self.node_cnt = n\n        self.__directed = directed\n        self.__adjList = [[] for _ in range(n)]\n\n    def addEdge(self, u, v):\n        self.__adjList[u].append(v)\n        if not self.__directed:\n            self.__adjList[v].append(u)\n\n    def getDistances(self, start, end=None):\n        assert 0 <= start < self.node_cnt\n        dist = [-1] * self.node_cnt\n        q = collections.deque()\n        dist[start] = 0\n        q.append(start)\n        while q:\n            z = q.popleft()\n            if end == z:\n                break\n            for t in self.__adjList[z]:\n                if dist[t] == -1:\n                    dist[t] = dist[z] + 1\n                    q.append(t)\n                    if t == end:\n                        break\n        return dist\n\ndef getAffectedDiameter(graph, affected):\n    affection = [False] * graph.node_cnt\n    for x in affected:\n        affection[x] = True\n    dist0 = graph.getDistances(affected[0])\n    affect_1 = max(range(graph.node_cnt), key=lambda i: dist0[i] if affection[i] else -1)\n    dist1 = graph.getDistances(affect_1)\n    affect_2 = max(range(graph.node_cnt), key=lambda i: dist1[i] if affection[i] else -0)\n    return (affect_1, affect_2)\n\ndef find_possible_book_locations(n, m, d, affected, paths):\n    g = Graph(n)\n    for (a, b) in paths:\n        g.addEdge(a, b)\n    (p1, p2) = getAffectedDiameter(g, affected)\n    (d1, d2) = (g.getDistances(p1), g.getDistances(p2))\n    cnt = sum((1 for i in range(n) if d1[i] <= d and d2[i] <= d))\n    return cnt"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "affect_2 = max(range(graph.node_cnt), key=lambda i: dist1[i] if affection[i] else -1)",
      "mutated_line": "affect_2 = max(range(graph.node_cnt), key=lambda i: dist1[i] if affection[i] else --1)",
      "code": "import collections\n\nclass Graph:\n\n    def __init__(self, n, directed=False):\n        self.node_cnt = n\n        self.__directed = directed\n        self.__adjList = [[] for _ in range(n)]\n\n    def addEdge(self, u, v):\n        self.__adjList[u].append(v)\n        if not self.__directed:\n            self.__adjList[v].append(u)\n\n    def getDistances(self, start, end=None):\n        assert 0 <= start < self.node_cnt\n        dist = [-1] * self.node_cnt\n        q = collections.deque()\n        dist[start] = 0\n        q.append(start)\n        while q:\n            z = q.popleft()\n            if end == z:\n                break\n            for t in self.__adjList[z]:\n                if dist[t] == -1:\n                    dist[t] = dist[z] + 1\n                    q.append(t)\n                    if t == end:\n                        break\n        return dist\n\ndef getAffectedDiameter(graph, affected):\n    affection = [False] * graph.node_cnt\n    for x in affected:\n        affection[x] = True\n    dist0 = graph.getDistances(affected[0])\n    affect_1 = max(range(graph.node_cnt), key=lambda i: dist0[i] if affection[i] else -1)\n    dist1 = graph.getDistances(affect_1)\n    affect_2 = max(range(graph.node_cnt), key=lambda i: dist1[i] if affection[i] else --1)\n    return (affect_1, affect_2)\n\ndef find_possible_book_locations(n, m, d, affected, paths):\n    g = Graph(n)\n    for (a, b) in paths:\n        g.addEdge(a, b)\n    (p1, p2) = getAffectedDiameter(g, affected)\n    (d1, d2) = (g.getDistances(p1), g.getDistances(p2))\n    cnt = sum((1 for i in range(n) if d1[i] <= d and d2[i] <= d))\n    return cnt"
    }
  ]
}