{
  "task_id": "taco_231",
  "entry_point": "count_valid_sequences",
  "mutant_count": 108,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "MOD = 998244353",
      "mutated_line": "MOD = 998244354",
      "code": "MOD = 998244354\n\ndef count_valid_sequences(N, sets):\n\n    def calc(arr):\n        vars = {i: 1 for i in arr[0]}\n        for i in range(1, len(arr)):\n            tot = sum(vars.values()) % MOD\n            next = {}\n            for num in arr[i]:\n                cur = tot\n                if num in vars:\n                    cur += MOD - vars[num]\n                cur %= MOD\n                next[num] = cur\n            vars = next\n        return sum(vars.values()) % MOD\n    if N <= 450:\n        ans = 0\n        sign = False\n        while len(sets) > 1:\n            cur = calc(sets)\n            if sign:\n                cur = MOD - cur\n            ans += cur\n            ans %= MOD\n            sets[0] = list(set(sets[0]).intersection(set(sets[-1])))\n            sets[0].sort()\n            del sets[-1:]\n            sign = not sign\n        return ans\n    else:\n        best = 10 ** 15\n        mem = -1\n        saved_set = []\n        for i in range(N):\n            prev = (i + N - 1) % N\n            t = set(sets[i]).intersection(set(sets[prev]))\n            sz = len(t)\n            if sz < best:\n                best = sz\n                mem = i\n                saved_set = list(t)\n        sets = sets[mem:] + sets[:mem]\n        ans = calc(sets)\n        saved_set.sort()\n        for val in saved_set:\n            sets[0] = [val]\n            sets[-1] = [val]\n            ans += MOD - calc(sets)\n            ans %= MOD\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "MOD = 998244353",
      "mutated_line": "MOD = 998244352",
      "code": "MOD = 998244352\n\ndef count_valid_sequences(N, sets):\n\n    def calc(arr):\n        vars = {i: 1 for i in arr[0]}\n        for i in range(1, len(arr)):\n            tot = sum(vars.values()) % MOD\n            next = {}\n            for num in arr[i]:\n                cur = tot\n                if num in vars:\n                    cur += MOD - vars[num]\n                cur %= MOD\n                next[num] = cur\n            vars = next\n        return sum(vars.values()) % MOD\n    if N <= 450:\n        ans = 0\n        sign = False\n        while len(sets) > 1:\n            cur = calc(sets)\n            if sign:\n                cur = MOD - cur\n            ans += cur\n            ans %= MOD\n            sets[0] = list(set(sets[0]).intersection(set(sets[-1])))\n            sets[0].sort()\n            del sets[-1:]\n            sign = not sign\n        return ans\n    else:\n        best = 10 ** 15\n        mem = -1\n        saved_set = []\n        for i in range(N):\n            prev = (i + N - 1) % N\n            t = set(sets[i]).intersection(set(sets[prev]))\n            sz = len(t)\n            if sz < best:\n                best = sz\n                mem = i\n                saved_set = list(t)\n        sets = sets[mem:] + sets[:mem]\n        ans = calc(sets)\n        saved_set.sort()\n        for val in saved_set:\n            sets[0] = [val]\n            sets[-1] = [val]\n            ans += MOD - calc(sets)\n            ans %= MOD\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "MOD = 998244353",
      "mutated_line": "MOD = 0",
      "code": "MOD = 0\n\ndef count_valid_sequences(N, sets):\n\n    def calc(arr):\n        vars = {i: 1 for i in arr[0]}\n        for i in range(1, len(arr)):\n            tot = sum(vars.values()) % MOD\n            next = {}\n            for num in arr[i]:\n                cur = tot\n                if num in vars:\n                    cur += MOD - vars[num]\n                cur %= MOD\n                next[num] = cur\n            vars = next\n        return sum(vars.values()) % MOD\n    if N <= 450:\n        ans = 0\n        sign = False\n        while len(sets) > 1:\n            cur = calc(sets)\n            if sign:\n                cur = MOD - cur\n            ans += cur\n            ans %= MOD\n            sets[0] = list(set(sets[0]).intersection(set(sets[-1])))\n            sets[0].sort()\n            del sets[-1:]\n            sign = not sign\n        return ans\n    else:\n        best = 10 ** 15\n        mem = -1\n        saved_set = []\n        for i in range(N):\n            prev = (i + N - 1) % N\n            t = set(sets[i]).intersection(set(sets[prev]))\n            sz = len(t)\n            if sz < best:\n                best = sz\n                mem = i\n                saved_set = list(t)\n        sets = sets[mem:] + sets[:mem]\n        ans = calc(sets)\n        saved_set.sort()\n        for val in saved_set:\n            sets[0] = [val]\n            sets[-1] = [val]\n            ans += MOD - calc(sets)\n            ans %= MOD\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "MOD = 998244353",
      "mutated_line": "MOD = 1",
      "code": "MOD = 1\n\ndef count_valid_sequences(N, sets):\n\n    def calc(arr):\n        vars = {i: 1 for i in arr[0]}\n        for i in range(1, len(arr)):\n            tot = sum(vars.values()) % MOD\n            next = {}\n            for num in arr[i]:\n                cur = tot\n                if num in vars:\n                    cur += MOD - vars[num]\n                cur %= MOD\n                next[num] = cur\n            vars = next\n        return sum(vars.values()) % MOD\n    if N <= 450:\n        ans = 0\n        sign = False\n        while len(sets) > 1:\n            cur = calc(sets)\n            if sign:\n                cur = MOD - cur\n            ans += cur\n            ans %= MOD\n            sets[0] = list(set(sets[0]).intersection(set(sets[-1])))\n            sets[0].sort()\n            del sets[-1:]\n            sign = not sign\n        return ans\n    else:\n        best = 10 ** 15\n        mem = -1\n        saved_set = []\n        for i in range(N):\n            prev = (i + N - 1) % N\n            t = set(sets[i]).intersection(set(sets[prev]))\n            sz = len(t)\n            if sz < best:\n                best = sz\n                mem = i\n                saved_set = list(t)\n        sets = sets[mem:] + sets[:mem]\n        ans = calc(sets)\n        saved_set.sort()\n        for val in saved_set:\n            sets[0] = [val]\n            sets[-1] = [val]\n            ans += MOD - calc(sets)\n            ans %= MOD\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "MOD = 998244353",
      "mutated_line": "MOD = -998244353",
      "code": "MOD = -998244353\n\ndef count_valid_sequences(N, sets):\n\n    def calc(arr):\n        vars = {i: 1 for i in arr[0]}\n        for i in range(1, len(arr)):\n            tot = sum(vars.values()) % MOD\n            next = {}\n            for num in arr[i]:\n                cur = tot\n                if num in vars:\n                    cur += MOD - vars[num]\n                cur %= MOD\n                next[num] = cur\n            vars = next\n        return sum(vars.values()) % MOD\n    if N <= 450:\n        ans = 0\n        sign = False\n        while len(sets) > 1:\n            cur = calc(sets)\n            if sign:\n                cur = MOD - cur\n            ans += cur\n            ans %= MOD\n            sets[0] = list(set(sets[0]).intersection(set(sets[-1])))\n            sets[0].sort()\n            del sets[-1:]\n            sign = not sign\n        return ans\n    else:\n        best = 10 ** 15\n        mem = -1\n        saved_set = []\n        for i in range(N):\n            prev = (i + N - 1) % N\n            t = set(sets[i]).intersection(set(sets[prev]))\n            sz = len(t)\n            if sz < best:\n                best = sz\n                mem = i\n                saved_set = list(t)\n        sets = sets[mem:] + sets[:mem]\n        ans = calc(sets)\n        saved_set.sort()\n        for val in saved_set:\n            sets[0] = [val]\n            sets[-1] = [val]\n            ans += MOD - calc(sets)\n            ans %= MOD\n        return ans"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if N <= 450:",
      "mutated_line": "if N < 450:",
      "code": "MOD = 998244353\n\ndef count_valid_sequences(N, sets):\n\n    def calc(arr):\n        vars = {i: 1 for i in arr[0]}\n        for i in range(1, len(arr)):\n            tot = sum(vars.values()) % MOD\n            next = {}\n            for num in arr[i]:\n                cur = tot\n                if num in vars:\n                    cur += MOD - vars[num]\n                cur %= MOD\n                next[num] = cur\n            vars = next\n        return sum(vars.values()) % MOD\n    if N < 450:\n        ans = 0\n        sign = False\n        while len(sets) > 1:\n            cur = calc(sets)\n            if sign:\n                cur = MOD - cur\n            ans += cur\n            ans %= MOD\n            sets[0] = list(set(sets[0]).intersection(set(sets[-1])))\n            sets[0].sort()\n            del sets[-1:]\n            sign = not sign\n        return ans\n    else:\n        best = 10 ** 15\n        mem = -1\n        saved_set = []\n        for i in range(N):\n            prev = (i + N - 1) % N\n            t = set(sets[i]).intersection(set(sets[prev]))\n            sz = len(t)\n            if sz < best:\n                best = sz\n                mem = i\n                saved_set = list(t)\n        sets = sets[mem:] + sets[:mem]\n        ans = calc(sets)\n        saved_set.sort()\n        for val in saved_set:\n            sets[0] = [val]\n            sets[-1] = [val]\n            ans += MOD - calc(sets)\n            ans %= MOD\n        return ans"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if N <= 450:",
      "mutated_line": "if N > 450:",
      "code": "MOD = 998244353\n\ndef count_valid_sequences(N, sets):\n\n    def calc(arr):\n        vars = {i: 1 for i in arr[0]}\n        for i in range(1, len(arr)):\n            tot = sum(vars.values()) % MOD\n            next = {}\n            for num in arr[i]:\n                cur = tot\n                if num in vars:\n                    cur += MOD - vars[num]\n                cur %= MOD\n                next[num] = cur\n            vars = next\n        return sum(vars.values()) % MOD\n    if N > 450:\n        ans = 0\n        sign = False\n        while len(sets) > 1:\n            cur = calc(sets)\n            if sign:\n                cur = MOD - cur\n            ans += cur\n            ans %= MOD\n            sets[0] = list(set(sets[0]).intersection(set(sets[-1])))\n            sets[0].sort()\n            del sets[-1:]\n            sign = not sign\n        return ans\n    else:\n        best = 10 ** 15\n        mem = -1\n        saved_set = []\n        for i in range(N):\n            prev = (i + N - 1) % N\n            t = set(sets[i]).intersection(set(sets[prev]))\n            sz = len(t)\n            if sz < best:\n                best = sz\n                mem = i\n                saved_set = list(t)\n        sets = sets[mem:] + sets[:mem]\n        ans = calc(sets)\n        saved_set.sort()\n        for val in saved_set:\n            sets[0] = [val]\n            sets[-1] = [val]\n            ans += MOD - calc(sets)\n            ans %= MOD\n        return ans"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if N <= 450:",
      "mutated_line": "if N == 450:",
      "code": "MOD = 998244353\n\ndef count_valid_sequences(N, sets):\n\n    def calc(arr):\n        vars = {i: 1 for i in arr[0]}\n        for i in range(1, len(arr)):\n            tot = sum(vars.values()) % MOD\n            next = {}\n            for num in arr[i]:\n                cur = tot\n                if num in vars:\n                    cur += MOD - vars[num]\n                cur %= MOD\n                next[num] = cur\n            vars = next\n        return sum(vars.values()) % MOD\n    if N == 450:\n        ans = 0\n        sign = False\n        while len(sets) > 1:\n            cur = calc(sets)\n            if sign:\n                cur = MOD - cur\n            ans += cur\n            ans %= MOD\n            sets[0] = list(set(sets[0]).intersection(set(sets[-1])))\n            sets[0].sort()\n            del sets[-1:]\n            sign = not sign\n        return ans\n    else:\n        best = 10 ** 15\n        mem = -1\n        saved_set = []\n        for i in range(N):\n            prev = (i + N - 1) % N\n            t = set(sets[i]).intersection(set(sets[prev]))\n            sz = len(t)\n            if sz < best:\n                best = sz\n                mem = i\n                saved_set = list(t)\n        sets = sets[mem:] + sets[:mem]\n        ans = calc(sets)\n        saved_set.sort()\n        for val in saved_set:\n            sets[0] = [val]\n            sets[-1] = [val]\n            ans += MOD - calc(sets)\n            ans %= MOD\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "return sum(vars.values()) % MOD",
      "mutated_line": "return sum(vars.values()) * MOD",
      "code": "MOD = 998244353\n\ndef count_valid_sequences(N, sets):\n\n    def calc(arr):\n        vars = {i: 1 for i in arr[0]}\n        for i in range(1, len(arr)):\n            tot = sum(vars.values()) % MOD\n            next = {}\n            for num in arr[i]:\n                cur = tot\n                if num in vars:\n                    cur += MOD - vars[num]\n                cur %= MOD\n                next[num] = cur\n            vars = next\n        return sum(vars.values()) * MOD\n    if N <= 450:\n        ans = 0\n        sign = False\n        while len(sets) > 1:\n            cur = calc(sets)\n            if sign:\n                cur = MOD - cur\n            ans += cur\n            ans %= MOD\n            sets[0] = list(set(sets[0]).intersection(set(sets[-1])))\n            sets[0].sort()\n            del sets[-1:]\n            sign = not sign\n        return ans\n    else:\n        best = 10 ** 15\n        mem = -1\n        saved_set = []\n        for i in range(N):\n            prev = (i + N - 1) % N\n            t = set(sets[i]).intersection(set(sets[prev]))\n            sz = len(t)\n            if sz < best:\n                best = sz\n                mem = i\n                saved_set = list(t)\n        sets = sets[mem:] + sets[:mem]\n        ans = calc(sets)\n        saved_set.sort()\n        for val in saved_set:\n            sets[0] = [val]\n            sets[-1] = [val]\n            ans += MOD - calc(sets)\n            ans %= MOD\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "return sum(vars.values()) % MOD",
      "mutated_line": "return sum(vars.values()) + MOD",
      "code": "MOD = 998244353\n\ndef count_valid_sequences(N, sets):\n\n    def calc(arr):\n        vars = {i: 1 for i in arr[0]}\n        for i in range(1, len(arr)):\n            tot = sum(vars.values()) % MOD\n            next = {}\n            for num in arr[i]:\n                cur = tot\n                if num in vars:\n                    cur += MOD - vars[num]\n                cur %= MOD\n                next[num] = cur\n            vars = next\n        return sum(vars.values()) + MOD\n    if N <= 450:\n        ans = 0\n        sign = False\n        while len(sets) > 1:\n            cur = calc(sets)\n            if sign:\n                cur = MOD - cur\n            ans += cur\n            ans %= MOD\n            sets[0] = list(set(sets[0]).intersection(set(sets[-1])))\n            sets[0].sort()\n            del sets[-1:]\n            sign = not sign\n        return ans\n    else:\n        best = 10 ** 15\n        mem = -1\n        saved_set = []\n        for i in range(N):\n            prev = (i + N - 1) % N\n            t = set(sets[i]).intersection(set(sets[prev]))\n            sz = len(t)\n            if sz < best:\n                best = sz\n                mem = i\n                saved_set = list(t)\n        sets = sets[mem:] + sets[:mem]\n        ans = calc(sets)\n        saved_set.sort()\n        for val in saved_set:\n            sets[0] = [val]\n            sets[-1] = [val]\n            ans += MOD - calc(sets)\n            ans %= MOD\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if N <= 450:",
      "mutated_line": "if N <= 451:",
      "code": "MOD = 998244353\n\ndef count_valid_sequences(N, sets):\n\n    def calc(arr):\n        vars = {i: 1 for i in arr[0]}\n        for i in range(1, len(arr)):\n            tot = sum(vars.values()) % MOD\n            next = {}\n            for num in arr[i]:\n                cur = tot\n                if num in vars:\n                    cur += MOD - vars[num]\n                cur %= MOD\n                next[num] = cur\n            vars = next\n        return sum(vars.values()) % MOD\n    if N <= 451:\n        ans = 0\n        sign = False\n        while len(sets) > 1:\n            cur = calc(sets)\n            if sign:\n                cur = MOD - cur\n            ans += cur\n            ans %= MOD\n            sets[0] = list(set(sets[0]).intersection(set(sets[-1])))\n            sets[0].sort()\n            del sets[-1:]\n            sign = not sign\n        return ans\n    else:\n        best = 10 ** 15\n        mem = -1\n        saved_set = []\n        for i in range(N):\n            prev = (i + N - 1) % N\n            t = set(sets[i]).intersection(set(sets[prev]))\n            sz = len(t)\n            if sz < best:\n                best = sz\n                mem = i\n                saved_set = list(t)\n        sets = sets[mem:] + sets[:mem]\n        ans = calc(sets)\n        saved_set.sort()\n        for val in saved_set:\n            sets[0] = [val]\n            sets[-1] = [val]\n            ans += MOD - calc(sets)\n            ans %= MOD\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if N <= 450:",
      "mutated_line": "if N <= 449:",
      "code": "MOD = 998244353\n\ndef count_valid_sequences(N, sets):\n\n    def calc(arr):\n        vars = {i: 1 for i in arr[0]}\n        for i in range(1, len(arr)):\n            tot = sum(vars.values()) % MOD\n            next = {}\n            for num in arr[i]:\n                cur = tot\n                if num in vars:\n                    cur += MOD - vars[num]\n                cur %= MOD\n                next[num] = cur\n            vars = next\n        return sum(vars.values()) % MOD\n    if N <= 449:\n        ans = 0\n        sign = False\n        while len(sets) > 1:\n            cur = calc(sets)\n            if sign:\n                cur = MOD - cur\n            ans += cur\n            ans %= MOD\n            sets[0] = list(set(sets[0]).intersection(set(sets[-1])))\n            sets[0].sort()\n            del sets[-1:]\n            sign = not sign\n        return ans\n    else:\n        best = 10 ** 15\n        mem = -1\n        saved_set = []\n        for i in range(N):\n            prev = (i + N - 1) % N\n            t = set(sets[i]).intersection(set(sets[prev]))\n            sz = len(t)\n            if sz < best:\n                best = sz\n                mem = i\n                saved_set = list(t)\n        sets = sets[mem:] + sets[:mem]\n        ans = calc(sets)\n        saved_set.sort()\n        for val in saved_set:\n            sets[0] = [val]\n            sets[-1] = [val]\n            ans += MOD - calc(sets)\n            ans %= MOD\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if N <= 450:",
      "mutated_line": "if N <= 0:",
      "code": "MOD = 998244353\n\ndef count_valid_sequences(N, sets):\n\n    def calc(arr):\n        vars = {i: 1 for i in arr[0]}\n        for i in range(1, len(arr)):\n            tot = sum(vars.values()) % MOD\n            next = {}\n            for num in arr[i]:\n                cur = tot\n                if num in vars:\n                    cur += MOD - vars[num]\n                cur %= MOD\n                next[num] = cur\n            vars = next\n        return sum(vars.values()) % MOD\n    if N <= 0:\n        ans = 0\n        sign = False\n        while len(sets) > 1:\n            cur = calc(sets)\n            if sign:\n                cur = MOD - cur\n            ans += cur\n            ans %= MOD\n            sets[0] = list(set(sets[0]).intersection(set(sets[-1])))\n            sets[0].sort()\n            del sets[-1:]\n            sign = not sign\n        return ans\n    else:\n        best = 10 ** 15\n        mem = -1\n        saved_set = []\n        for i in range(N):\n            prev = (i + N - 1) % N\n            t = set(sets[i]).intersection(set(sets[prev]))\n            sz = len(t)\n            if sz < best:\n                best = sz\n                mem = i\n                saved_set = list(t)\n        sets = sets[mem:] + sets[:mem]\n        ans = calc(sets)\n        saved_set.sort()\n        for val in saved_set:\n            sets[0] = [val]\n            sets[-1] = [val]\n            ans += MOD - calc(sets)\n            ans %= MOD\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if N <= 450:",
      "mutated_line": "if N <= 1:",
      "code": "MOD = 998244353\n\ndef count_valid_sequences(N, sets):\n\n    def calc(arr):\n        vars = {i: 1 for i in arr[0]}\n        for i in range(1, len(arr)):\n            tot = sum(vars.values()) % MOD\n            next = {}\n            for num in arr[i]:\n                cur = tot\n                if num in vars:\n                    cur += MOD - vars[num]\n                cur %= MOD\n                next[num] = cur\n            vars = next\n        return sum(vars.values()) % MOD\n    if N <= 1:\n        ans = 0\n        sign = False\n        while len(sets) > 1:\n            cur = calc(sets)\n            if sign:\n                cur = MOD - cur\n            ans += cur\n            ans %= MOD\n            sets[0] = list(set(sets[0]).intersection(set(sets[-1])))\n            sets[0].sort()\n            del sets[-1:]\n            sign = not sign\n        return ans\n    else:\n        best = 10 ** 15\n        mem = -1\n        saved_set = []\n        for i in range(N):\n            prev = (i + N - 1) % N\n            t = set(sets[i]).intersection(set(sets[prev]))\n            sz = len(t)\n            if sz < best:\n                best = sz\n                mem = i\n                saved_set = list(t)\n        sets = sets[mem:] + sets[:mem]\n        ans = calc(sets)\n        saved_set.sort()\n        for val in saved_set:\n            sets[0] = [val]\n            sets[-1] = [val]\n            ans += MOD - calc(sets)\n            ans %= MOD\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if N <= 450:",
      "mutated_line": "if N <= -450:",
      "code": "MOD = 998244353\n\ndef count_valid_sequences(N, sets):\n\n    def calc(arr):\n        vars = {i: 1 for i in arr[0]}\n        for i in range(1, len(arr)):\n            tot = sum(vars.values()) % MOD\n            next = {}\n            for num in arr[i]:\n                cur = tot\n                if num in vars:\n                    cur += MOD - vars[num]\n                cur %= MOD\n                next[num] = cur\n            vars = next\n        return sum(vars.values()) % MOD\n    if N <= -450:\n        ans = 0\n        sign = False\n        while len(sets) > 1:\n            cur = calc(sets)\n            if sign:\n                cur = MOD - cur\n            ans += cur\n            ans %= MOD\n            sets[0] = list(set(sets[0]).intersection(set(sets[-1])))\n            sets[0].sort()\n            del sets[-1:]\n            sign = not sign\n        return ans\n    else:\n        best = 10 ** 15\n        mem = -1\n        saved_set = []\n        for i in range(N):\n            prev = (i + N - 1) % N\n            t = set(sets[i]).intersection(set(sets[prev]))\n            sz = len(t)\n            if sz < best:\n                best = sz\n                mem = i\n                saved_set = list(t)\n        sets = sets[mem:] + sets[:mem]\n        ans = calc(sets)\n        saved_set.sort()\n        for val in saved_set:\n            sets[0] = [val]\n            sets[-1] = [val]\n            ans += MOD - calc(sets)\n            ans %= MOD\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "MOD = 998244353\n\ndef count_valid_sequences(N, sets):\n\n    def calc(arr):\n        vars = {i: 1 for i in arr[0]}\n        for i in range(1, len(arr)):\n            tot = sum(vars.values()) % MOD\n            next = {}\n            for num in arr[i]:\n                cur = tot\n                if num in vars:\n                    cur += MOD - vars[num]\n                cur %= MOD\n                next[num] = cur\n            vars = next\n        return sum(vars.values()) % MOD\n    if N <= 450:\n        ans = 1\n        sign = False\n        while len(sets) > 1:\n            cur = calc(sets)\n            if sign:\n                cur = MOD - cur\n            ans += cur\n            ans %= MOD\n            sets[0] = list(set(sets[0]).intersection(set(sets[-1])))\n            sets[0].sort()\n            del sets[-1:]\n            sign = not sign\n        return ans\n    else:\n        best = 10 ** 15\n        mem = -1\n        saved_set = []\n        for i in range(N):\n            prev = (i + N - 1) % N\n            t = set(sets[i]).intersection(set(sets[prev]))\n            sz = len(t)\n            if sz < best:\n                best = sz\n                mem = i\n                saved_set = list(t)\n        sets = sets[mem:] + sets[:mem]\n        ans = calc(sets)\n        saved_set.sort()\n        for val in saved_set:\n            sets[0] = [val]\n            sets[-1] = [val]\n            ans += MOD - calc(sets)\n            ans %= MOD\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "ans = 0",
      "mutated_line": "ans = -1",
      "code": "MOD = 998244353\n\ndef count_valid_sequences(N, sets):\n\n    def calc(arr):\n        vars = {i: 1 for i in arr[0]}\n        for i in range(1, len(arr)):\n            tot = sum(vars.values()) % MOD\n            next = {}\n            for num in arr[i]:\n                cur = tot\n                if num in vars:\n                    cur += MOD - vars[num]\n                cur %= MOD\n                next[num] = cur\n            vars = next\n        return sum(vars.values()) % MOD\n    if N <= 450:\n        ans = -1\n        sign = False\n        while len(sets) > 1:\n            cur = calc(sets)\n            if sign:\n                cur = MOD - cur\n            ans += cur\n            ans %= MOD\n            sets[0] = list(set(sets[0]).intersection(set(sets[-1])))\n            sets[0].sort()\n            del sets[-1:]\n            sign = not sign\n        return ans\n    else:\n        best = 10 ** 15\n        mem = -1\n        saved_set = []\n        for i in range(N):\n            prev = (i + N - 1) % N\n            t = set(sets[i]).intersection(set(sets[prev]))\n            sz = len(t)\n            if sz < best:\n                best = sz\n                mem = i\n                saved_set = list(t)\n        sets = sets[mem:] + sets[:mem]\n        ans = calc(sets)\n        saved_set.sort()\n        for val in saved_set:\n            sets[0] = [val]\n            sets[-1] = [val]\n            ans += MOD - calc(sets)\n            ans %= MOD\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "MOD = 998244353\n\ndef count_valid_sequences(N, sets):\n\n    def calc(arr):\n        vars = {i: 1 for i in arr[0]}\n        for i in range(1, len(arr)):\n            tot = sum(vars.values()) % MOD\n            next = {}\n            for num in arr[i]:\n                cur = tot\n                if num in vars:\n                    cur += MOD - vars[num]\n                cur %= MOD\n                next[num] = cur\n            vars = next\n        return sum(vars.values()) % MOD\n    if N <= 450:\n        ans = 1\n        sign = False\n        while len(sets) > 1:\n            cur = calc(sets)\n            if sign:\n                cur = MOD - cur\n            ans += cur\n            ans %= MOD\n            sets[0] = list(set(sets[0]).intersection(set(sets[-1])))\n            sets[0].sort()\n            del sets[-1:]\n            sign = not sign\n        return ans\n    else:\n        best = 10 ** 15\n        mem = -1\n        saved_set = []\n        for i in range(N):\n            prev = (i + N - 1) % N\n            t = set(sets[i]).intersection(set(sets[prev]))\n            sz = len(t)\n            if sz < best:\n                best = sz\n                mem = i\n                saved_set = list(t)\n        sets = sets[mem:] + sets[:mem]\n        ans = calc(sets)\n        saved_set.sort()\n        for val in saved_set:\n            sets[0] = [val]\n            sets[-1] = [val]\n            ans += MOD - calc(sets)\n            ans %= MOD\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "sign = False",
      "mutated_line": "sign = True",
      "code": "MOD = 998244353\n\ndef count_valid_sequences(N, sets):\n\n    def calc(arr):\n        vars = {i: 1 for i in arr[0]}\n        for i in range(1, len(arr)):\n            tot = sum(vars.values()) % MOD\n            next = {}\n            for num in arr[i]:\n                cur = tot\n                if num in vars:\n                    cur += MOD - vars[num]\n                cur %= MOD\n                next[num] = cur\n            vars = next\n        return sum(vars.values()) % MOD\n    if N <= 450:\n        ans = 0\n        sign = True\n        while len(sets) > 1:\n            cur = calc(sets)\n            if sign:\n                cur = MOD - cur\n            ans += cur\n            ans %= MOD\n            sets[0] = list(set(sets[0]).intersection(set(sets[-1])))\n            sets[0].sort()\n            del sets[-1:]\n            sign = not sign\n        return ans\n    else:\n        best = 10 ** 15\n        mem = -1\n        saved_set = []\n        for i in range(N):\n            prev = (i + N - 1) % N\n            t = set(sets[i]).intersection(set(sets[prev]))\n            sz = len(t)\n            if sz < best:\n                best = sz\n                mem = i\n                saved_set = list(t)\n        sets = sets[mem:] + sets[:mem]\n        ans = calc(sets)\n        saved_set.sort()\n        for val in saved_set:\n            sets[0] = [val]\n            sets[-1] = [val]\n            ans += MOD - calc(sets)\n            ans %= MOD\n        return ans"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "while len(sets) > 1:",
      "mutated_line": "while len(sets) >= 1:",
      "code": "MOD = 998244353\n\ndef count_valid_sequences(N, sets):\n\n    def calc(arr):\n        vars = {i: 1 for i in arr[0]}\n        for i in range(1, len(arr)):\n            tot = sum(vars.values()) % MOD\n            next = {}\n            for num in arr[i]:\n                cur = tot\n                if num in vars:\n                    cur += MOD - vars[num]\n                cur %= MOD\n                next[num] = cur\n            vars = next\n        return sum(vars.values()) % MOD\n    if N <= 450:\n        ans = 0\n        sign = False\n        while len(sets) >= 1:\n            cur = calc(sets)\n            if sign:\n                cur = MOD - cur\n            ans += cur\n            ans %= MOD\n            sets[0] = list(set(sets[0]).intersection(set(sets[-1])))\n            sets[0].sort()\n            del sets[-1:]\n            sign = not sign\n        return ans\n    else:\n        best = 10 ** 15\n        mem = -1\n        saved_set = []\n        for i in range(N):\n            prev = (i + N - 1) % N\n            t = set(sets[i]).intersection(set(sets[prev]))\n            sz = len(t)\n            if sz < best:\n                best = sz\n                mem = i\n                saved_set = list(t)\n        sets = sets[mem:] + sets[:mem]\n        ans = calc(sets)\n        saved_set.sort()\n        for val in saved_set:\n            sets[0] = [val]\n            sets[-1] = [val]\n            ans += MOD - calc(sets)\n            ans %= MOD\n        return ans"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "while len(sets) > 1:",
      "mutated_line": "while len(sets) <= 1:",
      "code": "MOD = 998244353\n\ndef count_valid_sequences(N, sets):\n\n    def calc(arr):\n        vars = {i: 1 for i in arr[0]}\n        for i in range(1, len(arr)):\n            tot = sum(vars.values()) % MOD\n            next = {}\n            for num in arr[i]:\n                cur = tot\n                if num in vars:\n                    cur += MOD - vars[num]\n                cur %= MOD\n                next[num] = cur\n            vars = next\n        return sum(vars.values()) % MOD\n    if N <= 450:\n        ans = 0\n        sign = False\n        while len(sets) <= 1:\n            cur = calc(sets)\n            if sign:\n                cur = MOD - cur\n            ans += cur\n            ans %= MOD\n            sets[0] = list(set(sets[0]).intersection(set(sets[-1])))\n            sets[0].sort()\n            del sets[-1:]\n            sign = not sign\n        return ans\n    else:\n        best = 10 ** 15\n        mem = -1\n        saved_set = []\n        for i in range(N):\n            prev = (i + N - 1) % N\n            t = set(sets[i]).intersection(set(sets[prev]))\n            sz = len(t)\n            if sz < best:\n                best = sz\n                mem = i\n                saved_set = list(t)\n        sets = sets[mem:] + sets[:mem]\n        ans = calc(sets)\n        saved_set.sort()\n        for val in saved_set:\n            sets[0] = [val]\n            sets[-1] = [val]\n            ans += MOD - calc(sets)\n            ans %= MOD\n        return ans"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "while len(sets) > 1:",
      "mutated_line": "while len(sets) != 1:",
      "code": "MOD = 998244353\n\ndef count_valid_sequences(N, sets):\n\n    def calc(arr):\n        vars = {i: 1 for i in arr[0]}\n        for i in range(1, len(arr)):\n            tot = sum(vars.values()) % MOD\n            next = {}\n            for num in arr[i]:\n                cur = tot\n                if num in vars:\n                    cur += MOD - vars[num]\n                cur %= MOD\n                next[num] = cur\n            vars = next\n        return sum(vars.values()) % MOD\n    if N <= 450:\n        ans = 0\n        sign = False\n        while len(sets) != 1:\n            cur = calc(sets)\n            if sign:\n                cur = MOD - cur\n            ans += cur\n            ans %= MOD\n            sets[0] = list(set(sets[0]).intersection(set(sets[-1])))\n            sets[0].sort()\n            del sets[-1:]\n            sign = not sign\n        return ans\n    else:\n        best = 10 ** 15\n        mem = -1\n        saved_set = []\n        for i in range(N):\n            prev = (i + N - 1) % N\n            t = set(sets[i]).intersection(set(sets[prev]))\n            sz = len(t)\n            if sz < best:\n                best = sz\n                mem = i\n                saved_set = list(t)\n        sets = sets[mem:] + sets[:mem]\n        ans = calc(sets)\n        saved_set.sort()\n        for val in saved_set:\n            sets[0] = [val]\n            sets[-1] = [val]\n            ans += MOD - calc(sets)\n            ans %= MOD\n        return ans"
    },
    {
      "operator": "ASR",
      "lineno": 25,
      "original_line": "ans += cur",
      "mutated_line": "ans -= cur",
      "code": "MOD = 998244353\n\ndef count_valid_sequences(N, sets):\n\n    def calc(arr):\n        vars = {i: 1 for i in arr[0]}\n        for i in range(1, len(arr)):\n            tot = sum(vars.values()) % MOD\n            next = {}\n            for num in arr[i]:\n                cur = tot\n                if num in vars:\n                    cur += MOD - vars[num]\n                cur %= MOD\n                next[num] = cur\n            vars = next\n        return sum(vars.values()) % MOD\n    if N <= 450:\n        ans = 0\n        sign = False\n        while len(sets) > 1:\n            cur = calc(sets)\n            if sign:\n                cur = MOD - cur\n            ans -= cur\n            ans %= MOD\n            sets[0] = list(set(sets[0]).intersection(set(sets[-1])))\n            sets[0].sort()\n            del sets[-1:]\n            sign = not sign\n        return ans\n    else:\n        best = 10 ** 15\n        mem = -1\n        saved_set = []\n        for i in range(N):\n            prev = (i + N - 1) % N\n            t = set(sets[i]).intersection(set(sets[prev]))\n            sz = len(t)\n            if sz < best:\n                best = sz\n                mem = i\n                saved_set = list(t)\n        sets = sets[mem:] + sets[:mem]\n        ans = calc(sets)\n        saved_set.sort()\n        for val in saved_set:\n            sets[0] = [val]\n            sets[-1] = [val]\n            ans += MOD - calc(sets)\n            ans %= MOD\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "best = 10 ** 15",
      "mutated_line": "best = 10 * 15",
      "code": "MOD = 998244353\n\ndef count_valid_sequences(N, sets):\n\n    def calc(arr):\n        vars = {i: 1 for i in arr[0]}\n        for i in range(1, len(arr)):\n            tot = sum(vars.values()) % MOD\n            next = {}\n            for num in arr[i]:\n                cur = tot\n                if num in vars:\n                    cur += MOD - vars[num]\n                cur %= MOD\n                next[num] = cur\n            vars = next\n        return sum(vars.values()) % MOD\n    if N <= 450:\n        ans = 0\n        sign = False\n        while len(sets) > 1:\n            cur = calc(sets)\n            if sign:\n                cur = MOD - cur\n            ans += cur\n            ans %= MOD\n            sets[0] = list(set(sets[0]).intersection(set(sets[-1])))\n            sets[0].sort()\n            del sets[-1:]\n            sign = not sign\n        return ans\n    else:\n        best = 10 * 15\n        mem = -1\n        saved_set = []\n        for i in range(N):\n            prev = (i + N - 1) % N\n            t = set(sets[i]).intersection(set(sets[prev]))\n            sz = len(t)\n            if sz < best:\n                best = sz\n                mem = i\n                saved_set = list(t)\n        sets = sets[mem:] + sets[:mem]\n        ans = calc(sets)\n        saved_set.sort()\n        for val in saved_set:\n            sets[0] = [val]\n            sets[-1] = [val]\n            ans += MOD - calc(sets)\n            ans %= MOD\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "best = 10 ** 15",
      "mutated_line": "best = 10 + 15",
      "code": "MOD = 998244353\n\ndef count_valid_sequences(N, sets):\n\n    def calc(arr):\n        vars = {i: 1 for i in arr[0]}\n        for i in range(1, len(arr)):\n            tot = sum(vars.values()) % MOD\n            next = {}\n            for num in arr[i]:\n                cur = tot\n                if num in vars:\n                    cur += MOD - vars[num]\n                cur %= MOD\n                next[num] = cur\n            vars = next\n        return sum(vars.values()) % MOD\n    if N <= 450:\n        ans = 0\n        sign = False\n        while len(sets) > 1:\n            cur = calc(sets)\n            if sign:\n                cur = MOD - cur\n            ans += cur\n            ans %= MOD\n            sets[0] = list(set(sets[0]).intersection(set(sets[-1])))\n            sets[0].sort()\n            del sets[-1:]\n            sign = not sign\n        return ans\n    else:\n        best = 10 + 15\n        mem = -1\n        saved_set = []\n        for i in range(N):\n            prev = (i + N - 1) % N\n            t = set(sets[i]).intersection(set(sets[prev]))\n            sz = len(t)\n            if sz < best:\n                best = sz\n                mem = i\n                saved_set = list(t)\n        sets = sets[mem:] + sets[:mem]\n        ans = calc(sets)\n        saved_set.sort()\n        for val in saved_set:\n            sets[0] = [val]\n            sets[-1] = [val]\n            ans += MOD - calc(sets)\n            ans %= MOD\n        return ans"
    },
    {
      "operator": "UOI",
      "lineno": 34,
      "original_line": "mem = -1",
      "mutated_line": "mem = +1",
      "code": "MOD = 998244353\n\ndef count_valid_sequences(N, sets):\n\n    def calc(arr):\n        vars = {i: 1 for i in arr[0]}\n        for i in range(1, len(arr)):\n            tot = sum(vars.values()) % MOD\n            next = {}\n            for num in arr[i]:\n                cur = tot\n                if num in vars:\n                    cur += MOD - vars[num]\n                cur %= MOD\n                next[num] = cur\n            vars = next\n        return sum(vars.values()) % MOD\n    if N <= 450:\n        ans = 0\n        sign = False\n        while len(sets) > 1:\n            cur = calc(sets)\n            if sign:\n                cur = MOD - cur\n            ans += cur\n            ans %= MOD\n            sets[0] = list(set(sets[0]).intersection(set(sets[-1])))\n            sets[0].sort()\n            del sets[-1:]\n            sign = not sign\n        return ans\n    else:\n        best = 10 ** 15\n        mem = +1\n        saved_set = []\n        for i in range(N):\n            prev = (i + N - 1) % N\n            t = set(sets[i]).intersection(set(sets[prev]))\n            sz = len(t)\n            if sz < best:\n                best = sz\n                mem = i\n                saved_set = list(t)\n        sets = sets[mem:] + sets[:mem]\n        ans = calc(sets)\n        saved_set.sort()\n        for val in saved_set:\n            sets[0] = [val]\n            sets[-1] = [val]\n            ans += MOD - calc(sets)\n            ans %= MOD\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "sets = sets[mem:] + sets[:mem]",
      "mutated_line": "sets = sets[mem:] - sets[:mem]",
      "code": "MOD = 998244353\n\ndef count_valid_sequences(N, sets):\n\n    def calc(arr):\n        vars = {i: 1 for i in arr[0]}\n        for i in range(1, len(arr)):\n            tot = sum(vars.values()) % MOD\n            next = {}\n            for num in arr[i]:\n                cur = tot\n                if num in vars:\n                    cur += MOD - vars[num]\n                cur %= MOD\n                next[num] = cur\n            vars = next\n        return sum(vars.values()) % MOD\n    if N <= 450:\n        ans = 0\n        sign = False\n        while len(sets) > 1:\n            cur = calc(sets)\n            if sign:\n                cur = MOD - cur\n            ans += cur\n            ans %= MOD\n            sets[0] = list(set(sets[0]).intersection(set(sets[-1])))\n            sets[0].sort()\n            del sets[-1:]\n            sign = not sign\n        return ans\n    else:\n        best = 10 ** 15\n        mem = -1\n        saved_set = []\n        for i in range(N):\n            prev = (i + N - 1) % N\n            t = set(sets[i]).intersection(set(sets[prev]))\n            sz = len(t)\n            if sz < best:\n                best = sz\n                mem = i\n                saved_set = list(t)\n        sets = sets[mem:] - sets[:mem]\n        ans = calc(sets)\n        saved_set.sort()\n        for val in saved_set:\n            sets[0] = [val]\n            sets[-1] = [val]\n            ans += MOD - calc(sets)\n            ans %= MOD\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "sets = sets[mem:] + sets[:mem]",
      "mutated_line": "sets = sets[mem:] * sets[:mem]",
      "code": "MOD = 998244353\n\ndef count_valid_sequences(N, sets):\n\n    def calc(arr):\n        vars = {i: 1 for i in arr[0]}\n        for i in range(1, len(arr)):\n            tot = sum(vars.values()) % MOD\n            next = {}\n            for num in arr[i]:\n                cur = tot\n                if num in vars:\n                    cur += MOD - vars[num]\n                cur %= MOD\n                next[num] = cur\n            vars = next\n        return sum(vars.values()) % MOD\n    if N <= 450:\n        ans = 0\n        sign = False\n        while len(sets) > 1:\n            cur = calc(sets)\n            if sign:\n                cur = MOD - cur\n            ans += cur\n            ans %= MOD\n            sets[0] = list(set(sets[0]).intersection(set(sets[-1])))\n            sets[0].sort()\n            del sets[-1:]\n            sign = not sign\n        return ans\n    else:\n        best = 10 ** 15\n        mem = -1\n        saved_set = []\n        for i in range(N):\n            prev = (i + N - 1) % N\n            t = set(sets[i]).intersection(set(sets[prev]))\n            sz = len(t)\n            if sz < best:\n                best = sz\n                mem = i\n                saved_set = list(t)\n        sets = sets[mem:] * sets[:mem]\n        ans = calc(sets)\n        saved_set.sort()\n        for val in saved_set:\n            sets[0] = [val]\n            sets[-1] = [val]\n            ans += MOD - calc(sets)\n            ans %= MOD\n        return ans"
    },
    {
      "operator": "ASR",
      "lineno": 50,
      "original_line": "ans += MOD - calc(sets)",
      "mutated_line": "ans -= MOD - calc(sets)",
      "code": "MOD = 998244353\n\ndef count_valid_sequences(N, sets):\n\n    def calc(arr):\n        vars = {i: 1 for i in arr[0]}\n        for i in range(1, len(arr)):\n            tot = sum(vars.values()) % MOD\n            next = {}\n            for num in arr[i]:\n                cur = tot\n                if num in vars:\n                    cur += MOD - vars[num]\n                cur %= MOD\n                next[num] = cur\n            vars = next\n        return sum(vars.values()) % MOD\n    if N <= 450:\n        ans = 0\n        sign = False\n        while len(sets) > 1:\n            cur = calc(sets)\n            if sign:\n                cur = MOD - cur\n            ans += cur\n            ans %= MOD\n            sets[0] = list(set(sets[0]).intersection(set(sets[-1])))\n            sets[0].sort()\n            del sets[-1:]\n            sign = not sign\n        return ans\n    else:\n        best = 10 ** 15\n        mem = -1\n        saved_set = []\n        for i in range(N):\n            prev = (i + N - 1) % N\n            t = set(sets[i]).intersection(set(sets[prev]))\n            sz = len(t)\n            if sz < best:\n                best = sz\n                mem = i\n                saved_set = list(t)\n        sets = sets[mem:] + sets[:mem]\n        ans = calc(sets)\n        saved_set.sort()\n        for val in saved_set:\n            sets[0] = [val]\n            sets[-1] = [val]\n            ans -= MOD - calc(sets)\n            ans %= MOD\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "vars = {i: 1 for i in arr[0]}",
      "mutated_line": "vars = {i: 2 for i in arr[0]}",
      "code": "MOD = 998244353\n\ndef count_valid_sequences(N, sets):\n\n    def calc(arr):\n        vars = {i: 2 for i in arr[0]}\n        for i in range(1, len(arr)):\n            tot = sum(vars.values()) % MOD\n            next = {}\n            for num in arr[i]:\n                cur = tot\n                if num in vars:\n                    cur += MOD - vars[num]\n                cur %= MOD\n                next[num] = cur\n            vars = next\n        return sum(vars.values()) % MOD\n    if N <= 450:\n        ans = 0\n        sign = False\n        while len(sets) > 1:\n            cur = calc(sets)\n            if sign:\n                cur = MOD - cur\n            ans += cur\n            ans %= MOD\n            sets[0] = list(set(sets[0]).intersection(set(sets[-1])))\n            sets[0].sort()\n            del sets[-1:]\n            sign = not sign\n        return ans\n    else:\n        best = 10 ** 15\n        mem = -1\n        saved_set = []\n        for i in range(N):\n            prev = (i + N - 1) % N\n            t = set(sets[i]).intersection(set(sets[prev]))\n            sz = len(t)\n            if sz < best:\n                best = sz\n                mem = i\n                saved_set = list(t)\n        sets = sets[mem:] + sets[:mem]\n        ans = calc(sets)\n        saved_set.sort()\n        for val in saved_set:\n            sets[0] = [val]\n            sets[-1] = [val]\n            ans += MOD - calc(sets)\n            ans %= MOD\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "vars = {i: 1 for i in arr[0]}",
      "mutated_line": "vars = {i: 0 for i in arr[0]}",
      "code": "MOD = 998244353\n\ndef count_valid_sequences(N, sets):\n\n    def calc(arr):\n        vars = {i: 0 for i in arr[0]}\n        for i in range(1, len(arr)):\n            tot = sum(vars.values()) % MOD\n            next = {}\n            for num in arr[i]:\n                cur = tot\n                if num in vars:\n                    cur += MOD - vars[num]\n                cur %= MOD\n                next[num] = cur\n            vars = next\n        return sum(vars.values()) % MOD\n    if N <= 450:\n        ans = 0\n        sign = False\n        while len(sets) > 1:\n            cur = calc(sets)\n            if sign:\n                cur = MOD - cur\n            ans += cur\n            ans %= MOD\n            sets[0] = list(set(sets[0]).intersection(set(sets[-1])))\n            sets[0].sort()\n            del sets[-1:]\n            sign = not sign\n        return ans\n    else:\n        best = 10 ** 15\n        mem = -1\n        saved_set = []\n        for i in range(N):\n            prev = (i + N - 1) % N\n            t = set(sets[i]).intersection(set(sets[prev]))\n            sz = len(t)\n            if sz < best:\n                best = sz\n                mem = i\n                saved_set = list(t)\n        sets = sets[mem:] + sets[:mem]\n        ans = calc(sets)\n        saved_set.sort()\n        for val in saved_set:\n            sets[0] = [val]\n            sets[-1] = [val]\n            ans += MOD - calc(sets)\n            ans %= MOD\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "vars = {i: 1 for i in arr[0]}",
      "mutated_line": "vars = {i: 0 for i in arr[0]}",
      "code": "MOD = 998244353\n\ndef count_valid_sequences(N, sets):\n\n    def calc(arr):\n        vars = {i: 0 for i in arr[0]}\n        for i in range(1, len(arr)):\n            tot = sum(vars.values()) % MOD\n            next = {}\n            for num in arr[i]:\n                cur = tot\n                if num in vars:\n                    cur += MOD - vars[num]\n                cur %= MOD\n                next[num] = cur\n            vars = next\n        return sum(vars.values()) % MOD\n    if N <= 450:\n        ans = 0\n        sign = False\n        while len(sets) > 1:\n            cur = calc(sets)\n            if sign:\n                cur = MOD - cur\n            ans += cur\n            ans %= MOD\n            sets[0] = list(set(sets[0]).intersection(set(sets[-1])))\n            sets[0].sort()\n            del sets[-1:]\n            sign = not sign\n        return ans\n    else:\n        best = 10 ** 15\n        mem = -1\n        saved_set = []\n        for i in range(N):\n            prev = (i + N - 1) % N\n            t = set(sets[i]).intersection(set(sets[prev]))\n            sz = len(t)\n            if sz < best:\n                best = sz\n                mem = i\n                saved_set = list(t)\n        sets = sets[mem:] + sets[:mem]\n        ans = calc(sets)\n        saved_set.sort()\n        for val in saved_set:\n            sets[0] = [val]\n            sets[-1] = [val]\n            ans += MOD - calc(sets)\n            ans %= MOD\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "vars = {i: 1 for i in arr[0]}",
      "mutated_line": "vars = {i: -1 for i in arr[0]}",
      "code": "MOD = 998244353\n\ndef count_valid_sequences(N, sets):\n\n    def calc(arr):\n        vars = {i: -1 for i in arr[0]}\n        for i in range(1, len(arr)):\n            tot = sum(vars.values()) % MOD\n            next = {}\n            for num in arr[i]:\n                cur = tot\n                if num in vars:\n                    cur += MOD - vars[num]\n                cur %= MOD\n                next[num] = cur\n            vars = next\n        return sum(vars.values()) % MOD\n    if N <= 450:\n        ans = 0\n        sign = False\n        while len(sets) > 1:\n            cur = calc(sets)\n            if sign:\n                cur = MOD - cur\n            ans += cur\n            ans %= MOD\n            sets[0] = list(set(sets[0]).intersection(set(sets[-1])))\n            sets[0].sort()\n            del sets[-1:]\n            sign = not sign\n        return ans\n    else:\n        best = 10 ** 15\n        mem = -1\n        saved_set = []\n        for i in range(N):\n            prev = (i + N - 1) % N\n            t = set(sets[i]).intersection(set(sets[prev]))\n            sz = len(t)\n            if sz < best:\n                best = sz\n                mem = i\n                saved_set = list(t)\n        sets = sets[mem:] + sets[:mem]\n        ans = calc(sets)\n        saved_set.sort()\n        for val in saved_set:\n            sets[0] = [val]\n            sets[-1] = [val]\n            ans += MOD - calc(sets)\n            ans %= MOD\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(1, len(arr)):",
      "mutated_line": "for i in range(2, len(arr)):",
      "code": "MOD = 998244353\n\ndef count_valid_sequences(N, sets):\n\n    def calc(arr):\n        vars = {i: 1 for i in arr[0]}\n        for i in range(2, len(arr)):\n            tot = sum(vars.values()) % MOD\n            next = {}\n            for num in arr[i]:\n                cur = tot\n                if num in vars:\n                    cur += MOD - vars[num]\n                cur %= MOD\n                next[num] = cur\n            vars = next\n        return sum(vars.values()) % MOD\n    if N <= 450:\n        ans = 0\n        sign = False\n        while len(sets) > 1:\n            cur = calc(sets)\n            if sign:\n                cur = MOD - cur\n            ans += cur\n            ans %= MOD\n            sets[0] = list(set(sets[0]).intersection(set(sets[-1])))\n            sets[0].sort()\n            del sets[-1:]\n            sign = not sign\n        return ans\n    else:\n        best = 10 ** 15\n        mem = -1\n        saved_set = []\n        for i in range(N):\n            prev = (i + N - 1) % N\n            t = set(sets[i]).intersection(set(sets[prev]))\n            sz = len(t)\n            if sz < best:\n                best = sz\n                mem = i\n                saved_set = list(t)\n        sets = sets[mem:] + sets[:mem]\n        ans = calc(sets)\n        saved_set.sort()\n        for val in saved_set:\n            sets[0] = [val]\n            sets[-1] = [val]\n            ans += MOD - calc(sets)\n            ans %= MOD\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(1, len(arr)):",
      "mutated_line": "for i in range(0, len(arr)):",
      "code": "MOD = 998244353\n\ndef count_valid_sequences(N, sets):\n\n    def calc(arr):\n        vars = {i: 1 for i in arr[0]}\n        for i in range(0, len(arr)):\n            tot = sum(vars.values()) % MOD\n            next = {}\n            for num in arr[i]:\n                cur = tot\n                if num in vars:\n                    cur += MOD - vars[num]\n                cur %= MOD\n                next[num] = cur\n            vars = next\n        return sum(vars.values()) % MOD\n    if N <= 450:\n        ans = 0\n        sign = False\n        while len(sets) > 1:\n            cur = calc(sets)\n            if sign:\n                cur = MOD - cur\n            ans += cur\n            ans %= MOD\n            sets[0] = list(set(sets[0]).intersection(set(sets[-1])))\n            sets[0].sort()\n            del sets[-1:]\n            sign = not sign\n        return ans\n    else:\n        best = 10 ** 15\n        mem = -1\n        saved_set = []\n        for i in range(N):\n            prev = (i + N - 1) % N\n            t = set(sets[i]).intersection(set(sets[prev]))\n            sz = len(t)\n            if sz < best:\n                best = sz\n                mem = i\n                saved_set = list(t)\n        sets = sets[mem:] + sets[:mem]\n        ans = calc(sets)\n        saved_set.sort()\n        for val in saved_set:\n            sets[0] = [val]\n            sets[-1] = [val]\n            ans += MOD - calc(sets)\n            ans %= MOD\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(1, len(arr)):",
      "mutated_line": "for i in range(0, len(arr)):",
      "code": "MOD = 998244353\n\ndef count_valid_sequences(N, sets):\n\n    def calc(arr):\n        vars = {i: 1 for i in arr[0]}\n        for i in range(0, len(arr)):\n            tot = sum(vars.values()) % MOD\n            next = {}\n            for num in arr[i]:\n                cur = tot\n                if num in vars:\n                    cur += MOD - vars[num]\n                cur %= MOD\n                next[num] = cur\n            vars = next\n        return sum(vars.values()) % MOD\n    if N <= 450:\n        ans = 0\n        sign = False\n        while len(sets) > 1:\n            cur = calc(sets)\n            if sign:\n                cur = MOD - cur\n            ans += cur\n            ans %= MOD\n            sets[0] = list(set(sets[0]).intersection(set(sets[-1])))\n            sets[0].sort()\n            del sets[-1:]\n            sign = not sign\n        return ans\n    else:\n        best = 10 ** 15\n        mem = -1\n        saved_set = []\n        for i in range(N):\n            prev = (i + N - 1) % N\n            t = set(sets[i]).intersection(set(sets[prev]))\n            sz = len(t)\n            if sz < best:\n                best = sz\n                mem = i\n                saved_set = list(t)\n        sets = sets[mem:] + sets[:mem]\n        ans = calc(sets)\n        saved_set.sort()\n        for val in saved_set:\n            sets[0] = [val]\n            sets[-1] = [val]\n            ans += MOD - calc(sets)\n            ans %= MOD\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(1, len(arr)):",
      "mutated_line": "for i in range(-1, len(arr)):",
      "code": "MOD = 998244353\n\ndef count_valid_sequences(N, sets):\n\n    def calc(arr):\n        vars = {i: 1 for i in arr[0]}\n        for i in range(-1, len(arr)):\n            tot = sum(vars.values()) % MOD\n            next = {}\n            for num in arr[i]:\n                cur = tot\n                if num in vars:\n                    cur += MOD - vars[num]\n                cur %= MOD\n                next[num] = cur\n            vars = next\n        return sum(vars.values()) % MOD\n    if N <= 450:\n        ans = 0\n        sign = False\n        while len(sets) > 1:\n            cur = calc(sets)\n            if sign:\n                cur = MOD - cur\n            ans += cur\n            ans %= MOD\n            sets[0] = list(set(sets[0]).intersection(set(sets[-1])))\n            sets[0].sort()\n            del sets[-1:]\n            sign = not sign\n        return ans\n    else:\n        best = 10 ** 15\n        mem = -1\n        saved_set = []\n        for i in range(N):\n            prev = (i + N - 1) % N\n            t = set(sets[i]).intersection(set(sets[prev]))\n            sz = len(t)\n            if sz < best:\n                best = sz\n                mem = i\n                saved_set = list(t)\n        sets = sets[mem:] + sets[:mem]\n        ans = calc(sets)\n        saved_set.sort()\n        for val in saved_set:\n            sets[0] = [val]\n            sets[-1] = [val]\n            ans += MOD - calc(sets)\n            ans %= MOD\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "tot = sum(vars.values()) % MOD",
      "mutated_line": "tot = sum(vars.values()) * MOD",
      "code": "MOD = 998244353\n\ndef count_valid_sequences(N, sets):\n\n    def calc(arr):\n        vars = {i: 1 for i in arr[0]}\n        for i in range(1, len(arr)):\n            tot = sum(vars.values()) * MOD\n            next = {}\n            for num in arr[i]:\n                cur = tot\n                if num in vars:\n                    cur += MOD - vars[num]\n                cur %= MOD\n                next[num] = cur\n            vars = next\n        return sum(vars.values()) % MOD\n    if N <= 450:\n        ans = 0\n        sign = False\n        while len(sets) > 1:\n            cur = calc(sets)\n            if sign:\n                cur = MOD - cur\n            ans += cur\n            ans %= MOD\n            sets[0] = list(set(sets[0]).intersection(set(sets[-1])))\n            sets[0].sort()\n            del sets[-1:]\n            sign = not sign\n        return ans\n    else:\n        best = 10 ** 15\n        mem = -1\n        saved_set = []\n        for i in range(N):\n            prev = (i + N - 1) % N\n            t = set(sets[i]).intersection(set(sets[prev]))\n            sz = len(t)\n            if sz < best:\n                best = sz\n                mem = i\n                saved_set = list(t)\n        sets = sets[mem:] + sets[:mem]\n        ans = calc(sets)\n        saved_set.sort()\n        for val in saved_set:\n            sets[0] = [val]\n            sets[-1] = [val]\n            ans += MOD - calc(sets)\n            ans %= MOD\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "tot = sum(vars.values()) % MOD",
      "mutated_line": "tot = sum(vars.values()) + MOD",
      "code": "MOD = 998244353\n\ndef count_valid_sequences(N, sets):\n\n    def calc(arr):\n        vars = {i: 1 for i in arr[0]}\n        for i in range(1, len(arr)):\n            tot = sum(vars.values()) + MOD\n            next = {}\n            for num in arr[i]:\n                cur = tot\n                if num in vars:\n                    cur += MOD - vars[num]\n                cur %= MOD\n                next[num] = cur\n            vars = next\n        return sum(vars.values()) % MOD\n    if N <= 450:\n        ans = 0\n        sign = False\n        while len(sets) > 1:\n            cur = calc(sets)\n            if sign:\n                cur = MOD - cur\n            ans += cur\n            ans %= MOD\n            sets[0] = list(set(sets[0]).intersection(set(sets[-1])))\n            sets[0].sort()\n            del sets[-1:]\n            sign = not sign\n        return ans\n    else:\n        best = 10 ** 15\n        mem = -1\n        saved_set = []\n        for i in range(N):\n            prev = (i + N - 1) % N\n            t = set(sets[i]).intersection(set(sets[prev]))\n            sz = len(t)\n            if sz < best:\n                best = sz\n                mem = i\n                saved_set = list(t)\n        sets = sets[mem:] + sets[:mem]\n        ans = calc(sets)\n        saved_set.sort()\n        for val in saved_set:\n            sets[0] = [val]\n            sets[-1] = [val]\n            ans += MOD - calc(sets)\n            ans %= MOD\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "while len(sets) > 1:",
      "mutated_line": "while len(sets) > 2:",
      "code": "MOD = 998244353\n\ndef count_valid_sequences(N, sets):\n\n    def calc(arr):\n        vars = {i: 1 for i in arr[0]}\n        for i in range(1, len(arr)):\n            tot = sum(vars.values()) % MOD\n            next = {}\n            for num in arr[i]:\n                cur = tot\n                if num in vars:\n                    cur += MOD - vars[num]\n                cur %= MOD\n                next[num] = cur\n            vars = next\n        return sum(vars.values()) % MOD\n    if N <= 450:\n        ans = 0\n        sign = False\n        while len(sets) > 2:\n            cur = calc(sets)\n            if sign:\n                cur = MOD - cur\n            ans += cur\n            ans %= MOD\n            sets[0] = list(set(sets[0]).intersection(set(sets[-1])))\n            sets[0].sort()\n            del sets[-1:]\n            sign = not sign\n        return ans\n    else:\n        best = 10 ** 15\n        mem = -1\n        saved_set = []\n        for i in range(N):\n            prev = (i + N - 1) % N\n            t = set(sets[i]).intersection(set(sets[prev]))\n            sz = len(t)\n            if sz < best:\n                best = sz\n                mem = i\n                saved_set = list(t)\n        sets = sets[mem:] + sets[:mem]\n        ans = calc(sets)\n        saved_set.sort()\n        for val in saved_set:\n            sets[0] = [val]\n            sets[-1] = [val]\n            ans += MOD - calc(sets)\n            ans %= MOD\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "while len(sets) > 1:",
      "mutated_line": "while len(sets) > 0:",
      "code": "MOD = 998244353\n\ndef count_valid_sequences(N, sets):\n\n    def calc(arr):\n        vars = {i: 1 for i in arr[0]}\n        for i in range(1, len(arr)):\n            tot = sum(vars.values()) % MOD\n            next = {}\n            for num in arr[i]:\n                cur = tot\n                if num in vars:\n                    cur += MOD - vars[num]\n                cur %= MOD\n                next[num] = cur\n            vars = next\n        return sum(vars.values()) % MOD\n    if N <= 450:\n        ans = 0\n        sign = False\n        while len(sets) > 0:\n            cur = calc(sets)\n            if sign:\n                cur = MOD - cur\n            ans += cur\n            ans %= MOD\n            sets[0] = list(set(sets[0]).intersection(set(sets[-1])))\n            sets[0].sort()\n            del sets[-1:]\n            sign = not sign\n        return ans\n    else:\n        best = 10 ** 15\n        mem = -1\n        saved_set = []\n        for i in range(N):\n            prev = (i + N - 1) % N\n            t = set(sets[i]).intersection(set(sets[prev]))\n            sz = len(t)\n            if sz < best:\n                best = sz\n                mem = i\n                saved_set = list(t)\n        sets = sets[mem:] + sets[:mem]\n        ans = calc(sets)\n        saved_set.sort()\n        for val in saved_set:\n            sets[0] = [val]\n            sets[-1] = [val]\n            ans += MOD - calc(sets)\n            ans %= MOD\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "while len(sets) > 1:",
      "mutated_line": "while len(sets) > 0:",
      "code": "MOD = 998244353\n\ndef count_valid_sequences(N, sets):\n\n    def calc(arr):\n        vars = {i: 1 for i in arr[0]}\n        for i in range(1, len(arr)):\n            tot = sum(vars.values()) % MOD\n            next = {}\n            for num in arr[i]:\n                cur = tot\n                if num in vars:\n                    cur += MOD - vars[num]\n                cur %= MOD\n                next[num] = cur\n            vars = next\n        return sum(vars.values()) % MOD\n    if N <= 450:\n        ans = 0\n        sign = False\n        while len(sets) > 0:\n            cur = calc(sets)\n            if sign:\n                cur = MOD - cur\n            ans += cur\n            ans %= MOD\n            sets[0] = list(set(sets[0]).intersection(set(sets[-1])))\n            sets[0].sort()\n            del sets[-1:]\n            sign = not sign\n        return ans\n    else:\n        best = 10 ** 15\n        mem = -1\n        saved_set = []\n        for i in range(N):\n            prev = (i + N - 1) % N\n            t = set(sets[i]).intersection(set(sets[prev]))\n            sz = len(t)\n            if sz < best:\n                best = sz\n                mem = i\n                saved_set = list(t)\n        sets = sets[mem:] + sets[:mem]\n        ans = calc(sets)\n        saved_set.sort()\n        for val in saved_set:\n            sets[0] = [val]\n            sets[-1] = [val]\n            ans += MOD - calc(sets)\n            ans %= MOD\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "while len(sets) > 1:",
      "mutated_line": "while len(sets) > -1:",
      "code": "MOD = 998244353\n\ndef count_valid_sequences(N, sets):\n\n    def calc(arr):\n        vars = {i: 1 for i in arr[0]}\n        for i in range(1, len(arr)):\n            tot = sum(vars.values()) % MOD\n            next = {}\n            for num in arr[i]:\n                cur = tot\n                if num in vars:\n                    cur += MOD - vars[num]\n                cur %= MOD\n                next[num] = cur\n            vars = next\n        return sum(vars.values()) % MOD\n    if N <= 450:\n        ans = 0\n        sign = False\n        while len(sets) > -1:\n            cur = calc(sets)\n            if sign:\n                cur = MOD - cur\n            ans += cur\n            ans %= MOD\n            sets[0] = list(set(sets[0]).intersection(set(sets[-1])))\n            sets[0].sort()\n            del sets[-1:]\n            sign = not sign\n        return ans\n    else:\n        best = 10 ** 15\n        mem = -1\n        saved_set = []\n        for i in range(N):\n            prev = (i + N - 1) % N\n            t = set(sets[i]).intersection(set(sets[prev]))\n            sz = len(t)\n            if sz < best:\n                best = sz\n                mem = i\n                saved_set = list(t)\n        sets = sets[mem:] + sets[:mem]\n        ans = calc(sets)\n        saved_set.sort()\n        for val in saved_set:\n            sets[0] = [val]\n            sets[-1] = [val]\n            ans += MOD - calc(sets)\n            ans %= MOD\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "best = 10 ** 15",
      "mutated_line": "best = 11 ** 15",
      "code": "MOD = 998244353\n\ndef count_valid_sequences(N, sets):\n\n    def calc(arr):\n        vars = {i: 1 for i in arr[0]}\n        for i in range(1, len(arr)):\n            tot = sum(vars.values()) % MOD\n            next = {}\n            for num in arr[i]:\n                cur = tot\n                if num in vars:\n                    cur += MOD - vars[num]\n                cur %= MOD\n                next[num] = cur\n            vars = next\n        return sum(vars.values()) % MOD\n    if N <= 450:\n        ans = 0\n        sign = False\n        while len(sets) > 1:\n            cur = calc(sets)\n            if sign:\n                cur = MOD - cur\n            ans += cur\n            ans %= MOD\n            sets[0] = list(set(sets[0]).intersection(set(sets[-1])))\n            sets[0].sort()\n            del sets[-1:]\n            sign = not sign\n        return ans\n    else:\n        best = 11 ** 15\n        mem = -1\n        saved_set = []\n        for i in range(N):\n            prev = (i + N - 1) % N\n            t = set(sets[i]).intersection(set(sets[prev]))\n            sz = len(t)\n            if sz < best:\n                best = sz\n                mem = i\n                saved_set = list(t)\n        sets = sets[mem:] + sets[:mem]\n        ans = calc(sets)\n        saved_set.sort()\n        for val in saved_set:\n            sets[0] = [val]\n            sets[-1] = [val]\n            ans += MOD - calc(sets)\n            ans %= MOD\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "best = 10 ** 15",
      "mutated_line": "best = 9 ** 15",
      "code": "MOD = 998244353\n\ndef count_valid_sequences(N, sets):\n\n    def calc(arr):\n        vars = {i: 1 for i in arr[0]}\n        for i in range(1, len(arr)):\n            tot = sum(vars.values()) % MOD\n            next = {}\n            for num in arr[i]:\n                cur = tot\n                if num in vars:\n                    cur += MOD - vars[num]\n                cur %= MOD\n                next[num] = cur\n            vars = next\n        return sum(vars.values()) % MOD\n    if N <= 450:\n        ans = 0\n        sign = False\n        while len(sets) > 1:\n            cur = calc(sets)\n            if sign:\n                cur = MOD - cur\n            ans += cur\n            ans %= MOD\n            sets[0] = list(set(sets[0]).intersection(set(sets[-1])))\n            sets[0].sort()\n            del sets[-1:]\n            sign = not sign\n        return ans\n    else:\n        best = 9 ** 15\n        mem = -1\n        saved_set = []\n        for i in range(N):\n            prev = (i + N - 1) % N\n            t = set(sets[i]).intersection(set(sets[prev]))\n            sz = len(t)\n            if sz < best:\n                best = sz\n                mem = i\n                saved_set = list(t)\n        sets = sets[mem:] + sets[:mem]\n        ans = calc(sets)\n        saved_set.sort()\n        for val in saved_set:\n            sets[0] = [val]\n            sets[-1] = [val]\n            ans += MOD - calc(sets)\n            ans %= MOD\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "best = 10 ** 15",
      "mutated_line": "best = 0 ** 15",
      "code": "MOD = 998244353\n\ndef count_valid_sequences(N, sets):\n\n    def calc(arr):\n        vars = {i: 1 for i in arr[0]}\n        for i in range(1, len(arr)):\n            tot = sum(vars.values()) % MOD\n            next = {}\n            for num in arr[i]:\n                cur = tot\n                if num in vars:\n                    cur += MOD - vars[num]\n                cur %= MOD\n                next[num] = cur\n            vars = next\n        return sum(vars.values()) % MOD\n    if N <= 450:\n        ans = 0\n        sign = False\n        while len(sets) > 1:\n            cur = calc(sets)\n            if sign:\n                cur = MOD - cur\n            ans += cur\n            ans %= MOD\n            sets[0] = list(set(sets[0]).intersection(set(sets[-1])))\n            sets[0].sort()\n            del sets[-1:]\n            sign = not sign\n        return ans\n    else:\n        best = 0 ** 15\n        mem = -1\n        saved_set = []\n        for i in range(N):\n            prev = (i + N - 1) % N\n            t = set(sets[i]).intersection(set(sets[prev]))\n            sz = len(t)\n            if sz < best:\n                best = sz\n                mem = i\n                saved_set = list(t)\n        sets = sets[mem:] + sets[:mem]\n        ans = calc(sets)\n        saved_set.sort()\n        for val in saved_set:\n            sets[0] = [val]\n            sets[-1] = [val]\n            ans += MOD - calc(sets)\n            ans %= MOD\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "best = 10 ** 15",
      "mutated_line": "best = 1 ** 15",
      "code": "MOD = 998244353\n\ndef count_valid_sequences(N, sets):\n\n    def calc(arr):\n        vars = {i: 1 for i in arr[0]}\n        for i in range(1, len(arr)):\n            tot = sum(vars.values()) % MOD\n            next = {}\n            for num in arr[i]:\n                cur = tot\n                if num in vars:\n                    cur += MOD - vars[num]\n                cur %= MOD\n                next[num] = cur\n            vars = next\n        return sum(vars.values()) % MOD\n    if N <= 450:\n        ans = 0\n        sign = False\n        while len(sets) > 1:\n            cur = calc(sets)\n            if sign:\n                cur = MOD - cur\n            ans += cur\n            ans %= MOD\n            sets[0] = list(set(sets[0]).intersection(set(sets[-1])))\n            sets[0].sort()\n            del sets[-1:]\n            sign = not sign\n        return ans\n    else:\n        best = 1 ** 15\n        mem = -1\n        saved_set = []\n        for i in range(N):\n            prev = (i + N - 1) % N\n            t = set(sets[i]).intersection(set(sets[prev]))\n            sz = len(t)\n            if sz < best:\n                best = sz\n                mem = i\n                saved_set = list(t)\n        sets = sets[mem:] + sets[:mem]\n        ans = calc(sets)\n        saved_set.sort()\n        for val in saved_set:\n            sets[0] = [val]\n            sets[-1] = [val]\n            ans += MOD - calc(sets)\n            ans %= MOD\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "best = 10 ** 15",
      "mutated_line": "best = -10 ** 15",
      "code": "MOD = 998244353\n\ndef count_valid_sequences(N, sets):\n\n    def calc(arr):\n        vars = {i: 1 for i in arr[0]}\n        for i in range(1, len(arr)):\n            tot = sum(vars.values()) % MOD\n            next = {}\n            for num in arr[i]:\n                cur = tot\n                if num in vars:\n                    cur += MOD - vars[num]\n                cur %= MOD\n                next[num] = cur\n            vars = next\n        return sum(vars.values()) % MOD\n    if N <= 450:\n        ans = 0\n        sign = False\n        while len(sets) > 1:\n            cur = calc(sets)\n            if sign:\n                cur = MOD - cur\n            ans += cur\n            ans %= MOD\n            sets[0] = list(set(sets[0]).intersection(set(sets[-1])))\n            sets[0].sort()\n            del sets[-1:]\n            sign = not sign\n        return ans\n    else:\n        best = -10 ** 15\n        mem = -1\n        saved_set = []\n        for i in range(N):\n            prev = (i + N - 1) % N\n            t = set(sets[i]).intersection(set(sets[prev]))\n            sz = len(t)\n            if sz < best:\n                best = sz\n                mem = i\n                saved_set = list(t)\n        sets = sets[mem:] + sets[:mem]\n        ans = calc(sets)\n        saved_set.sort()\n        for val in saved_set:\n            sets[0] = [val]\n            sets[-1] = [val]\n            ans += MOD - calc(sets)\n            ans %= MOD\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "best = 10 ** 15",
      "mutated_line": "best = 10 ** 16",
      "code": "MOD = 998244353\n\ndef count_valid_sequences(N, sets):\n\n    def calc(arr):\n        vars = {i: 1 for i in arr[0]}\n        for i in range(1, len(arr)):\n            tot = sum(vars.values()) % MOD\n            next = {}\n            for num in arr[i]:\n                cur = tot\n                if num in vars:\n                    cur += MOD - vars[num]\n                cur %= MOD\n                next[num] = cur\n            vars = next\n        return sum(vars.values()) % MOD\n    if N <= 450:\n        ans = 0\n        sign = False\n        while len(sets) > 1:\n            cur = calc(sets)\n            if sign:\n                cur = MOD - cur\n            ans += cur\n            ans %= MOD\n            sets[0] = list(set(sets[0]).intersection(set(sets[-1])))\n            sets[0].sort()\n            del sets[-1:]\n            sign = not sign\n        return ans\n    else:\n        best = 10 ** 16\n        mem = -1\n        saved_set = []\n        for i in range(N):\n            prev = (i + N - 1) % N\n            t = set(sets[i]).intersection(set(sets[prev]))\n            sz = len(t)\n            if sz < best:\n                best = sz\n                mem = i\n                saved_set = list(t)\n        sets = sets[mem:] + sets[:mem]\n        ans = calc(sets)\n        saved_set.sort()\n        for val in saved_set:\n            sets[0] = [val]\n            sets[-1] = [val]\n            ans += MOD - calc(sets)\n            ans %= MOD\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "best = 10 ** 15",
      "mutated_line": "best = 10 ** 14",
      "code": "MOD = 998244353\n\ndef count_valid_sequences(N, sets):\n\n    def calc(arr):\n        vars = {i: 1 for i in arr[0]}\n        for i in range(1, len(arr)):\n            tot = sum(vars.values()) % MOD\n            next = {}\n            for num in arr[i]:\n                cur = tot\n                if num in vars:\n                    cur += MOD - vars[num]\n                cur %= MOD\n                next[num] = cur\n            vars = next\n        return sum(vars.values()) % MOD\n    if N <= 450:\n        ans = 0\n        sign = False\n        while len(sets) > 1:\n            cur = calc(sets)\n            if sign:\n                cur = MOD - cur\n            ans += cur\n            ans %= MOD\n            sets[0] = list(set(sets[0]).intersection(set(sets[-1])))\n            sets[0].sort()\n            del sets[-1:]\n            sign = not sign\n        return ans\n    else:\n        best = 10 ** 14\n        mem = -1\n        saved_set = []\n        for i in range(N):\n            prev = (i + N - 1) % N\n            t = set(sets[i]).intersection(set(sets[prev]))\n            sz = len(t)\n            if sz < best:\n                best = sz\n                mem = i\n                saved_set = list(t)\n        sets = sets[mem:] + sets[:mem]\n        ans = calc(sets)\n        saved_set.sort()\n        for val in saved_set:\n            sets[0] = [val]\n            sets[-1] = [val]\n            ans += MOD - calc(sets)\n            ans %= MOD\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "best = 10 ** 15",
      "mutated_line": "best = 10 ** 0",
      "code": "MOD = 998244353\n\ndef count_valid_sequences(N, sets):\n\n    def calc(arr):\n        vars = {i: 1 for i in arr[0]}\n        for i in range(1, len(arr)):\n            tot = sum(vars.values()) % MOD\n            next = {}\n            for num in arr[i]:\n                cur = tot\n                if num in vars:\n                    cur += MOD - vars[num]\n                cur %= MOD\n                next[num] = cur\n            vars = next\n        return sum(vars.values()) % MOD\n    if N <= 450:\n        ans = 0\n        sign = False\n        while len(sets) > 1:\n            cur = calc(sets)\n            if sign:\n                cur = MOD - cur\n            ans += cur\n            ans %= MOD\n            sets[0] = list(set(sets[0]).intersection(set(sets[-1])))\n            sets[0].sort()\n            del sets[-1:]\n            sign = not sign\n        return ans\n    else:\n        best = 10 ** 0\n        mem = -1\n        saved_set = []\n        for i in range(N):\n            prev = (i + N - 1) % N\n            t = set(sets[i]).intersection(set(sets[prev]))\n            sz = len(t)\n            if sz < best:\n                best = sz\n                mem = i\n                saved_set = list(t)\n        sets = sets[mem:] + sets[:mem]\n        ans = calc(sets)\n        saved_set.sort()\n        for val in saved_set:\n            sets[0] = [val]\n            sets[-1] = [val]\n            ans += MOD - calc(sets)\n            ans %= MOD\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "best = 10 ** 15",
      "mutated_line": "best = 10 ** 1",
      "code": "MOD = 998244353\n\ndef count_valid_sequences(N, sets):\n\n    def calc(arr):\n        vars = {i: 1 for i in arr[0]}\n        for i in range(1, len(arr)):\n            tot = sum(vars.values()) % MOD\n            next = {}\n            for num in arr[i]:\n                cur = tot\n                if num in vars:\n                    cur += MOD - vars[num]\n                cur %= MOD\n                next[num] = cur\n            vars = next\n        return sum(vars.values()) % MOD\n    if N <= 450:\n        ans = 0\n        sign = False\n        while len(sets) > 1:\n            cur = calc(sets)\n            if sign:\n                cur = MOD - cur\n            ans += cur\n            ans %= MOD\n            sets[0] = list(set(sets[0]).intersection(set(sets[-1])))\n            sets[0].sort()\n            del sets[-1:]\n            sign = not sign\n        return ans\n    else:\n        best = 10 ** 1\n        mem = -1\n        saved_set = []\n        for i in range(N):\n            prev = (i + N - 1) % N\n            t = set(sets[i]).intersection(set(sets[prev]))\n            sz = len(t)\n            if sz < best:\n                best = sz\n                mem = i\n                saved_set = list(t)\n        sets = sets[mem:] + sets[:mem]\n        ans = calc(sets)\n        saved_set.sort()\n        for val in saved_set:\n            sets[0] = [val]\n            sets[-1] = [val]\n            ans += MOD - calc(sets)\n            ans %= MOD\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "best = 10 ** 15",
      "mutated_line": "best = 10 ** -15",
      "code": "MOD = 998244353\n\ndef count_valid_sequences(N, sets):\n\n    def calc(arr):\n        vars = {i: 1 for i in arr[0]}\n        for i in range(1, len(arr)):\n            tot = sum(vars.values()) % MOD\n            next = {}\n            for num in arr[i]:\n                cur = tot\n                if num in vars:\n                    cur += MOD - vars[num]\n                cur %= MOD\n                next[num] = cur\n            vars = next\n        return sum(vars.values()) % MOD\n    if N <= 450:\n        ans = 0\n        sign = False\n        while len(sets) > 1:\n            cur = calc(sets)\n            if sign:\n                cur = MOD - cur\n            ans += cur\n            ans %= MOD\n            sets[0] = list(set(sets[0]).intersection(set(sets[-1])))\n            sets[0].sort()\n            del sets[-1:]\n            sign = not sign\n        return ans\n    else:\n        best = 10 ** -15\n        mem = -1\n        saved_set = []\n        for i in range(N):\n            prev = (i + N - 1) % N\n            t = set(sets[i]).intersection(set(sets[prev]))\n            sz = len(t)\n            if sz < best:\n                best = sz\n                mem = i\n                saved_set = list(t)\n        sets = sets[mem:] + sets[:mem]\n        ans = calc(sets)\n        saved_set.sort()\n        for val in saved_set:\n            sets[0] = [val]\n            sets[-1] = [val]\n            ans += MOD - calc(sets)\n            ans %= MOD\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "mem = -1",
      "mutated_line": "mem = -2",
      "code": "MOD = 998244353\n\ndef count_valid_sequences(N, sets):\n\n    def calc(arr):\n        vars = {i: 1 for i in arr[0]}\n        for i in range(1, len(arr)):\n            tot = sum(vars.values()) % MOD\n            next = {}\n            for num in arr[i]:\n                cur = tot\n                if num in vars:\n                    cur += MOD - vars[num]\n                cur %= MOD\n                next[num] = cur\n            vars = next\n        return sum(vars.values()) % MOD\n    if N <= 450:\n        ans = 0\n        sign = False\n        while len(sets) > 1:\n            cur = calc(sets)\n            if sign:\n                cur = MOD - cur\n            ans += cur\n            ans %= MOD\n            sets[0] = list(set(sets[0]).intersection(set(sets[-1])))\n            sets[0].sort()\n            del sets[-1:]\n            sign = not sign\n        return ans\n    else:\n        best = 10 ** 15\n        mem = -2\n        saved_set = []\n        for i in range(N):\n            prev = (i + N - 1) % N\n            t = set(sets[i]).intersection(set(sets[prev]))\n            sz = len(t)\n            if sz < best:\n                best = sz\n                mem = i\n                saved_set = list(t)\n        sets = sets[mem:] + sets[:mem]\n        ans = calc(sets)\n        saved_set.sort()\n        for val in saved_set:\n            sets[0] = [val]\n            sets[-1] = [val]\n            ans += MOD - calc(sets)\n            ans %= MOD\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "mem = -1",
      "mutated_line": "mem = -0",
      "code": "MOD = 998244353\n\ndef count_valid_sequences(N, sets):\n\n    def calc(arr):\n        vars = {i: 1 for i in arr[0]}\n        for i in range(1, len(arr)):\n            tot = sum(vars.values()) % MOD\n            next = {}\n            for num in arr[i]:\n                cur = tot\n                if num in vars:\n                    cur += MOD - vars[num]\n                cur %= MOD\n                next[num] = cur\n            vars = next\n        return sum(vars.values()) % MOD\n    if N <= 450:\n        ans = 0\n        sign = False\n        while len(sets) > 1:\n            cur = calc(sets)\n            if sign:\n                cur = MOD - cur\n            ans += cur\n            ans %= MOD\n            sets[0] = list(set(sets[0]).intersection(set(sets[-1])))\n            sets[0].sort()\n            del sets[-1:]\n            sign = not sign\n        return ans\n    else:\n        best = 10 ** 15\n        mem = -0\n        saved_set = []\n        for i in range(N):\n            prev = (i + N - 1) % N\n            t = set(sets[i]).intersection(set(sets[prev]))\n            sz = len(t)\n            if sz < best:\n                best = sz\n                mem = i\n                saved_set = list(t)\n        sets = sets[mem:] + sets[:mem]\n        ans = calc(sets)\n        saved_set.sort()\n        for val in saved_set:\n            sets[0] = [val]\n            sets[-1] = [val]\n            ans += MOD - calc(sets)\n            ans %= MOD\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "mem = -1",
      "mutated_line": "mem = -0",
      "code": "MOD = 998244353\n\ndef count_valid_sequences(N, sets):\n\n    def calc(arr):\n        vars = {i: 1 for i in arr[0]}\n        for i in range(1, len(arr)):\n            tot = sum(vars.values()) % MOD\n            next = {}\n            for num in arr[i]:\n                cur = tot\n                if num in vars:\n                    cur += MOD - vars[num]\n                cur %= MOD\n                next[num] = cur\n            vars = next\n        return sum(vars.values()) % MOD\n    if N <= 450:\n        ans = 0\n        sign = False\n        while len(sets) > 1:\n            cur = calc(sets)\n            if sign:\n                cur = MOD - cur\n            ans += cur\n            ans %= MOD\n            sets[0] = list(set(sets[0]).intersection(set(sets[-1])))\n            sets[0].sort()\n            del sets[-1:]\n            sign = not sign\n        return ans\n    else:\n        best = 10 ** 15\n        mem = -0\n        saved_set = []\n        for i in range(N):\n            prev = (i + N - 1) % N\n            t = set(sets[i]).intersection(set(sets[prev]))\n            sz = len(t)\n            if sz < best:\n                best = sz\n                mem = i\n                saved_set = list(t)\n        sets = sets[mem:] + sets[:mem]\n        ans = calc(sets)\n        saved_set.sort()\n        for val in saved_set:\n            sets[0] = [val]\n            sets[-1] = [val]\n            ans += MOD - calc(sets)\n            ans %= MOD\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "mem = -1",
      "mutated_line": "mem = --1",
      "code": "MOD = 998244353\n\ndef count_valid_sequences(N, sets):\n\n    def calc(arr):\n        vars = {i: 1 for i in arr[0]}\n        for i in range(1, len(arr)):\n            tot = sum(vars.values()) % MOD\n            next = {}\n            for num in arr[i]:\n                cur = tot\n                if num in vars:\n                    cur += MOD - vars[num]\n                cur %= MOD\n                next[num] = cur\n            vars = next\n        return sum(vars.values()) % MOD\n    if N <= 450:\n        ans = 0\n        sign = False\n        while len(sets) > 1:\n            cur = calc(sets)\n            if sign:\n                cur = MOD - cur\n            ans += cur\n            ans %= MOD\n            sets[0] = list(set(sets[0]).intersection(set(sets[-1])))\n            sets[0].sort()\n            del sets[-1:]\n            sign = not sign\n        return ans\n    else:\n        best = 10 ** 15\n        mem = --1\n        saved_set = []\n        for i in range(N):\n            prev = (i + N - 1) % N\n            t = set(sets[i]).intersection(set(sets[prev]))\n            sz = len(t)\n            if sz < best:\n                best = sz\n                mem = i\n                saved_set = list(t)\n        sets = sets[mem:] + sets[:mem]\n        ans = calc(sets)\n        saved_set.sort()\n        for val in saved_set:\n            sets[0] = [val]\n            sets[-1] = [val]\n            ans += MOD - calc(sets)\n            ans %= MOD\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "prev = (i + N - 1) % N",
      "mutated_line": "prev = (i + N - 1) * N",
      "code": "MOD = 998244353\n\ndef count_valid_sequences(N, sets):\n\n    def calc(arr):\n        vars = {i: 1 for i in arr[0]}\n        for i in range(1, len(arr)):\n            tot = sum(vars.values()) % MOD\n            next = {}\n            for num in arr[i]:\n                cur = tot\n                if num in vars:\n                    cur += MOD - vars[num]\n                cur %= MOD\n                next[num] = cur\n            vars = next\n        return sum(vars.values()) % MOD\n    if N <= 450:\n        ans = 0\n        sign = False\n        while len(sets) > 1:\n            cur = calc(sets)\n            if sign:\n                cur = MOD - cur\n            ans += cur\n            ans %= MOD\n            sets[0] = list(set(sets[0]).intersection(set(sets[-1])))\n            sets[0].sort()\n            del sets[-1:]\n            sign = not sign\n        return ans\n    else:\n        best = 10 ** 15\n        mem = -1\n        saved_set = []\n        for i in range(N):\n            prev = (i + N - 1) * N\n            t = set(sets[i]).intersection(set(sets[prev]))\n            sz = len(t)\n            if sz < best:\n                best = sz\n                mem = i\n                saved_set = list(t)\n        sets = sets[mem:] + sets[:mem]\n        ans = calc(sets)\n        saved_set.sort()\n        for val in saved_set:\n            sets[0] = [val]\n            sets[-1] = [val]\n            ans += MOD - calc(sets)\n            ans %= MOD\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "prev = (i + N - 1) % N",
      "mutated_line": "prev = i + N - 1 + N",
      "code": "MOD = 998244353\n\ndef count_valid_sequences(N, sets):\n\n    def calc(arr):\n        vars = {i: 1 for i in arr[0]}\n        for i in range(1, len(arr)):\n            tot = sum(vars.values()) % MOD\n            next = {}\n            for num in arr[i]:\n                cur = tot\n                if num in vars:\n                    cur += MOD - vars[num]\n                cur %= MOD\n                next[num] = cur\n            vars = next\n        return sum(vars.values()) % MOD\n    if N <= 450:\n        ans = 0\n        sign = False\n        while len(sets) > 1:\n            cur = calc(sets)\n            if sign:\n                cur = MOD - cur\n            ans += cur\n            ans %= MOD\n            sets[0] = list(set(sets[0]).intersection(set(sets[-1])))\n            sets[0].sort()\n            del sets[-1:]\n            sign = not sign\n        return ans\n    else:\n        best = 10 ** 15\n        mem = -1\n        saved_set = []\n        for i in range(N):\n            prev = i + N - 1 + N\n            t = set(sets[i]).intersection(set(sets[prev]))\n            sz = len(t)\n            if sz < best:\n                best = sz\n                mem = i\n                saved_set = list(t)\n        sets = sets[mem:] + sets[:mem]\n        ans = calc(sets)\n        saved_set.sort()\n        for val in saved_set:\n            sets[0] = [val]\n            sets[-1] = [val]\n            ans += MOD - calc(sets)\n            ans %= MOD\n        return ans"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if sz < best:",
      "mutated_line": "if sz <= best:",
      "code": "MOD = 998244353\n\ndef count_valid_sequences(N, sets):\n\n    def calc(arr):\n        vars = {i: 1 for i in arr[0]}\n        for i in range(1, len(arr)):\n            tot = sum(vars.values()) % MOD\n            next = {}\n            for num in arr[i]:\n                cur = tot\n                if num in vars:\n                    cur += MOD - vars[num]\n                cur %= MOD\n                next[num] = cur\n            vars = next\n        return sum(vars.values()) % MOD\n    if N <= 450:\n        ans = 0\n        sign = False\n        while len(sets) > 1:\n            cur = calc(sets)\n            if sign:\n                cur = MOD - cur\n            ans += cur\n            ans %= MOD\n            sets[0] = list(set(sets[0]).intersection(set(sets[-1])))\n            sets[0].sort()\n            del sets[-1:]\n            sign = not sign\n        return ans\n    else:\n        best = 10 ** 15\n        mem = -1\n        saved_set = []\n        for i in range(N):\n            prev = (i + N - 1) % N\n            t = set(sets[i]).intersection(set(sets[prev]))\n            sz = len(t)\n            if sz <= best:\n                best = sz\n                mem = i\n                saved_set = list(t)\n        sets = sets[mem:] + sets[:mem]\n        ans = calc(sets)\n        saved_set.sort()\n        for val in saved_set:\n            sets[0] = [val]\n            sets[-1] = [val]\n            ans += MOD - calc(sets)\n            ans %= MOD\n        return ans"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if sz < best:",
      "mutated_line": "if sz >= best:",
      "code": "MOD = 998244353\n\ndef count_valid_sequences(N, sets):\n\n    def calc(arr):\n        vars = {i: 1 for i in arr[0]}\n        for i in range(1, len(arr)):\n            tot = sum(vars.values()) % MOD\n            next = {}\n            for num in arr[i]:\n                cur = tot\n                if num in vars:\n                    cur += MOD - vars[num]\n                cur %= MOD\n                next[num] = cur\n            vars = next\n        return sum(vars.values()) % MOD\n    if N <= 450:\n        ans = 0\n        sign = False\n        while len(sets) > 1:\n            cur = calc(sets)\n            if sign:\n                cur = MOD - cur\n            ans += cur\n            ans %= MOD\n            sets[0] = list(set(sets[0]).intersection(set(sets[-1])))\n            sets[0].sort()\n            del sets[-1:]\n            sign = not sign\n        return ans\n    else:\n        best = 10 ** 15\n        mem = -1\n        saved_set = []\n        for i in range(N):\n            prev = (i + N - 1) % N\n            t = set(sets[i]).intersection(set(sets[prev]))\n            sz = len(t)\n            if sz >= best:\n                best = sz\n                mem = i\n                saved_set = list(t)\n        sets = sets[mem:] + sets[:mem]\n        ans = calc(sets)\n        saved_set.sort()\n        for val in saved_set:\n            sets[0] = [val]\n            sets[-1] = [val]\n            ans += MOD - calc(sets)\n            ans %= MOD\n        return ans"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if sz < best:",
      "mutated_line": "if sz != best:",
      "code": "MOD = 998244353\n\ndef count_valid_sequences(N, sets):\n\n    def calc(arr):\n        vars = {i: 1 for i in arr[0]}\n        for i in range(1, len(arr)):\n            tot = sum(vars.values()) % MOD\n            next = {}\n            for num in arr[i]:\n                cur = tot\n                if num in vars:\n                    cur += MOD - vars[num]\n                cur %= MOD\n                next[num] = cur\n            vars = next\n        return sum(vars.values()) % MOD\n    if N <= 450:\n        ans = 0\n        sign = False\n        while len(sets) > 1:\n            cur = calc(sets)\n            if sign:\n                cur = MOD - cur\n            ans += cur\n            ans %= MOD\n            sets[0] = list(set(sets[0]).intersection(set(sets[-1])))\n            sets[0].sort()\n            del sets[-1:]\n            sign = not sign\n        return ans\n    else:\n        best = 10 ** 15\n        mem = -1\n        saved_set = []\n        for i in range(N):\n            prev = (i + N - 1) % N\n            t = set(sets[i]).intersection(set(sets[prev]))\n            sz = len(t)\n            if sz != best:\n                best = sz\n                mem = i\n                saved_set = list(t)\n        sets = sets[mem:] + sets[:mem]\n        ans = calc(sets)\n        saved_set.sort()\n        for val in saved_set:\n            sets[0] = [val]\n            sets[-1] = [val]\n            ans += MOD - calc(sets)\n            ans %= MOD\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "ans += MOD - calc(sets)",
      "mutated_line": "ans += MOD + calc(sets)",
      "code": "MOD = 998244353\n\ndef count_valid_sequences(N, sets):\n\n    def calc(arr):\n        vars = {i: 1 for i in arr[0]}\n        for i in range(1, len(arr)):\n            tot = sum(vars.values()) % MOD\n            next = {}\n            for num in arr[i]:\n                cur = tot\n                if num in vars:\n                    cur += MOD - vars[num]\n                cur %= MOD\n                next[num] = cur\n            vars = next\n        return sum(vars.values()) % MOD\n    if N <= 450:\n        ans = 0\n        sign = False\n        while len(sets) > 1:\n            cur = calc(sets)\n            if sign:\n                cur = MOD - cur\n            ans += cur\n            ans %= MOD\n            sets[0] = list(set(sets[0]).intersection(set(sets[-1])))\n            sets[0].sort()\n            del sets[-1:]\n            sign = not sign\n        return ans\n    else:\n        best = 10 ** 15\n        mem = -1\n        saved_set = []\n        for i in range(N):\n            prev = (i + N - 1) % N\n            t = set(sets[i]).intersection(set(sets[prev]))\n            sz = len(t)\n            if sz < best:\n                best = sz\n                mem = i\n                saved_set = list(t)\n        sets = sets[mem:] + sets[:mem]\n        ans = calc(sets)\n        saved_set.sort()\n        for val in saved_set:\n            sets[0] = [val]\n            sets[-1] = [val]\n            ans += MOD + calc(sets)\n            ans %= MOD\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "ans += MOD - calc(sets)",
      "mutated_line": "ans += MOD * calc(sets)",
      "code": "MOD = 998244353\n\ndef count_valid_sequences(N, sets):\n\n    def calc(arr):\n        vars = {i: 1 for i in arr[0]}\n        for i in range(1, len(arr)):\n            tot = sum(vars.values()) % MOD\n            next = {}\n            for num in arr[i]:\n                cur = tot\n                if num in vars:\n                    cur += MOD - vars[num]\n                cur %= MOD\n                next[num] = cur\n            vars = next\n        return sum(vars.values()) % MOD\n    if N <= 450:\n        ans = 0\n        sign = False\n        while len(sets) > 1:\n            cur = calc(sets)\n            if sign:\n                cur = MOD - cur\n            ans += cur\n            ans %= MOD\n            sets[0] = list(set(sets[0]).intersection(set(sets[-1])))\n            sets[0].sort()\n            del sets[-1:]\n            sign = not sign\n        return ans\n    else:\n        best = 10 ** 15\n        mem = -1\n        saved_set = []\n        for i in range(N):\n            prev = (i + N - 1) % N\n            t = set(sets[i]).intersection(set(sets[prev]))\n            sz = len(t)\n            if sz < best:\n                best = sz\n                mem = i\n                saved_set = list(t)\n        sets = sets[mem:] + sets[:mem]\n        ans = calc(sets)\n        saved_set.sort()\n        for val in saved_set:\n            sets[0] = [val]\n            sets[-1] = [val]\n            ans += MOD * calc(sets)\n            ans %= MOD\n        return ans"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if num in vars:",
      "mutated_line": "if num not in vars:",
      "code": "MOD = 998244353\n\ndef count_valid_sequences(N, sets):\n\n    def calc(arr):\n        vars = {i: 1 for i in arr[0]}\n        for i in range(1, len(arr)):\n            tot = sum(vars.values()) % MOD\n            next = {}\n            for num in arr[i]:\n                cur = tot\n                if num not in vars:\n                    cur += MOD - vars[num]\n                cur %= MOD\n                next[num] = cur\n            vars = next\n        return sum(vars.values()) % MOD\n    if N <= 450:\n        ans = 0\n        sign = False\n        while len(sets) > 1:\n            cur = calc(sets)\n            if sign:\n                cur = MOD - cur\n            ans += cur\n            ans %= MOD\n            sets[0] = list(set(sets[0]).intersection(set(sets[-1])))\n            sets[0].sort()\n            del sets[-1:]\n            sign = not sign\n        return ans\n    else:\n        best = 10 ** 15\n        mem = -1\n        saved_set = []\n        for i in range(N):\n            prev = (i + N - 1) % N\n            t = set(sets[i]).intersection(set(sets[prev]))\n            sz = len(t)\n            if sz < best:\n                best = sz\n                mem = i\n                saved_set = list(t)\n        sets = sets[mem:] + sets[:mem]\n        ans = calc(sets)\n        saved_set.sort()\n        for val in saved_set:\n            sets[0] = [val]\n            sets[-1] = [val]\n            ans += MOD - calc(sets)\n            ans %= MOD\n        return ans"
    },
    {
      "operator": "ASR",
      "lineno": 12,
      "original_line": "cur += MOD - vars[num]",
      "mutated_line": "cur -= MOD - vars[num]",
      "code": "MOD = 998244353\n\ndef count_valid_sequences(N, sets):\n\n    def calc(arr):\n        vars = {i: 1 for i in arr[0]}\n        for i in range(1, len(arr)):\n            tot = sum(vars.values()) % MOD\n            next = {}\n            for num in arr[i]:\n                cur = tot\n                if num in vars:\n                    cur -= MOD - vars[num]\n                cur %= MOD\n                next[num] = cur\n            vars = next\n        return sum(vars.values()) % MOD\n    if N <= 450:\n        ans = 0\n        sign = False\n        while len(sets) > 1:\n            cur = calc(sets)\n            if sign:\n                cur = MOD - cur\n            ans += cur\n            ans %= MOD\n            sets[0] = list(set(sets[0]).intersection(set(sets[-1])))\n            sets[0].sort()\n            del sets[-1:]\n            sign = not sign\n        return ans\n    else:\n        best = 10 ** 15\n        mem = -1\n        saved_set = []\n        for i in range(N):\n            prev = (i + N - 1) % N\n            t = set(sets[i]).intersection(set(sets[prev]))\n            sz = len(t)\n            if sz < best:\n                best = sz\n                mem = i\n                saved_set = list(t)\n        sets = sets[mem:] + sets[:mem]\n        ans = calc(sets)\n        saved_set.sort()\n        for val in saved_set:\n            sets[0] = [val]\n            sets[-1] = [val]\n            ans += MOD - calc(sets)\n            ans %= MOD\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "cur = MOD - cur",
      "mutated_line": "cur = MOD + cur",
      "code": "MOD = 998244353\n\ndef count_valid_sequences(N, sets):\n\n    def calc(arr):\n        vars = {i: 1 for i in arr[0]}\n        for i in range(1, len(arr)):\n            tot = sum(vars.values()) % MOD\n            next = {}\n            for num in arr[i]:\n                cur = tot\n                if num in vars:\n                    cur += MOD - vars[num]\n                cur %= MOD\n                next[num] = cur\n            vars = next\n        return sum(vars.values()) % MOD\n    if N <= 450:\n        ans = 0\n        sign = False\n        while len(sets) > 1:\n            cur = calc(sets)\n            if sign:\n                cur = MOD + cur\n            ans += cur\n            ans %= MOD\n            sets[0] = list(set(sets[0]).intersection(set(sets[-1])))\n            sets[0].sort()\n            del sets[-1:]\n            sign = not sign\n        return ans\n    else:\n        best = 10 ** 15\n        mem = -1\n        saved_set = []\n        for i in range(N):\n            prev = (i + N - 1) % N\n            t = set(sets[i]).intersection(set(sets[prev]))\n            sz = len(t)\n            if sz < best:\n                best = sz\n                mem = i\n                saved_set = list(t)\n        sets = sets[mem:] + sets[:mem]\n        ans = calc(sets)\n        saved_set.sort()\n        for val in saved_set:\n            sets[0] = [val]\n            sets[-1] = [val]\n            ans += MOD - calc(sets)\n            ans %= MOD\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "cur = MOD - cur",
      "mutated_line": "cur = MOD * cur",
      "code": "MOD = 998244353\n\ndef count_valid_sequences(N, sets):\n\n    def calc(arr):\n        vars = {i: 1 for i in arr[0]}\n        for i in range(1, len(arr)):\n            tot = sum(vars.values()) % MOD\n            next = {}\n            for num in arr[i]:\n                cur = tot\n                if num in vars:\n                    cur += MOD - vars[num]\n                cur %= MOD\n                next[num] = cur\n            vars = next\n        return sum(vars.values()) % MOD\n    if N <= 450:\n        ans = 0\n        sign = False\n        while len(sets) > 1:\n            cur = calc(sets)\n            if sign:\n                cur = MOD * cur\n            ans += cur\n            ans %= MOD\n            sets[0] = list(set(sets[0]).intersection(set(sets[-1])))\n            sets[0].sort()\n            del sets[-1:]\n            sign = not sign\n        return ans\n    else:\n        best = 10 ** 15\n        mem = -1\n        saved_set = []\n        for i in range(N):\n            prev = (i + N - 1) % N\n            t = set(sets[i]).intersection(set(sets[prev]))\n            sz = len(t)\n            if sz < best:\n                best = sz\n                mem = i\n                saved_set = list(t)\n        sets = sets[mem:] + sets[:mem]\n        ans = calc(sets)\n        saved_set.sort()\n        for val in saved_set:\n            sets[0] = [val]\n            sets[-1] = [val]\n            ans += MOD - calc(sets)\n            ans %= MOD\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "sets[0] = list(set(sets[0]).intersection(set(sets[-1])))",
      "mutated_line": "sets[1] = list(set(sets[0]).intersection(set(sets[-1])))",
      "code": "MOD = 998244353\n\ndef count_valid_sequences(N, sets):\n\n    def calc(arr):\n        vars = {i: 1 for i in arr[0]}\n        for i in range(1, len(arr)):\n            tot = sum(vars.values()) % MOD\n            next = {}\n            for num in arr[i]:\n                cur = tot\n                if num in vars:\n                    cur += MOD - vars[num]\n                cur %= MOD\n                next[num] = cur\n            vars = next\n        return sum(vars.values()) % MOD\n    if N <= 450:\n        ans = 0\n        sign = False\n        while len(sets) > 1:\n            cur = calc(sets)\n            if sign:\n                cur = MOD - cur\n            ans += cur\n            ans %= MOD\n            sets[1] = list(set(sets[0]).intersection(set(sets[-1])))\n            sets[0].sort()\n            del sets[-1:]\n            sign = not sign\n        return ans\n    else:\n        best = 10 ** 15\n        mem = -1\n        saved_set = []\n        for i in range(N):\n            prev = (i + N - 1) % N\n            t = set(sets[i]).intersection(set(sets[prev]))\n            sz = len(t)\n            if sz < best:\n                best = sz\n                mem = i\n                saved_set = list(t)\n        sets = sets[mem:] + sets[:mem]\n        ans = calc(sets)\n        saved_set.sort()\n        for val in saved_set:\n            sets[0] = [val]\n            sets[-1] = [val]\n            ans += MOD - calc(sets)\n            ans %= MOD\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "sets[0] = list(set(sets[0]).intersection(set(sets[-1])))",
      "mutated_line": "sets[-1] = list(set(sets[0]).intersection(set(sets[-1])))",
      "code": "MOD = 998244353\n\ndef count_valid_sequences(N, sets):\n\n    def calc(arr):\n        vars = {i: 1 for i in arr[0]}\n        for i in range(1, len(arr)):\n            tot = sum(vars.values()) % MOD\n            next = {}\n            for num in arr[i]:\n                cur = tot\n                if num in vars:\n                    cur += MOD - vars[num]\n                cur %= MOD\n                next[num] = cur\n            vars = next\n        return sum(vars.values()) % MOD\n    if N <= 450:\n        ans = 0\n        sign = False\n        while len(sets) > 1:\n            cur = calc(sets)\n            if sign:\n                cur = MOD - cur\n            ans += cur\n            ans %= MOD\n            sets[-1] = list(set(sets[0]).intersection(set(sets[-1])))\n            sets[0].sort()\n            del sets[-1:]\n            sign = not sign\n        return ans\n    else:\n        best = 10 ** 15\n        mem = -1\n        saved_set = []\n        for i in range(N):\n            prev = (i + N - 1) % N\n            t = set(sets[i]).intersection(set(sets[prev]))\n            sz = len(t)\n            if sz < best:\n                best = sz\n                mem = i\n                saved_set = list(t)\n        sets = sets[mem:] + sets[:mem]\n        ans = calc(sets)\n        saved_set.sort()\n        for val in saved_set:\n            sets[0] = [val]\n            sets[-1] = [val]\n            ans += MOD - calc(sets)\n            ans %= MOD\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "sets[0] = list(set(sets[0]).intersection(set(sets[-1])))",
      "mutated_line": "sets[1] = list(set(sets[0]).intersection(set(sets[-1])))",
      "code": "MOD = 998244353\n\ndef count_valid_sequences(N, sets):\n\n    def calc(arr):\n        vars = {i: 1 for i in arr[0]}\n        for i in range(1, len(arr)):\n            tot = sum(vars.values()) % MOD\n            next = {}\n            for num in arr[i]:\n                cur = tot\n                if num in vars:\n                    cur += MOD - vars[num]\n                cur %= MOD\n                next[num] = cur\n            vars = next\n        return sum(vars.values()) % MOD\n    if N <= 450:\n        ans = 0\n        sign = False\n        while len(sets) > 1:\n            cur = calc(sets)\n            if sign:\n                cur = MOD - cur\n            ans += cur\n            ans %= MOD\n            sets[1] = list(set(sets[0]).intersection(set(sets[-1])))\n            sets[0].sort()\n            del sets[-1:]\n            sign = not sign\n        return ans\n    else:\n        best = 10 ** 15\n        mem = -1\n        saved_set = []\n        for i in range(N):\n            prev = (i + N - 1) % N\n            t = set(sets[i]).intersection(set(sets[prev]))\n            sz = len(t)\n            if sz < best:\n                best = sz\n                mem = i\n                saved_set = list(t)\n        sets = sets[mem:] + sets[:mem]\n        ans = calc(sets)\n        saved_set.sort()\n        for val in saved_set:\n            sets[0] = [val]\n            sets[-1] = [val]\n            ans += MOD - calc(sets)\n            ans %= MOD\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "prev = (i + N - 1) % N",
      "mutated_line": "prev = (i + N + 1) % N",
      "code": "MOD = 998244353\n\ndef count_valid_sequences(N, sets):\n\n    def calc(arr):\n        vars = {i: 1 for i in arr[0]}\n        for i in range(1, len(arr)):\n            tot = sum(vars.values()) % MOD\n            next = {}\n            for num in arr[i]:\n                cur = tot\n                if num in vars:\n                    cur += MOD - vars[num]\n                cur %= MOD\n                next[num] = cur\n            vars = next\n        return sum(vars.values()) % MOD\n    if N <= 450:\n        ans = 0\n        sign = False\n        while len(sets) > 1:\n            cur = calc(sets)\n            if sign:\n                cur = MOD - cur\n            ans += cur\n            ans %= MOD\n            sets[0] = list(set(sets[0]).intersection(set(sets[-1])))\n            sets[0].sort()\n            del sets[-1:]\n            sign = not sign\n        return ans\n    else:\n        best = 10 ** 15\n        mem = -1\n        saved_set = []\n        for i in range(N):\n            prev = (i + N + 1) % N\n            t = set(sets[i]).intersection(set(sets[prev]))\n            sz = len(t)\n            if sz < best:\n                best = sz\n                mem = i\n                saved_set = list(t)\n        sets = sets[mem:] + sets[:mem]\n        ans = calc(sets)\n        saved_set.sort()\n        for val in saved_set:\n            sets[0] = [val]\n            sets[-1] = [val]\n            ans += MOD - calc(sets)\n            ans %= MOD\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "prev = (i + N - 1) % N",
      "mutated_line": "prev = (i + N) * 1 % N",
      "code": "MOD = 998244353\n\ndef count_valid_sequences(N, sets):\n\n    def calc(arr):\n        vars = {i: 1 for i in arr[0]}\n        for i in range(1, len(arr)):\n            tot = sum(vars.values()) % MOD\n            next = {}\n            for num in arr[i]:\n                cur = tot\n                if num in vars:\n                    cur += MOD - vars[num]\n                cur %= MOD\n                next[num] = cur\n            vars = next\n        return sum(vars.values()) % MOD\n    if N <= 450:\n        ans = 0\n        sign = False\n        while len(sets) > 1:\n            cur = calc(sets)\n            if sign:\n                cur = MOD - cur\n            ans += cur\n            ans %= MOD\n            sets[0] = list(set(sets[0]).intersection(set(sets[-1])))\n            sets[0].sort()\n            del sets[-1:]\n            sign = not sign\n        return ans\n    else:\n        best = 10 ** 15\n        mem = -1\n        saved_set = []\n        for i in range(N):\n            prev = (i + N) * 1 % N\n            t = set(sets[i]).intersection(set(sets[prev]))\n            sz = len(t)\n            if sz < best:\n                best = sz\n                mem = i\n                saved_set = list(t)\n        sets = sets[mem:] + sets[:mem]\n        ans = calc(sets)\n        saved_set.sort()\n        for val in saved_set:\n            sets[0] = [val]\n            sets[-1] = [val]\n            ans += MOD - calc(sets)\n            ans %= MOD\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "sets[0] = [val]",
      "mutated_line": "sets[1] = [val]",
      "code": "MOD = 998244353\n\ndef count_valid_sequences(N, sets):\n\n    def calc(arr):\n        vars = {i: 1 for i in arr[0]}\n        for i in range(1, len(arr)):\n            tot = sum(vars.values()) % MOD\n            next = {}\n            for num in arr[i]:\n                cur = tot\n                if num in vars:\n                    cur += MOD - vars[num]\n                cur %= MOD\n                next[num] = cur\n            vars = next\n        return sum(vars.values()) % MOD\n    if N <= 450:\n        ans = 0\n        sign = False\n        while len(sets) > 1:\n            cur = calc(sets)\n            if sign:\n                cur = MOD - cur\n            ans += cur\n            ans %= MOD\n            sets[0] = list(set(sets[0]).intersection(set(sets[-1])))\n            sets[0].sort()\n            del sets[-1:]\n            sign = not sign\n        return ans\n    else:\n        best = 10 ** 15\n        mem = -1\n        saved_set = []\n        for i in range(N):\n            prev = (i + N - 1) % N\n            t = set(sets[i]).intersection(set(sets[prev]))\n            sz = len(t)\n            if sz < best:\n                best = sz\n                mem = i\n                saved_set = list(t)\n        sets = sets[mem:] + sets[:mem]\n        ans = calc(sets)\n        saved_set.sort()\n        for val in saved_set:\n            sets[1] = [val]\n            sets[-1] = [val]\n            ans += MOD - calc(sets)\n            ans %= MOD\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "sets[0] = [val]",
      "mutated_line": "sets[-1] = [val]",
      "code": "MOD = 998244353\n\ndef count_valid_sequences(N, sets):\n\n    def calc(arr):\n        vars = {i: 1 for i in arr[0]}\n        for i in range(1, len(arr)):\n            tot = sum(vars.values()) % MOD\n            next = {}\n            for num in arr[i]:\n                cur = tot\n                if num in vars:\n                    cur += MOD - vars[num]\n                cur %= MOD\n                next[num] = cur\n            vars = next\n        return sum(vars.values()) % MOD\n    if N <= 450:\n        ans = 0\n        sign = False\n        while len(sets) > 1:\n            cur = calc(sets)\n            if sign:\n                cur = MOD - cur\n            ans += cur\n            ans %= MOD\n            sets[0] = list(set(sets[0]).intersection(set(sets[-1])))\n            sets[0].sort()\n            del sets[-1:]\n            sign = not sign\n        return ans\n    else:\n        best = 10 ** 15\n        mem = -1\n        saved_set = []\n        for i in range(N):\n            prev = (i + N - 1) % N\n            t = set(sets[i]).intersection(set(sets[prev]))\n            sz = len(t)\n            if sz < best:\n                best = sz\n                mem = i\n                saved_set = list(t)\n        sets = sets[mem:] + sets[:mem]\n        ans = calc(sets)\n        saved_set.sort()\n        for val in saved_set:\n            sets[-1] = [val]\n            sets[-1] = [val]\n            ans += MOD - calc(sets)\n            ans %= MOD\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "sets[0] = [val]",
      "mutated_line": "sets[1] = [val]",
      "code": "MOD = 998244353\n\ndef count_valid_sequences(N, sets):\n\n    def calc(arr):\n        vars = {i: 1 for i in arr[0]}\n        for i in range(1, len(arr)):\n            tot = sum(vars.values()) % MOD\n            next = {}\n            for num in arr[i]:\n                cur = tot\n                if num in vars:\n                    cur += MOD - vars[num]\n                cur %= MOD\n                next[num] = cur\n            vars = next\n        return sum(vars.values()) % MOD\n    if N <= 450:\n        ans = 0\n        sign = False\n        while len(sets) > 1:\n            cur = calc(sets)\n            if sign:\n                cur = MOD - cur\n            ans += cur\n            ans %= MOD\n            sets[0] = list(set(sets[0]).intersection(set(sets[-1])))\n            sets[0].sort()\n            del sets[-1:]\n            sign = not sign\n        return ans\n    else:\n        best = 10 ** 15\n        mem = -1\n        saved_set = []\n        for i in range(N):\n            prev = (i + N - 1) % N\n            t = set(sets[i]).intersection(set(sets[prev]))\n            sz = len(t)\n            if sz < best:\n                best = sz\n                mem = i\n                saved_set = list(t)\n        sets = sets[mem:] + sets[:mem]\n        ans = calc(sets)\n        saved_set.sort()\n        for val in saved_set:\n            sets[1] = [val]\n            sets[-1] = [val]\n            ans += MOD - calc(sets)\n            ans %= MOD\n        return ans"
    },
    {
      "operator": "UOI",
      "lineno": 49,
      "original_line": "sets[-1] = [val]",
      "mutated_line": "sets[+1] = [val]",
      "code": "MOD = 998244353\n\ndef count_valid_sequences(N, sets):\n\n    def calc(arr):\n        vars = {i: 1 for i in arr[0]}\n        for i in range(1, len(arr)):\n            tot = sum(vars.values()) % MOD\n            next = {}\n            for num in arr[i]:\n                cur = tot\n                if num in vars:\n                    cur += MOD - vars[num]\n                cur %= MOD\n                next[num] = cur\n            vars = next\n        return sum(vars.values()) % MOD\n    if N <= 450:\n        ans = 0\n        sign = False\n        while len(sets) > 1:\n            cur = calc(sets)\n            if sign:\n                cur = MOD - cur\n            ans += cur\n            ans %= MOD\n            sets[0] = list(set(sets[0]).intersection(set(sets[-1])))\n            sets[0].sort()\n            del sets[-1:]\n            sign = not sign\n        return ans\n    else:\n        best = 10 ** 15\n        mem = -1\n        saved_set = []\n        for i in range(N):\n            prev = (i + N - 1) % N\n            t = set(sets[i]).intersection(set(sets[prev]))\n            sz = len(t)\n            if sz < best:\n                best = sz\n                mem = i\n                saved_set = list(t)\n        sets = sets[mem:] + sets[:mem]\n        ans = calc(sets)\n        saved_set.sort()\n        for val in saved_set:\n            sets[0] = [val]\n            sets[+1] = [val]\n            ans += MOD - calc(sets)\n            ans %= MOD\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "vars = {i: 1 for i in arr[0]}",
      "mutated_line": "vars = {i: 1 for i in arr[1]}",
      "code": "MOD = 998244353\n\ndef count_valid_sequences(N, sets):\n\n    def calc(arr):\n        vars = {i: 1 for i in arr[1]}\n        for i in range(1, len(arr)):\n            tot = sum(vars.values()) % MOD\n            next = {}\n            for num in arr[i]:\n                cur = tot\n                if num in vars:\n                    cur += MOD - vars[num]\n                cur %= MOD\n                next[num] = cur\n            vars = next\n        return sum(vars.values()) % MOD\n    if N <= 450:\n        ans = 0\n        sign = False\n        while len(sets) > 1:\n            cur = calc(sets)\n            if sign:\n                cur = MOD - cur\n            ans += cur\n            ans %= MOD\n            sets[0] = list(set(sets[0]).intersection(set(sets[-1])))\n            sets[0].sort()\n            del sets[-1:]\n            sign = not sign\n        return ans\n    else:\n        best = 10 ** 15\n        mem = -1\n        saved_set = []\n        for i in range(N):\n            prev = (i + N - 1) % N\n            t = set(sets[i]).intersection(set(sets[prev]))\n            sz = len(t)\n            if sz < best:\n                best = sz\n                mem = i\n                saved_set = list(t)\n        sets = sets[mem:] + sets[:mem]\n        ans = calc(sets)\n        saved_set.sort()\n        for val in saved_set:\n            sets[0] = [val]\n            sets[-1] = [val]\n            ans += MOD - calc(sets)\n            ans %= MOD\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "vars = {i: 1 for i in arr[0]}",
      "mutated_line": "vars = {i: 1 for i in arr[-1]}",
      "code": "MOD = 998244353\n\ndef count_valid_sequences(N, sets):\n\n    def calc(arr):\n        vars = {i: 1 for i in arr[-1]}\n        for i in range(1, len(arr)):\n            tot = sum(vars.values()) % MOD\n            next = {}\n            for num in arr[i]:\n                cur = tot\n                if num in vars:\n                    cur += MOD - vars[num]\n                cur %= MOD\n                next[num] = cur\n            vars = next\n        return sum(vars.values()) % MOD\n    if N <= 450:\n        ans = 0\n        sign = False\n        while len(sets) > 1:\n            cur = calc(sets)\n            if sign:\n                cur = MOD - cur\n            ans += cur\n            ans %= MOD\n            sets[0] = list(set(sets[0]).intersection(set(sets[-1])))\n            sets[0].sort()\n            del sets[-1:]\n            sign = not sign\n        return ans\n    else:\n        best = 10 ** 15\n        mem = -1\n        saved_set = []\n        for i in range(N):\n            prev = (i + N - 1) % N\n            t = set(sets[i]).intersection(set(sets[prev]))\n            sz = len(t)\n            if sz < best:\n                best = sz\n                mem = i\n                saved_set = list(t)\n        sets = sets[mem:] + sets[:mem]\n        ans = calc(sets)\n        saved_set.sort()\n        for val in saved_set:\n            sets[0] = [val]\n            sets[-1] = [val]\n            ans += MOD - calc(sets)\n            ans %= MOD\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "vars = {i: 1 for i in arr[0]}",
      "mutated_line": "vars = {i: 1 for i in arr[1]}",
      "code": "MOD = 998244353\n\ndef count_valid_sequences(N, sets):\n\n    def calc(arr):\n        vars = {i: 1 for i in arr[1]}\n        for i in range(1, len(arr)):\n            tot = sum(vars.values()) % MOD\n            next = {}\n            for num in arr[i]:\n                cur = tot\n                if num in vars:\n                    cur += MOD - vars[num]\n                cur %= MOD\n                next[num] = cur\n            vars = next\n        return sum(vars.values()) % MOD\n    if N <= 450:\n        ans = 0\n        sign = False\n        while len(sets) > 1:\n            cur = calc(sets)\n            if sign:\n                cur = MOD - cur\n            ans += cur\n            ans %= MOD\n            sets[0] = list(set(sets[0]).intersection(set(sets[-1])))\n            sets[0].sort()\n            del sets[-1:]\n            sign = not sign\n        return ans\n    else:\n        best = 10 ** 15\n        mem = -1\n        saved_set = []\n        for i in range(N):\n            prev = (i + N - 1) % N\n            t = set(sets[i]).intersection(set(sets[prev]))\n            sz = len(t)\n            if sz < best:\n                best = sz\n                mem = i\n                saved_set = list(t)\n        sets = sets[mem:] + sets[:mem]\n        ans = calc(sets)\n        saved_set.sort()\n        for val in saved_set:\n            sets[0] = [val]\n            sets[-1] = [val]\n            ans += MOD - calc(sets)\n            ans %= MOD\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "cur += MOD - vars[num]",
      "mutated_line": "cur += MOD + vars[num]",
      "code": "MOD = 998244353\n\ndef count_valid_sequences(N, sets):\n\n    def calc(arr):\n        vars = {i: 1 for i in arr[0]}\n        for i in range(1, len(arr)):\n            tot = sum(vars.values()) % MOD\n            next = {}\n            for num in arr[i]:\n                cur = tot\n                if num in vars:\n                    cur += MOD + vars[num]\n                cur %= MOD\n                next[num] = cur\n            vars = next\n        return sum(vars.values()) % MOD\n    if N <= 450:\n        ans = 0\n        sign = False\n        while len(sets) > 1:\n            cur = calc(sets)\n            if sign:\n                cur = MOD - cur\n            ans += cur\n            ans %= MOD\n            sets[0] = list(set(sets[0]).intersection(set(sets[-1])))\n            sets[0].sort()\n            del sets[-1:]\n            sign = not sign\n        return ans\n    else:\n        best = 10 ** 15\n        mem = -1\n        saved_set = []\n        for i in range(N):\n            prev = (i + N - 1) % N\n            t = set(sets[i]).intersection(set(sets[prev]))\n            sz = len(t)\n            if sz < best:\n                best = sz\n                mem = i\n                saved_set = list(t)\n        sets = sets[mem:] + sets[:mem]\n        ans = calc(sets)\n        saved_set.sort()\n        for val in saved_set:\n            sets[0] = [val]\n            sets[-1] = [val]\n            ans += MOD - calc(sets)\n            ans %= MOD\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "cur += MOD - vars[num]",
      "mutated_line": "cur += MOD * vars[num]",
      "code": "MOD = 998244353\n\ndef count_valid_sequences(N, sets):\n\n    def calc(arr):\n        vars = {i: 1 for i in arr[0]}\n        for i in range(1, len(arr)):\n            tot = sum(vars.values()) % MOD\n            next = {}\n            for num in arr[i]:\n                cur = tot\n                if num in vars:\n                    cur += MOD * vars[num]\n                cur %= MOD\n                next[num] = cur\n            vars = next\n        return sum(vars.values()) % MOD\n    if N <= 450:\n        ans = 0\n        sign = False\n        while len(sets) > 1:\n            cur = calc(sets)\n            if sign:\n                cur = MOD - cur\n            ans += cur\n            ans %= MOD\n            sets[0] = list(set(sets[0]).intersection(set(sets[-1])))\n            sets[0].sort()\n            del sets[-1:]\n            sign = not sign\n        return ans\n    else:\n        best = 10 ** 15\n        mem = -1\n        saved_set = []\n        for i in range(N):\n            prev = (i + N - 1) % N\n            t = set(sets[i]).intersection(set(sets[prev]))\n            sz = len(t)\n            if sz < best:\n                best = sz\n                mem = i\n                saved_set = list(t)\n        sets = sets[mem:] + sets[:mem]\n        ans = calc(sets)\n        saved_set.sort()\n        for val in saved_set:\n            sets[0] = [val]\n            sets[-1] = [val]\n            ans += MOD - calc(sets)\n            ans %= MOD\n        return ans"
    },
    {
      "operator": "UOI",
      "lineno": 29,
      "original_line": "del sets[-1:]",
      "mutated_line": "del sets[+1:]",
      "code": "MOD = 998244353\n\ndef count_valid_sequences(N, sets):\n\n    def calc(arr):\n        vars = {i: 1 for i in arr[0]}\n        for i in range(1, len(arr)):\n            tot = sum(vars.values()) % MOD\n            next = {}\n            for num in arr[i]:\n                cur = tot\n                if num in vars:\n                    cur += MOD - vars[num]\n                cur %= MOD\n                next[num] = cur\n            vars = next\n        return sum(vars.values()) % MOD\n    if N <= 450:\n        ans = 0\n        sign = False\n        while len(sets) > 1:\n            cur = calc(sets)\n            if sign:\n                cur = MOD - cur\n            ans += cur\n            ans %= MOD\n            sets[0] = list(set(sets[0]).intersection(set(sets[-1])))\n            sets[0].sort()\n            del sets[+1:]\n            sign = not sign\n        return ans\n    else:\n        best = 10 ** 15\n        mem = -1\n        saved_set = []\n        for i in range(N):\n            prev = (i + N - 1) % N\n            t = set(sets[i]).intersection(set(sets[prev]))\n            sz = len(t)\n            if sz < best:\n                best = sz\n                mem = i\n                saved_set = list(t)\n        sets = sets[mem:] + sets[:mem]\n        ans = calc(sets)\n        saved_set.sort()\n        for val in saved_set:\n            sets[0] = [val]\n            sets[-1] = [val]\n            ans += MOD - calc(sets)\n            ans %= MOD\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "prev = (i + N - 1) % N",
      "mutated_line": "prev = (i - N - 1) % N",
      "code": "MOD = 998244353\n\ndef count_valid_sequences(N, sets):\n\n    def calc(arr):\n        vars = {i: 1 for i in arr[0]}\n        for i in range(1, len(arr)):\n            tot = sum(vars.values()) % MOD\n            next = {}\n            for num in arr[i]:\n                cur = tot\n                if num in vars:\n                    cur += MOD - vars[num]\n                cur %= MOD\n                next[num] = cur\n            vars = next\n        return sum(vars.values()) % MOD\n    if N <= 450:\n        ans = 0\n        sign = False\n        while len(sets) > 1:\n            cur = calc(sets)\n            if sign:\n                cur = MOD - cur\n            ans += cur\n            ans %= MOD\n            sets[0] = list(set(sets[0]).intersection(set(sets[-1])))\n            sets[0].sort()\n            del sets[-1:]\n            sign = not sign\n        return ans\n    else:\n        best = 10 ** 15\n        mem = -1\n        saved_set = []\n        for i in range(N):\n            prev = (i - N - 1) % N\n            t = set(sets[i]).intersection(set(sets[prev]))\n            sz = len(t)\n            if sz < best:\n                best = sz\n                mem = i\n                saved_set = list(t)\n        sets = sets[mem:] + sets[:mem]\n        ans = calc(sets)\n        saved_set.sort()\n        for val in saved_set:\n            sets[0] = [val]\n            sets[-1] = [val]\n            ans += MOD - calc(sets)\n            ans %= MOD\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "prev = (i + N - 1) % N",
      "mutated_line": "prev = (i * N - 1) % N",
      "code": "MOD = 998244353\n\ndef count_valid_sequences(N, sets):\n\n    def calc(arr):\n        vars = {i: 1 for i in arr[0]}\n        for i in range(1, len(arr)):\n            tot = sum(vars.values()) % MOD\n            next = {}\n            for num in arr[i]:\n                cur = tot\n                if num in vars:\n                    cur += MOD - vars[num]\n                cur %= MOD\n                next[num] = cur\n            vars = next\n        return sum(vars.values()) % MOD\n    if N <= 450:\n        ans = 0\n        sign = False\n        while len(sets) > 1:\n            cur = calc(sets)\n            if sign:\n                cur = MOD - cur\n            ans += cur\n            ans %= MOD\n            sets[0] = list(set(sets[0]).intersection(set(sets[-1])))\n            sets[0].sort()\n            del sets[-1:]\n            sign = not sign\n        return ans\n    else:\n        best = 10 ** 15\n        mem = -1\n        saved_set = []\n        for i in range(N):\n            prev = (i * N - 1) % N\n            t = set(sets[i]).intersection(set(sets[prev]))\n            sz = len(t)\n            if sz < best:\n                best = sz\n                mem = i\n                saved_set = list(t)\n        sets = sets[mem:] + sets[:mem]\n        ans = calc(sets)\n        saved_set.sort()\n        for val in saved_set:\n            sets[0] = [val]\n            sets[-1] = [val]\n            ans += MOD - calc(sets)\n            ans %= MOD\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "prev = (i + N - 1) % N",
      "mutated_line": "prev = (i + N - 2) % N",
      "code": "MOD = 998244353\n\ndef count_valid_sequences(N, sets):\n\n    def calc(arr):\n        vars = {i: 1 for i in arr[0]}\n        for i in range(1, len(arr)):\n            tot = sum(vars.values()) % MOD\n            next = {}\n            for num in arr[i]:\n                cur = tot\n                if num in vars:\n                    cur += MOD - vars[num]\n                cur %= MOD\n                next[num] = cur\n            vars = next\n        return sum(vars.values()) % MOD\n    if N <= 450:\n        ans = 0\n        sign = False\n        while len(sets) > 1:\n            cur = calc(sets)\n            if sign:\n                cur = MOD - cur\n            ans += cur\n            ans %= MOD\n            sets[0] = list(set(sets[0]).intersection(set(sets[-1])))\n            sets[0].sort()\n            del sets[-1:]\n            sign = not sign\n        return ans\n    else:\n        best = 10 ** 15\n        mem = -1\n        saved_set = []\n        for i in range(N):\n            prev = (i + N - 2) % N\n            t = set(sets[i]).intersection(set(sets[prev]))\n            sz = len(t)\n            if sz < best:\n                best = sz\n                mem = i\n                saved_set = list(t)\n        sets = sets[mem:] + sets[:mem]\n        ans = calc(sets)\n        saved_set.sort()\n        for val in saved_set:\n            sets[0] = [val]\n            sets[-1] = [val]\n            ans += MOD - calc(sets)\n            ans %= MOD\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "prev = (i + N - 1) % N",
      "mutated_line": "prev = (i + N - 0) % N",
      "code": "MOD = 998244353\n\ndef count_valid_sequences(N, sets):\n\n    def calc(arr):\n        vars = {i: 1 for i in arr[0]}\n        for i in range(1, len(arr)):\n            tot = sum(vars.values()) % MOD\n            next = {}\n            for num in arr[i]:\n                cur = tot\n                if num in vars:\n                    cur += MOD - vars[num]\n                cur %= MOD\n                next[num] = cur\n            vars = next\n        return sum(vars.values()) % MOD\n    if N <= 450:\n        ans = 0\n        sign = False\n        while len(sets) > 1:\n            cur = calc(sets)\n            if sign:\n                cur = MOD - cur\n            ans += cur\n            ans %= MOD\n            sets[0] = list(set(sets[0]).intersection(set(sets[-1])))\n            sets[0].sort()\n            del sets[-1:]\n            sign = not sign\n        return ans\n    else:\n        best = 10 ** 15\n        mem = -1\n        saved_set = []\n        for i in range(N):\n            prev = (i + N - 0) % N\n            t = set(sets[i]).intersection(set(sets[prev]))\n            sz = len(t)\n            if sz < best:\n                best = sz\n                mem = i\n                saved_set = list(t)\n        sets = sets[mem:] + sets[:mem]\n        ans = calc(sets)\n        saved_set.sort()\n        for val in saved_set:\n            sets[0] = [val]\n            sets[-1] = [val]\n            ans += MOD - calc(sets)\n            ans %= MOD\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "prev = (i + N - 1) % N",
      "mutated_line": "prev = (i + N - 0) % N",
      "code": "MOD = 998244353\n\ndef count_valid_sequences(N, sets):\n\n    def calc(arr):\n        vars = {i: 1 for i in arr[0]}\n        for i in range(1, len(arr)):\n            tot = sum(vars.values()) % MOD\n            next = {}\n            for num in arr[i]:\n                cur = tot\n                if num in vars:\n                    cur += MOD - vars[num]\n                cur %= MOD\n                next[num] = cur\n            vars = next\n        return sum(vars.values()) % MOD\n    if N <= 450:\n        ans = 0\n        sign = False\n        while len(sets) > 1:\n            cur = calc(sets)\n            if sign:\n                cur = MOD - cur\n            ans += cur\n            ans %= MOD\n            sets[0] = list(set(sets[0]).intersection(set(sets[-1])))\n            sets[0].sort()\n            del sets[-1:]\n            sign = not sign\n        return ans\n    else:\n        best = 10 ** 15\n        mem = -1\n        saved_set = []\n        for i in range(N):\n            prev = (i + N - 0) % N\n            t = set(sets[i]).intersection(set(sets[prev]))\n            sz = len(t)\n            if sz < best:\n                best = sz\n                mem = i\n                saved_set = list(t)\n        sets = sets[mem:] + sets[:mem]\n        ans = calc(sets)\n        saved_set.sort()\n        for val in saved_set:\n            sets[0] = [val]\n            sets[-1] = [val]\n            ans += MOD - calc(sets)\n            ans %= MOD\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "prev = (i + N - 1) % N",
      "mutated_line": "prev = (i + N - -1) % N",
      "code": "MOD = 998244353\n\ndef count_valid_sequences(N, sets):\n\n    def calc(arr):\n        vars = {i: 1 for i in arr[0]}\n        for i in range(1, len(arr)):\n            tot = sum(vars.values()) % MOD\n            next = {}\n            for num in arr[i]:\n                cur = tot\n                if num in vars:\n                    cur += MOD - vars[num]\n                cur %= MOD\n                next[num] = cur\n            vars = next\n        return sum(vars.values()) % MOD\n    if N <= 450:\n        ans = 0\n        sign = False\n        while len(sets) > 1:\n            cur = calc(sets)\n            if sign:\n                cur = MOD - cur\n            ans += cur\n            ans %= MOD\n            sets[0] = list(set(sets[0]).intersection(set(sets[-1])))\n            sets[0].sort()\n            del sets[-1:]\n            sign = not sign\n        return ans\n    else:\n        best = 10 ** 15\n        mem = -1\n        saved_set = []\n        for i in range(N):\n            prev = (i + N - -1) % N\n            t = set(sets[i]).intersection(set(sets[prev]))\n            sz = len(t)\n            if sz < best:\n                best = sz\n                mem = i\n                saved_set = list(t)\n        sets = sets[mem:] + sets[:mem]\n        ans = calc(sets)\n        saved_set.sort()\n        for val in saved_set:\n            sets[0] = [val]\n            sets[-1] = [val]\n            ans += MOD - calc(sets)\n            ans %= MOD\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "sets[-1] = [val]",
      "mutated_line": "sets[-2] = [val]",
      "code": "MOD = 998244353\n\ndef count_valid_sequences(N, sets):\n\n    def calc(arr):\n        vars = {i: 1 for i in arr[0]}\n        for i in range(1, len(arr)):\n            tot = sum(vars.values()) % MOD\n            next = {}\n            for num in arr[i]:\n                cur = tot\n                if num in vars:\n                    cur += MOD - vars[num]\n                cur %= MOD\n                next[num] = cur\n            vars = next\n        return sum(vars.values()) % MOD\n    if N <= 450:\n        ans = 0\n        sign = False\n        while len(sets) > 1:\n            cur = calc(sets)\n            if sign:\n                cur = MOD - cur\n            ans += cur\n            ans %= MOD\n            sets[0] = list(set(sets[0]).intersection(set(sets[-1])))\n            sets[0].sort()\n            del sets[-1:]\n            sign = not sign\n        return ans\n    else:\n        best = 10 ** 15\n        mem = -1\n        saved_set = []\n        for i in range(N):\n            prev = (i + N - 1) % N\n            t = set(sets[i]).intersection(set(sets[prev]))\n            sz = len(t)\n            if sz < best:\n                best = sz\n                mem = i\n                saved_set = list(t)\n        sets = sets[mem:] + sets[:mem]\n        ans = calc(sets)\n        saved_set.sort()\n        for val in saved_set:\n            sets[0] = [val]\n            sets[-2] = [val]\n            ans += MOD - calc(sets)\n            ans %= MOD\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "sets[-1] = [val]",
      "mutated_line": "sets[-0] = [val]",
      "code": "MOD = 998244353\n\ndef count_valid_sequences(N, sets):\n\n    def calc(arr):\n        vars = {i: 1 for i in arr[0]}\n        for i in range(1, len(arr)):\n            tot = sum(vars.values()) % MOD\n            next = {}\n            for num in arr[i]:\n                cur = tot\n                if num in vars:\n                    cur += MOD - vars[num]\n                cur %= MOD\n                next[num] = cur\n            vars = next\n        return sum(vars.values()) % MOD\n    if N <= 450:\n        ans = 0\n        sign = False\n        while len(sets) > 1:\n            cur = calc(sets)\n            if sign:\n                cur = MOD - cur\n            ans += cur\n            ans %= MOD\n            sets[0] = list(set(sets[0]).intersection(set(sets[-1])))\n            sets[0].sort()\n            del sets[-1:]\n            sign = not sign\n        return ans\n    else:\n        best = 10 ** 15\n        mem = -1\n        saved_set = []\n        for i in range(N):\n            prev = (i + N - 1) % N\n            t = set(sets[i]).intersection(set(sets[prev]))\n            sz = len(t)\n            if sz < best:\n                best = sz\n                mem = i\n                saved_set = list(t)\n        sets = sets[mem:] + sets[:mem]\n        ans = calc(sets)\n        saved_set.sort()\n        for val in saved_set:\n            sets[0] = [val]\n            sets[-0] = [val]\n            ans += MOD - calc(sets)\n            ans %= MOD\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "sets[-1] = [val]",
      "mutated_line": "sets[-0] = [val]",
      "code": "MOD = 998244353\n\ndef count_valid_sequences(N, sets):\n\n    def calc(arr):\n        vars = {i: 1 for i in arr[0]}\n        for i in range(1, len(arr)):\n            tot = sum(vars.values()) % MOD\n            next = {}\n            for num in arr[i]:\n                cur = tot\n                if num in vars:\n                    cur += MOD - vars[num]\n                cur %= MOD\n                next[num] = cur\n            vars = next\n        return sum(vars.values()) % MOD\n    if N <= 450:\n        ans = 0\n        sign = False\n        while len(sets) > 1:\n            cur = calc(sets)\n            if sign:\n                cur = MOD - cur\n            ans += cur\n            ans %= MOD\n            sets[0] = list(set(sets[0]).intersection(set(sets[-1])))\n            sets[0].sort()\n            del sets[-1:]\n            sign = not sign\n        return ans\n    else:\n        best = 10 ** 15\n        mem = -1\n        saved_set = []\n        for i in range(N):\n            prev = (i + N - 1) % N\n            t = set(sets[i]).intersection(set(sets[prev]))\n            sz = len(t)\n            if sz < best:\n                best = sz\n                mem = i\n                saved_set = list(t)\n        sets = sets[mem:] + sets[:mem]\n        ans = calc(sets)\n        saved_set.sort()\n        for val in saved_set:\n            sets[0] = [val]\n            sets[-0] = [val]\n            ans += MOD - calc(sets)\n            ans %= MOD\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "sets[-1] = [val]",
      "mutated_line": "sets[--1] = [val]",
      "code": "MOD = 998244353\n\ndef count_valid_sequences(N, sets):\n\n    def calc(arr):\n        vars = {i: 1 for i in arr[0]}\n        for i in range(1, len(arr)):\n            tot = sum(vars.values()) % MOD\n            next = {}\n            for num in arr[i]:\n                cur = tot\n                if num in vars:\n                    cur += MOD - vars[num]\n                cur %= MOD\n                next[num] = cur\n            vars = next\n        return sum(vars.values()) % MOD\n    if N <= 450:\n        ans = 0\n        sign = False\n        while len(sets) > 1:\n            cur = calc(sets)\n            if sign:\n                cur = MOD - cur\n            ans += cur\n            ans %= MOD\n            sets[0] = list(set(sets[0]).intersection(set(sets[-1])))\n            sets[0].sort()\n            del sets[-1:]\n            sign = not sign\n        return ans\n    else:\n        best = 10 ** 15\n        mem = -1\n        saved_set = []\n        for i in range(N):\n            prev = (i + N - 1) % N\n            t = set(sets[i]).intersection(set(sets[prev]))\n            sz = len(t)\n            if sz < best:\n                best = sz\n                mem = i\n                saved_set = list(t)\n        sets = sets[mem:] + sets[:mem]\n        ans = calc(sets)\n        saved_set.sort()\n        for val in saved_set:\n            sets[0] = [val]\n            sets[--1] = [val]\n            ans += MOD - calc(sets)\n            ans %= MOD\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "sets[0].sort()",
      "mutated_line": "sets[1].sort()",
      "code": "MOD = 998244353\n\ndef count_valid_sequences(N, sets):\n\n    def calc(arr):\n        vars = {i: 1 for i in arr[0]}\n        for i in range(1, len(arr)):\n            tot = sum(vars.values()) % MOD\n            next = {}\n            for num in arr[i]:\n                cur = tot\n                if num in vars:\n                    cur += MOD - vars[num]\n                cur %= MOD\n                next[num] = cur\n            vars = next\n        return sum(vars.values()) % MOD\n    if N <= 450:\n        ans = 0\n        sign = False\n        while len(sets) > 1:\n            cur = calc(sets)\n            if sign:\n                cur = MOD - cur\n            ans += cur\n            ans %= MOD\n            sets[0] = list(set(sets[0]).intersection(set(sets[-1])))\n            sets[1].sort()\n            del sets[-1:]\n            sign = not sign\n        return ans\n    else:\n        best = 10 ** 15\n        mem = -1\n        saved_set = []\n        for i in range(N):\n            prev = (i + N - 1) % N\n            t = set(sets[i]).intersection(set(sets[prev]))\n            sz = len(t)\n            if sz < best:\n                best = sz\n                mem = i\n                saved_set = list(t)\n        sets = sets[mem:] + sets[:mem]\n        ans = calc(sets)\n        saved_set.sort()\n        for val in saved_set:\n            sets[0] = [val]\n            sets[-1] = [val]\n            ans += MOD - calc(sets)\n            ans %= MOD\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "sets[0].sort()",
      "mutated_line": "sets[-1].sort()",
      "code": "MOD = 998244353\n\ndef count_valid_sequences(N, sets):\n\n    def calc(arr):\n        vars = {i: 1 for i in arr[0]}\n        for i in range(1, len(arr)):\n            tot = sum(vars.values()) % MOD\n            next = {}\n            for num in arr[i]:\n                cur = tot\n                if num in vars:\n                    cur += MOD - vars[num]\n                cur %= MOD\n                next[num] = cur\n            vars = next\n        return sum(vars.values()) % MOD\n    if N <= 450:\n        ans = 0\n        sign = False\n        while len(sets) > 1:\n            cur = calc(sets)\n            if sign:\n                cur = MOD - cur\n            ans += cur\n            ans %= MOD\n            sets[0] = list(set(sets[0]).intersection(set(sets[-1])))\n            sets[-1].sort()\n            del sets[-1:]\n            sign = not sign\n        return ans\n    else:\n        best = 10 ** 15\n        mem = -1\n        saved_set = []\n        for i in range(N):\n            prev = (i + N - 1) % N\n            t = set(sets[i]).intersection(set(sets[prev]))\n            sz = len(t)\n            if sz < best:\n                best = sz\n                mem = i\n                saved_set = list(t)\n        sets = sets[mem:] + sets[:mem]\n        ans = calc(sets)\n        saved_set.sort()\n        for val in saved_set:\n            sets[0] = [val]\n            sets[-1] = [val]\n            ans += MOD - calc(sets)\n            ans %= MOD\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "sets[0].sort()",
      "mutated_line": "sets[1].sort()",
      "code": "MOD = 998244353\n\ndef count_valid_sequences(N, sets):\n\n    def calc(arr):\n        vars = {i: 1 for i in arr[0]}\n        for i in range(1, len(arr)):\n            tot = sum(vars.values()) % MOD\n            next = {}\n            for num in arr[i]:\n                cur = tot\n                if num in vars:\n                    cur += MOD - vars[num]\n                cur %= MOD\n                next[num] = cur\n            vars = next\n        return sum(vars.values()) % MOD\n    if N <= 450:\n        ans = 0\n        sign = False\n        while len(sets) > 1:\n            cur = calc(sets)\n            if sign:\n                cur = MOD - cur\n            ans += cur\n            ans %= MOD\n            sets[0] = list(set(sets[0]).intersection(set(sets[-1])))\n            sets[1].sort()\n            del sets[-1:]\n            sign = not sign\n        return ans\n    else:\n        best = 10 ** 15\n        mem = -1\n        saved_set = []\n        for i in range(N):\n            prev = (i + N - 1) % N\n            t = set(sets[i]).intersection(set(sets[prev]))\n            sz = len(t)\n            if sz < best:\n                best = sz\n                mem = i\n                saved_set = list(t)\n        sets = sets[mem:] + sets[:mem]\n        ans = calc(sets)\n        saved_set.sort()\n        for val in saved_set:\n            sets[0] = [val]\n            sets[-1] = [val]\n            ans += MOD - calc(sets)\n            ans %= MOD\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "del sets[-1:]",
      "mutated_line": "del sets[-2:]",
      "code": "MOD = 998244353\n\ndef count_valid_sequences(N, sets):\n\n    def calc(arr):\n        vars = {i: 1 for i in arr[0]}\n        for i in range(1, len(arr)):\n            tot = sum(vars.values()) % MOD\n            next = {}\n            for num in arr[i]:\n                cur = tot\n                if num in vars:\n                    cur += MOD - vars[num]\n                cur %= MOD\n                next[num] = cur\n            vars = next\n        return sum(vars.values()) % MOD\n    if N <= 450:\n        ans = 0\n        sign = False\n        while len(sets) > 1:\n            cur = calc(sets)\n            if sign:\n                cur = MOD - cur\n            ans += cur\n            ans %= MOD\n            sets[0] = list(set(sets[0]).intersection(set(sets[-1])))\n            sets[0].sort()\n            del sets[-2:]\n            sign = not sign\n        return ans\n    else:\n        best = 10 ** 15\n        mem = -1\n        saved_set = []\n        for i in range(N):\n            prev = (i + N - 1) % N\n            t = set(sets[i]).intersection(set(sets[prev]))\n            sz = len(t)\n            if sz < best:\n                best = sz\n                mem = i\n                saved_set = list(t)\n        sets = sets[mem:] + sets[:mem]\n        ans = calc(sets)\n        saved_set.sort()\n        for val in saved_set:\n            sets[0] = [val]\n            sets[-1] = [val]\n            ans += MOD - calc(sets)\n            ans %= MOD\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "del sets[-1:]",
      "mutated_line": "del sets[-0:]",
      "code": "MOD = 998244353\n\ndef count_valid_sequences(N, sets):\n\n    def calc(arr):\n        vars = {i: 1 for i in arr[0]}\n        for i in range(1, len(arr)):\n            tot = sum(vars.values()) % MOD\n            next = {}\n            for num in arr[i]:\n                cur = tot\n                if num in vars:\n                    cur += MOD - vars[num]\n                cur %= MOD\n                next[num] = cur\n            vars = next\n        return sum(vars.values()) % MOD\n    if N <= 450:\n        ans = 0\n        sign = False\n        while len(sets) > 1:\n            cur = calc(sets)\n            if sign:\n                cur = MOD - cur\n            ans += cur\n            ans %= MOD\n            sets[0] = list(set(sets[0]).intersection(set(sets[-1])))\n            sets[0].sort()\n            del sets[-0:]\n            sign = not sign\n        return ans\n    else:\n        best = 10 ** 15\n        mem = -1\n        saved_set = []\n        for i in range(N):\n            prev = (i + N - 1) % N\n            t = set(sets[i]).intersection(set(sets[prev]))\n            sz = len(t)\n            if sz < best:\n                best = sz\n                mem = i\n                saved_set = list(t)\n        sets = sets[mem:] + sets[:mem]\n        ans = calc(sets)\n        saved_set.sort()\n        for val in saved_set:\n            sets[0] = [val]\n            sets[-1] = [val]\n            ans += MOD - calc(sets)\n            ans %= MOD\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "del sets[-1:]",
      "mutated_line": "del sets[-0:]",
      "code": "MOD = 998244353\n\ndef count_valid_sequences(N, sets):\n\n    def calc(arr):\n        vars = {i: 1 for i in arr[0]}\n        for i in range(1, len(arr)):\n            tot = sum(vars.values()) % MOD\n            next = {}\n            for num in arr[i]:\n                cur = tot\n                if num in vars:\n                    cur += MOD - vars[num]\n                cur %= MOD\n                next[num] = cur\n            vars = next\n        return sum(vars.values()) % MOD\n    if N <= 450:\n        ans = 0\n        sign = False\n        while len(sets) > 1:\n            cur = calc(sets)\n            if sign:\n                cur = MOD - cur\n            ans += cur\n            ans %= MOD\n            sets[0] = list(set(sets[0]).intersection(set(sets[-1])))\n            sets[0].sort()\n            del sets[-0:]\n            sign = not sign\n        return ans\n    else:\n        best = 10 ** 15\n        mem = -1\n        saved_set = []\n        for i in range(N):\n            prev = (i + N - 1) % N\n            t = set(sets[i]).intersection(set(sets[prev]))\n            sz = len(t)\n            if sz < best:\n                best = sz\n                mem = i\n                saved_set = list(t)\n        sets = sets[mem:] + sets[:mem]\n        ans = calc(sets)\n        saved_set.sort()\n        for val in saved_set:\n            sets[0] = [val]\n            sets[-1] = [val]\n            ans += MOD - calc(sets)\n            ans %= MOD\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "del sets[-1:]",
      "mutated_line": "del sets[--1:]",
      "code": "MOD = 998244353\n\ndef count_valid_sequences(N, sets):\n\n    def calc(arr):\n        vars = {i: 1 for i in arr[0]}\n        for i in range(1, len(arr)):\n            tot = sum(vars.values()) % MOD\n            next = {}\n            for num in arr[i]:\n                cur = tot\n                if num in vars:\n                    cur += MOD - vars[num]\n                cur %= MOD\n                next[num] = cur\n            vars = next\n        return sum(vars.values()) % MOD\n    if N <= 450:\n        ans = 0\n        sign = False\n        while len(sets) > 1:\n            cur = calc(sets)\n            if sign:\n                cur = MOD - cur\n            ans += cur\n            ans %= MOD\n            sets[0] = list(set(sets[0]).intersection(set(sets[-1])))\n            sets[0].sort()\n            del sets[--1:]\n            sign = not sign\n        return ans\n    else:\n        best = 10 ** 15\n        mem = -1\n        saved_set = []\n        for i in range(N):\n            prev = (i + N - 1) % N\n            t = set(sets[i]).intersection(set(sets[prev]))\n            sz = len(t)\n            if sz < best:\n                best = sz\n                mem = i\n                saved_set = list(t)\n        sets = sets[mem:] + sets[:mem]\n        ans = calc(sets)\n        saved_set.sort()\n        for val in saved_set:\n            sets[0] = [val]\n            sets[-1] = [val]\n            ans += MOD - calc(sets)\n            ans %= MOD\n        return ans"
    },
    {
      "operator": "UOI",
      "lineno": 27,
      "original_line": "sets[0] = list(set(sets[0]).intersection(set(sets[-1])))",
      "mutated_line": "sets[0] = list(set(sets[0]).intersection(set(sets[+1])))",
      "code": "MOD = 998244353\n\ndef count_valid_sequences(N, sets):\n\n    def calc(arr):\n        vars = {i: 1 for i in arr[0]}\n        for i in range(1, len(arr)):\n            tot = sum(vars.values()) % MOD\n            next = {}\n            for num in arr[i]:\n                cur = tot\n                if num in vars:\n                    cur += MOD - vars[num]\n                cur %= MOD\n                next[num] = cur\n            vars = next\n        return sum(vars.values()) % MOD\n    if N <= 450:\n        ans = 0\n        sign = False\n        while len(sets) > 1:\n            cur = calc(sets)\n            if sign:\n                cur = MOD - cur\n            ans += cur\n            ans %= MOD\n            sets[0] = list(set(sets[0]).intersection(set(sets[+1])))\n            sets[0].sort()\n            del sets[-1:]\n            sign = not sign\n        return ans\n    else:\n        best = 10 ** 15\n        mem = -1\n        saved_set = []\n        for i in range(N):\n            prev = (i + N - 1) % N\n            t = set(sets[i]).intersection(set(sets[prev]))\n            sz = len(t)\n            if sz < best:\n                best = sz\n                mem = i\n                saved_set = list(t)\n        sets = sets[mem:] + sets[:mem]\n        ans = calc(sets)\n        saved_set.sort()\n        for val in saved_set:\n            sets[0] = [val]\n            sets[-1] = [val]\n            ans += MOD - calc(sets)\n            ans %= MOD\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "sets[0] = list(set(sets[0]).intersection(set(sets[-1])))",
      "mutated_line": "sets[0] = list(set(sets[1]).intersection(set(sets[-1])))",
      "code": "MOD = 998244353\n\ndef count_valid_sequences(N, sets):\n\n    def calc(arr):\n        vars = {i: 1 for i in arr[0]}\n        for i in range(1, len(arr)):\n            tot = sum(vars.values()) % MOD\n            next = {}\n            for num in arr[i]:\n                cur = tot\n                if num in vars:\n                    cur += MOD - vars[num]\n                cur %= MOD\n                next[num] = cur\n            vars = next\n        return sum(vars.values()) % MOD\n    if N <= 450:\n        ans = 0\n        sign = False\n        while len(sets) > 1:\n            cur = calc(sets)\n            if sign:\n                cur = MOD - cur\n            ans += cur\n            ans %= MOD\n            sets[0] = list(set(sets[1]).intersection(set(sets[-1])))\n            sets[0].sort()\n            del sets[-1:]\n            sign = not sign\n        return ans\n    else:\n        best = 10 ** 15\n        mem = -1\n        saved_set = []\n        for i in range(N):\n            prev = (i + N - 1) % N\n            t = set(sets[i]).intersection(set(sets[prev]))\n            sz = len(t)\n            if sz < best:\n                best = sz\n                mem = i\n                saved_set = list(t)\n        sets = sets[mem:] + sets[:mem]\n        ans = calc(sets)\n        saved_set.sort()\n        for val in saved_set:\n            sets[0] = [val]\n            sets[-1] = [val]\n            ans += MOD - calc(sets)\n            ans %= MOD\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "sets[0] = list(set(sets[0]).intersection(set(sets[-1])))",
      "mutated_line": "sets[0] = list(set(sets[-1]).intersection(set(sets[-1])))",
      "code": "MOD = 998244353\n\ndef count_valid_sequences(N, sets):\n\n    def calc(arr):\n        vars = {i: 1 for i in arr[0]}\n        for i in range(1, len(arr)):\n            tot = sum(vars.values()) % MOD\n            next = {}\n            for num in arr[i]:\n                cur = tot\n                if num in vars:\n                    cur += MOD - vars[num]\n                cur %= MOD\n                next[num] = cur\n            vars = next\n        return sum(vars.values()) % MOD\n    if N <= 450:\n        ans = 0\n        sign = False\n        while len(sets) > 1:\n            cur = calc(sets)\n            if sign:\n                cur = MOD - cur\n            ans += cur\n            ans %= MOD\n            sets[0] = list(set(sets[-1]).intersection(set(sets[-1])))\n            sets[0].sort()\n            del sets[-1:]\n            sign = not sign\n        return ans\n    else:\n        best = 10 ** 15\n        mem = -1\n        saved_set = []\n        for i in range(N):\n            prev = (i + N - 1) % N\n            t = set(sets[i]).intersection(set(sets[prev]))\n            sz = len(t)\n            if sz < best:\n                best = sz\n                mem = i\n                saved_set = list(t)\n        sets = sets[mem:] + sets[:mem]\n        ans = calc(sets)\n        saved_set.sort()\n        for val in saved_set:\n            sets[0] = [val]\n            sets[-1] = [val]\n            ans += MOD - calc(sets)\n            ans %= MOD\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "sets[0] = list(set(sets[0]).intersection(set(sets[-1])))",
      "mutated_line": "sets[0] = list(set(sets[1]).intersection(set(sets[-1])))",
      "code": "MOD = 998244353\n\ndef count_valid_sequences(N, sets):\n\n    def calc(arr):\n        vars = {i: 1 for i in arr[0]}\n        for i in range(1, len(arr)):\n            tot = sum(vars.values()) % MOD\n            next = {}\n            for num in arr[i]:\n                cur = tot\n                if num in vars:\n                    cur += MOD - vars[num]\n                cur %= MOD\n                next[num] = cur\n            vars = next\n        return sum(vars.values()) % MOD\n    if N <= 450:\n        ans = 0\n        sign = False\n        while len(sets) > 1:\n            cur = calc(sets)\n            if sign:\n                cur = MOD - cur\n            ans += cur\n            ans %= MOD\n            sets[0] = list(set(sets[1]).intersection(set(sets[-1])))\n            sets[0].sort()\n            del sets[-1:]\n            sign = not sign\n        return ans\n    else:\n        best = 10 ** 15\n        mem = -1\n        saved_set = []\n        for i in range(N):\n            prev = (i + N - 1) % N\n            t = set(sets[i]).intersection(set(sets[prev]))\n            sz = len(t)\n            if sz < best:\n                best = sz\n                mem = i\n                saved_set = list(t)\n        sets = sets[mem:] + sets[:mem]\n        ans = calc(sets)\n        saved_set.sort()\n        for val in saved_set:\n            sets[0] = [val]\n            sets[-1] = [val]\n            ans += MOD - calc(sets)\n            ans %= MOD\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "sets[0] = list(set(sets[0]).intersection(set(sets[-1])))",
      "mutated_line": "sets[0] = list(set(sets[0]).intersection(set(sets[-2])))",
      "code": "MOD = 998244353\n\ndef count_valid_sequences(N, sets):\n\n    def calc(arr):\n        vars = {i: 1 for i in arr[0]}\n        for i in range(1, len(arr)):\n            tot = sum(vars.values()) % MOD\n            next = {}\n            for num in arr[i]:\n                cur = tot\n                if num in vars:\n                    cur += MOD - vars[num]\n                cur %= MOD\n                next[num] = cur\n            vars = next\n        return sum(vars.values()) % MOD\n    if N <= 450:\n        ans = 0\n        sign = False\n        while len(sets) > 1:\n            cur = calc(sets)\n            if sign:\n                cur = MOD - cur\n            ans += cur\n            ans %= MOD\n            sets[0] = list(set(sets[0]).intersection(set(sets[-2])))\n            sets[0].sort()\n            del sets[-1:]\n            sign = not sign\n        return ans\n    else:\n        best = 10 ** 15\n        mem = -1\n        saved_set = []\n        for i in range(N):\n            prev = (i + N - 1) % N\n            t = set(sets[i]).intersection(set(sets[prev]))\n            sz = len(t)\n            if sz < best:\n                best = sz\n                mem = i\n                saved_set = list(t)\n        sets = sets[mem:] + sets[:mem]\n        ans = calc(sets)\n        saved_set.sort()\n        for val in saved_set:\n            sets[0] = [val]\n            sets[-1] = [val]\n            ans += MOD - calc(sets)\n            ans %= MOD\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "sets[0] = list(set(sets[0]).intersection(set(sets[-1])))",
      "mutated_line": "sets[0] = list(set(sets[0]).intersection(set(sets[-0])))",
      "code": "MOD = 998244353\n\ndef count_valid_sequences(N, sets):\n\n    def calc(arr):\n        vars = {i: 1 for i in arr[0]}\n        for i in range(1, len(arr)):\n            tot = sum(vars.values()) % MOD\n            next = {}\n            for num in arr[i]:\n                cur = tot\n                if num in vars:\n                    cur += MOD - vars[num]\n                cur %= MOD\n                next[num] = cur\n            vars = next\n        return sum(vars.values()) % MOD\n    if N <= 450:\n        ans = 0\n        sign = False\n        while len(sets) > 1:\n            cur = calc(sets)\n            if sign:\n                cur = MOD - cur\n            ans += cur\n            ans %= MOD\n            sets[0] = list(set(sets[0]).intersection(set(sets[-0])))\n            sets[0].sort()\n            del sets[-1:]\n            sign = not sign\n        return ans\n    else:\n        best = 10 ** 15\n        mem = -1\n        saved_set = []\n        for i in range(N):\n            prev = (i + N - 1) % N\n            t = set(sets[i]).intersection(set(sets[prev]))\n            sz = len(t)\n            if sz < best:\n                best = sz\n                mem = i\n                saved_set = list(t)\n        sets = sets[mem:] + sets[:mem]\n        ans = calc(sets)\n        saved_set.sort()\n        for val in saved_set:\n            sets[0] = [val]\n            sets[-1] = [val]\n            ans += MOD - calc(sets)\n            ans %= MOD\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "sets[0] = list(set(sets[0]).intersection(set(sets[-1])))",
      "mutated_line": "sets[0] = list(set(sets[0]).intersection(set(sets[-0])))",
      "code": "MOD = 998244353\n\ndef count_valid_sequences(N, sets):\n\n    def calc(arr):\n        vars = {i: 1 for i in arr[0]}\n        for i in range(1, len(arr)):\n            tot = sum(vars.values()) % MOD\n            next = {}\n            for num in arr[i]:\n                cur = tot\n                if num in vars:\n                    cur += MOD - vars[num]\n                cur %= MOD\n                next[num] = cur\n            vars = next\n        return sum(vars.values()) % MOD\n    if N <= 450:\n        ans = 0\n        sign = False\n        while len(sets) > 1:\n            cur = calc(sets)\n            if sign:\n                cur = MOD - cur\n            ans += cur\n            ans %= MOD\n            sets[0] = list(set(sets[0]).intersection(set(sets[-0])))\n            sets[0].sort()\n            del sets[-1:]\n            sign = not sign\n        return ans\n    else:\n        best = 10 ** 15\n        mem = -1\n        saved_set = []\n        for i in range(N):\n            prev = (i + N - 1) % N\n            t = set(sets[i]).intersection(set(sets[prev]))\n            sz = len(t)\n            if sz < best:\n                best = sz\n                mem = i\n                saved_set = list(t)\n        sets = sets[mem:] + sets[:mem]\n        ans = calc(sets)\n        saved_set.sort()\n        for val in saved_set:\n            sets[0] = [val]\n            sets[-1] = [val]\n            ans += MOD - calc(sets)\n            ans %= MOD\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "sets[0] = list(set(sets[0]).intersection(set(sets[-1])))",
      "mutated_line": "sets[0] = list(set(sets[0]).intersection(set(sets[--1])))",
      "code": "MOD = 998244353\n\ndef count_valid_sequences(N, sets):\n\n    def calc(arr):\n        vars = {i: 1 for i in arr[0]}\n        for i in range(1, len(arr)):\n            tot = sum(vars.values()) % MOD\n            next = {}\n            for num in arr[i]:\n                cur = tot\n                if num in vars:\n                    cur += MOD - vars[num]\n                cur %= MOD\n                next[num] = cur\n            vars = next\n        return sum(vars.values()) % MOD\n    if N <= 450:\n        ans = 0\n        sign = False\n        while len(sets) > 1:\n            cur = calc(sets)\n            if sign:\n                cur = MOD - cur\n            ans += cur\n            ans %= MOD\n            sets[0] = list(set(sets[0]).intersection(set(sets[--1])))\n            sets[0].sort()\n            del sets[-1:]\n            sign = not sign\n        return ans\n    else:\n        best = 10 ** 15\n        mem = -1\n        saved_set = []\n        for i in range(N):\n            prev = (i + N - 1) % N\n            t = set(sets[i]).intersection(set(sets[prev]))\n            sz = len(t)\n            if sz < best:\n                best = sz\n                mem = i\n                saved_set = list(t)\n        sets = sets[mem:] + sets[:mem]\n        ans = calc(sets)\n        saved_set.sort()\n        for val in saved_set:\n            sets[0] = [val]\n            sets[-1] = [val]\n            ans += MOD - calc(sets)\n            ans %= MOD\n        return ans"
    }
  ]
}