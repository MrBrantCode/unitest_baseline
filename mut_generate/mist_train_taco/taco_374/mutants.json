{
  "task_id": "taco_374",
  "entry_point": "find_valid_a",
  "mutant_count": 215,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "while i < j:",
      "mutated_line": "while i <= j:",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i <= j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "while i < j:",
      "mutated_line": "while i >= j:",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i >= j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "while i < j:",
      "mutated_line": "while i != j:",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i != j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "ASR",
      "lineno": 29,
      "original_line": "i += 1",
      "mutated_line": "i -= 1",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i -= 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "ASR",
      "lineno": 30,
      "original_line": "j -= 1",
      "mutated_line": "j += 1",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j += 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if i == j:",
      "mutated_line": "if i != j:",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i != j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "return al + list(reversed(ar))",
      "mutated_line": "return al - list(reversed(ar))",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al - list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "return al + list(reversed(ar))",
      "mutated_line": "return al * list(reversed(ar))",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al * list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if dn[0] == 1:",
      "mutated_line": "if dn[0] != 1:",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] != 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "di = dn[i] + 10 * ci",
      "mutated_line": "di = dn[i] - 10 * ci",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] - 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "di = dn[i] + 10 * ci",
      "mutated_line": "di = dn[i] * (10 * ci)",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] * (10 * ci)\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dj = dn[j] - cj",
      "mutated_line": "dj = dn[j] + cj",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] + cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dj = dn[j] - cj",
      "mutated_line": "dj = dn[j] * cj",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] * cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "i += 1",
      "mutated_line": "i += 2",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 2\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "i += 1",
      "mutated_line": "i += 0",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 0\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "i += 1",
      "mutated_line": "i += 0",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 0\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "i += 1",
      "mutated_line": "i += -1",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += -1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "j -= 1",
      "mutated_line": "j -= 2",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 2\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "j -= 1",
      "mutated_line": "j -= 0",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 0\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "j -= 1",
      "mutated_line": "j -= 0",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 0\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "j -= 1",
      "mutated_line": "j -= -1",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= -1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "d = dn[i] + 10 * ci - cj",
      "mutated_line": "d = dn[i] + 10 * ci + cj",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci + cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "d = dn[i] + 10 * ci - cj",
      "mutated_line": "d = (dn[i] + 10 * ci) * cj",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = (dn[i] + 10 * ci) * cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "LCR",
      "lineno": 33,
      "original_line": "if d < 0 or d % 2:",
      "mutated_line": "if d < 0 and d % 2:",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 and d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "elif ci != cj:",
      "mutated_line": "elif ci == cj:",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci == cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if dn[0] == 1:",
      "mutated_line": "if dn[0] == 2:",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 2:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if dn[0] == 1:",
      "mutated_line": "if dn[0] == 0:",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 0:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if dn[0] == 1:",
      "mutated_line": "if dn[0] == 0:",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 0:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if dn[0] == 1:",
      "mutated_line": "if dn[0] == -1:",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == -1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "LCR",
      "lineno": 42,
      "original_line": "return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]",
      "mutated_line": "return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) and _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) and [0]",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) and _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) and [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "LCR",
      "lineno": 44,
      "original_line": "return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]",
      "mutated_line": "return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) and [0]",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) and [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return ''.join(map(str, result))",
      "mutated_line": "return 'MUTATED'.join(map(str, result))",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return 'MUTATED'.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "(n, d) = divmod(n, 10)",
      "mutated_line": "(n, d) = divmod(n, 11)",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 11)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "(n, d) = divmod(n, 10)",
      "mutated_line": "(n, d) = divmod(n, 9)",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 9)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "(n, d) = divmod(n, 10)",
      "mutated_line": "(n, d) = divmod(n, 0)",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 0)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "(n, d) = divmod(n, 10)",
      "mutated_line": "(n, d) = divmod(n, 1)",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 1)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "(n, d) = divmod(n, 10)",
      "mutated_line": "(n, d) = divmod(n, -10)",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, -10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "di = dn[i] + 10 * ci",
      "mutated_line": "di = dn[i] + 10 / ci",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 / ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "di = dn[i] + 10 * ci",
      "mutated_line": "di = dn[i] + (10 + ci)",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + (10 + ci)\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "di = dn[i] + 10 * ci",
      "mutated_line": "di = dn[i] + 10 ** ci",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 ** ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "d = di - ci",
      "mutated_line": "d = di + ci",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di + ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "d = di - ci",
      "mutated_line": "d = di * ci",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di * ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "LCR",
      "lineno": 15,
      "original_line": "if d < 0 or d > 18:",
      "mutated_line": "if d < 0 and d > 18:",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 and d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if dj + 10 * cj == d:",
      "mutated_line": "if dj + 10 * cj != d:",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj != d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "d = dn[i] + 10 * ci - cj",
      "mutated_line": "d = dn[i] - 10 * ci - cj",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] - 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "d = dn[i] + 10 * ci - cj",
      "mutated_line": "d = dn[i] * (10 * ci) - cj",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] * (10 * ci) - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if d < 0 or d % 2:",
      "mutated_line": "if d <= 0 or d % 2:",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d <= 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if d < 0 or d % 2:",
      "mutated_line": "if d >= 0 or d % 2:",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d >= 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if d < 0 or d % 2:",
      "mutated_line": "if d != 0 or d % 2:",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d != 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "if d < 0 or d % 2:",
      "mutated_line": "if d < 0 or d * 2:",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d * 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "if d < 0 or d % 2:",
      "mutated_line": "if d < 0 or d + 2:",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d + 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "al.append(d // 2)",
      "mutated_line": "al.append(d / 2)",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d / 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "al.append(d // 2)",
      "mutated_line": "al.append(d * 2)",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d * 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if dn[0] == 1:",
      "mutated_line": "if dn[1] == 1:",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[1] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if dn[0] == 1:",
      "mutated_line": "if dn[-1] == 1:",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[-1] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if dn[0] == 1:",
      "mutated_line": "if dn[1] == 1:",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[1] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "di = dn[i] + 10 * ci",
      "mutated_line": "di = dn[i] + 11 * ci",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 11 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "di = dn[i] + 10 * ci",
      "mutated_line": "di = dn[i] + 9 * ci",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 9 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "di = dn[i] + 10 * ci",
      "mutated_line": "di = dn[i] + 0 * ci",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 0 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "di = dn[i] + 10 * ci",
      "mutated_line": "di = dn[i] + 1 * ci",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 1 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "di = dn[i] + 10 * ci",
      "mutated_line": "di = dn[i] + -10 * ci",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + -10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):",
      "mutated_line": "for (ci, cj) in ((1, 0), (0, 1), (1, 0), (1, 1)):",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((1, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):",
      "mutated_line": "for (ci, cj) in ((-1, 0), (0, 1), (1, 0), (1, 1)):",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((-1, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):",
      "mutated_line": "for (ci, cj) in ((1, 0), (0, 1), (1, 0), (1, 1)):",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((1, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):",
      "mutated_line": "for (ci, cj) in ((0, 1), (0, 1), (1, 0), (1, 1)):",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 1), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):",
      "mutated_line": "for (ci, cj) in ((0, -1), (0, 1), (1, 0), (1, 1)):",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, -1), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):",
      "mutated_line": "for (ci, cj) in ((0, 1), (0, 1), (1, 0), (1, 1)):",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 1), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):",
      "mutated_line": "for (ci, cj) in ((0, 0), (1, 1), (1, 0), (1, 1)):",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (1, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):",
      "mutated_line": "for (ci, cj) in ((0, 0), (-1, 1), (1, 0), (1, 1)):",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (-1, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):",
      "mutated_line": "for (ci, cj) in ((0, 0), (1, 1), (1, 0), (1, 1)):",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (1, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):",
      "mutated_line": "for (ci, cj) in ((0, 0), (0, 2), (1, 0), (1, 1)):",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 2), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):",
      "mutated_line": "for (ci, cj) in ((0, 0), (0, 0), (1, 0), (1, 1)):",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 0), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):",
      "mutated_line": "for (ci, cj) in ((0, 0), (0, 0), (1, 0), (1, 1)):",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 0), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):",
      "mutated_line": "for (ci, cj) in ((0, 0), (0, -1), (1, 0), (1, 1)):",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, -1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):",
      "mutated_line": "for (ci, cj) in ((0, 0), (0, 1), (2, 0), (1, 1)):",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (2, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):",
      "mutated_line": "for (ci, cj) in ((0, 0), (0, 1), (0, 0), (1, 1)):",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (0, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):",
      "mutated_line": "for (ci, cj) in ((0, 0), (0, 1), (0, 0), (1, 1)):",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (0, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):",
      "mutated_line": "for (ci, cj) in ((0, 0), (0, 1), (-1, 0), (1, 1)):",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (-1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):",
      "mutated_line": "for (ci, cj) in ((0, 0), (0, 1), (1, 1), (1, 1)):",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 1), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):",
      "mutated_line": "for (ci, cj) in ((0, 0), (0, 1), (1, -1), (1, 1)):",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, -1), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):",
      "mutated_line": "for (ci, cj) in ((0, 0), (0, 1), (1, 1), (1, 1)):",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 1), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):",
      "mutated_line": "for (ci, cj) in ((0, 0), (0, 1), (1, 0), (2, 1)):",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (2, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):",
      "mutated_line": "for (ci, cj) in ((0, 0), (0, 1), (1, 0), (0, 1)):",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (0, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):",
      "mutated_line": "for (ci, cj) in ((0, 0), (0, 1), (1, 0), (0, 1)):",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (0, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):",
      "mutated_line": "for (ci, cj) in ((0, 0), (0, 1), (1, 0), (-1, 1)):",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (-1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):",
      "mutated_line": "for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 2)):",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 2)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):",
      "mutated_line": "for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 0)):",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 0)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):",
      "mutated_line": "for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 0)):",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 0)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):",
      "mutated_line": "for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, -1)):",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, -1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if d < 0 or d > 18:",
      "mutated_line": "if d <= 0 or d > 18:",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d <= 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if d < 0 or d > 18:",
      "mutated_line": "if d >= 0 or d > 18:",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d >= 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if d < 0 or d > 18:",
      "mutated_line": "if d != 0 or d > 18:",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d != 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if d < 0 or d > 18:",
      "mutated_line": "if d < 0 or d >= 18:",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d >= 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if d < 0 or d > 18:",
      "mutated_line": "if d < 0 or d <= 18:",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d <= 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if d < 0 or d > 18:",
      "mutated_line": "if d < 0 or d != 18:",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d != 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "if dj + 10 * cj == d:",
      "mutated_line": "if dj - 10 * cj == d:",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj - 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "if dj + 10 * cj == d:",
      "mutated_line": "if dj * (10 * cj) == d:",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj * (10 * cj) == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if d < 10:",
      "mutated_line": "if d <= 10:",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d <= 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if d < 10:",
      "mutated_line": "if d >= 10:",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d >= 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if d < 10:",
      "mutated_line": "if d != 10:",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d != 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "d = dn[i] + 10 * ci - cj",
      "mutated_line": "d = dn[i] + 10 / ci - cj",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 / ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "d = dn[i] + 10 * ci - cj",
      "mutated_line": "d = dn[i] + (10 + ci) - cj",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + (10 + ci) - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "d = dn[i] + 10 * ci - cj",
      "mutated_line": "d = dn[i] + 10 ** ci - cj",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 ** ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if d < 0 or d % 2:",
      "mutated_line": "if d < 1 or d % 2:",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 1 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if d < 0 or d % 2:",
      "mutated_line": "if d < -1 or d % 2:",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < -1 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if d < 0 or d % 2:",
      "mutated_line": "if d < 1 or d % 2:",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 1 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if d < 0 or d % 2:",
      "mutated_line": "if d < 0 or d % 3:",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 3:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if d < 0 or d % 2:",
      "mutated_line": "if d < 0 or d % 1:",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 1:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if d < 0 or d % 2:",
      "mutated_line": "if d < 0 or d % 0:",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 0:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if d < 0 or d % 2:",
      "mutated_line": "if d < 0 or d % 1:",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 1:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if d < 0 or d % 2:",
      "mutated_line": "if d < 0 or d % -2:",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % -2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "al.append(d // 2)",
      "mutated_line": "al.append(d // 3)",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 3)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "al.append(d // 2)",
      "mutated_line": "al.append(d // 1)",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 1)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "al.append(d // 2)",
      "mutated_line": "al.append(d // 0)",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 0)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "al.append(d // 2)",
      "mutated_line": "al.append(d // 1)",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 1)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "al.append(d // 2)",
      "mutated_line": "al.append(d // -2)",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // -2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]",
      "mutated_line": "return _ifs(dn, 1, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 1, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]",
      "mutated_line": "return _ifs(dn, -1, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, -1, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]",
      "mutated_line": "return _ifs(dn, 1, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 1, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]",
      "mutated_line": "return _ifs(dn, 0, len(dn) + 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) + 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]",
      "mutated_line": "return _ifs(dn, 0, len(dn) * 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) * 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]",
      "mutated_line": "return _ifs(dn, 0, len(dn) - 1, 1, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 1, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]",
      "mutated_line": "return _ifs(dn, 0, len(dn) - 1, -1, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, -1, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]",
      "mutated_line": "return _ifs(dn, 0, len(dn) - 1, 1, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 1, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]",
      "mutated_line": "return _ifs(dn, 0, len(dn) - 1, 0, 1, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 1, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]",
      "mutated_line": "return _ifs(dn, 0, len(dn) - 1, 0, -1, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, -1, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]",
      "mutated_line": "return _ifs(dn, 0, len(dn) - 1, 0, 1, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 1, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]",
      "mutated_line": "return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 2, len(dn) - 1, 1, 0, [], []) or [0]",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 2, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]",
      "mutated_line": "return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 0, len(dn) - 1, 1, 0, [], []) or [0]",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 0, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]",
      "mutated_line": "return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 0, len(dn) - 1, 1, 0, [], []) or [0]",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 0, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]",
      "mutated_line": "return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, -1, len(dn) - 1, 1, 0, [], []) or [0]",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, -1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]",
      "mutated_line": "return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) + 1, 1, 0, [], []) or [0]",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) + 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]",
      "mutated_line": "return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) * 1, 1, 0, [], []) or [0]",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) * 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]",
      "mutated_line": "return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 2, 0, [], []) or [0]",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 2, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]",
      "mutated_line": "return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 0, 0, [], []) or [0]",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 0, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]",
      "mutated_line": "return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 0, 0, [], []) or [0]",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 0, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]",
      "mutated_line": "return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, -1, 0, [], []) or [0]",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, -1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]",
      "mutated_line": "return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 1, [], []) or [0]",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 1, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]",
      "mutated_line": "return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, -1, [], []) or [0]",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, -1, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]",
      "mutated_line": "return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 1, [], []) or [0]",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 1, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]",
      "mutated_line": "return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [1]",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [1]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]",
      "mutated_line": "return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [-1]",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [-1]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]",
      "mutated_line": "return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [1]",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [1]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]",
      "mutated_line": "return _ifs(dn, 1, len(dn) - 1, 0, 0, [], []) or [0]",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 1, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]",
      "mutated_line": "return _ifs(dn, -1, len(dn) - 1, 0, 0, [], []) or [0]",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, -1, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]",
      "mutated_line": "return _ifs(dn, 1, len(dn) - 1, 0, 0, [], []) or [0]",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 1, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]",
      "mutated_line": "return _ifs(dn, 0, len(dn) + 1, 0, 0, [], []) or [0]",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) + 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]",
      "mutated_line": "return _ifs(dn, 0, len(dn) * 1, 0, 0, [], []) or [0]",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) * 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]",
      "mutated_line": "return _ifs(dn, 0, len(dn) - 1, 1, 0, [], []) or [0]",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 1, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]",
      "mutated_line": "return _ifs(dn, 0, len(dn) - 1, -1, 0, [], []) or [0]",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, -1, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]",
      "mutated_line": "return _ifs(dn, 0, len(dn) - 1, 1, 0, [], []) or [0]",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 1, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]",
      "mutated_line": "return _ifs(dn, 0, len(dn) - 1, 0, 1, [], []) or [0]",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 1, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]",
      "mutated_line": "return _ifs(dn, 0, len(dn) - 1, 0, -1, [], []) or [0]",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, -1, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]",
      "mutated_line": "return _ifs(dn, 0, len(dn) - 1, 0, 1, [], []) or [0]",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 1, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]",
      "mutated_line": "return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [1]",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [1]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]",
      "mutated_line": "return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [-1]",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [-1]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]",
      "mutated_line": "return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [1]",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [1]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if d < 0 or d > 18:",
      "mutated_line": "if d < 1 or d > 18:",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 1 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if d < 0 or d > 18:",
      "mutated_line": "if d < -1 or d > 18:",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < -1 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if d < 0 or d > 18:",
      "mutated_line": "if d < 1 or d > 18:",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 1 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if d < 0 or d > 18:",
      "mutated_line": "if d < 0 or d > 19:",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 19:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if d < 0 or d > 18:",
      "mutated_line": "if d < 0 or d > 17:",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 17:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if d < 0 or d > 18:",
      "mutated_line": "if d < 0 or d > 0:",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 0:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if d < 0 or d > 18:",
      "mutated_line": "if d < 0 or d > 1:",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 1:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if d < 0 or d > 18:",
      "mutated_line": "if d < 0 or d > -18:",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > -18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "if dj + 10 * cj == d:",
      "mutated_line": "if dj + 10 / cj == d:",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 / cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "if dj + 10 * cj == d:",
      "mutated_line": "if dj + (10 + cj) == d:",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + (10 + cj) == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "if dj + 10 * cj == d:",
      "mutated_line": "if dj + 10 ** cj == d:",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 ** cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if d < 10:",
      "mutated_line": "if d < 11:",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 11:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if d < 10:",
      "mutated_line": "if d < 9:",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 9:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if d < 10:",
      "mutated_line": "if d < 0:",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 0:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if d < 10:",
      "mutated_line": "if d < 1:",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 1:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if d < 10:",
      "mutated_line": "if d < -10:",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < -10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "LCR",
      "lineno": 19,
      "original_line": "if d == 0 and (not al):",
      "mutated_line": "if d == 0 or not al:",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 or not al:\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "d = dn[i] + 10 * ci - cj",
      "mutated_line": "d = dn[i] + 11 * ci - cj",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 11 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "d = dn[i] + 10 * ci - cj",
      "mutated_line": "d = dn[i] + 9 * ci - cj",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 9 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "d = dn[i] + 10 * ci - cj",
      "mutated_line": "d = dn[i] + 0 * ci - cj",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 0 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "d = dn[i] + 10 * ci - cj",
      "mutated_line": "d = dn[i] + 1 * ci - cj",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 1 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "d = dn[i] + 10 * ci - cj",
      "mutated_line": "d = dn[i] + -10 * ci - cj",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + -10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]",
      "mutated_line": "return _ifs(dn, 0, len(dn) - 2, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 2, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]",
      "mutated_line": "return _ifs(dn, 0, len(dn) - 0, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 0, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]",
      "mutated_line": "return _ifs(dn, 0, len(dn) - 0, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 0, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]",
      "mutated_line": "return _ifs(dn, 0, len(dn) - -1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - -1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]",
      "mutated_line": "return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 2, 1, 0, [], []) or [0]",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 2, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]",
      "mutated_line": "return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 0, 1, 0, [], []) or [0]",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 0, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]",
      "mutated_line": "return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 0, 1, 0, [], []) or [0]",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 0, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]",
      "mutated_line": "return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - -1, 1, 0, [], []) or [0]",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - -1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]",
      "mutated_line": "return _ifs(dn, 0, len(dn) - 2, 0, 0, [], []) or [0]",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 2, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]",
      "mutated_line": "return _ifs(dn, 0, len(dn) - 0, 0, 0, [], []) or [0]",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 0, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]",
      "mutated_line": "return _ifs(dn, 0, len(dn) - 0, 0, 0, [], []) or [0]",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 0, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]",
      "mutated_line": "return _ifs(dn, 0, len(dn) - -1, 0, 0, [], []) or [0]",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - -1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if dj + 10 * cj == d:",
      "mutated_line": "if dj + 11 * cj == d:",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 11 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if dj + 10 * cj == d:",
      "mutated_line": "if dj + 9 * cj == d:",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 9 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if dj + 10 * cj == d:",
      "mutated_line": "if dj + 0 * cj == d:",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 0 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if dj + 10 * cj == d:",
      "mutated_line": "if dj + 1 * cj == d:",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 1 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if dj + 10 * cj == d:",
      "mutated_line": "if dj + -10 * cj == d:",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + -10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if d == 0 and (not al):",
      "mutated_line": "if d != 0 and (not al):",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d != 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "ar.append(0)",
      "mutated_line": "ar.append(1)",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(1)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "ar.append(0)",
      "mutated_line": "ar.append(-1)",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(-1)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "ar.append(0)",
      "mutated_line": "ar.append(1)",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(1)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "al.append(9)",
      "mutated_line": "al.append(10)",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(10)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "al.append(9)",
      "mutated_line": "al.append(8)",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(8)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "al.append(9)",
      "mutated_line": "al.append(0)",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(0)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "al.append(9)",
      "mutated_line": "al.append(1)",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(1)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "al.append(9)",
      "mutated_line": "al.append(-9)",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(-9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "ar.append(d - 9)",
      "mutated_line": "ar.append(d + 9)",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d + 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "ar.append(d - 9)",
      "mutated_line": "ar.append(d * 9)",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d * 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if d == 0 and (not al):",
      "mutated_line": "if d == 1 and (not al):",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 1 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if d == 0 and (not al):",
      "mutated_line": "if d == -1 and (not al):",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == -1 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if d == 0 and (not al):",
      "mutated_line": "if d == 1 and (not al):",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 1 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ar.append(d - 9)",
      "mutated_line": "ar.append(d - 10)",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 10)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ar.append(d - 9)",
      "mutated_line": "ar.append(d - 8)",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 8)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ar.append(d - 9)",
      "mutated_line": "ar.append(d - 0)",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 0)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ar.append(d - 9)",
      "mutated_line": "ar.append(d - 1)",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - 1)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ar.append(d - 9)",
      "mutated_line": "ar.append(d - -9)",
      "code": "def find_valid_a(n: int) -> str:\n\n    def digits(n):\n        rd = []\n        while n:\n            (n, d) = divmod(n, 10)\n            rd.append(d)\n        return list(reversed(rd))\n\n    def _ifs(dn, i, j, ci, cj, al, ar):\n        while i < j:\n            di = dn[i] + 10 * ci\n            dj = dn[j] - cj\n            for (ci, cj) in ((0, 0), (0, 1), (1, 0), (1, 1)):\n                d = di - ci\n                if d < 0 or d > 18:\n                    continue\n                if dj + 10 * cj == d:\n                    if d < 10:\n                        if d == 0 and (not al):\n                            return\n                        al.append(d)\n                        ar.append(0)\n                    else:\n                        al.append(9)\n                        ar.append(d - -9)\n                    break\n            else:\n                return\n            i += 1\n            j -= 1\n        if i == j:\n            d = dn[i] + 10 * ci - cj\n            if d < 0 or d % 2:\n                return\n            al.append(d // 2)\n        elif ci != cj:\n            return\n        return al + list(reversed(ar))\n\n    def inv_fsum(dn):\n        if dn[0] == 1:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or _ifs(dn, 1, len(dn) - 1, 1, 0, [], []) or [0]\n        else:\n            return _ifs(dn, 0, len(dn) - 1, 0, 0, [], []) or [0]\n    dn = tuple(digits(n))\n    result = inv_fsum(dn)\n    return ''.join(map(str, result))"
    }
  ]
}