{
  "task_id": "taco_6549",
  "entry_point": "single_source_shortest_path",
  "mutant_count": 33,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "INF = 10 ** 10",
      "mutated_line": "INF = 10 * 10",
      "code": "from heapq import heappush, heappop\nINF = 10 * 10\n\ndef single_source_shortest_path(N, edges, source):\n    graph = [[] for _ in range(N)]\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n    dist = [INF] * N\n    dist[source] = 0\n    que = [(0, source)]\n    while que:\n        (current_dist, u) = heappop(que)\n        if dist[u] < current_dist:\n            continue\n        for (v, weight) in graph[u]:\n            if dist[u] + weight < dist[v]:\n                dist[v] = dist[u] + weight\n                heappush(que, (dist[v], v))\n    dist = ['INF' if d == INF else d for d in dist]\n    return dist"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "INF = 10 ** 10",
      "mutated_line": "INF = 10 + 10",
      "code": "from heapq import heappush, heappop\nINF = 10 + 10\n\ndef single_source_shortest_path(N, edges, source):\n    graph = [[] for _ in range(N)]\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n    dist = [INF] * N\n    dist[source] = 0\n    que = [(0, source)]\n    while que:\n        (current_dist, u) = heappop(que)\n        if dist[u] < current_dist:\n            continue\n        for (v, weight) in graph[u]:\n            if dist[u] + weight < dist[v]:\n                dist[v] = dist[u] + weight\n                heappush(que, (dist[v], v))\n    dist = ['INF' if d == INF else d for d in dist]\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "INF = 10 ** 10",
      "mutated_line": "INF = 11 ** 10",
      "code": "from heapq import heappush, heappop\nINF = 11 ** 10\n\ndef single_source_shortest_path(N, edges, source):\n    graph = [[] for _ in range(N)]\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n    dist = [INF] * N\n    dist[source] = 0\n    que = [(0, source)]\n    while que:\n        (current_dist, u) = heappop(que)\n        if dist[u] < current_dist:\n            continue\n        for (v, weight) in graph[u]:\n            if dist[u] + weight < dist[v]:\n                dist[v] = dist[u] + weight\n                heappush(que, (dist[v], v))\n    dist = ['INF' if d == INF else d for d in dist]\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "INF = 10 ** 10",
      "mutated_line": "INF = 9 ** 10",
      "code": "from heapq import heappush, heappop\nINF = 9 ** 10\n\ndef single_source_shortest_path(N, edges, source):\n    graph = [[] for _ in range(N)]\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n    dist = [INF] * N\n    dist[source] = 0\n    que = [(0, source)]\n    while que:\n        (current_dist, u) = heappop(que)\n        if dist[u] < current_dist:\n            continue\n        for (v, weight) in graph[u]:\n            if dist[u] + weight < dist[v]:\n                dist[v] = dist[u] + weight\n                heappush(que, (dist[v], v))\n    dist = ['INF' if d == INF else d for d in dist]\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "INF = 10 ** 10",
      "mutated_line": "INF = 0 ** 10",
      "code": "from heapq import heappush, heappop\nINF = 0 ** 10\n\ndef single_source_shortest_path(N, edges, source):\n    graph = [[] for _ in range(N)]\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n    dist = [INF] * N\n    dist[source] = 0\n    que = [(0, source)]\n    while que:\n        (current_dist, u) = heappop(que)\n        if dist[u] < current_dist:\n            continue\n        for (v, weight) in graph[u]:\n            if dist[u] + weight < dist[v]:\n                dist[v] = dist[u] + weight\n                heappush(que, (dist[v], v))\n    dist = ['INF' if d == INF else d for d in dist]\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "INF = 10 ** 10",
      "mutated_line": "INF = 1 ** 10",
      "code": "from heapq import heappush, heappop\nINF = 1 ** 10\n\ndef single_source_shortest_path(N, edges, source):\n    graph = [[] for _ in range(N)]\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n    dist = [INF] * N\n    dist[source] = 0\n    que = [(0, source)]\n    while que:\n        (current_dist, u) = heappop(que)\n        if dist[u] < current_dist:\n            continue\n        for (v, weight) in graph[u]:\n            if dist[u] + weight < dist[v]:\n                dist[v] = dist[u] + weight\n                heappush(que, (dist[v], v))\n    dist = ['INF' if d == INF else d for d in dist]\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "INF = 10 ** 10",
      "mutated_line": "INF = -10 ** 10",
      "code": "from heapq import heappush, heappop\nINF = -10 ** 10\n\ndef single_source_shortest_path(N, edges, source):\n    graph = [[] for _ in range(N)]\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n    dist = [INF] * N\n    dist[source] = 0\n    que = [(0, source)]\n    while que:\n        (current_dist, u) = heappop(que)\n        if dist[u] < current_dist:\n            continue\n        for (v, weight) in graph[u]:\n            if dist[u] + weight < dist[v]:\n                dist[v] = dist[u] + weight\n                heappush(que, (dist[v], v))\n    dist = ['INF' if d == INF else d for d in dist]\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "INF = 10 ** 10",
      "mutated_line": "INF = 10 ** 11",
      "code": "from heapq import heappush, heappop\nINF = 10 ** 11\n\ndef single_source_shortest_path(N, edges, source):\n    graph = [[] for _ in range(N)]\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n    dist = [INF] * N\n    dist[source] = 0\n    que = [(0, source)]\n    while que:\n        (current_dist, u) = heappop(que)\n        if dist[u] < current_dist:\n            continue\n        for (v, weight) in graph[u]:\n            if dist[u] + weight < dist[v]:\n                dist[v] = dist[u] + weight\n                heappush(que, (dist[v], v))\n    dist = ['INF' if d == INF else d for d in dist]\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "INF = 10 ** 10",
      "mutated_line": "INF = 10 ** 9",
      "code": "from heapq import heappush, heappop\nINF = 10 ** 9\n\ndef single_source_shortest_path(N, edges, source):\n    graph = [[] for _ in range(N)]\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n    dist = [INF] * N\n    dist[source] = 0\n    que = [(0, source)]\n    while que:\n        (current_dist, u) = heappop(que)\n        if dist[u] < current_dist:\n            continue\n        for (v, weight) in graph[u]:\n            if dist[u] + weight < dist[v]:\n                dist[v] = dist[u] + weight\n                heappush(que, (dist[v], v))\n    dist = ['INF' if d == INF else d for d in dist]\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "INF = 10 ** 10",
      "mutated_line": "INF = 10 ** 0",
      "code": "from heapq import heappush, heappop\nINF = 10 ** 0\n\ndef single_source_shortest_path(N, edges, source):\n    graph = [[] for _ in range(N)]\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n    dist = [INF] * N\n    dist[source] = 0\n    que = [(0, source)]\n    while que:\n        (current_dist, u) = heappop(que)\n        if dist[u] < current_dist:\n            continue\n        for (v, weight) in graph[u]:\n            if dist[u] + weight < dist[v]:\n                dist[v] = dist[u] + weight\n                heappush(que, (dist[v], v))\n    dist = ['INF' if d == INF else d for d in dist]\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "INF = 10 ** 10",
      "mutated_line": "INF = 10 ** 1",
      "code": "from heapq import heappush, heappop\nINF = 10 ** 1\n\ndef single_source_shortest_path(N, edges, source):\n    graph = [[] for _ in range(N)]\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n    dist = [INF] * N\n    dist[source] = 0\n    que = [(0, source)]\n    while que:\n        (current_dist, u) = heappop(que)\n        if dist[u] < current_dist:\n            continue\n        for (v, weight) in graph[u]:\n            if dist[u] + weight < dist[v]:\n                dist[v] = dist[u] + weight\n                heappush(que, (dist[v], v))\n    dist = ['INF' if d == INF else d for d in dist]\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "INF = 10 ** 10",
      "mutated_line": "INF = 10 ** -10",
      "code": "from heapq import heappush, heappop\nINF = 10 ** -10\n\ndef single_source_shortest_path(N, edges, source):\n    graph = [[] for _ in range(N)]\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n    dist = [INF] * N\n    dist[source] = 0\n    que = [(0, source)]\n    while que:\n        (current_dist, u) = heappop(que)\n        if dist[u] < current_dist:\n            continue\n        for (v, weight) in graph[u]:\n            if dist[u] + weight < dist[v]:\n                dist[v] = dist[u] + weight\n                heappush(que, (dist[v], v))\n    dist = ['INF' if d == INF else d for d in dist]\n    return dist"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dist = [INF] * N",
      "mutated_line": "dist = [INF] / N",
      "code": "from heapq import heappush, heappop\nINF = 10 ** 10\n\ndef single_source_shortest_path(N, edges, source):\n    graph = [[] for _ in range(N)]\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n    dist = [INF] / N\n    dist[source] = 0\n    que = [(0, source)]\n    while que:\n        (current_dist, u) = heappop(que)\n        if dist[u] < current_dist:\n            continue\n        for (v, weight) in graph[u]:\n            if dist[u] + weight < dist[v]:\n                dist[v] = dist[u] + weight\n                heappush(que, (dist[v], v))\n    dist = ['INF' if d == INF else d for d in dist]\n    return dist"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dist = [INF] * N",
      "mutated_line": "dist = [INF] + N",
      "code": "from heapq import heappush, heappop\nINF = 10 ** 10\n\ndef single_source_shortest_path(N, edges, source):\n    graph = [[] for _ in range(N)]\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n    dist = [INF] + N\n    dist[source] = 0\n    que = [(0, source)]\n    while que:\n        (current_dist, u) = heappop(que)\n        if dist[u] < current_dist:\n            continue\n        for (v, weight) in graph[u]:\n            if dist[u] + weight < dist[v]:\n                dist[v] = dist[u] + weight\n                heappush(que, (dist[v], v))\n    dist = ['INF' if d == INF else d for d in dist]\n    return dist"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dist = [INF] * N",
      "mutated_line": "dist = [INF] ** N",
      "code": "from heapq import heappush, heappop\nINF = 10 ** 10\n\ndef single_source_shortest_path(N, edges, source):\n    graph = [[] for _ in range(N)]\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n    dist = [INF] ** N\n    dist[source] = 0\n    que = [(0, source)]\n    while que:\n        (current_dist, u) = heappop(que)\n        if dist[u] < current_dist:\n            continue\n        for (v, weight) in graph[u]:\n            if dist[u] + weight < dist[v]:\n                dist[v] = dist[u] + weight\n                heappush(que, (dist[v], v))\n    dist = ['INF' if d == INF else d for d in dist]\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dist[source] = 0",
      "mutated_line": "dist[source] = 1",
      "code": "from heapq import heappush, heappop\nINF = 10 ** 10\n\ndef single_source_shortest_path(N, edges, source):\n    graph = [[] for _ in range(N)]\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n    dist = [INF] * N\n    dist[source] = 1\n    que = [(0, source)]\n    while que:\n        (current_dist, u) = heappop(que)\n        if dist[u] < current_dist:\n            continue\n        for (v, weight) in graph[u]:\n            if dist[u] + weight < dist[v]:\n                dist[v] = dist[u] + weight\n                heappush(que, (dist[v], v))\n    dist = ['INF' if d == INF else d for d in dist]\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dist[source] = 0",
      "mutated_line": "dist[source] = -1",
      "code": "from heapq import heappush, heappop\nINF = 10 ** 10\n\ndef single_source_shortest_path(N, edges, source):\n    graph = [[] for _ in range(N)]\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n    dist = [INF] * N\n    dist[source] = -1\n    que = [(0, source)]\n    while que:\n        (current_dist, u) = heappop(que)\n        if dist[u] < current_dist:\n            continue\n        for (v, weight) in graph[u]:\n            if dist[u] + weight < dist[v]:\n                dist[v] = dist[u] + weight\n                heappush(que, (dist[v], v))\n    dist = ['INF' if d == INF else d for d in dist]\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dist[source] = 0",
      "mutated_line": "dist[source] = 1",
      "code": "from heapq import heappush, heappop\nINF = 10 ** 10\n\ndef single_source_shortest_path(N, edges, source):\n    graph = [[] for _ in range(N)]\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n    dist = [INF] * N\n    dist[source] = 1\n    que = [(0, source)]\n    while que:\n        (current_dist, u) = heappop(que)\n        if dist[u] < current_dist:\n            continue\n        for (v, weight) in graph[u]:\n            if dist[u] + weight < dist[v]:\n                dist[v] = dist[u] + weight\n                heappush(que, (dist[v], v))\n    dist = ['INF' if d == INF else d for d in dist]\n    return dist"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if dist[u] < current_dist:",
      "mutated_line": "if dist[u] <= current_dist:",
      "code": "from heapq import heappush, heappop\nINF = 10 ** 10\n\ndef single_source_shortest_path(N, edges, source):\n    graph = [[] for _ in range(N)]\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n    dist = [INF] * N\n    dist[source] = 0\n    que = [(0, source)]\n    while que:\n        (current_dist, u) = heappop(que)\n        if dist[u] <= current_dist:\n            continue\n        for (v, weight) in graph[u]:\n            if dist[u] + weight < dist[v]:\n                dist[v] = dist[u] + weight\n                heappush(que, (dist[v], v))\n    dist = ['INF' if d == INF else d for d in dist]\n    return dist"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if dist[u] < current_dist:",
      "mutated_line": "if dist[u] >= current_dist:",
      "code": "from heapq import heappush, heappop\nINF = 10 ** 10\n\ndef single_source_shortest_path(N, edges, source):\n    graph = [[] for _ in range(N)]\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n    dist = [INF] * N\n    dist[source] = 0\n    que = [(0, source)]\n    while que:\n        (current_dist, u) = heappop(que)\n        if dist[u] >= current_dist:\n            continue\n        for (v, weight) in graph[u]:\n            if dist[u] + weight < dist[v]:\n                dist[v] = dist[u] + weight\n                heappush(que, (dist[v], v))\n    dist = ['INF' if d == INF else d for d in dist]\n    return dist"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if dist[u] < current_dist:",
      "mutated_line": "if dist[u] != current_dist:",
      "code": "from heapq import heappush, heappop\nINF = 10 ** 10\n\ndef single_source_shortest_path(N, edges, source):\n    graph = [[] for _ in range(N)]\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n    dist = [INF] * N\n    dist[source] = 0\n    que = [(0, source)]\n    while que:\n        (current_dist, u) = heappop(que)\n        if dist[u] != current_dist:\n            continue\n        for (v, weight) in graph[u]:\n            if dist[u] + weight < dist[v]:\n                dist[v] = dist[u] + weight\n                heappush(que, (dist[v], v))\n    dist = ['INF' if d == INF else d for d in dist]\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "que = [(0, source)]",
      "mutated_line": "que = [(1, source)]",
      "code": "from heapq import heappush, heappop\nINF = 10 ** 10\n\ndef single_source_shortest_path(N, edges, source):\n    graph = [[] for _ in range(N)]\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n    dist = [INF] * N\n    dist[source] = 0\n    que = [(1, source)]\n    while que:\n        (current_dist, u) = heappop(que)\n        if dist[u] < current_dist:\n            continue\n        for (v, weight) in graph[u]:\n            if dist[u] + weight < dist[v]:\n                dist[v] = dist[u] + weight\n                heappush(que, (dist[v], v))\n    dist = ['INF' if d == INF else d for d in dist]\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "que = [(0, source)]",
      "mutated_line": "que = [(-1, source)]",
      "code": "from heapq import heappush, heappop\nINF = 10 ** 10\n\ndef single_source_shortest_path(N, edges, source):\n    graph = [[] for _ in range(N)]\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n    dist = [INF] * N\n    dist[source] = 0\n    que = [(-1, source)]\n    while que:\n        (current_dist, u) = heappop(que)\n        if dist[u] < current_dist:\n            continue\n        for (v, weight) in graph[u]:\n            if dist[u] + weight < dist[v]:\n                dist[v] = dist[u] + weight\n                heappush(que, (dist[v], v))\n    dist = ['INF' if d == INF else d for d in dist]\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "que = [(0, source)]",
      "mutated_line": "que = [(1, source)]",
      "code": "from heapq import heappush, heappop\nINF = 10 ** 10\n\ndef single_source_shortest_path(N, edges, source):\n    graph = [[] for _ in range(N)]\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n    dist = [INF] * N\n    dist[source] = 0\n    que = [(1, source)]\n    while que:\n        (current_dist, u) = heappop(que)\n        if dist[u] < current_dist:\n            continue\n        for (v, weight) in graph[u]:\n            if dist[u] + weight < dist[v]:\n                dist[v] = dist[u] + weight\n                heappush(que, (dist[v], v))\n    dist = ['INF' if d == INF else d for d in dist]\n    return dist"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if dist[u] + weight < dist[v]:",
      "mutated_line": "if dist[u] + weight <= dist[v]:",
      "code": "from heapq import heappush, heappop\nINF = 10 ** 10\n\ndef single_source_shortest_path(N, edges, source):\n    graph = [[] for _ in range(N)]\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n    dist = [INF] * N\n    dist[source] = 0\n    que = [(0, source)]\n    while que:\n        (current_dist, u) = heappop(que)\n        if dist[u] < current_dist:\n            continue\n        for (v, weight) in graph[u]:\n            if dist[u] + weight <= dist[v]:\n                dist[v] = dist[u] + weight\n                heappush(que, (dist[v], v))\n    dist = ['INF' if d == INF else d for d in dist]\n    return dist"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if dist[u] + weight < dist[v]:",
      "mutated_line": "if dist[u] + weight >= dist[v]:",
      "code": "from heapq import heappush, heappop\nINF = 10 ** 10\n\ndef single_source_shortest_path(N, edges, source):\n    graph = [[] for _ in range(N)]\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n    dist = [INF] * N\n    dist[source] = 0\n    que = [(0, source)]\n    while que:\n        (current_dist, u) = heappop(que)\n        if dist[u] < current_dist:\n            continue\n        for (v, weight) in graph[u]:\n            if dist[u] + weight >= dist[v]:\n                dist[v] = dist[u] + weight\n                heappush(que, (dist[v], v))\n    dist = ['INF' if d == INF else d for d in dist]\n    return dist"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if dist[u] + weight < dist[v]:",
      "mutated_line": "if dist[u] + weight != dist[v]:",
      "code": "from heapq import heappush, heappop\nINF = 10 ** 10\n\ndef single_source_shortest_path(N, edges, source):\n    graph = [[] for _ in range(N)]\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n    dist = [INF] * N\n    dist[source] = 0\n    que = [(0, source)]\n    while que:\n        (current_dist, u) = heappop(que)\n        if dist[u] < current_dist:\n            continue\n        for (v, weight) in graph[u]:\n            if dist[u] + weight != dist[v]:\n                dist[v] = dist[u] + weight\n                heappush(que, (dist[v], v))\n    dist = ['INF' if d == INF else d for d in dist]\n    return dist"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "dist = ['INF' if d == INF else d for d in dist]",
      "mutated_line": "dist = ['INF' if d != INF else d for d in dist]",
      "code": "from heapq import heappush, heappop\nINF = 10 ** 10\n\ndef single_source_shortest_path(N, edges, source):\n    graph = [[] for _ in range(N)]\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n    dist = [INF] * N\n    dist[source] = 0\n    que = [(0, source)]\n    while que:\n        (current_dist, u) = heappop(que)\n        if dist[u] < current_dist:\n            continue\n        for (v, weight) in graph[u]:\n            if dist[u] + weight < dist[v]:\n                dist[v] = dist[u] + weight\n                heappush(que, (dist[v], v))\n    dist = ['INF' if d != INF else d for d in dist]\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dist = ['INF' if d == INF else d for d in dist]",
      "mutated_line": "dist = ['' if d == INF else d for d in dist]",
      "code": "from heapq import heappush, heappop\nINF = 10 ** 10\n\ndef single_source_shortest_path(N, edges, source):\n    graph = [[] for _ in range(N)]\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n    dist = [INF] * N\n    dist[source] = 0\n    que = [(0, source)]\n    while que:\n        (current_dist, u) = heappop(que)\n        if dist[u] < current_dist:\n            continue\n        for (v, weight) in graph[u]:\n            if dist[u] + weight < dist[v]:\n                dist[v] = dist[u] + weight\n                heappush(que, (dist[v], v))\n    dist = ['' if d == INF else d for d in dist]\n    return dist"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "if dist[u] + weight < dist[v]:",
      "mutated_line": "if dist[u] - weight < dist[v]:",
      "code": "from heapq import heappush, heappop\nINF = 10 ** 10\n\ndef single_source_shortest_path(N, edges, source):\n    graph = [[] for _ in range(N)]\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n    dist = [INF] * N\n    dist[source] = 0\n    que = [(0, source)]\n    while que:\n        (current_dist, u) = heappop(que)\n        if dist[u] < current_dist:\n            continue\n        for (v, weight) in graph[u]:\n            if dist[u] - weight < dist[v]:\n                dist[v] = dist[u] + weight\n                heappush(que, (dist[v], v))\n    dist = ['INF' if d == INF else d for d in dist]\n    return dist"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "if dist[u] + weight < dist[v]:",
      "mutated_line": "if dist[u] * weight < dist[v]:",
      "code": "from heapq import heappush, heappop\nINF = 10 ** 10\n\ndef single_source_shortest_path(N, edges, source):\n    graph = [[] for _ in range(N)]\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n    dist = [INF] * N\n    dist[source] = 0\n    que = [(0, source)]\n    while que:\n        (current_dist, u) = heappop(que)\n        if dist[u] < current_dist:\n            continue\n        for (v, weight) in graph[u]:\n            if dist[u] * weight < dist[v]:\n                dist[v] = dist[u] + weight\n                heappush(que, (dist[v], v))\n    dist = ['INF' if d == INF else d for d in dist]\n    return dist"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "dist[v] = dist[u] + weight",
      "mutated_line": "dist[v] = dist[u] - weight",
      "code": "from heapq import heappush, heappop\nINF = 10 ** 10\n\ndef single_source_shortest_path(N, edges, source):\n    graph = [[] for _ in range(N)]\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n    dist = [INF] * N\n    dist[source] = 0\n    que = [(0, source)]\n    while que:\n        (current_dist, u) = heappop(que)\n        if dist[u] < current_dist:\n            continue\n        for (v, weight) in graph[u]:\n            if dist[u] + weight < dist[v]:\n                dist[v] = dist[u] - weight\n                heappush(que, (dist[v], v))\n    dist = ['INF' if d == INF else d for d in dist]\n    return dist"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "dist[v] = dist[u] + weight",
      "mutated_line": "dist[v] = dist[u] * weight",
      "code": "from heapq import heappush, heappop\nINF = 10 ** 10\n\ndef single_source_shortest_path(N, edges, source):\n    graph = [[] for _ in range(N)]\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n    dist = [INF] * N\n    dist[source] = 0\n    que = [(0, source)]\n    while que:\n        (current_dist, u) = heappop(que)\n        if dist[u] < current_dist:\n            continue\n        for (v, weight) in graph[u]:\n            if dist[u] + weight < dist[v]:\n                dist[v] = dist[u] * weight\n                heappush(que, (dist[v], v))\n    dist = ['INF' if d == INF else d for d in dist]\n    return dist"
    }
  ]
}