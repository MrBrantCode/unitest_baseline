{
  "task_id": "taco_17912",
  "entry_point": "can_all_participants_communicate",
  "mutant_count": 72,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "return \"YES\"",
      "mutated_line": "return ''",
      "code": "def can_all_participants_communicate(N, M, languages):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n            self.count = [1] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n                self.count[y] += self.count[x]\n                self.count[x] = 0\n            else:\n                self.par[y] = x\n                self.count[x] += self.count[y]\n                self.count[y] = 0\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def size(self, x):\n            q = UnionFind.find(self, x)\n            return self.count[q]\n    K = [set() for _ in range(M)]\n    tree = UnionFind(N)\n    for i in range(N):\n        L = languages[i][1:]\n        for m in L:\n            K[m - 1].add(i)\n    for i in range(M):\n        Ki = list(K[i])\n        if len(Ki) == 0:\n            continue\n        for h in range(len(Ki)):\n            tree.union(Ki[h], Ki[0])\n    for i in range(N):\n        if not tree.same_check(0, i):\n            return 'NO'\n    return ''"
    },
    {
      "operator": "ROR",
      "lineno": 46,
      "original_line": "if len(Ki) == 0:",
      "mutated_line": "if len(Ki) != 0:",
      "code": "def can_all_participants_communicate(N, M, languages):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n            self.count = [1] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n                self.count[y] += self.count[x]\n                self.count[x] = 0\n            else:\n                self.par[y] = x\n                self.count[x] += self.count[y]\n                self.count[y] = 0\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def size(self, x):\n            q = UnionFind.find(self, x)\n            return self.count[q]\n    K = [set() for _ in range(M)]\n    tree = UnionFind(N)\n    for i in range(N):\n        L = languages[i][1:]\n        for m in L:\n            K[m - 1].add(i)\n    for i in range(M):\n        Ki = list(K[i])\n        if len(Ki) != 0:\n            continue\n        for h in range(len(Ki)):\n            tree.union(Ki[h], Ki[0])\n    for i in range(N):\n        if not tree.same_check(0, i):\n            return 'NO'\n    return 'YES'"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "self.rank = [0] * (n + 1)",
      "mutated_line": "self.rank = [0] / (n + 1)",
      "code": "def can_all_participants_communicate(N, M, languages):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] / (n + 1)\n            self.count = [1] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n                self.count[y] += self.count[x]\n                self.count[x] = 0\n            else:\n                self.par[y] = x\n                self.count[x] += self.count[y]\n                self.count[y] = 0\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def size(self, x):\n            q = UnionFind.find(self, x)\n            return self.count[q]\n    K = [set() for _ in range(M)]\n    tree = UnionFind(N)\n    for i in range(N):\n        L = languages[i][1:]\n        for m in L:\n            K[m - 1].add(i)\n    for i in range(M):\n        Ki = list(K[i])\n        if len(Ki) == 0:\n            continue\n        for h in range(len(Ki)):\n            tree.union(Ki[h], Ki[0])\n    for i in range(N):\n        if not tree.same_check(0, i):\n            return 'NO'\n    return 'YES'"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "self.rank = [0] * (n + 1)",
      "mutated_line": "self.rank = [0] + (n + 1)",
      "code": "def can_all_participants_communicate(N, M, languages):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] + (n + 1)\n            self.count = [1] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n                self.count[y] += self.count[x]\n                self.count[x] = 0\n            else:\n                self.par[y] = x\n                self.count[x] += self.count[y]\n                self.count[y] = 0\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def size(self, x):\n            q = UnionFind.find(self, x)\n            return self.count[q]\n    K = [set() for _ in range(M)]\n    tree = UnionFind(N)\n    for i in range(N):\n        L = languages[i][1:]\n        for m in L:\n            K[m - 1].add(i)\n    for i in range(M):\n        Ki = list(K[i])\n        if len(Ki) == 0:\n            continue\n        for h in range(len(Ki)):\n            tree.union(Ki[h], Ki[0])\n    for i in range(N):\n        if not tree.same_check(0, i):\n            return 'NO'\n    return 'YES'"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "self.rank = [0] * (n + 1)",
      "mutated_line": "self.rank = [0] ** (n + 1)",
      "code": "def can_all_participants_communicate(N, M, languages):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] ** (n + 1)\n            self.count = [1] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n                self.count[y] += self.count[x]\n                self.count[x] = 0\n            else:\n                self.par[y] = x\n                self.count[x] += self.count[y]\n                self.count[y] = 0\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def size(self, x):\n            q = UnionFind.find(self, x)\n            return self.count[q]\n    K = [set() for _ in range(M)]\n    tree = UnionFind(N)\n    for i in range(N):\n        L = languages[i][1:]\n        for m in L:\n            K[m - 1].add(i)\n    for i in range(M):\n        Ki = list(K[i])\n        if len(Ki) == 0:\n            continue\n        for h in range(len(Ki)):\n            tree.union(Ki[h], Ki[0])\n    for i in range(N):\n        if not tree.same_check(0, i):\n            return 'NO'\n    return 'YES'"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "self.count = [1] * (n + 1)",
      "mutated_line": "self.count = [1] / (n + 1)",
      "code": "def can_all_participants_communicate(N, M, languages):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n            self.count = [1] / (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n                self.count[y] += self.count[x]\n                self.count[x] = 0\n            else:\n                self.par[y] = x\n                self.count[x] += self.count[y]\n                self.count[y] = 0\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def size(self, x):\n            q = UnionFind.find(self, x)\n            return self.count[q]\n    K = [set() for _ in range(M)]\n    tree = UnionFind(N)\n    for i in range(N):\n        L = languages[i][1:]\n        for m in L:\n            K[m - 1].add(i)\n    for i in range(M):\n        Ki = list(K[i])\n        if len(Ki) == 0:\n            continue\n        for h in range(len(Ki)):\n            tree.union(Ki[h], Ki[0])\n    for i in range(N):\n        if not tree.same_check(0, i):\n            return 'NO'\n    return 'YES'"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "self.count = [1] * (n + 1)",
      "mutated_line": "self.count = [1] + (n + 1)",
      "code": "def can_all_participants_communicate(N, M, languages):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n            self.count = [1] + (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n                self.count[y] += self.count[x]\n                self.count[x] = 0\n            else:\n                self.par[y] = x\n                self.count[x] += self.count[y]\n                self.count[y] = 0\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def size(self, x):\n            q = UnionFind.find(self, x)\n            return self.count[q]\n    K = [set() for _ in range(M)]\n    tree = UnionFind(N)\n    for i in range(N):\n        L = languages[i][1:]\n        for m in L:\n            K[m - 1].add(i)\n    for i in range(M):\n        Ki = list(K[i])\n        if len(Ki) == 0:\n            continue\n        for h in range(len(Ki)):\n            tree.union(Ki[h], Ki[0])\n    for i in range(N):\n        if not tree.same_check(0, i):\n            return 'NO'\n    return 'YES'"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "self.count = [1] * (n + 1)",
      "mutated_line": "self.count = [1] ** (n + 1)",
      "code": "def can_all_participants_communicate(N, M, languages):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n            self.count = [1] ** (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n                self.count[y] += self.count[x]\n                self.count[x] = 0\n            else:\n                self.par[y] = x\n                self.count[x] += self.count[y]\n                self.count[y] = 0\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def size(self, x):\n            q = UnionFind.find(self, x)\n            return self.count[q]\n    K = [set() for _ in range(M)]\n    tree = UnionFind(N)\n    for i in range(N):\n        L = languages[i][1:]\n        for m in L:\n            K[m - 1].add(i)\n    for i in range(M):\n        Ki = list(K[i])\n        if len(Ki) == 0:\n            continue\n        for h in range(len(Ki)):\n            tree.union(Ki[h], Ki[0])\n    for i in range(N):\n        if not tree.same_check(0, i):\n            return 'NO'\n    return 'YES'"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if self.par[x] == x:",
      "mutated_line": "if self.par[x] != x:",
      "code": "def can_all_participants_communicate(N, M, languages):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n            self.count = [1] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] != x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n                self.count[y] += self.count[x]\n                self.count[x] = 0\n            else:\n                self.par[y] = x\n                self.count[x] += self.count[y]\n                self.count[y] = 0\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def size(self, x):\n            q = UnionFind.find(self, x)\n            return self.count[q]\n    K = [set() for _ in range(M)]\n    tree = UnionFind(N)\n    for i in range(N):\n        L = languages[i][1:]\n        for m in L:\n            K[m - 1].add(i)\n    for i in range(M):\n        Ki = list(K[i])\n        if len(Ki) == 0:\n            continue\n        for h in range(len(Ki)):\n            tree.union(Ki[h], Ki[0])\n    for i in range(N):\n        if not tree.same_check(0, i):\n            return 'NO'\n    return 'YES'"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if self.rank[x] < self.rank[y]:",
      "mutated_line": "if self.rank[x] <= self.rank[y]:",
      "code": "def can_all_participants_communicate(N, M, languages):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n            self.count = [1] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] <= self.rank[y]:\n                self.par[x] = y\n                self.count[y] += self.count[x]\n                self.count[x] = 0\n            else:\n                self.par[y] = x\n                self.count[x] += self.count[y]\n                self.count[y] = 0\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def size(self, x):\n            q = UnionFind.find(self, x)\n            return self.count[q]\n    K = [set() for _ in range(M)]\n    tree = UnionFind(N)\n    for i in range(N):\n        L = languages[i][1:]\n        for m in L:\n            K[m - 1].add(i)\n    for i in range(M):\n        Ki = list(K[i])\n        if len(Ki) == 0:\n            continue\n        for h in range(len(Ki)):\n            tree.union(Ki[h], Ki[0])\n    for i in range(N):\n        if not tree.same_check(0, i):\n            return 'NO'\n    return 'YES'"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if self.rank[x] < self.rank[y]:",
      "mutated_line": "if self.rank[x] >= self.rank[y]:",
      "code": "def can_all_participants_communicate(N, M, languages):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n            self.count = [1] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] >= self.rank[y]:\n                self.par[x] = y\n                self.count[y] += self.count[x]\n                self.count[x] = 0\n            else:\n                self.par[y] = x\n                self.count[x] += self.count[y]\n                self.count[y] = 0\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def size(self, x):\n            q = UnionFind.find(self, x)\n            return self.count[q]\n    K = [set() for _ in range(M)]\n    tree = UnionFind(N)\n    for i in range(N):\n        L = languages[i][1:]\n        for m in L:\n            K[m - 1].add(i)\n    for i in range(M):\n        Ki = list(K[i])\n        if len(Ki) == 0:\n            continue\n        for h in range(len(Ki)):\n            tree.union(Ki[h], Ki[0])\n    for i in range(N):\n        if not tree.same_check(0, i):\n            return 'NO'\n    return 'YES'"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if self.rank[x] < self.rank[y]:",
      "mutated_line": "if self.rank[x] != self.rank[y]:",
      "code": "def can_all_participants_communicate(N, M, languages):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n            self.count = [1] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] != self.rank[y]:\n                self.par[x] = y\n                self.count[y] += self.count[x]\n                self.count[x] = 0\n            else:\n                self.par[y] = x\n                self.count[x] += self.count[y]\n                self.count[y] = 0\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def size(self, x):\n            q = UnionFind.find(self, x)\n            return self.count[q]\n    K = [set() for _ in range(M)]\n    tree = UnionFind(N)\n    for i in range(N):\n        L = languages[i][1:]\n        for m in L:\n            K[m - 1].add(i)\n    for i in range(M):\n        Ki = list(K[i])\n        if len(Ki) == 0:\n            continue\n        for h in range(len(Ki)):\n            tree.union(Ki[h], Ki[0])\n    for i in range(N):\n        if not tree.same_check(0, i):\n            return 'NO'\n    return 'YES'"
    },
    {
      "operator": "ASR",
      "lineno": 20,
      "original_line": "self.count[y] += self.count[x]",
      "mutated_line": "self.count[y] -= self.count[x]",
      "code": "def can_all_participants_communicate(N, M, languages):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n            self.count = [1] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n                self.count[y] -= self.count[x]\n                self.count[x] = 0\n            else:\n                self.par[y] = x\n                self.count[x] += self.count[y]\n                self.count[y] = 0\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def size(self, x):\n            q = UnionFind.find(self, x)\n            return self.count[q]\n    K = [set() for _ in range(M)]\n    tree = UnionFind(N)\n    for i in range(N):\n        L = languages[i][1:]\n        for m in L:\n            K[m - 1].add(i)\n    for i in range(M):\n        Ki = list(K[i])\n        if len(Ki) == 0:\n            continue\n        for h in range(len(Ki)):\n            tree.union(Ki[h], Ki[0])\n    for i in range(N):\n        if not tree.same_check(0, i):\n            return 'NO'\n    return 'YES'"
    },
    {
      "operator": "ASR",
      "lineno": 24,
      "original_line": "self.count[x] += self.count[y]",
      "mutated_line": "self.count[x] -= self.count[y]",
      "code": "def can_all_participants_communicate(N, M, languages):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n            self.count = [1] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n                self.count[y] += self.count[x]\n                self.count[x] = 0\n            else:\n                self.par[y] = x\n                self.count[x] -= self.count[y]\n                self.count[y] = 0\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def size(self, x):\n            q = UnionFind.find(self, x)\n            return self.count[q]\n    K = [set() for _ in range(M)]\n    tree = UnionFind(N)\n    for i in range(N):\n        L = languages[i][1:]\n        for m in L:\n            K[m - 1].add(i)\n    for i in range(M):\n        Ki = list(K[i])\n        if len(Ki) == 0:\n            continue\n        for h in range(len(Ki)):\n            tree.union(Ki[h], Ki[0])\n    for i in range(N):\n        if not tree.same_check(0, i):\n            return 'NO'\n    return 'YES'"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "return self.find(x) == self.find(y)",
      "mutated_line": "return self.find(x) != self.find(y)",
      "code": "def can_all_participants_communicate(N, M, languages):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n            self.count = [1] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n                self.count[y] += self.count[x]\n                self.count[x] = 0\n            else:\n                self.par[y] = x\n                self.count[x] += self.count[y]\n                self.count[y] = 0\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) != self.find(y)\n\n        def size(self, x):\n            q = UnionFind.find(self, x)\n            return self.count[q]\n    K = [set() for _ in range(M)]\n    tree = UnionFind(N)\n    for i in range(N):\n        L = languages[i][1:]\n        for m in L:\n            K[m - 1].add(i)\n    for i in range(M):\n        Ki = list(K[i])\n        if len(Ki) == 0:\n            continue\n        for h in range(len(Ki)):\n            tree.union(Ki[h], Ki[0])\n    for i in range(N):\n        if not tree.same_check(0, i):\n            return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if len(Ki) == 0:",
      "mutated_line": "if len(Ki) == 1:",
      "code": "def can_all_participants_communicate(N, M, languages):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n            self.count = [1] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n                self.count[y] += self.count[x]\n                self.count[x] = 0\n            else:\n                self.par[y] = x\n                self.count[x] += self.count[y]\n                self.count[y] = 0\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def size(self, x):\n            q = UnionFind.find(self, x)\n            return self.count[q]\n    K = [set() for _ in range(M)]\n    tree = UnionFind(N)\n    for i in range(N):\n        L = languages[i][1:]\n        for m in L:\n            K[m - 1].add(i)\n    for i in range(M):\n        Ki = list(K[i])\n        if len(Ki) == 1:\n            continue\n        for h in range(len(Ki)):\n            tree.union(Ki[h], Ki[0])\n    for i in range(N):\n        if not tree.same_check(0, i):\n            return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if len(Ki) == 0:",
      "mutated_line": "if len(Ki) == -1:",
      "code": "def can_all_participants_communicate(N, M, languages):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n            self.count = [1] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n                self.count[y] += self.count[x]\n                self.count[x] = 0\n            else:\n                self.par[y] = x\n                self.count[x] += self.count[y]\n                self.count[y] = 0\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def size(self, x):\n            q = UnionFind.find(self, x)\n            return self.count[q]\n    K = [set() for _ in range(M)]\n    tree = UnionFind(N)\n    for i in range(N):\n        L = languages[i][1:]\n        for m in L:\n            K[m - 1].add(i)\n    for i in range(M):\n        Ki = list(K[i])\n        if len(Ki) == -1:\n            continue\n        for h in range(len(Ki)):\n            tree.union(Ki[h], Ki[0])\n    for i in range(N):\n        if not tree.same_check(0, i):\n            return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if len(Ki) == 0:",
      "mutated_line": "if len(Ki) == 1:",
      "code": "def can_all_participants_communicate(N, M, languages):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n            self.count = [1] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n                self.count[y] += self.count[x]\n                self.count[x] = 0\n            else:\n                self.par[y] = x\n                self.count[x] += self.count[y]\n                self.count[y] = 0\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def size(self, x):\n            q = UnionFind.find(self, x)\n            return self.count[q]\n    K = [set() for _ in range(M)]\n    tree = UnionFind(N)\n    for i in range(N):\n        L = languages[i][1:]\n        for m in L:\n            K[m - 1].add(i)\n    for i in range(M):\n        Ki = list(K[i])\n        if len(Ki) == 1:\n            continue\n        for h in range(len(Ki)):\n            tree.union(Ki[h], Ki[0])\n    for i in range(N):\n        if not tree.same_check(0, i):\n            return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "return \"NO\"",
      "mutated_line": "return ''",
      "code": "def can_all_participants_communicate(N, M, languages):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n            self.count = [1] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n                self.count[y] += self.count[x]\n                self.count[x] = 0\n            else:\n                self.par[y] = x\n                self.count[x] += self.count[y]\n                self.count[y] = 0\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def size(self, x):\n            q = UnionFind.find(self, x)\n            return self.count[q]\n    K = [set() for _ in range(M)]\n    tree = UnionFind(N)\n    for i in range(N):\n        L = languages[i][1:]\n        for m in L:\n            K[m - 1].add(i)\n    for i in range(M):\n        Ki = list(K[i])\n        if len(Ki) == 0:\n            continue\n        for h in range(len(Ki)):\n            tree.union(Ki[h], Ki[0])\n    for i in range(N):\n        if not tree.same_check(0, i):\n            return ''\n    return 'YES'"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "self.rank = [0] * (n + 1)",
      "mutated_line": "self.rank = [0] * (n - 1)",
      "code": "def can_all_participants_communicate(N, M, languages):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n - 1)\n            self.count = [1] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n                self.count[y] += self.count[x]\n                self.count[x] = 0\n            else:\n                self.par[y] = x\n                self.count[x] += self.count[y]\n                self.count[y] = 0\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def size(self, x):\n            q = UnionFind.find(self, x)\n            return self.count[q]\n    K = [set() for _ in range(M)]\n    tree = UnionFind(N)\n    for i in range(N):\n        L = languages[i][1:]\n        for m in L:\n            K[m - 1].add(i)\n    for i in range(M):\n        Ki = list(K[i])\n        if len(Ki) == 0:\n            continue\n        for h in range(len(Ki)):\n            tree.union(Ki[h], Ki[0])\n    for i in range(N):\n        if not tree.same_check(0, i):\n            return 'NO'\n    return 'YES'"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "self.rank = [0] * (n + 1)",
      "mutated_line": "self.rank = [0] * (n * 1)",
      "code": "def can_all_participants_communicate(N, M, languages):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n * 1)\n            self.count = [1] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n                self.count[y] += self.count[x]\n                self.count[x] = 0\n            else:\n                self.par[y] = x\n                self.count[x] += self.count[y]\n                self.count[y] = 0\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def size(self, x):\n            q = UnionFind.find(self, x)\n            return self.count[q]\n    K = [set() for _ in range(M)]\n    tree = UnionFind(N)\n    for i in range(N):\n        L = languages[i][1:]\n        for m in L:\n            K[m - 1].add(i)\n    for i in range(M):\n        Ki = list(K[i])\n        if len(Ki) == 0:\n            continue\n        for h in range(len(Ki)):\n            tree.union(Ki[h], Ki[0])\n    for i in range(N):\n        if not tree.same_check(0, i):\n            return 'NO'\n    return 'YES'"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "self.count = [1] * (n + 1)",
      "mutated_line": "self.count = [1] * (n - 1)",
      "code": "def can_all_participants_communicate(N, M, languages):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n            self.count = [1] * (n - 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n                self.count[y] += self.count[x]\n                self.count[x] = 0\n            else:\n                self.par[y] = x\n                self.count[x] += self.count[y]\n                self.count[y] = 0\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def size(self, x):\n            q = UnionFind.find(self, x)\n            return self.count[q]\n    K = [set() for _ in range(M)]\n    tree = UnionFind(N)\n    for i in range(N):\n        L = languages[i][1:]\n        for m in L:\n            K[m - 1].add(i)\n    for i in range(M):\n        Ki = list(K[i])\n        if len(Ki) == 0:\n            continue\n        for h in range(len(Ki)):\n            tree.union(Ki[h], Ki[0])\n    for i in range(N):\n        if not tree.same_check(0, i):\n            return 'NO'\n    return 'YES'"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "self.count = [1] * (n + 1)",
      "mutated_line": "self.count = [1] * (n * 1)",
      "code": "def can_all_participants_communicate(N, M, languages):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n            self.count = [1] * (n * 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n                self.count[y] += self.count[x]\n                self.count[x] = 0\n            else:\n                self.par[y] = x\n                self.count[x] += self.count[y]\n                self.count[y] = 0\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def size(self, x):\n            q = UnionFind.find(self, x)\n            return self.count[q]\n    K = [set() for _ in range(M)]\n    tree = UnionFind(N)\n    for i in range(N):\n        L = languages[i][1:]\n        for m in L:\n            K[m - 1].add(i)\n    for i in range(M):\n        Ki = list(K[i])\n        if len(Ki) == 0:\n            continue\n        for h in range(len(Ki)):\n            tree.union(Ki[h], Ki[0])\n    for i in range(N):\n        if not tree.same_check(0, i):\n            return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "self.count[x] = 0",
      "mutated_line": "self.count[x] = 1",
      "code": "def can_all_participants_communicate(N, M, languages):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n            self.count = [1] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n                self.count[y] += self.count[x]\n                self.count[x] = 1\n            else:\n                self.par[y] = x\n                self.count[x] += self.count[y]\n                self.count[y] = 0\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def size(self, x):\n            q = UnionFind.find(self, x)\n            return self.count[q]\n    K = [set() for _ in range(M)]\n    tree = UnionFind(N)\n    for i in range(N):\n        L = languages[i][1:]\n        for m in L:\n            K[m - 1].add(i)\n    for i in range(M):\n        Ki = list(K[i])\n        if len(Ki) == 0:\n            continue\n        for h in range(len(Ki)):\n            tree.union(Ki[h], Ki[0])\n    for i in range(N):\n        if not tree.same_check(0, i):\n            return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "self.count[x] = 0",
      "mutated_line": "self.count[x] = -1",
      "code": "def can_all_participants_communicate(N, M, languages):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n            self.count = [1] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n                self.count[y] += self.count[x]\n                self.count[x] = -1\n            else:\n                self.par[y] = x\n                self.count[x] += self.count[y]\n                self.count[y] = 0\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def size(self, x):\n            q = UnionFind.find(self, x)\n            return self.count[q]\n    K = [set() for _ in range(M)]\n    tree = UnionFind(N)\n    for i in range(N):\n        L = languages[i][1:]\n        for m in L:\n            K[m - 1].add(i)\n    for i in range(M):\n        Ki = list(K[i])\n        if len(Ki) == 0:\n            continue\n        for h in range(len(Ki)):\n            tree.union(Ki[h], Ki[0])\n    for i in range(N):\n        if not tree.same_check(0, i):\n            return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "self.count[x] = 0",
      "mutated_line": "self.count[x] = 1",
      "code": "def can_all_participants_communicate(N, M, languages):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n            self.count = [1] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n                self.count[y] += self.count[x]\n                self.count[x] = 1\n            else:\n                self.par[y] = x\n                self.count[x] += self.count[y]\n                self.count[y] = 0\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def size(self, x):\n            q = UnionFind.find(self, x)\n            return self.count[q]\n    K = [set() for _ in range(M)]\n    tree = UnionFind(N)\n    for i in range(N):\n        L = languages[i][1:]\n        for m in L:\n            K[m - 1].add(i)\n    for i in range(M):\n        Ki = list(K[i])\n        if len(Ki) == 0:\n            continue\n        for h in range(len(Ki)):\n            tree.union(Ki[h], Ki[0])\n    for i in range(N):\n        if not tree.same_check(0, i):\n            return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "self.count[y] = 0",
      "mutated_line": "self.count[y] = 1",
      "code": "def can_all_participants_communicate(N, M, languages):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n            self.count = [1] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n                self.count[y] += self.count[x]\n                self.count[x] = 0\n            else:\n                self.par[y] = x\n                self.count[x] += self.count[y]\n                self.count[y] = 1\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def size(self, x):\n            q = UnionFind.find(self, x)\n            return self.count[q]\n    K = [set() for _ in range(M)]\n    tree = UnionFind(N)\n    for i in range(N):\n        L = languages[i][1:]\n        for m in L:\n            K[m - 1].add(i)\n    for i in range(M):\n        Ki = list(K[i])\n        if len(Ki) == 0:\n            continue\n        for h in range(len(Ki)):\n            tree.union(Ki[h], Ki[0])\n    for i in range(N):\n        if not tree.same_check(0, i):\n            return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "self.count[y] = 0",
      "mutated_line": "self.count[y] = -1",
      "code": "def can_all_participants_communicate(N, M, languages):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n            self.count = [1] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n                self.count[y] += self.count[x]\n                self.count[x] = 0\n            else:\n                self.par[y] = x\n                self.count[x] += self.count[y]\n                self.count[y] = -1\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def size(self, x):\n            q = UnionFind.find(self, x)\n            return self.count[q]\n    K = [set() for _ in range(M)]\n    tree = UnionFind(N)\n    for i in range(N):\n        L = languages[i][1:]\n        for m in L:\n            K[m - 1].add(i)\n    for i in range(M):\n        Ki = list(K[i])\n        if len(Ki) == 0:\n            continue\n        for h in range(len(Ki)):\n            tree.union(Ki[h], Ki[0])\n    for i in range(N):\n        if not tree.same_check(0, i):\n            return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "self.count[y] = 0",
      "mutated_line": "self.count[y] = 1",
      "code": "def can_all_participants_communicate(N, M, languages):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n            self.count = [1] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n                self.count[y] += self.count[x]\n                self.count[x] = 0\n            else:\n                self.par[y] = x\n                self.count[x] += self.count[y]\n                self.count[y] = 1\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def size(self, x):\n            q = UnionFind.find(self, x)\n            return self.count[q]\n    K = [set() for _ in range(M)]\n    tree = UnionFind(N)\n    for i in range(N):\n        L = languages[i][1:]\n        for m in L:\n            K[m - 1].add(i)\n    for i in range(M):\n        Ki = list(K[i])\n        if len(Ki) == 0:\n            continue\n        for h in range(len(Ki)):\n            tree.union(Ki[h], Ki[0])\n    for i in range(N):\n        if not tree.same_check(0, i):\n            return 'NO'\n    return 'YES'"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if self.rank[x] == self.rank[y]:",
      "mutated_line": "if self.rank[x] != self.rank[y]:",
      "code": "def can_all_participants_communicate(N, M, languages):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n            self.count = [1] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n                self.count[y] += self.count[x]\n                self.count[x] = 0\n            else:\n                self.par[y] = x\n                self.count[x] += self.count[y]\n                self.count[y] = 0\n                if self.rank[x] != self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def size(self, x):\n            q = UnionFind.find(self, x)\n            return self.count[q]\n    K = [set() for _ in range(M)]\n    tree = UnionFind(N)\n    for i in range(N):\n        L = languages[i][1:]\n        for m in L:\n            K[m - 1].add(i)\n    for i in range(M):\n        Ki = list(K[i])\n        if len(Ki) == 0:\n            continue\n        for h in range(len(Ki)):\n            tree.union(Ki[h], Ki[0])\n    for i in range(N):\n        if not tree.same_check(0, i):\n            return 'NO'\n    return 'YES'"
    },
    {
      "operator": "ASR",
      "lineno": 27,
      "original_line": "self.rank[x] += 1",
      "mutated_line": "self.rank[x] -= 1",
      "code": "def can_all_participants_communicate(N, M, languages):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n            self.count = [1] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n                self.count[y] += self.count[x]\n                self.count[x] = 0\n            else:\n                self.par[y] = x\n                self.count[x] += self.count[y]\n                self.count[y] = 0\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] -= 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def size(self, x):\n            q = UnionFind.find(self, x)\n            return self.count[q]\n    K = [set() for _ in range(M)]\n    tree = UnionFind(N)\n    for i in range(N):\n        L = languages[i][1:]\n        for m in L:\n            K[m - 1].add(i)\n    for i in range(M):\n        Ki = list(K[i])\n        if len(Ki) == 0:\n            continue\n        for h in range(len(Ki)):\n            tree.union(Ki[h], Ki[0])\n    for i in range(N):\n        if not tree.same_check(0, i):\n            return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "L = languages[i][1:]  # Extract the languages spoken by the i-th participant",
      "mutated_line": "L = languages[i][2:]",
      "code": "def can_all_participants_communicate(N, M, languages):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n            self.count = [1] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n                self.count[y] += self.count[x]\n                self.count[x] = 0\n            else:\n                self.par[y] = x\n                self.count[x] += self.count[y]\n                self.count[y] = 0\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def size(self, x):\n            q = UnionFind.find(self, x)\n            return self.count[q]\n    K = [set() for _ in range(M)]\n    tree = UnionFind(N)\n    for i in range(N):\n        L = languages[i][2:]\n        for m in L:\n            K[m - 1].add(i)\n    for i in range(M):\n        Ki = list(K[i])\n        if len(Ki) == 0:\n            continue\n        for h in range(len(Ki)):\n            tree.union(Ki[h], Ki[0])\n    for i in range(N):\n        if not tree.same_check(0, i):\n            return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "L = languages[i][1:]  # Extract the languages spoken by the i-th participant",
      "mutated_line": "L = languages[i][0:]",
      "code": "def can_all_participants_communicate(N, M, languages):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n            self.count = [1] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n                self.count[y] += self.count[x]\n                self.count[x] = 0\n            else:\n                self.par[y] = x\n                self.count[x] += self.count[y]\n                self.count[y] = 0\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def size(self, x):\n            q = UnionFind.find(self, x)\n            return self.count[q]\n    K = [set() for _ in range(M)]\n    tree = UnionFind(N)\n    for i in range(N):\n        L = languages[i][0:]\n        for m in L:\n            K[m - 1].add(i)\n    for i in range(M):\n        Ki = list(K[i])\n        if len(Ki) == 0:\n            continue\n        for h in range(len(Ki)):\n            tree.union(Ki[h], Ki[0])\n    for i in range(N):\n        if not tree.same_check(0, i):\n            return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "L = languages[i][1:]  # Extract the languages spoken by the i-th participant",
      "mutated_line": "L = languages[i][0:]",
      "code": "def can_all_participants_communicate(N, M, languages):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n            self.count = [1] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n                self.count[y] += self.count[x]\n                self.count[x] = 0\n            else:\n                self.par[y] = x\n                self.count[x] += self.count[y]\n                self.count[y] = 0\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def size(self, x):\n            q = UnionFind.find(self, x)\n            return self.count[q]\n    K = [set() for _ in range(M)]\n    tree = UnionFind(N)\n    for i in range(N):\n        L = languages[i][0:]\n        for m in L:\n            K[m - 1].add(i)\n    for i in range(M):\n        Ki = list(K[i])\n        if len(Ki) == 0:\n            continue\n        for h in range(len(Ki)):\n            tree.union(Ki[h], Ki[0])\n    for i in range(N):\n        if not tree.same_check(0, i):\n            return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "L = languages[i][1:]  # Extract the languages spoken by the i-th participant",
      "mutated_line": "L = languages[i][-1:]",
      "code": "def can_all_participants_communicate(N, M, languages):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n            self.count = [1] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n                self.count[y] += self.count[x]\n                self.count[x] = 0\n            else:\n                self.par[y] = x\n                self.count[x] += self.count[y]\n                self.count[y] = 0\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def size(self, x):\n            q = UnionFind.find(self, x)\n            return self.count[q]\n    K = [set() for _ in range(M)]\n    tree = UnionFind(N)\n    for i in range(N):\n        L = languages[i][-1:]\n        for m in L:\n            K[m - 1].add(i)\n    for i in range(M):\n        Ki = list(K[i])\n        if len(Ki) == 0:\n            continue\n        for h in range(len(Ki)):\n            tree.union(Ki[h], Ki[0])\n    for i in range(N):\n        if not tree.same_check(0, i):\n            return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "if not tree.same_check(0, i):",
      "mutated_line": "if not tree.same_check(1, i):",
      "code": "def can_all_participants_communicate(N, M, languages):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n            self.count = [1] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n                self.count[y] += self.count[x]\n                self.count[x] = 0\n            else:\n                self.par[y] = x\n                self.count[x] += self.count[y]\n                self.count[y] = 0\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def size(self, x):\n            q = UnionFind.find(self, x)\n            return self.count[q]\n    K = [set() for _ in range(M)]\n    tree = UnionFind(N)\n    for i in range(N):\n        L = languages[i][1:]\n        for m in L:\n            K[m - 1].add(i)\n    for i in range(M):\n        Ki = list(K[i])\n        if len(Ki) == 0:\n            continue\n        for h in range(len(Ki)):\n            tree.union(Ki[h], Ki[0])\n    for i in range(N):\n        if not tree.same_check(1, i):\n            return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "if not tree.same_check(0, i):",
      "mutated_line": "if not tree.same_check(-1, i):",
      "code": "def can_all_participants_communicate(N, M, languages):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n            self.count = [1] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n                self.count[y] += self.count[x]\n                self.count[x] = 0\n            else:\n                self.par[y] = x\n                self.count[x] += self.count[y]\n                self.count[y] = 0\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def size(self, x):\n            q = UnionFind.find(self, x)\n            return self.count[q]\n    K = [set() for _ in range(M)]\n    tree = UnionFind(N)\n    for i in range(N):\n        L = languages[i][1:]\n        for m in L:\n            K[m - 1].add(i)\n    for i in range(M):\n        Ki = list(K[i])\n        if len(Ki) == 0:\n            continue\n        for h in range(len(Ki)):\n            tree.union(Ki[h], Ki[0])\n    for i in range(N):\n        if not tree.same_check(-1, i):\n            return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "if not tree.same_check(0, i):",
      "mutated_line": "if not tree.same_check(1, i):",
      "code": "def can_all_participants_communicate(N, M, languages):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n            self.count = [1] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n                self.count[y] += self.count[x]\n                self.count[x] = 0\n            else:\n                self.par[y] = x\n                self.count[x] += self.count[y]\n                self.count[y] = 0\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def size(self, x):\n            q = UnionFind.find(self, x)\n            return self.count[q]\n    K = [set() for _ in range(M)]\n    tree = UnionFind(N)\n    for i in range(N):\n        L = languages[i][1:]\n        for m in L:\n            K[m - 1].add(i)\n    for i in range(M):\n        Ki = list(K[i])\n        if len(Ki) == 0:\n            continue\n        for h in range(len(Ki)):\n            tree.union(Ki[h], Ki[0])\n    for i in range(N):\n        if not tree.same_check(1, i):\n            return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "self.rank = [0] * (n + 1)",
      "mutated_line": "self.rank = [1] * (n + 1)",
      "code": "def can_all_participants_communicate(N, M, languages):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [1] * (n + 1)\n            self.count = [1] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n                self.count[y] += self.count[x]\n                self.count[x] = 0\n            else:\n                self.par[y] = x\n                self.count[x] += self.count[y]\n                self.count[y] = 0\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def size(self, x):\n            q = UnionFind.find(self, x)\n            return self.count[q]\n    K = [set() for _ in range(M)]\n    tree = UnionFind(N)\n    for i in range(N):\n        L = languages[i][1:]\n        for m in L:\n            K[m - 1].add(i)\n    for i in range(M):\n        Ki = list(K[i])\n        if len(Ki) == 0:\n            continue\n        for h in range(len(Ki)):\n            tree.union(Ki[h], Ki[0])\n    for i in range(N):\n        if not tree.same_check(0, i):\n            return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "self.rank = [0] * (n + 1)",
      "mutated_line": "self.rank = [-1] * (n + 1)",
      "code": "def can_all_participants_communicate(N, M, languages):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [-1] * (n + 1)\n            self.count = [1] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n                self.count[y] += self.count[x]\n                self.count[x] = 0\n            else:\n                self.par[y] = x\n                self.count[x] += self.count[y]\n                self.count[y] = 0\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def size(self, x):\n            q = UnionFind.find(self, x)\n            return self.count[q]\n    K = [set() for _ in range(M)]\n    tree = UnionFind(N)\n    for i in range(N):\n        L = languages[i][1:]\n        for m in L:\n            K[m - 1].add(i)\n    for i in range(M):\n        Ki = list(K[i])\n        if len(Ki) == 0:\n            continue\n        for h in range(len(Ki)):\n            tree.union(Ki[h], Ki[0])\n    for i in range(N):\n        if not tree.same_check(0, i):\n            return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "self.rank = [0] * (n + 1)",
      "mutated_line": "self.rank = [1] * (n + 1)",
      "code": "def can_all_participants_communicate(N, M, languages):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [1] * (n + 1)\n            self.count = [1] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n                self.count[y] += self.count[x]\n                self.count[x] = 0\n            else:\n                self.par[y] = x\n                self.count[x] += self.count[y]\n                self.count[y] = 0\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def size(self, x):\n            q = UnionFind.find(self, x)\n            return self.count[q]\n    K = [set() for _ in range(M)]\n    tree = UnionFind(N)\n    for i in range(N):\n        L = languages[i][1:]\n        for m in L:\n            K[m - 1].add(i)\n    for i in range(M):\n        Ki = list(K[i])\n        if len(Ki) == 0:\n            continue\n        for h in range(len(Ki)):\n            tree.union(Ki[h], Ki[0])\n    for i in range(N):\n        if not tree.same_check(0, i):\n            return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "self.rank = [0] * (n + 1)",
      "mutated_line": "self.rank = [0] * (n + 2)",
      "code": "def can_all_participants_communicate(N, M, languages):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 2)\n            self.count = [1] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n                self.count[y] += self.count[x]\n                self.count[x] = 0\n            else:\n                self.par[y] = x\n                self.count[x] += self.count[y]\n                self.count[y] = 0\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def size(self, x):\n            q = UnionFind.find(self, x)\n            return self.count[q]\n    K = [set() for _ in range(M)]\n    tree = UnionFind(N)\n    for i in range(N):\n        L = languages[i][1:]\n        for m in L:\n            K[m - 1].add(i)\n    for i in range(M):\n        Ki = list(K[i])\n        if len(Ki) == 0:\n            continue\n        for h in range(len(Ki)):\n            tree.union(Ki[h], Ki[0])\n    for i in range(N):\n        if not tree.same_check(0, i):\n            return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "self.rank = [0] * (n + 1)",
      "mutated_line": "self.rank = [0] * (n + 0)",
      "code": "def can_all_participants_communicate(N, M, languages):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 0)\n            self.count = [1] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n                self.count[y] += self.count[x]\n                self.count[x] = 0\n            else:\n                self.par[y] = x\n                self.count[x] += self.count[y]\n                self.count[y] = 0\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def size(self, x):\n            q = UnionFind.find(self, x)\n            return self.count[q]\n    K = [set() for _ in range(M)]\n    tree = UnionFind(N)\n    for i in range(N):\n        L = languages[i][1:]\n        for m in L:\n            K[m - 1].add(i)\n    for i in range(M):\n        Ki = list(K[i])\n        if len(Ki) == 0:\n            continue\n        for h in range(len(Ki)):\n            tree.union(Ki[h], Ki[0])\n    for i in range(N):\n        if not tree.same_check(0, i):\n            return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "self.rank = [0] * (n + 1)",
      "mutated_line": "self.rank = [0] * (n + 0)",
      "code": "def can_all_participants_communicate(N, M, languages):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 0)\n            self.count = [1] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n                self.count[y] += self.count[x]\n                self.count[x] = 0\n            else:\n                self.par[y] = x\n                self.count[x] += self.count[y]\n                self.count[y] = 0\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def size(self, x):\n            q = UnionFind.find(self, x)\n            return self.count[q]\n    K = [set() for _ in range(M)]\n    tree = UnionFind(N)\n    for i in range(N):\n        L = languages[i][1:]\n        for m in L:\n            K[m - 1].add(i)\n    for i in range(M):\n        Ki = list(K[i])\n        if len(Ki) == 0:\n            continue\n        for h in range(len(Ki)):\n            tree.union(Ki[h], Ki[0])\n    for i in range(N):\n        if not tree.same_check(0, i):\n            return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "self.rank = [0] * (n + 1)",
      "mutated_line": "self.rank = [0] * (n + -1)",
      "code": "def can_all_participants_communicate(N, M, languages):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + -1)\n            self.count = [1] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n                self.count[y] += self.count[x]\n                self.count[x] = 0\n            else:\n                self.par[y] = x\n                self.count[x] += self.count[y]\n                self.count[y] = 0\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def size(self, x):\n            q = UnionFind.find(self, x)\n            return self.count[q]\n    K = [set() for _ in range(M)]\n    tree = UnionFind(N)\n    for i in range(N):\n        L = languages[i][1:]\n        for m in L:\n            K[m - 1].add(i)\n    for i in range(M):\n        Ki = list(K[i])\n        if len(Ki) == 0:\n            continue\n        for h in range(len(Ki)):\n            tree.union(Ki[h], Ki[0])\n    for i in range(N):\n        if not tree.same_check(0, i):\n            return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "self.count = [1] * (n + 1)",
      "mutated_line": "self.count = [2] * (n + 1)",
      "code": "def can_all_participants_communicate(N, M, languages):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n            self.count = [2] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n                self.count[y] += self.count[x]\n                self.count[x] = 0\n            else:\n                self.par[y] = x\n                self.count[x] += self.count[y]\n                self.count[y] = 0\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def size(self, x):\n            q = UnionFind.find(self, x)\n            return self.count[q]\n    K = [set() for _ in range(M)]\n    tree = UnionFind(N)\n    for i in range(N):\n        L = languages[i][1:]\n        for m in L:\n            K[m - 1].add(i)\n    for i in range(M):\n        Ki = list(K[i])\n        if len(Ki) == 0:\n            continue\n        for h in range(len(Ki)):\n            tree.union(Ki[h], Ki[0])\n    for i in range(N):\n        if not tree.same_check(0, i):\n            return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "self.count = [1] * (n + 1)",
      "mutated_line": "self.count = [0] * (n + 1)",
      "code": "def can_all_participants_communicate(N, M, languages):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n            self.count = [0] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n                self.count[y] += self.count[x]\n                self.count[x] = 0\n            else:\n                self.par[y] = x\n                self.count[x] += self.count[y]\n                self.count[y] = 0\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def size(self, x):\n            q = UnionFind.find(self, x)\n            return self.count[q]\n    K = [set() for _ in range(M)]\n    tree = UnionFind(N)\n    for i in range(N):\n        L = languages[i][1:]\n        for m in L:\n            K[m - 1].add(i)\n    for i in range(M):\n        Ki = list(K[i])\n        if len(Ki) == 0:\n            continue\n        for h in range(len(Ki)):\n            tree.union(Ki[h], Ki[0])\n    for i in range(N):\n        if not tree.same_check(0, i):\n            return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "self.count = [1] * (n + 1)",
      "mutated_line": "self.count = [0] * (n + 1)",
      "code": "def can_all_participants_communicate(N, M, languages):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n            self.count = [0] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n                self.count[y] += self.count[x]\n                self.count[x] = 0\n            else:\n                self.par[y] = x\n                self.count[x] += self.count[y]\n                self.count[y] = 0\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def size(self, x):\n            q = UnionFind.find(self, x)\n            return self.count[q]\n    K = [set() for _ in range(M)]\n    tree = UnionFind(N)\n    for i in range(N):\n        L = languages[i][1:]\n        for m in L:\n            K[m - 1].add(i)\n    for i in range(M):\n        Ki = list(K[i])\n        if len(Ki) == 0:\n            continue\n        for h in range(len(Ki)):\n            tree.union(Ki[h], Ki[0])\n    for i in range(N):\n        if not tree.same_check(0, i):\n            return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "self.count = [1] * (n + 1)",
      "mutated_line": "self.count = [-1] * (n + 1)",
      "code": "def can_all_participants_communicate(N, M, languages):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n            self.count = [-1] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n                self.count[y] += self.count[x]\n                self.count[x] = 0\n            else:\n                self.par[y] = x\n                self.count[x] += self.count[y]\n                self.count[y] = 0\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def size(self, x):\n            q = UnionFind.find(self, x)\n            return self.count[q]\n    K = [set() for _ in range(M)]\n    tree = UnionFind(N)\n    for i in range(N):\n        L = languages[i][1:]\n        for m in L:\n            K[m - 1].add(i)\n    for i in range(M):\n        Ki = list(K[i])\n        if len(Ki) == 0:\n            continue\n        for h in range(len(Ki)):\n            tree.union(Ki[h], Ki[0])\n    for i in range(N):\n        if not tree.same_check(0, i):\n            return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "self.count = [1] * (n + 1)",
      "mutated_line": "self.count = [1] * (n + 2)",
      "code": "def can_all_participants_communicate(N, M, languages):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n            self.count = [1] * (n + 2)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n                self.count[y] += self.count[x]\n                self.count[x] = 0\n            else:\n                self.par[y] = x\n                self.count[x] += self.count[y]\n                self.count[y] = 0\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def size(self, x):\n            q = UnionFind.find(self, x)\n            return self.count[q]\n    K = [set() for _ in range(M)]\n    tree = UnionFind(N)\n    for i in range(N):\n        L = languages[i][1:]\n        for m in L:\n            K[m - 1].add(i)\n    for i in range(M):\n        Ki = list(K[i])\n        if len(Ki) == 0:\n            continue\n        for h in range(len(Ki)):\n            tree.union(Ki[h], Ki[0])\n    for i in range(N):\n        if not tree.same_check(0, i):\n            return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "self.count = [1] * (n + 1)",
      "mutated_line": "self.count = [1] * (n + 0)",
      "code": "def can_all_participants_communicate(N, M, languages):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n            self.count = [1] * (n + 0)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n                self.count[y] += self.count[x]\n                self.count[x] = 0\n            else:\n                self.par[y] = x\n                self.count[x] += self.count[y]\n                self.count[y] = 0\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def size(self, x):\n            q = UnionFind.find(self, x)\n            return self.count[q]\n    K = [set() for _ in range(M)]\n    tree = UnionFind(N)\n    for i in range(N):\n        L = languages[i][1:]\n        for m in L:\n            K[m - 1].add(i)\n    for i in range(M):\n        Ki = list(K[i])\n        if len(Ki) == 0:\n            continue\n        for h in range(len(Ki)):\n            tree.union(Ki[h], Ki[0])\n    for i in range(N):\n        if not tree.same_check(0, i):\n            return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "self.count = [1] * (n + 1)",
      "mutated_line": "self.count = [1] * (n + 0)",
      "code": "def can_all_participants_communicate(N, M, languages):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n            self.count = [1] * (n + 0)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n                self.count[y] += self.count[x]\n                self.count[x] = 0\n            else:\n                self.par[y] = x\n                self.count[x] += self.count[y]\n                self.count[y] = 0\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def size(self, x):\n            q = UnionFind.find(self, x)\n            return self.count[q]\n    K = [set() for _ in range(M)]\n    tree = UnionFind(N)\n    for i in range(N):\n        L = languages[i][1:]\n        for m in L:\n            K[m - 1].add(i)\n    for i in range(M):\n        Ki = list(K[i])\n        if len(Ki) == 0:\n            continue\n        for h in range(len(Ki)):\n            tree.union(Ki[h], Ki[0])\n    for i in range(N):\n        if not tree.same_check(0, i):\n            return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "self.count = [1] * (n + 1)",
      "mutated_line": "self.count = [1] * (n + -1)",
      "code": "def can_all_participants_communicate(N, M, languages):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n            self.count = [1] * (n + -1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n                self.count[y] += self.count[x]\n                self.count[x] = 0\n            else:\n                self.par[y] = x\n                self.count[x] += self.count[y]\n                self.count[y] = 0\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def size(self, x):\n            q = UnionFind.find(self, x)\n            return self.count[q]\n    K = [set() for _ in range(M)]\n    tree = UnionFind(N)\n    for i in range(N):\n        L = languages[i][1:]\n        for m in L:\n            K[m - 1].add(i)\n    for i in range(M):\n        Ki = list(K[i])\n        if len(Ki) == 0:\n            continue\n        for h in range(len(Ki)):\n            tree.union(Ki[h], Ki[0])\n    for i in range(N):\n        if not tree.same_check(0, i):\n            return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "self.rank[x] += 1",
      "mutated_line": "self.rank[x] += 2",
      "code": "def can_all_participants_communicate(N, M, languages):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n            self.count = [1] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n                self.count[y] += self.count[x]\n                self.count[x] = 0\n            else:\n                self.par[y] = x\n                self.count[x] += self.count[y]\n                self.count[y] = 0\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 2\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def size(self, x):\n            q = UnionFind.find(self, x)\n            return self.count[q]\n    K = [set() for _ in range(M)]\n    tree = UnionFind(N)\n    for i in range(N):\n        L = languages[i][1:]\n        for m in L:\n            K[m - 1].add(i)\n    for i in range(M):\n        Ki = list(K[i])\n        if len(Ki) == 0:\n            continue\n        for h in range(len(Ki)):\n            tree.union(Ki[h], Ki[0])\n    for i in range(N):\n        if not tree.same_check(0, i):\n            return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "self.rank[x] += 1",
      "mutated_line": "self.rank[x] += 0",
      "code": "def can_all_participants_communicate(N, M, languages):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n            self.count = [1] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n                self.count[y] += self.count[x]\n                self.count[x] = 0\n            else:\n                self.par[y] = x\n                self.count[x] += self.count[y]\n                self.count[y] = 0\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 0\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def size(self, x):\n            q = UnionFind.find(self, x)\n            return self.count[q]\n    K = [set() for _ in range(M)]\n    tree = UnionFind(N)\n    for i in range(N):\n        L = languages[i][1:]\n        for m in L:\n            K[m - 1].add(i)\n    for i in range(M):\n        Ki = list(K[i])\n        if len(Ki) == 0:\n            continue\n        for h in range(len(Ki)):\n            tree.union(Ki[h], Ki[0])\n    for i in range(N):\n        if not tree.same_check(0, i):\n            return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "self.rank[x] += 1",
      "mutated_line": "self.rank[x] += 0",
      "code": "def can_all_participants_communicate(N, M, languages):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n            self.count = [1] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n                self.count[y] += self.count[x]\n                self.count[x] = 0\n            else:\n                self.par[y] = x\n                self.count[x] += self.count[y]\n                self.count[y] = 0\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 0\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def size(self, x):\n            q = UnionFind.find(self, x)\n            return self.count[q]\n    K = [set() for _ in range(M)]\n    tree = UnionFind(N)\n    for i in range(N):\n        L = languages[i][1:]\n        for m in L:\n            K[m - 1].add(i)\n    for i in range(M):\n        Ki = list(K[i])\n        if len(Ki) == 0:\n            continue\n        for h in range(len(Ki)):\n            tree.union(Ki[h], Ki[0])\n    for i in range(N):\n        if not tree.same_check(0, i):\n            return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "self.rank[x] += 1",
      "mutated_line": "self.rank[x] += -1",
      "code": "def can_all_participants_communicate(N, M, languages):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n            self.count = [1] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n                self.count[y] += self.count[x]\n                self.count[x] = 0\n            else:\n                self.par[y] = x\n                self.count[x] += self.count[y]\n                self.count[y] = 0\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += -1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def size(self, x):\n            q = UnionFind.find(self, x)\n            return self.count[q]\n    K = [set() for _ in range(M)]\n    tree = UnionFind(N)\n    for i in range(N):\n        L = languages[i][1:]\n        for m in L:\n            K[m - 1].add(i)\n    for i in range(M):\n        Ki = list(K[i])\n        if len(Ki) == 0:\n            continue\n        for h in range(len(Ki)):\n            tree.union(Ki[h], Ki[0])\n    for i in range(N):\n        if not tree.same_check(0, i):\n            return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "tree.union(Ki[h], Ki[0])",
      "mutated_line": "tree.union(Ki[h], Ki[1])",
      "code": "def can_all_participants_communicate(N, M, languages):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n            self.count = [1] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n                self.count[y] += self.count[x]\n                self.count[x] = 0\n            else:\n                self.par[y] = x\n                self.count[x] += self.count[y]\n                self.count[y] = 0\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def size(self, x):\n            q = UnionFind.find(self, x)\n            return self.count[q]\n    K = [set() for _ in range(M)]\n    tree = UnionFind(N)\n    for i in range(N):\n        L = languages[i][1:]\n        for m in L:\n            K[m - 1].add(i)\n    for i in range(M):\n        Ki = list(K[i])\n        if len(Ki) == 0:\n            continue\n        for h in range(len(Ki)):\n            tree.union(Ki[h], Ki[1])\n    for i in range(N):\n        if not tree.same_check(0, i):\n            return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "tree.union(Ki[h], Ki[0])",
      "mutated_line": "tree.union(Ki[h], Ki[-1])",
      "code": "def can_all_participants_communicate(N, M, languages):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n            self.count = [1] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n                self.count[y] += self.count[x]\n                self.count[x] = 0\n            else:\n                self.par[y] = x\n                self.count[x] += self.count[y]\n                self.count[y] = 0\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def size(self, x):\n            q = UnionFind.find(self, x)\n            return self.count[q]\n    K = [set() for _ in range(M)]\n    tree = UnionFind(N)\n    for i in range(N):\n        L = languages[i][1:]\n        for m in L:\n            K[m - 1].add(i)\n    for i in range(M):\n        Ki = list(K[i])\n        if len(Ki) == 0:\n            continue\n        for h in range(len(Ki)):\n            tree.union(Ki[h], Ki[-1])\n    for i in range(N):\n        if not tree.same_check(0, i):\n            return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "tree.union(Ki[h], Ki[0])",
      "mutated_line": "tree.union(Ki[h], Ki[1])",
      "code": "def can_all_participants_communicate(N, M, languages):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n            self.count = [1] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n                self.count[y] += self.count[x]\n                self.count[x] = 0\n            else:\n                self.par[y] = x\n                self.count[x] += self.count[y]\n                self.count[y] = 0\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def size(self, x):\n            q = UnionFind.find(self, x)\n            return self.count[q]\n    K = [set() for _ in range(M)]\n    tree = UnionFind(N)\n    for i in range(N):\n        L = languages[i][1:]\n        for m in L:\n            K[m - 1].add(i)\n    for i in range(M):\n        Ki = list(K[i])\n        if len(Ki) == 0:\n            continue\n        for h in range(len(Ki)):\n            tree.union(Ki[h], Ki[1])\n    for i in range(N):\n        if not tree.same_check(0, i):\n            return 'NO'\n    return 'YES'"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "self.par = [i for i in range(n + 1)]",
      "mutated_line": "self.par = [i for i in range(n - 1)]",
      "code": "def can_all_participants_communicate(N, M, languages):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n - 1)]\n            self.rank = [0] * (n + 1)\n            self.count = [1] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n                self.count[y] += self.count[x]\n                self.count[x] = 0\n            else:\n                self.par[y] = x\n                self.count[x] += self.count[y]\n                self.count[y] = 0\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def size(self, x):\n            q = UnionFind.find(self, x)\n            return self.count[q]\n    K = [set() for _ in range(M)]\n    tree = UnionFind(N)\n    for i in range(N):\n        L = languages[i][1:]\n        for m in L:\n            K[m - 1].add(i)\n    for i in range(M):\n        Ki = list(K[i])\n        if len(Ki) == 0:\n            continue\n        for h in range(len(Ki)):\n            tree.union(Ki[h], Ki[0])\n    for i in range(N):\n        if not tree.same_check(0, i):\n            return 'NO'\n    return 'YES'"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "self.par = [i for i in range(n + 1)]",
      "mutated_line": "self.par = [i for i in range(n * 1)]",
      "code": "def can_all_participants_communicate(N, M, languages):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n * 1)]\n            self.rank = [0] * (n + 1)\n            self.count = [1] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n                self.count[y] += self.count[x]\n                self.count[x] = 0\n            else:\n                self.par[y] = x\n                self.count[x] += self.count[y]\n                self.count[y] = 0\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def size(self, x):\n            q = UnionFind.find(self, x)\n            return self.count[q]\n    K = [set() for _ in range(M)]\n    tree = UnionFind(N)\n    for i in range(N):\n        L = languages[i][1:]\n        for m in L:\n            K[m - 1].add(i)\n    for i in range(M):\n        Ki = list(K[i])\n        if len(Ki) == 0:\n            continue\n        for h in range(len(Ki)):\n            tree.union(Ki[h], Ki[0])\n    for i in range(N):\n        if not tree.same_check(0, i):\n            return 'NO'\n    return 'YES'"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "K[m - 1].add(i)  # Adjusting for 0-based index",
      "mutated_line": "K[m + 1].add(i)",
      "code": "def can_all_participants_communicate(N, M, languages):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n            self.count = [1] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n                self.count[y] += self.count[x]\n                self.count[x] = 0\n            else:\n                self.par[y] = x\n                self.count[x] += self.count[y]\n                self.count[y] = 0\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def size(self, x):\n            q = UnionFind.find(self, x)\n            return self.count[q]\n    K = [set() for _ in range(M)]\n    tree = UnionFind(N)\n    for i in range(N):\n        L = languages[i][1:]\n        for m in L:\n            K[m + 1].add(i)\n    for i in range(M):\n        Ki = list(K[i])\n        if len(Ki) == 0:\n            continue\n        for h in range(len(Ki)):\n            tree.union(Ki[h], Ki[0])\n    for i in range(N):\n        if not tree.same_check(0, i):\n            return 'NO'\n    return 'YES'"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "K[m - 1].add(i)  # Adjusting for 0-based index",
      "mutated_line": "K[m * 1].add(i)",
      "code": "def can_all_participants_communicate(N, M, languages):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n            self.count = [1] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n                self.count[y] += self.count[x]\n                self.count[x] = 0\n            else:\n                self.par[y] = x\n                self.count[x] += self.count[y]\n                self.count[y] = 0\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def size(self, x):\n            q = UnionFind.find(self, x)\n            return self.count[q]\n    K = [set() for _ in range(M)]\n    tree = UnionFind(N)\n    for i in range(N):\n        L = languages[i][1:]\n        for m in L:\n            K[m * 1].add(i)\n    for i in range(M):\n        Ki = list(K[i])\n        if len(Ki) == 0:\n            continue\n        for h in range(len(Ki)):\n            tree.union(Ki[h], Ki[0])\n    for i in range(N):\n        if not tree.same_check(0, i):\n            return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "self.par = [i for i in range(n + 1)]",
      "mutated_line": "self.par = [i for i in range(n + 2)]",
      "code": "def can_all_participants_communicate(N, M, languages):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 2)]\n            self.rank = [0] * (n + 1)\n            self.count = [1] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n                self.count[y] += self.count[x]\n                self.count[x] = 0\n            else:\n                self.par[y] = x\n                self.count[x] += self.count[y]\n                self.count[y] = 0\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def size(self, x):\n            q = UnionFind.find(self, x)\n            return self.count[q]\n    K = [set() for _ in range(M)]\n    tree = UnionFind(N)\n    for i in range(N):\n        L = languages[i][1:]\n        for m in L:\n            K[m - 1].add(i)\n    for i in range(M):\n        Ki = list(K[i])\n        if len(Ki) == 0:\n            continue\n        for h in range(len(Ki)):\n            tree.union(Ki[h], Ki[0])\n    for i in range(N):\n        if not tree.same_check(0, i):\n            return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "self.par = [i for i in range(n + 1)]",
      "mutated_line": "self.par = [i for i in range(n + 0)]",
      "code": "def can_all_participants_communicate(N, M, languages):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 0)]\n            self.rank = [0] * (n + 1)\n            self.count = [1] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n                self.count[y] += self.count[x]\n                self.count[x] = 0\n            else:\n                self.par[y] = x\n                self.count[x] += self.count[y]\n                self.count[y] = 0\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def size(self, x):\n            q = UnionFind.find(self, x)\n            return self.count[q]\n    K = [set() for _ in range(M)]\n    tree = UnionFind(N)\n    for i in range(N):\n        L = languages[i][1:]\n        for m in L:\n            K[m - 1].add(i)\n    for i in range(M):\n        Ki = list(K[i])\n        if len(Ki) == 0:\n            continue\n        for h in range(len(Ki)):\n            tree.union(Ki[h], Ki[0])\n    for i in range(N):\n        if not tree.same_check(0, i):\n            return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "self.par = [i for i in range(n + 1)]",
      "mutated_line": "self.par = [i for i in range(n + 0)]",
      "code": "def can_all_participants_communicate(N, M, languages):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 0)]\n            self.rank = [0] * (n + 1)\n            self.count = [1] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n                self.count[y] += self.count[x]\n                self.count[x] = 0\n            else:\n                self.par[y] = x\n                self.count[x] += self.count[y]\n                self.count[y] = 0\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def size(self, x):\n            q = UnionFind.find(self, x)\n            return self.count[q]\n    K = [set() for _ in range(M)]\n    tree = UnionFind(N)\n    for i in range(N):\n        L = languages[i][1:]\n        for m in L:\n            K[m - 1].add(i)\n    for i in range(M):\n        Ki = list(K[i])\n        if len(Ki) == 0:\n            continue\n        for h in range(len(Ki)):\n            tree.union(Ki[h], Ki[0])\n    for i in range(N):\n        if not tree.same_check(0, i):\n            return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "self.par = [i for i in range(n + 1)]",
      "mutated_line": "self.par = [i for i in range(n + -1)]",
      "code": "def can_all_participants_communicate(N, M, languages):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + -1)]\n            self.rank = [0] * (n + 1)\n            self.count = [1] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n                self.count[y] += self.count[x]\n                self.count[x] = 0\n            else:\n                self.par[y] = x\n                self.count[x] += self.count[y]\n                self.count[y] = 0\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def size(self, x):\n            q = UnionFind.find(self, x)\n            return self.count[q]\n    K = [set() for _ in range(M)]\n    tree = UnionFind(N)\n    for i in range(N):\n        L = languages[i][1:]\n        for m in L:\n            K[m - 1].add(i)\n    for i in range(M):\n        Ki = list(K[i])\n        if len(Ki) == 0:\n            continue\n        for h in range(len(Ki)):\n            tree.union(Ki[h], Ki[0])\n    for i in range(N):\n        if not tree.same_check(0, i):\n            return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "K[m - 1].add(i)  # Adjusting for 0-based index",
      "mutated_line": "K[m - 2].add(i)",
      "code": "def can_all_participants_communicate(N, M, languages):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n            self.count = [1] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n                self.count[y] += self.count[x]\n                self.count[x] = 0\n            else:\n                self.par[y] = x\n                self.count[x] += self.count[y]\n                self.count[y] = 0\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def size(self, x):\n            q = UnionFind.find(self, x)\n            return self.count[q]\n    K = [set() for _ in range(M)]\n    tree = UnionFind(N)\n    for i in range(N):\n        L = languages[i][1:]\n        for m in L:\n            K[m - 2].add(i)\n    for i in range(M):\n        Ki = list(K[i])\n        if len(Ki) == 0:\n            continue\n        for h in range(len(Ki)):\n            tree.union(Ki[h], Ki[0])\n    for i in range(N):\n        if not tree.same_check(0, i):\n            return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "K[m - 1].add(i)  # Adjusting for 0-based index",
      "mutated_line": "K[m - 0].add(i)",
      "code": "def can_all_participants_communicate(N, M, languages):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n            self.count = [1] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n                self.count[y] += self.count[x]\n                self.count[x] = 0\n            else:\n                self.par[y] = x\n                self.count[x] += self.count[y]\n                self.count[y] = 0\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def size(self, x):\n            q = UnionFind.find(self, x)\n            return self.count[q]\n    K = [set() for _ in range(M)]\n    tree = UnionFind(N)\n    for i in range(N):\n        L = languages[i][1:]\n        for m in L:\n            K[m - 0].add(i)\n    for i in range(M):\n        Ki = list(K[i])\n        if len(Ki) == 0:\n            continue\n        for h in range(len(Ki)):\n            tree.union(Ki[h], Ki[0])\n    for i in range(N):\n        if not tree.same_check(0, i):\n            return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "K[m - 1].add(i)  # Adjusting for 0-based index",
      "mutated_line": "K[m - 0].add(i)",
      "code": "def can_all_participants_communicate(N, M, languages):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n            self.count = [1] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n                self.count[y] += self.count[x]\n                self.count[x] = 0\n            else:\n                self.par[y] = x\n                self.count[x] += self.count[y]\n                self.count[y] = 0\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def size(self, x):\n            q = UnionFind.find(self, x)\n            return self.count[q]\n    K = [set() for _ in range(M)]\n    tree = UnionFind(N)\n    for i in range(N):\n        L = languages[i][1:]\n        for m in L:\n            K[m - 0].add(i)\n    for i in range(M):\n        Ki = list(K[i])\n        if len(Ki) == 0:\n            continue\n        for h in range(len(Ki)):\n            tree.union(Ki[h], Ki[0])\n    for i in range(N):\n        if not tree.same_check(0, i):\n            return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "K[m - 1].add(i)  # Adjusting for 0-based index",
      "mutated_line": "K[m - -1].add(i)",
      "code": "def can_all_participants_communicate(N, M, languages):\n\n    class UnionFind:\n\n        def __init__(self, n):\n            self.par = [i for i in range(n + 1)]\n            self.rank = [0] * (n + 1)\n            self.count = [1] * (n + 1)\n\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n                self.count[y] += self.count[x]\n                self.count[x] = 0\n            else:\n                self.par[y] = x\n                self.count[x] += self.count[y]\n                self.count[y] = 0\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n        def same_check(self, x, y):\n            return self.find(x) == self.find(y)\n\n        def size(self, x):\n            q = UnionFind.find(self, x)\n            return self.count[q]\n    K = [set() for _ in range(M)]\n    tree = UnionFind(N)\n    for i in range(N):\n        L = languages[i][1:]\n        for m in L:\n            K[m - -1].add(i)\n    for i in range(M):\n        Ki = list(K[i])\n        if len(Ki) == 0:\n            continue\n        for h in range(len(Ki)):\n            tree.union(Ki[h], Ki[0])\n    for i in range(N):\n        if not tree.same_check(0, i):\n            return 'NO'\n    return 'YES'"
    }
  ]
}