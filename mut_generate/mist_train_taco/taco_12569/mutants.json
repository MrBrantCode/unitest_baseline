{
  "task_id": "taco_12569",
  "entry_point": "min_operations_to_recolor_tree",
  "mutant_count": 131,
  "mutants": [
    {
      "operator": "LCR",
      "lineno": 13,
      "original_line": "if len(d[node]) == 1 and node != 1:",
      "mutated_line": "if len(d[node]) == 1 or node != 1:",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 or node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "return go(1, None, A[0], False)",
      "mutated_line": "return go(2, None, A[0], False)",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(2, None, A[0], False)"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "return go(1, None, A[0], False)",
      "mutated_line": "return go(0, None, A[0], False)",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(0, None, A[0], False)"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "return go(1, None, A[0], False)",
      "mutated_line": "return go(0, None, A[0], False)",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(0, None, A[0], False)"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "return go(1, None, A[0], False)",
      "mutated_line": "return go(-1, None, A[0], False)",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(-1, None, A[0], False)"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "return go(1, None, A[0], False)",
      "mutated_line": "return go(1, None, A[0], True)",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], True)"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if len(d[node]) == 1 and node != 1:",
      "mutated_line": "if len(d[node]) != 1 and node != 1:",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) != 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if len(d[node]) == 1 and node != 1:",
      "mutated_line": "if len(d[node]) == 1 and node == 1:",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node == 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if c != B[node - 1]:",
      "mutated_line": "if c == B[node - 1]:",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c == B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if A[node - 1] == B[node - 1]:",
      "mutated_line": "if A[node - 1] != B[node - 1]:",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] != B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "tans = 1",
      "mutated_line": "tans = 2",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 2\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "tans = 1",
      "mutated_line": "tans = 0",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 0\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "tans = 1",
      "mutated_line": "tans = 0",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 0\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "tans = 1",
      "mutated_line": "tans = -1",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = -1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "if tans < ans:",
      "mutated_line": "if tans <= ans:",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans <= ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "if tans < ans:",
      "mutated_line": "if tans >= ans:",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans >= ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "if tans < ans:",
      "mutated_line": "if tans != ans:",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans != ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "return go(1, None, A[0], False)",
      "mutated_line": "return go(1, None, A[1], False)",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[1], False)"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "return go(1, None, A[0], False)",
      "mutated_line": "return go(1, None, A[-1], False)",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[-1], False)"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "return go(1, None, A[0], False)",
      "mutated_line": "return go(1, None, A[1], False)",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[1], False)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if len(d[node]) == 1 and node != 1:",
      "mutated_line": "if len(d[node]) == 2 and node != 1:",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 2 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if len(d[node]) == 1 and node != 1:",
      "mutated_line": "if len(d[node]) == 0 and node != 1:",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 0 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if len(d[node]) == 1 and node != 1:",
      "mutated_line": "if len(d[node]) == 0 and node != 1:",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 0 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if len(d[node]) == 1 and node != 1:",
      "mutated_line": "if len(d[node]) == -1 and node != 1:",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == -1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if len(d[node]) == 1 and node != 1:",
      "mutated_line": "if len(d[node]) == 1 and node != 2:",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 2:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if len(d[node]) == 1 and node != 1:",
      "mutated_line": "if len(d[node]) == 1 and node != 0:",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 0:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if len(d[node]) == 1 and node != 1:",
      "mutated_line": "if len(d[node]) == 1 and node != 0:",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 0:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if len(d[node]) == 1 and node != 1:",
      "mutated_line": "if len(d[node]) == 1 and node != -1:",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != -1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "LCR",
      "lineno": 14,
      "original_line": "return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0",
      "mutated_line": "return 1 if (swapped and c != B[node - 1]) and (not swapped and A[node - 1] != B[node - 1]) else 0",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if (swapped and c != B[node - 1]) and (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0",
      "mutated_line": "return 2 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 2 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0",
      "mutated_line": "return 0 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 0 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0",
      "mutated_line": "return 0 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 0 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0",
      "mutated_line": "return -1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return -1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0",
      "mutated_line": "return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 1",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 1\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0",
      "mutated_line": "return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else -1",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else -1\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0",
      "mutated_line": "return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 1",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 1\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "tans = 1",
      "mutated_line": "tans = 2",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 2\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "tans = 1",
      "mutated_line": "tans = 0",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "tans = 1",
      "mutated_line": "tans = 0",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "tans = 1",
      "mutated_line": "tans = -1",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = -1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if tans < ans:",
      "mutated_line": "if tans <= ans:",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans <= ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if tans < ans:",
      "mutated_line": "if tans >= ans:",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans >= ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if tans < ans:",
      "mutated_line": "if tans != ans:",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans != ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "tans = 0",
      "mutated_line": "tans = 1",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "tans = 0",
      "mutated_line": "tans = -1",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = -1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "tans = 0",
      "mutated_line": "tans = 1",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if tans < ans:",
      "mutated_line": "if tans <= ans:",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans <= ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if tans < ans:",
      "mutated_line": "if tans >= ans:",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans >= ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if tans < ans:",
      "mutated_line": "if tans != ans:",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans != ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "tans = 0",
      "mutated_line": "tans = 1",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "tans = 0",
      "mutated_line": "tans = -1",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = -1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "tans = 0",
      "mutated_line": "tans = 1",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if tans < ans:",
      "mutated_line": "if tans <= ans:",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans <= ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if tans < ans:",
      "mutated_line": "if tans >= ans:",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans >= ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if tans < ans:",
      "mutated_line": "if tans != ans:",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans != ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if child != parent:",
      "mutated_line": "if child == parent:",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child == parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "ASR",
      "lineno": 42,
      "original_line": "tans += go(child, node, B[node - 1], True)",
      "mutated_line": "tans -= go(child, node, B[node - 1], True)",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans -= go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "LCR",
      "lineno": 14,
      "original_line": "return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0",
      "mutated_line": "return 1 if (swapped or c != B[node - 1]) or (not swapped and A[node - 1] != B[node - 1]) else 0",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if (swapped or c != B[node - 1]) or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "LCR",
      "lineno": 14,
      "original_line": "return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0",
      "mutated_line": "return 1 if swapped and c != B[node - 1] or (not swapped or A[node - 1] != B[node - 1]) else 0",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped or A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "if c != B[node - 1]:",
      "mutated_line": "if c != B[node + 1]:",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node + 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "if c != B[node - 1]:",
      "mutated_line": "if c != B[node * 1]:",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node * 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if child != parent:",
      "mutated_line": "if child == parent:",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child == parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "ASR",
      "lineno": 21,
      "original_line": "tans += go(child, node, B[node - 1], True)",
      "mutated_line": "tans -= go(child, node, B[node - 1], True)",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans -= go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if child != parent:",
      "mutated_line": "if child == parent:",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child == parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "ASR",
      "lineno": 28,
      "original_line": "tans += go(child, node, B[node - 1], True)",
      "mutated_line": "tans -= go(child, node, B[node - 1], True)",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans -= go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "if A[node - 1] == B[node - 1]:",
      "mutated_line": "if A[node + 1] == B[node - 1]:",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node + 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "if A[node - 1] == B[node - 1]:",
      "mutated_line": "if A[node * 1] == B[node - 1]:",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node * 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "if A[node - 1] == B[node - 1]:",
      "mutated_line": "if A[node - 1] == B[node + 1]:",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node + 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "if A[node - 1] == B[node - 1]:",
      "mutated_line": "if A[node - 1] == B[node * 1]:",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node * 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if child != parent:",
      "mutated_line": "if child == parent:",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child == parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "ASR",
      "lineno": 36,
      "original_line": "tans += go(child, node, B[node - 1], False)",
      "mutated_line": "tans -= go(child, node, B[node - 1], False)",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans -= go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0",
      "mutated_line": "return 1 if swapped and c == B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c == B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0",
      "mutated_line": "return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] == B[node - 1]) else 0",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] == B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if c != B[node - 1]:",
      "mutated_line": "if c != B[node - 2]:",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 2]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if c != B[node - 1]:",
      "mutated_line": "if c != B[node - 0]:",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 0]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if c != B[node - 1]:",
      "mutated_line": "if c != B[node - 0]:",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 0]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if c != B[node - 1]:",
      "mutated_line": "if c != B[node - -1]:",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - -1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if A[node - 1] == B[node - 1]:",
      "mutated_line": "if A[node - 2] == B[node - 1]:",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 2] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if A[node - 1] == B[node - 1]:",
      "mutated_line": "if A[node - 0] == B[node - 1]:",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 0] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if A[node - 1] == B[node - 1]:",
      "mutated_line": "if A[node - 0] == B[node - 1]:",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 0] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if A[node - 1] == B[node - 1]:",
      "mutated_line": "if A[node - -1] == B[node - 1]:",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - -1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if A[node - 1] == B[node - 1]:",
      "mutated_line": "if A[node - 1] == B[node - 2]:",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 2]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if A[node - 1] == B[node - 1]:",
      "mutated_line": "if A[node - 1] == B[node - 0]:",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 0]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if A[node - 1] == B[node - 1]:",
      "mutated_line": "if A[node - 1] == B[node - 0]:",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 0]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if A[node - 1] == B[node - 1]:",
      "mutated_line": "if A[node - 1] == B[node - -1]:",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - -1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "tans += go(child, node, B[node - 1], True)",
      "mutated_line": "tans += go(child, node, B[node - 1], False)",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], False)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "tans += go(child, node, B[node - 1], True)",
      "mutated_line": "tans += go(child, node, B[node - 1], False)",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "tans += go(child, node, B[node - 1], True)",
      "mutated_line": "tans += go(child, node, B[node - 1], False)",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "tans += go(child, node, B[node - 1], False)",
      "mutated_line": "tans += go(child, node, B[node - 1], True)",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "tans += go(child, node, B[node - 1], True)",
      "mutated_line": "tans += go(child, node, B[node + 1], True)",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node + 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "tans += go(child, node, B[node - 1], True)",
      "mutated_line": "tans += go(child, node, B[node * 1], True)",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node * 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0",
      "mutated_line": "return 1 if swapped and c != B[node + 1] or (not swapped and A[node - 1] != B[node - 1]) else 0",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node + 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0",
      "mutated_line": "return 1 if swapped and c != B[node * 1] or (not swapped and A[node - 1] != B[node - 1]) else 0",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node * 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0",
      "mutated_line": "return 1 if swapped and c != B[node - 1] or (not swapped and A[node + 1] != B[node - 1]) else 0",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node + 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0",
      "mutated_line": "return 1 if swapped and c != B[node - 1] or (not swapped and A[node * 1] != B[node - 1]) else 0",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node * 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0",
      "mutated_line": "return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node + 1]) else 0",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node + 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0",
      "mutated_line": "return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node * 1]) else 0",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node * 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "tans += go(child, node, B[node - 1], True)",
      "mutated_line": "tans += go(child, node, B[node + 1], True)",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node + 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "tans += go(child, node, B[node - 1], True)",
      "mutated_line": "tans += go(child, node, B[node * 1], True)",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node * 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "tans += go(child, node, B[node - 1], True)",
      "mutated_line": "tans += go(child, node, B[node + 1], True)",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node + 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "tans += go(child, node, B[node - 1], True)",
      "mutated_line": "tans += go(child, node, B[node * 1], True)",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node * 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "tans += go(child, node, B[node - 1], False)",
      "mutated_line": "tans += go(child, node, B[node + 1], False)",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node + 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "tans += go(child, node, B[node - 1], False)",
      "mutated_line": "tans += go(child, node, B[node * 1], False)",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node * 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "tans += go(child, node, B[node - 1], True)",
      "mutated_line": "tans += go(child, node, B[node - 2], True)",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 2], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "tans += go(child, node, B[node - 1], True)",
      "mutated_line": "tans += go(child, node, B[node - 0], True)",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 0], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "tans += go(child, node, B[node - 1], True)",
      "mutated_line": "tans += go(child, node, B[node - 0], True)",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 0], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "tans += go(child, node, B[node - 1], True)",
      "mutated_line": "tans += go(child, node, B[node - -1], True)",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - -1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0",
      "mutated_line": "return 1 if swapped and c != B[node - 2] or (not swapped and A[node - 1] != B[node - 1]) else 0",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 2] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0",
      "mutated_line": "return 1 if swapped and c != B[node - 0] or (not swapped and A[node - 1] != B[node - 1]) else 0",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 0] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0",
      "mutated_line": "return 1 if swapped and c != B[node - 0] or (not swapped and A[node - 1] != B[node - 1]) else 0",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 0] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0",
      "mutated_line": "return 1 if swapped and c != B[node - -1] or (not swapped and A[node - 1] != B[node - 1]) else 0",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - -1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0",
      "mutated_line": "return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 2] != B[node - 1]) else 0",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 2] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0",
      "mutated_line": "return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 0] != B[node - 1]) else 0",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 0] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0",
      "mutated_line": "return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 0] != B[node - 1]) else 0",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 0] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0",
      "mutated_line": "return 1 if swapped and c != B[node - 1] or (not swapped and A[node - -1] != B[node - 1]) else 0",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - -1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0",
      "mutated_line": "return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 2]) else 0",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 2]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0",
      "mutated_line": "return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 0]) else 0",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 0]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0",
      "mutated_line": "return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 0]) else 0",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 0]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0",
      "mutated_line": "return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - -1]) else 0",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - -1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "tans += go(child, node, B[node - 1], True)",
      "mutated_line": "tans += go(child, node, B[node - 2], True)",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 2], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "tans += go(child, node, B[node - 1], True)",
      "mutated_line": "tans += go(child, node, B[node - 0], True)",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 0], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "tans += go(child, node, B[node - 1], True)",
      "mutated_line": "tans += go(child, node, B[node - 0], True)",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 0], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "tans += go(child, node, B[node - 1], True)",
      "mutated_line": "tans += go(child, node, B[node - -1], True)",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - -1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "tans += go(child, node, B[node - 1], True)",
      "mutated_line": "tans += go(child, node, B[node - 2], True)",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 2], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "tans += go(child, node, B[node - 1], True)",
      "mutated_line": "tans += go(child, node, B[node - 0], True)",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 0], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "tans += go(child, node, B[node - 1], True)",
      "mutated_line": "tans += go(child, node, B[node - 0], True)",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 0], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "tans += go(child, node, B[node - 1], True)",
      "mutated_line": "tans += go(child, node, B[node - -1], True)",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - -1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "tans += go(child, node, B[node - 1], False)",
      "mutated_line": "tans += go(child, node, B[node - 2], False)",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 2], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "tans += go(child, node, B[node - 1], False)",
      "mutated_line": "tans += go(child, node, B[node - 0], False)",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 0], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "tans += go(child, node, B[node - 1], False)",
      "mutated_line": "tans += go(child, node, B[node - 0], False)",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 0], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "tans += go(child, node, B[node - 1], False)",
      "mutated_line": "tans += go(child, node, B[node - -1], False)",
      "code": "from math import inf\nfrom collections import defaultdict\nfrom functools import lru_cache\n\ndef min_operations_to_recolor_tree(N, A, B, edges):\n    d = defaultdict(list)\n    for (u, v) in edges:\n        d[u].append(v)\n        d[v].append(u)\n\n    @lru_cache(None)\n    def go(node, parent, c, swapped):\n        if len(d[node]) == 1 and node != 1:\n            return 1 if swapped and c != B[node - 1] or (not swapped and A[node - 1] != B[node - 1]) else 0\n        ans = inf\n        if swapped:\n            if c != B[node - 1]:\n                tans = 1\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n            else:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - 1], True)\n                if tans < ans:\n                    ans = tans\n        else:\n            if A[node - 1] == B[node - 1]:\n                tans = 0\n                for child in d[node]:\n                    if child != parent:\n                        tans += go(child, node, B[node - -1], False)\n                if tans < ans:\n                    ans = tans\n            tans = 1\n            for child in d[node]:\n                if child != parent:\n                    tans += go(child, node, B[node - 1], True)\n            if tans < ans:\n                ans = tans\n        return ans\n    return go(1, None, A[0], False)"
    }
  ]
}