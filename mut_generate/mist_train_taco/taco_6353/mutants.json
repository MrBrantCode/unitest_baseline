{
  "task_id": "taco_6353",
  "entry_point": "find_minimal_time_for_ants",
  "mutant_count": 98,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "tree = [0] * n",
      "mutated_line": "tree = [0] / n",
      "code": "def find_minimal_time_for_ants(n, edges):\n    graph = [[] for _ in range(n)]\n    tree = [0] / n\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n        tree[u - 1] += 1\n        tree[v - 1] += 1\n    ans = 0\n    for x in graph[0]:\n        depth = []\n        stack = [(x, 0, 1)]\n        while stack:\n            (v, par, d) = stack.pop()\n            if tree[v] == 1:\n                depth.append(d)\n            else:\n                for dest in graph[v]:\n                    if dest != par:\n                        stack.append((dest, v, d + 1))\n        depth.sort()\n        for i in range(1, len(depth)):\n            depth[i] = max(depth[i], depth[i - 1] + 1)\n        ans = max(ans, depth[-1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "tree = [0] * n",
      "mutated_line": "tree = [0] + n",
      "code": "def find_minimal_time_for_ants(n, edges):\n    graph = [[] for _ in range(n)]\n    tree = [0] + n\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n        tree[u - 1] += 1\n        tree[v - 1] += 1\n    ans = 0\n    for x in graph[0]:\n        depth = []\n        stack = [(x, 0, 1)]\n        while stack:\n            (v, par, d) = stack.pop()\n            if tree[v] == 1:\n                depth.append(d)\n            else:\n                for dest in graph[v]:\n                    if dest != par:\n                        stack.append((dest, v, d + 1))\n        depth.sort()\n        for i in range(1, len(depth)):\n            depth[i] = max(depth[i], depth[i - 1] + 1)\n        ans = max(ans, depth[-1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "tree = [0] * n",
      "mutated_line": "tree = [0] ** n",
      "code": "def find_minimal_time_for_ants(n, edges):\n    graph = [[] for _ in range(n)]\n    tree = [0] ** n\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n        tree[u - 1] += 1\n        tree[v - 1] += 1\n    ans = 0\n    for x in graph[0]:\n        depth = []\n        stack = [(x, 0, 1)]\n        while stack:\n            (v, par, d) = stack.pop()\n            if tree[v] == 1:\n                depth.append(d)\n            else:\n                for dest in graph[v]:\n                    if dest != par:\n                        stack.append((dest, v, d + 1))\n        depth.sort()\n        for i in range(1, len(depth)):\n            depth[i] = max(depth[i], depth[i - 1] + 1)\n        ans = max(ans, depth[-1])\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 9,
      "original_line": "tree[u - 1] += 1",
      "mutated_line": "tree[u - 1] -= 1",
      "code": "def find_minimal_time_for_ants(n, edges):\n    graph = [[] for _ in range(n)]\n    tree = [0] * n\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n        tree[u - 1] -= 1\n        tree[v - 1] += 1\n    ans = 0\n    for x in graph[0]:\n        depth = []\n        stack = [(x, 0, 1)]\n        while stack:\n            (v, par, d) = stack.pop()\n            if tree[v] == 1:\n                depth.append(d)\n            else:\n                for dest in graph[v]:\n                    if dest != par:\n                        stack.append((dest, v, d + 1))\n        depth.sort()\n        for i in range(1, len(depth)):\n            depth[i] = max(depth[i], depth[i - 1] + 1)\n        ans = max(ans, depth[-1])\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 10,
      "original_line": "tree[v - 1] += 1",
      "mutated_line": "tree[v - 1] -= 1",
      "code": "def find_minimal_time_for_ants(n, edges):\n    graph = [[] for _ in range(n)]\n    tree = [0] * n\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n        tree[u - 1] += 1\n        tree[v - 1] -= 1\n    ans = 0\n    for x in graph[0]:\n        depth = []\n        stack = [(x, 0, 1)]\n        while stack:\n            (v, par, d) = stack.pop()\n            if tree[v] == 1:\n                depth.append(d)\n            else:\n                for dest in graph[v]:\n                    if dest != par:\n                        stack.append((dest, v, d + 1))\n        depth.sort()\n        for i in range(1, len(depth)):\n            depth[i] = max(depth[i], depth[i - 1] + 1)\n        ans = max(ans, depth[-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def find_minimal_time_for_ants(n, edges):\n    graph = [[] for _ in range(n)]\n    tree = [0] * n\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n        tree[u - 1] += 1\n        tree[v - 1] += 1\n    ans = 1\n    for x in graph[0]:\n        depth = []\n        stack = [(x, 0, 1)]\n        while stack:\n            (v, par, d) = stack.pop()\n            if tree[v] == 1:\n                depth.append(d)\n            else:\n                for dest in graph[v]:\n                    if dest != par:\n                        stack.append((dest, v, d + 1))\n        depth.sort()\n        for i in range(1, len(depth)):\n            depth[i] = max(depth[i], depth[i - 1] + 1)\n        ans = max(ans, depth[-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "ans = 0",
      "mutated_line": "ans = -1",
      "code": "def find_minimal_time_for_ants(n, edges):\n    graph = [[] for _ in range(n)]\n    tree = [0] * n\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n        tree[u - 1] += 1\n        tree[v - 1] += 1\n    ans = -1\n    for x in graph[0]:\n        depth = []\n        stack = [(x, 0, 1)]\n        while stack:\n            (v, par, d) = stack.pop()\n            if tree[v] == 1:\n                depth.append(d)\n            else:\n                for dest in graph[v]:\n                    if dest != par:\n                        stack.append((dest, v, d + 1))\n        depth.sort()\n        for i in range(1, len(depth)):\n            depth[i] = max(depth[i], depth[i - 1] + 1)\n        ans = max(ans, depth[-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def find_minimal_time_for_ants(n, edges):\n    graph = [[] for _ in range(n)]\n    tree = [0] * n\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n        tree[u - 1] += 1\n        tree[v - 1] += 1\n    ans = 1\n    for x in graph[0]:\n        depth = []\n        stack = [(x, 0, 1)]\n        while stack:\n            (v, par, d) = stack.pop()\n            if tree[v] == 1:\n                depth.append(d)\n            else:\n                for dest in graph[v]:\n                    if dest != par:\n                        stack.append((dest, v, d + 1))\n        depth.sort()\n        for i in range(1, len(depth)):\n            depth[i] = max(depth[i], depth[i - 1] + 1)\n        ans = max(ans, depth[-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "tree[u - 1] += 1",
      "mutated_line": "tree[u - 1] += 2",
      "code": "def find_minimal_time_for_ants(n, edges):\n    graph = [[] for _ in range(n)]\n    tree = [0] * n\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n        tree[u - 1] += 2\n        tree[v - 1] += 1\n    ans = 0\n    for x in graph[0]:\n        depth = []\n        stack = [(x, 0, 1)]\n        while stack:\n            (v, par, d) = stack.pop()\n            if tree[v] == 1:\n                depth.append(d)\n            else:\n                for dest in graph[v]:\n                    if dest != par:\n                        stack.append((dest, v, d + 1))\n        depth.sort()\n        for i in range(1, len(depth)):\n            depth[i] = max(depth[i], depth[i - 1] + 1)\n        ans = max(ans, depth[-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "tree[u - 1] += 1",
      "mutated_line": "tree[u - 1] += 0",
      "code": "def find_minimal_time_for_ants(n, edges):\n    graph = [[] for _ in range(n)]\n    tree = [0] * n\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n        tree[u - 1] += 0\n        tree[v - 1] += 1\n    ans = 0\n    for x in graph[0]:\n        depth = []\n        stack = [(x, 0, 1)]\n        while stack:\n            (v, par, d) = stack.pop()\n            if tree[v] == 1:\n                depth.append(d)\n            else:\n                for dest in graph[v]:\n                    if dest != par:\n                        stack.append((dest, v, d + 1))\n        depth.sort()\n        for i in range(1, len(depth)):\n            depth[i] = max(depth[i], depth[i - 1] + 1)\n        ans = max(ans, depth[-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "tree[u - 1] += 1",
      "mutated_line": "tree[u - 1] += 0",
      "code": "def find_minimal_time_for_ants(n, edges):\n    graph = [[] for _ in range(n)]\n    tree = [0] * n\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n        tree[u - 1] += 0\n        tree[v - 1] += 1\n    ans = 0\n    for x in graph[0]:\n        depth = []\n        stack = [(x, 0, 1)]\n        while stack:\n            (v, par, d) = stack.pop()\n            if tree[v] == 1:\n                depth.append(d)\n            else:\n                for dest in graph[v]:\n                    if dest != par:\n                        stack.append((dest, v, d + 1))\n        depth.sort()\n        for i in range(1, len(depth)):\n            depth[i] = max(depth[i], depth[i - 1] + 1)\n        ans = max(ans, depth[-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "tree[u - 1] += 1",
      "mutated_line": "tree[u - 1] += -1",
      "code": "def find_minimal_time_for_ants(n, edges):\n    graph = [[] for _ in range(n)]\n    tree = [0] * n\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n        tree[u - 1] += -1\n        tree[v - 1] += 1\n    ans = 0\n    for x in graph[0]:\n        depth = []\n        stack = [(x, 0, 1)]\n        while stack:\n            (v, par, d) = stack.pop()\n            if tree[v] == 1:\n                depth.append(d)\n            else:\n                for dest in graph[v]:\n                    if dest != par:\n                        stack.append((dest, v, d + 1))\n        depth.sort()\n        for i in range(1, len(depth)):\n            depth[i] = max(depth[i], depth[i - 1] + 1)\n        ans = max(ans, depth[-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "tree[v - 1] += 1",
      "mutated_line": "tree[v - 1] += 2",
      "code": "def find_minimal_time_for_ants(n, edges):\n    graph = [[] for _ in range(n)]\n    tree = [0] * n\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n        tree[u - 1] += 1\n        tree[v - 1] += 2\n    ans = 0\n    for x in graph[0]:\n        depth = []\n        stack = [(x, 0, 1)]\n        while stack:\n            (v, par, d) = stack.pop()\n            if tree[v] == 1:\n                depth.append(d)\n            else:\n                for dest in graph[v]:\n                    if dest != par:\n                        stack.append((dest, v, d + 1))\n        depth.sort()\n        for i in range(1, len(depth)):\n            depth[i] = max(depth[i], depth[i - 1] + 1)\n        ans = max(ans, depth[-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "tree[v - 1] += 1",
      "mutated_line": "tree[v - 1] += 0",
      "code": "def find_minimal_time_for_ants(n, edges):\n    graph = [[] for _ in range(n)]\n    tree = [0] * n\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n        tree[u - 1] += 1\n        tree[v - 1] += 0\n    ans = 0\n    for x in graph[0]:\n        depth = []\n        stack = [(x, 0, 1)]\n        while stack:\n            (v, par, d) = stack.pop()\n            if tree[v] == 1:\n                depth.append(d)\n            else:\n                for dest in graph[v]:\n                    if dest != par:\n                        stack.append((dest, v, d + 1))\n        depth.sort()\n        for i in range(1, len(depth)):\n            depth[i] = max(depth[i], depth[i - 1] + 1)\n        ans = max(ans, depth[-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "tree[v - 1] += 1",
      "mutated_line": "tree[v - 1] += 0",
      "code": "def find_minimal_time_for_ants(n, edges):\n    graph = [[] for _ in range(n)]\n    tree = [0] * n\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n        tree[u - 1] += 1\n        tree[v - 1] += 0\n    ans = 0\n    for x in graph[0]:\n        depth = []\n        stack = [(x, 0, 1)]\n        while stack:\n            (v, par, d) = stack.pop()\n            if tree[v] == 1:\n                depth.append(d)\n            else:\n                for dest in graph[v]:\n                    if dest != par:\n                        stack.append((dest, v, d + 1))\n        depth.sort()\n        for i in range(1, len(depth)):\n            depth[i] = max(depth[i], depth[i - 1] + 1)\n        ans = max(ans, depth[-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "tree[v - 1] += 1",
      "mutated_line": "tree[v - 1] += -1",
      "code": "def find_minimal_time_for_ants(n, edges):\n    graph = [[] for _ in range(n)]\n    tree = [0] * n\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n        tree[u - 1] += 1\n        tree[v - 1] += -1\n    ans = 0\n    for x in graph[0]:\n        depth = []\n        stack = [(x, 0, 1)]\n        while stack:\n            (v, par, d) = stack.pop()\n            if tree[v] == 1:\n                depth.append(d)\n            else:\n                for dest in graph[v]:\n                    if dest != par:\n                        stack.append((dest, v, d + 1))\n        depth.sort()\n        for i in range(1, len(depth)):\n            depth[i] = max(depth[i], depth[i - 1] + 1)\n        ans = max(ans, depth[-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for x in graph[0]:",
      "mutated_line": "for x in graph[1]:",
      "code": "def find_minimal_time_for_ants(n, edges):\n    graph = [[] for _ in range(n)]\n    tree = [0] * n\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n        tree[u - 1] += 1\n        tree[v - 1] += 1\n    ans = 0\n    for x in graph[1]:\n        depth = []\n        stack = [(x, 0, 1)]\n        while stack:\n            (v, par, d) = stack.pop()\n            if tree[v] == 1:\n                depth.append(d)\n            else:\n                for dest in graph[v]:\n                    if dest != par:\n                        stack.append((dest, v, d + 1))\n        depth.sort()\n        for i in range(1, len(depth)):\n            depth[i] = max(depth[i], depth[i - 1] + 1)\n        ans = max(ans, depth[-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for x in graph[0]:",
      "mutated_line": "for x in graph[-1]:",
      "code": "def find_minimal_time_for_ants(n, edges):\n    graph = [[] for _ in range(n)]\n    tree = [0] * n\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n        tree[u - 1] += 1\n        tree[v - 1] += 1\n    ans = 0\n    for x in graph[-1]:\n        depth = []\n        stack = [(x, 0, 1)]\n        while stack:\n            (v, par, d) = stack.pop()\n            if tree[v] == 1:\n                depth.append(d)\n            else:\n                for dest in graph[v]:\n                    if dest != par:\n                        stack.append((dest, v, d + 1))\n        depth.sort()\n        for i in range(1, len(depth)):\n            depth[i] = max(depth[i], depth[i - 1] + 1)\n        ans = max(ans, depth[-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for x in graph[0]:",
      "mutated_line": "for x in graph[1]:",
      "code": "def find_minimal_time_for_ants(n, edges):\n    graph = [[] for _ in range(n)]\n    tree = [0] * n\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n        tree[u - 1] += 1\n        tree[v - 1] += 1\n    ans = 0\n    for x in graph[1]:\n        depth = []\n        stack = [(x, 0, 1)]\n        while stack:\n            (v, par, d) = stack.pop()\n            if tree[v] == 1:\n                depth.append(d)\n            else:\n                for dest in graph[v]:\n                    if dest != par:\n                        stack.append((dest, v, d + 1))\n        depth.sort()\n        for i in range(1, len(depth)):\n            depth[i] = max(depth[i], depth[i - 1] + 1)\n        ans = max(ans, depth[-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "tree = [0] * n",
      "mutated_line": "tree = [1] * n",
      "code": "def find_minimal_time_for_ants(n, edges):\n    graph = [[] for _ in range(n)]\n    tree = [1] * n\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n        tree[u - 1] += 1\n        tree[v - 1] += 1\n    ans = 0\n    for x in graph[0]:\n        depth = []\n        stack = [(x, 0, 1)]\n        while stack:\n            (v, par, d) = stack.pop()\n            if tree[v] == 1:\n                depth.append(d)\n            else:\n                for dest in graph[v]:\n                    if dest != par:\n                        stack.append((dest, v, d + 1))\n        depth.sort()\n        for i in range(1, len(depth)):\n            depth[i] = max(depth[i], depth[i - 1] + 1)\n        ans = max(ans, depth[-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "tree = [0] * n",
      "mutated_line": "tree = [-1] * n",
      "code": "def find_minimal_time_for_ants(n, edges):\n    graph = [[] for _ in range(n)]\n    tree = [-1] * n\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n        tree[u - 1] += 1\n        tree[v - 1] += 1\n    ans = 0\n    for x in graph[0]:\n        depth = []\n        stack = [(x, 0, 1)]\n        while stack:\n            (v, par, d) = stack.pop()\n            if tree[v] == 1:\n                depth.append(d)\n            else:\n                for dest in graph[v]:\n                    if dest != par:\n                        stack.append((dest, v, d + 1))\n        depth.sort()\n        for i in range(1, len(depth)):\n            depth[i] = max(depth[i], depth[i - 1] + 1)\n        ans = max(ans, depth[-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "tree = [0] * n",
      "mutated_line": "tree = [1] * n",
      "code": "def find_minimal_time_for_ants(n, edges):\n    graph = [[] for _ in range(n)]\n    tree = [1] * n\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n        tree[u - 1] += 1\n        tree[v - 1] += 1\n    ans = 0\n    for x in graph[0]:\n        depth = []\n        stack = [(x, 0, 1)]\n        while stack:\n            (v, par, d) = stack.pop()\n            if tree[v] == 1:\n                depth.append(d)\n            else:\n                for dest in graph[v]:\n                    if dest != par:\n                        stack.append((dest, v, d + 1))\n        depth.sort()\n        for i in range(1, len(depth)):\n            depth[i] = max(depth[i], depth[i - 1] + 1)\n        ans = max(ans, depth[-1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "graph[u - 1].append(v - 1)",
      "mutated_line": "graph[u - 1].append(v + 1)",
      "code": "def find_minimal_time_for_ants(n, edges):\n    graph = [[] for _ in range(n)]\n    tree = [0] * n\n    for (u, v) in edges:\n        graph[u - 1].append(v + 1)\n        graph[v - 1].append(u - 1)\n        tree[u - 1] += 1\n        tree[v - 1] += 1\n    ans = 0\n    for x in graph[0]:\n        depth = []\n        stack = [(x, 0, 1)]\n        while stack:\n            (v, par, d) = stack.pop()\n            if tree[v] == 1:\n                depth.append(d)\n            else:\n                for dest in graph[v]:\n                    if dest != par:\n                        stack.append((dest, v, d + 1))\n        depth.sort()\n        for i in range(1, len(depth)):\n            depth[i] = max(depth[i], depth[i - 1] + 1)\n        ans = max(ans, depth[-1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "graph[u - 1].append(v - 1)",
      "mutated_line": "graph[u - 1].append(v * 1)",
      "code": "def find_minimal_time_for_ants(n, edges):\n    graph = [[] for _ in range(n)]\n    tree = [0] * n\n    for (u, v) in edges:\n        graph[u - 1].append(v * 1)\n        graph[v - 1].append(u - 1)\n        tree[u - 1] += 1\n        tree[v - 1] += 1\n    ans = 0\n    for x in graph[0]:\n        depth = []\n        stack = [(x, 0, 1)]\n        while stack:\n            (v, par, d) = stack.pop()\n            if tree[v] == 1:\n                depth.append(d)\n            else:\n                for dest in graph[v]:\n                    if dest != par:\n                        stack.append((dest, v, d + 1))\n        depth.sort()\n        for i in range(1, len(depth)):\n            depth[i] = max(depth[i], depth[i - 1] + 1)\n        ans = max(ans, depth[-1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "graph[v - 1].append(u - 1)",
      "mutated_line": "graph[v - 1].append(u + 1)",
      "code": "def find_minimal_time_for_ants(n, edges):\n    graph = [[] for _ in range(n)]\n    tree = [0] * n\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u + 1)\n        tree[u - 1] += 1\n        tree[v - 1] += 1\n    ans = 0\n    for x in graph[0]:\n        depth = []\n        stack = [(x, 0, 1)]\n        while stack:\n            (v, par, d) = stack.pop()\n            if tree[v] == 1:\n                depth.append(d)\n            else:\n                for dest in graph[v]:\n                    if dest != par:\n                        stack.append((dest, v, d + 1))\n        depth.sort()\n        for i in range(1, len(depth)):\n            depth[i] = max(depth[i], depth[i - 1] + 1)\n        ans = max(ans, depth[-1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "graph[v - 1].append(u - 1)",
      "mutated_line": "graph[v - 1].append(u * 1)",
      "code": "def find_minimal_time_for_ants(n, edges):\n    graph = [[] for _ in range(n)]\n    tree = [0] * n\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u * 1)\n        tree[u - 1] += 1\n        tree[v - 1] += 1\n    ans = 0\n    for x in graph[0]:\n        depth = []\n        stack = [(x, 0, 1)]\n        while stack:\n            (v, par, d) = stack.pop()\n            if tree[v] == 1:\n                depth.append(d)\n            else:\n                for dest in graph[v]:\n                    if dest != par:\n                        stack.append((dest, v, d + 1))\n        depth.sort()\n        for i in range(1, len(depth)):\n            depth[i] = max(depth[i], depth[i - 1] + 1)\n        ans = max(ans, depth[-1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "tree[u - 1] += 1",
      "mutated_line": "tree[u + 1] += 1",
      "code": "def find_minimal_time_for_ants(n, edges):\n    graph = [[] for _ in range(n)]\n    tree = [0] * n\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n        tree[u + 1] += 1\n        tree[v - 1] += 1\n    ans = 0\n    for x in graph[0]:\n        depth = []\n        stack = [(x, 0, 1)]\n        while stack:\n            (v, par, d) = stack.pop()\n            if tree[v] == 1:\n                depth.append(d)\n            else:\n                for dest in graph[v]:\n                    if dest != par:\n                        stack.append((dest, v, d + 1))\n        depth.sort()\n        for i in range(1, len(depth)):\n            depth[i] = max(depth[i], depth[i - 1] + 1)\n        ans = max(ans, depth[-1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "tree[u - 1] += 1",
      "mutated_line": "tree[u * 1] += 1",
      "code": "def find_minimal_time_for_ants(n, edges):\n    graph = [[] for _ in range(n)]\n    tree = [0] * n\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n        tree[u * 1] += 1\n        tree[v - 1] += 1\n    ans = 0\n    for x in graph[0]:\n        depth = []\n        stack = [(x, 0, 1)]\n        while stack:\n            (v, par, d) = stack.pop()\n            if tree[v] == 1:\n                depth.append(d)\n            else:\n                for dest in graph[v]:\n                    if dest != par:\n                        stack.append((dest, v, d + 1))\n        depth.sort()\n        for i in range(1, len(depth)):\n            depth[i] = max(depth[i], depth[i - 1] + 1)\n        ans = max(ans, depth[-1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "tree[v - 1] += 1",
      "mutated_line": "tree[v + 1] += 1",
      "code": "def find_minimal_time_for_ants(n, edges):\n    graph = [[] for _ in range(n)]\n    tree = [0] * n\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n        tree[u - 1] += 1\n        tree[v + 1] += 1\n    ans = 0\n    for x in graph[0]:\n        depth = []\n        stack = [(x, 0, 1)]\n        while stack:\n            (v, par, d) = stack.pop()\n            if tree[v] == 1:\n                depth.append(d)\n            else:\n                for dest in graph[v]:\n                    if dest != par:\n                        stack.append((dest, v, d + 1))\n        depth.sort()\n        for i in range(1, len(depth)):\n            depth[i] = max(depth[i], depth[i - 1] + 1)\n        ans = max(ans, depth[-1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "tree[v - 1] += 1",
      "mutated_line": "tree[v * 1] += 1",
      "code": "def find_minimal_time_for_ants(n, edges):\n    graph = [[] for _ in range(n)]\n    tree = [0] * n\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n        tree[u - 1] += 1\n        tree[v * 1] += 1\n    ans = 0\n    for x in graph[0]:\n        depth = []\n        stack = [(x, 0, 1)]\n        while stack:\n            (v, par, d) = stack.pop()\n            if tree[v] == 1:\n                depth.append(d)\n            else:\n                for dest in graph[v]:\n                    if dest != par:\n                        stack.append((dest, v, d + 1))\n        depth.sort()\n        for i in range(1, len(depth)):\n            depth[i] = max(depth[i], depth[i - 1] + 1)\n        ans = max(ans, depth[-1])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if tree[v] == 1:",
      "mutated_line": "if tree[v] != 1:",
      "code": "def find_minimal_time_for_ants(n, edges):\n    graph = [[] for _ in range(n)]\n    tree = [0] * n\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n        tree[u - 1] += 1\n        tree[v - 1] += 1\n    ans = 0\n    for x in graph[0]:\n        depth = []\n        stack = [(x, 0, 1)]\n        while stack:\n            (v, par, d) = stack.pop()\n            if tree[v] != 1:\n                depth.append(d)\n            else:\n                for dest in graph[v]:\n                    if dest != par:\n                        stack.append((dest, v, d + 1))\n        depth.sort()\n        for i in range(1, len(depth)):\n            depth[i] = max(depth[i], depth[i - 1] + 1)\n        ans = max(ans, depth[-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for i in range(1, len(depth)):",
      "mutated_line": "for i in range(2, len(depth)):",
      "code": "def find_minimal_time_for_ants(n, edges):\n    graph = [[] for _ in range(n)]\n    tree = [0] * n\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n        tree[u - 1] += 1\n        tree[v - 1] += 1\n    ans = 0\n    for x in graph[0]:\n        depth = []\n        stack = [(x, 0, 1)]\n        while stack:\n            (v, par, d) = stack.pop()\n            if tree[v] == 1:\n                depth.append(d)\n            else:\n                for dest in graph[v]:\n                    if dest != par:\n                        stack.append((dest, v, d + 1))\n        depth.sort()\n        for i in range(2, len(depth)):\n            depth[i] = max(depth[i], depth[i - 1] + 1)\n        ans = max(ans, depth[-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for i in range(1, len(depth)):",
      "mutated_line": "for i in range(0, len(depth)):",
      "code": "def find_minimal_time_for_ants(n, edges):\n    graph = [[] for _ in range(n)]\n    tree = [0] * n\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n        tree[u - 1] += 1\n        tree[v - 1] += 1\n    ans = 0\n    for x in graph[0]:\n        depth = []\n        stack = [(x, 0, 1)]\n        while stack:\n            (v, par, d) = stack.pop()\n            if tree[v] == 1:\n                depth.append(d)\n            else:\n                for dest in graph[v]:\n                    if dest != par:\n                        stack.append((dest, v, d + 1))\n        depth.sort()\n        for i in range(0, len(depth)):\n            depth[i] = max(depth[i], depth[i - 1] + 1)\n        ans = max(ans, depth[-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for i in range(1, len(depth)):",
      "mutated_line": "for i in range(0, len(depth)):",
      "code": "def find_minimal_time_for_ants(n, edges):\n    graph = [[] for _ in range(n)]\n    tree = [0] * n\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n        tree[u - 1] += 1\n        tree[v - 1] += 1\n    ans = 0\n    for x in graph[0]:\n        depth = []\n        stack = [(x, 0, 1)]\n        while stack:\n            (v, par, d) = stack.pop()\n            if tree[v] == 1:\n                depth.append(d)\n            else:\n                for dest in graph[v]:\n                    if dest != par:\n                        stack.append((dest, v, d + 1))\n        depth.sort()\n        for i in range(0, len(depth)):\n            depth[i] = max(depth[i], depth[i - 1] + 1)\n        ans = max(ans, depth[-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for i in range(1, len(depth)):",
      "mutated_line": "for i in range(-1, len(depth)):",
      "code": "def find_minimal_time_for_ants(n, edges):\n    graph = [[] for _ in range(n)]\n    tree = [0] * n\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n        tree[u - 1] += 1\n        tree[v - 1] += 1\n    ans = 0\n    for x in graph[0]:\n        depth = []\n        stack = [(x, 0, 1)]\n        while stack:\n            (v, par, d) = stack.pop()\n            if tree[v] == 1:\n                depth.append(d)\n            else:\n                for dest in graph[v]:\n                    if dest != par:\n                        stack.append((dest, v, d + 1))\n        depth.sort()\n        for i in range(-1, len(depth)):\n            depth[i] = max(depth[i], depth[i - 1] + 1)\n        ans = max(ans, depth[-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "graph[u - 1].append(v - 1)",
      "mutated_line": "graph[u - 1].append(v - 2)",
      "code": "def find_minimal_time_for_ants(n, edges):\n    graph = [[] for _ in range(n)]\n    tree = [0] * n\n    for (u, v) in edges:\n        graph[u - 1].append(v - 2)\n        graph[v - 1].append(u - 1)\n        tree[u - 1] += 1\n        tree[v - 1] += 1\n    ans = 0\n    for x in graph[0]:\n        depth = []\n        stack = [(x, 0, 1)]\n        while stack:\n            (v, par, d) = stack.pop()\n            if tree[v] == 1:\n                depth.append(d)\n            else:\n                for dest in graph[v]:\n                    if dest != par:\n                        stack.append((dest, v, d + 1))\n        depth.sort()\n        for i in range(1, len(depth)):\n            depth[i] = max(depth[i], depth[i - 1] + 1)\n        ans = max(ans, depth[-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "graph[u - 1].append(v - 1)",
      "mutated_line": "graph[u - 1].append(v - 0)",
      "code": "def find_minimal_time_for_ants(n, edges):\n    graph = [[] for _ in range(n)]\n    tree = [0] * n\n    for (u, v) in edges:\n        graph[u - 1].append(v - 0)\n        graph[v - 1].append(u - 1)\n        tree[u - 1] += 1\n        tree[v - 1] += 1\n    ans = 0\n    for x in graph[0]:\n        depth = []\n        stack = [(x, 0, 1)]\n        while stack:\n            (v, par, d) = stack.pop()\n            if tree[v] == 1:\n                depth.append(d)\n            else:\n                for dest in graph[v]:\n                    if dest != par:\n                        stack.append((dest, v, d + 1))\n        depth.sort()\n        for i in range(1, len(depth)):\n            depth[i] = max(depth[i], depth[i - 1] + 1)\n        ans = max(ans, depth[-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "graph[u - 1].append(v - 1)",
      "mutated_line": "graph[u - 1].append(v - 0)",
      "code": "def find_minimal_time_for_ants(n, edges):\n    graph = [[] for _ in range(n)]\n    tree = [0] * n\n    for (u, v) in edges:\n        graph[u - 1].append(v - 0)\n        graph[v - 1].append(u - 1)\n        tree[u - 1] += 1\n        tree[v - 1] += 1\n    ans = 0\n    for x in graph[0]:\n        depth = []\n        stack = [(x, 0, 1)]\n        while stack:\n            (v, par, d) = stack.pop()\n            if tree[v] == 1:\n                depth.append(d)\n            else:\n                for dest in graph[v]:\n                    if dest != par:\n                        stack.append((dest, v, d + 1))\n        depth.sort()\n        for i in range(1, len(depth)):\n            depth[i] = max(depth[i], depth[i - 1] + 1)\n        ans = max(ans, depth[-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "graph[u - 1].append(v - 1)",
      "mutated_line": "graph[u - 1].append(v - -1)",
      "code": "def find_minimal_time_for_ants(n, edges):\n    graph = [[] for _ in range(n)]\n    tree = [0] * n\n    for (u, v) in edges:\n        graph[u - 1].append(v - -1)\n        graph[v - 1].append(u - 1)\n        tree[u - 1] += 1\n        tree[v - 1] += 1\n    ans = 0\n    for x in graph[0]:\n        depth = []\n        stack = [(x, 0, 1)]\n        while stack:\n            (v, par, d) = stack.pop()\n            if tree[v] == 1:\n                depth.append(d)\n            else:\n                for dest in graph[v]:\n                    if dest != par:\n                        stack.append((dest, v, d + 1))\n        depth.sort()\n        for i in range(1, len(depth)):\n            depth[i] = max(depth[i], depth[i - 1] + 1)\n        ans = max(ans, depth[-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "graph[v - 1].append(u - 1)",
      "mutated_line": "graph[v - 1].append(u - 2)",
      "code": "def find_minimal_time_for_ants(n, edges):\n    graph = [[] for _ in range(n)]\n    tree = [0] * n\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 2)\n        tree[u - 1] += 1\n        tree[v - 1] += 1\n    ans = 0\n    for x in graph[0]:\n        depth = []\n        stack = [(x, 0, 1)]\n        while stack:\n            (v, par, d) = stack.pop()\n            if tree[v] == 1:\n                depth.append(d)\n            else:\n                for dest in graph[v]:\n                    if dest != par:\n                        stack.append((dest, v, d + 1))\n        depth.sort()\n        for i in range(1, len(depth)):\n            depth[i] = max(depth[i], depth[i - 1] + 1)\n        ans = max(ans, depth[-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "graph[v - 1].append(u - 1)",
      "mutated_line": "graph[v - 1].append(u - 0)",
      "code": "def find_minimal_time_for_ants(n, edges):\n    graph = [[] for _ in range(n)]\n    tree = [0] * n\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 0)\n        tree[u - 1] += 1\n        tree[v - 1] += 1\n    ans = 0\n    for x in graph[0]:\n        depth = []\n        stack = [(x, 0, 1)]\n        while stack:\n            (v, par, d) = stack.pop()\n            if tree[v] == 1:\n                depth.append(d)\n            else:\n                for dest in graph[v]:\n                    if dest != par:\n                        stack.append((dest, v, d + 1))\n        depth.sort()\n        for i in range(1, len(depth)):\n            depth[i] = max(depth[i], depth[i - 1] + 1)\n        ans = max(ans, depth[-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "graph[v - 1].append(u - 1)",
      "mutated_line": "graph[v - 1].append(u - 0)",
      "code": "def find_minimal_time_for_ants(n, edges):\n    graph = [[] for _ in range(n)]\n    tree = [0] * n\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 0)\n        tree[u - 1] += 1\n        tree[v - 1] += 1\n    ans = 0\n    for x in graph[0]:\n        depth = []\n        stack = [(x, 0, 1)]\n        while stack:\n            (v, par, d) = stack.pop()\n            if tree[v] == 1:\n                depth.append(d)\n            else:\n                for dest in graph[v]:\n                    if dest != par:\n                        stack.append((dest, v, d + 1))\n        depth.sort()\n        for i in range(1, len(depth)):\n            depth[i] = max(depth[i], depth[i - 1] + 1)\n        ans = max(ans, depth[-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "graph[v - 1].append(u - 1)",
      "mutated_line": "graph[v - 1].append(u - -1)",
      "code": "def find_minimal_time_for_ants(n, edges):\n    graph = [[] for _ in range(n)]\n    tree = [0] * n\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - -1)\n        tree[u - 1] += 1\n        tree[v - 1] += 1\n    ans = 0\n    for x in graph[0]:\n        depth = []\n        stack = [(x, 0, 1)]\n        while stack:\n            (v, par, d) = stack.pop()\n            if tree[v] == 1:\n                depth.append(d)\n            else:\n                for dest in graph[v]:\n                    if dest != par:\n                        stack.append((dest, v, d + 1))\n        depth.sort()\n        for i in range(1, len(depth)):\n            depth[i] = max(depth[i], depth[i - 1] + 1)\n        ans = max(ans, depth[-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "tree[u - 1] += 1",
      "mutated_line": "tree[u - 2] += 1",
      "code": "def find_minimal_time_for_ants(n, edges):\n    graph = [[] for _ in range(n)]\n    tree = [0] * n\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n        tree[u - 2] += 1\n        tree[v - 1] += 1\n    ans = 0\n    for x in graph[0]:\n        depth = []\n        stack = [(x, 0, 1)]\n        while stack:\n            (v, par, d) = stack.pop()\n            if tree[v] == 1:\n                depth.append(d)\n            else:\n                for dest in graph[v]:\n                    if dest != par:\n                        stack.append((dest, v, d + 1))\n        depth.sort()\n        for i in range(1, len(depth)):\n            depth[i] = max(depth[i], depth[i - 1] + 1)\n        ans = max(ans, depth[-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "tree[u - 1] += 1",
      "mutated_line": "tree[u - 0] += 1",
      "code": "def find_minimal_time_for_ants(n, edges):\n    graph = [[] for _ in range(n)]\n    tree = [0] * n\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n        tree[u - 0] += 1\n        tree[v - 1] += 1\n    ans = 0\n    for x in graph[0]:\n        depth = []\n        stack = [(x, 0, 1)]\n        while stack:\n            (v, par, d) = stack.pop()\n            if tree[v] == 1:\n                depth.append(d)\n            else:\n                for dest in graph[v]:\n                    if dest != par:\n                        stack.append((dest, v, d + 1))\n        depth.sort()\n        for i in range(1, len(depth)):\n            depth[i] = max(depth[i], depth[i - 1] + 1)\n        ans = max(ans, depth[-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "tree[u - 1] += 1",
      "mutated_line": "tree[u - 0] += 1",
      "code": "def find_minimal_time_for_ants(n, edges):\n    graph = [[] for _ in range(n)]\n    tree = [0] * n\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n        tree[u - 0] += 1\n        tree[v - 1] += 1\n    ans = 0\n    for x in graph[0]:\n        depth = []\n        stack = [(x, 0, 1)]\n        while stack:\n            (v, par, d) = stack.pop()\n            if tree[v] == 1:\n                depth.append(d)\n            else:\n                for dest in graph[v]:\n                    if dest != par:\n                        stack.append((dest, v, d + 1))\n        depth.sort()\n        for i in range(1, len(depth)):\n            depth[i] = max(depth[i], depth[i - 1] + 1)\n        ans = max(ans, depth[-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "tree[u - 1] += 1",
      "mutated_line": "tree[u - -1] += 1",
      "code": "def find_minimal_time_for_ants(n, edges):\n    graph = [[] for _ in range(n)]\n    tree = [0] * n\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n        tree[u - -1] += 1\n        tree[v - 1] += 1\n    ans = 0\n    for x in graph[0]:\n        depth = []\n        stack = [(x, 0, 1)]\n        while stack:\n            (v, par, d) = stack.pop()\n            if tree[v] == 1:\n                depth.append(d)\n            else:\n                for dest in graph[v]:\n                    if dest != par:\n                        stack.append((dest, v, d + 1))\n        depth.sort()\n        for i in range(1, len(depth)):\n            depth[i] = max(depth[i], depth[i - 1] + 1)\n        ans = max(ans, depth[-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "tree[v - 1] += 1",
      "mutated_line": "tree[v - 2] += 1",
      "code": "def find_minimal_time_for_ants(n, edges):\n    graph = [[] for _ in range(n)]\n    tree = [0] * n\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n        tree[u - 1] += 1\n        tree[v - 2] += 1\n    ans = 0\n    for x in graph[0]:\n        depth = []\n        stack = [(x, 0, 1)]\n        while stack:\n            (v, par, d) = stack.pop()\n            if tree[v] == 1:\n                depth.append(d)\n            else:\n                for dest in graph[v]:\n                    if dest != par:\n                        stack.append((dest, v, d + 1))\n        depth.sort()\n        for i in range(1, len(depth)):\n            depth[i] = max(depth[i], depth[i - 1] + 1)\n        ans = max(ans, depth[-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "tree[v - 1] += 1",
      "mutated_line": "tree[v - 0] += 1",
      "code": "def find_minimal_time_for_ants(n, edges):\n    graph = [[] for _ in range(n)]\n    tree = [0] * n\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n        tree[u - 1] += 1\n        tree[v - 0] += 1\n    ans = 0\n    for x in graph[0]:\n        depth = []\n        stack = [(x, 0, 1)]\n        while stack:\n            (v, par, d) = stack.pop()\n            if tree[v] == 1:\n                depth.append(d)\n            else:\n                for dest in graph[v]:\n                    if dest != par:\n                        stack.append((dest, v, d + 1))\n        depth.sort()\n        for i in range(1, len(depth)):\n            depth[i] = max(depth[i], depth[i - 1] + 1)\n        ans = max(ans, depth[-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "tree[v - 1] += 1",
      "mutated_line": "tree[v - 0] += 1",
      "code": "def find_minimal_time_for_ants(n, edges):\n    graph = [[] for _ in range(n)]\n    tree = [0] * n\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n        tree[u - 1] += 1\n        tree[v - 0] += 1\n    ans = 0\n    for x in graph[0]:\n        depth = []\n        stack = [(x, 0, 1)]\n        while stack:\n            (v, par, d) = stack.pop()\n            if tree[v] == 1:\n                depth.append(d)\n            else:\n                for dest in graph[v]:\n                    if dest != par:\n                        stack.append((dest, v, d + 1))\n        depth.sort()\n        for i in range(1, len(depth)):\n            depth[i] = max(depth[i], depth[i - 1] + 1)\n        ans = max(ans, depth[-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "tree[v - 1] += 1",
      "mutated_line": "tree[v - -1] += 1",
      "code": "def find_minimal_time_for_ants(n, edges):\n    graph = [[] for _ in range(n)]\n    tree = [0] * n\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n        tree[u - 1] += 1\n        tree[v - -1] += 1\n    ans = 0\n    for x in graph[0]:\n        depth = []\n        stack = [(x, 0, 1)]\n        while stack:\n            (v, par, d) = stack.pop()\n            if tree[v] == 1:\n                depth.append(d)\n            else:\n                for dest in graph[v]:\n                    if dest != par:\n                        stack.append((dest, v, d + 1))\n        depth.sort()\n        for i in range(1, len(depth)):\n            depth[i] = max(depth[i], depth[i - 1] + 1)\n        ans = max(ans, depth[-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "stack = [(x, 0, 1)]",
      "mutated_line": "stack = [(x, 1, 1)]",
      "code": "def find_minimal_time_for_ants(n, edges):\n    graph = [[] for _ in range(n)]\n    tree = [0] * n\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n        tree[u - 1] += 1\n        tree[v - 1] += 1\n    ans = 0\n    for x in graph[0]:\n        depth = []\n        stack = [(x, 1, 1)]\n        while stack:\n            (v, par, d) = stack.pop()\n            if tree[v] == 1:\n                depth.append(d)\n            else:\n                for dest in graph[v]:\n                    if dest != par:\n                        stack.append((dest, v, d + 1))\n        depth.sort()\n        for i in range(1, len(depth)):\n            depth[i] = max(depth[i], depth[i - 1] + 1)\n        ans = max(ans, depth[-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "stack = [(x, 0, 1)]",
      "mutated_line": "stack = [(x, -1, 1)]",
      "code": "def find_minimal_time_for_ants(n, edges):\n    graph = [[] for _ in range(n)]\n    tree = [0] * n\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n        tree[u - 1] += 1\n        tree[v - 1] += 1\n    ans = 0\n    for x in graph[0]:\n        depth = []\n        stack = [(x, -1, 1)]\n        while stack:\n            (v, par, d) = stack.pop()\n            if tree[v] == 1:\n                depth.append(d)\n            else:\n                for dest in graph[v]:\n                    if dest != par:\n                        stack.append((dest, v, d + 1))\n        depth.sort()\n        for i in range(1, len(depth)):\n            depth[i] = max(depth[i], depth[i - 1] + 1)\n        ans = max(ans, depth[-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "stack = [(x, 0, 1)]",
      "mutated_line": "stack = [(x, 1, 1)]",
      "code": "def find_minimal_time_for_ants(n, edges):\n    graph = [[] for _ in range(n)]\n    tree = [0] * n\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n        tree[u - 1] += 1\n        tree[v - 1] += 1\n    ans = 0\n    for x in graph[0]:\n        depth = []\n        stack = [(x, 1, 1)]\n        while stack:\n            (v, par, d) = stack.pop()\n            if tree[v] == 1:\n                depth.append(d)\n            else:\n                for dest in graph[v]:\n                    if dest != par:\n                        stack.append((dest, v, d + 1))\n        depth.sort()\n        for i in range(1, len(depth)):\n            depth[i] = max(depth[i], depth[i - 1] + 1)\n        ans = max(ans, depth[-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "stack = [(x, 0, 1)]",
      "mutated_line": "stack = [(x, 0, 2)]",
      "code": "def find_minimal_time_for_ants(n, edges):\n    graph = [[] for _ in range(n)]\n    tree = [0] * n\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n        tree[u - 1] += 1\n        tree[v - 1] += 1\n    ans = 0\n    for x in graph[0]:\n        depth = []\n        stack = [(x, 0, 2)]\n        while stack:\n            (v, par, d) = stack.pop()\n            if tree[v] == 1:\n                depth.append(d)\n            else:\n                for dest in graph[v]:\n                    if dest != par:\n                        stack.append((dest, v, d + 1))\n        depth.sort()\n        for i in range(1, len(depth)):\n            depth[i] = max(depth[i], depth[i - 1] + 1)\n        ans = max(ans, depth[-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "stack = [(x, 0, 1)]",
      "mutated_line": "stack = [(x, 0, 0)]",
      "code": "def find_minimal_time_for_ants(n, edges):\n    graph = [[] for _ in range(n)]\n    tree = [0] * n\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n        tree[u - 1] += 1\n        tree[v - 1] += 1\n    ans = 0\n    for x in graph[0]:\n        depth = []\n        stack = [(x, 0, 0)]\n        while stack:\n            (v, par, d) = stack.pop()\n            if tree[v] == 1:\n                depth.append(d)\n            else:\n                for dest in graph[v]:\n                    if dest != par:\n                        stack.append((dest, v, d + 1))\n        depth.sort()\n        for i in range(1, len(depth)):\n            depth[i] = max(depth[i], depth[i - 1] + 1)\n        ans = max(ans, depth[-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "stack = [(x, 0, 1)]",
      "mutated_line": "stack = [(x, 0, 0)]",
      "code": "def find_minimal_time_for_ants(n, edges):\n    graph = [[] for _ in range(n)]\n    tree = [0] * n\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n        tree[u - 1] += 1\n        tree[v - 1] += 1\n    ans = 0\n    for x in graph[0]:\n        depth = []\n        stack = [(x, 0, 0)]\n        while stack:\n            (v, par, d) = stack.pop()\n            if tree[v] == 1:\n                depth.append(d)\n            else:\n                for dest in graph[v]:\n                    if dest != par:\n                        stack.append((dest, v, d + 1))\n        depth.sort()\n        for i in range(1, len(depth)):\n            depth[i] = max(depth[i], depth[i - 1] + 1)\n        ans = max(ans, depth[-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "stack = [(x, 0, 1)]",
      "mutated_line": "stack = [(x, 0, -1)]",
      "code": "def find_minimal_time_for_ants(n, edges):\n    graph = [[] for _ in range(n)]\n    tree = [0] * n\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n        tree[u - 1] += 1\n        tree[v - 1] += 1\n    ans = 0\n    for x in graph[0]:\n        depth = []\n        stack = [(x, 0, -1)]\n        while stack:\n            (v, par, d) = stack.pop()\n            if tree[v] == 1:\n                depth.append(d)\n            else:\n                for dest in graph[v]:\n                    if dest != par:\n                        stack.append((dest, v, d + 1))\n        depth.sort()\n        for i in range(1, len(depth)):\n            depth[i] = max(depth[i], depth[i - 1] + 1)\n        ans = max(ans, depth[-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if tree[v] == 1:",
      "mutated_line": "if tree[v] == 2:",
      "code": "def find_minimal_time_for_ants(n, edges):\n    graph = [[] for _ in range(n)]\n    tree = [0] * n\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n        tree[u - 1] += 1\n        tree[v - 1] += 1\n    ans = 0\n    for x in graph[0]:\n        depth = []\n        stack = [(x, 0, 1)]\n        while stack:\n            (v, par, d) = stack.pop()\n            if tree[v] == 2:\n                depth.append(d)\n            else:\n                for dest in graph[v]:\n                    if dest != par:\n                        stack.append((dest, v, d + 1))\n        depth.sort()\n        for i in range(1, len(depth)):\n            depth[i] = max(depth[i], depth[i - 1] + 1)\n        ans = max(ans, depth[-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if tree[v] == 1:",
      "mutated_line": "if tree[v] == 0:",
      "code": "def find_minimal_time_for_ants(n, edges):\n    graph = [[] for _ in range(n)]\n    tree = [0] * n\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n        tree[u - 1] += 1\n        tree[v - 1] += 1\n    ans = 0\n    for x in graph[0]:\n        depth = []\n        stack = [(x, 0, 1)]\n        while stack:\n            (v, par, d) = stack.pop()\n            if tree[v] == 0:\n                depth.append(d)\n            else:\n                for dest in graph[v]:\n                    if dest != par:\n                        stack.append((dest, v, d + 1))\n        depth.sort()\n        for i in range(1, len(depth)):\n            depth[i] = max(depth[i], depth[i - 1] + 1)\n        ans = max(ans, depth[-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if tree[v] == 1:",
      "mutated_line": "if tree[v] == 0:",
      "code": "def find_minimal_time_for_ants(n, edges):\n    graph = [[] for _ in range(n)]\n    tree = [0] * n\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n        tree[u - 1] += 1\n        tree[v - 1] += 1\n    ans = 0\n    for x in graph[0]:\n        depth = []\n        stack = [(x, 0, 1)]\n        while stack:\n            (v, par, d) = stack.pop()\n            if tree[v] == 0:\n                depth.append(d)\n            else:\n                for dest in graph[v]:\n                    if dest != par:\n                        stack.append((dest, v, d + 1))\n        depth.sort()\n        for i in range(1, len(depth)):\n            depth[i] = max(depth[i], depth[i - 1] + 1)\n        ans = max(ans, depth[-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if tree[v] == 1:",
      "mutated_line": "if tree[v] == -1:",
      "code": "def find_minimal_time_for_ants(n, edges):\n    graph = [[] for _ in range(n)]\n    tree = [0] * n\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n        tree[u - 1] += 1\n        tree[v - 1] += 1\n    ans = 0\n    for x in graph[0]:\n        depth = []\n        stack = [(x, 0, 1)]\n        while stack:\n            (v, par, d) = stack.pop()\n            if tree[v] == -1:\n                depth.append(d)\n            else:\n                for dest in graph[v]:\n                    if dest != par:\n                        stack.append((dest, v, d + 1))\n        depth.sort()\n        for i in range(1, len(depth)):\n            depth[i] = max(depth[i], depth[i - 1] + 1)\n        ans = max(ans, depth[-1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "depth[i] = max(depth[i], depth[i - 1] + 1)",
      "mutated_line": "depth[i] = max(depth[i], depth[i - 1] - 1)",
      "code": "def find_minimal_time_for_ants(n, edges):\n    graph = [[] for _ in range(n)]\n    tree = [0] * n\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n        tree[u - 1] += 1\n        tree[v - 1] += 1\n    ans = 0\n    for x in graph[0]:\n        depth = []\n        stack = [(x, 0, 1)]\n        while stack:\n            (v, par, d) = stack.pop()\n            if tree[v] == 1:\n                depth.append(d)\n            else:\n                for dest in graph[v]:\n                    if dest != par:\n                        stack.append((dest, v, d + 1))\n        depth.sort()\n        for i in range(1, len(depth)):\n            depth[i] = max(depth[i], depth[i - 1] - 1)\n        ans = max(ans, depth[-1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "depth[i] = max(depth[i], depth[i - 1] + 1)",
      "mutated_line": "depth[i] = max(depth[i], depth[i - 1] * 1)",
      "code": "def find_minimal_time_for_ants(n, edges):\n    graph = [[] for _ in range(n)]\n    tree = [0] * n\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n        tree[u - 1] += 1\n        tree[v - 1] += 1\n    ans = 0\n    for x in graph[0]:\n        depth = []\n        stack = [(x, 0, 1)]\n        while stack:\n            (v, par, d) = stack.pop()\n            if tree[v] == 1:\n                depth.append(d)\n            else:\n                for dest in graph[v]:\n                    if dest != par:\n                        stack.append((dest, v, d + 1))\n        depth.sort()\n        for i in range(1, len(depth)):\n            depth[i] = max(depth[i], depth[i - 1] * 1)\n        ans = max(ans, depth[-1])\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 36,
      "original_line": "ans = max(ans, depth[-1])",
      "mutated_line": "ans = max(ans, depth[+1])",
      "code": "def find_minimal_time_for_ants(n, edges):\n    graph = [[] for _ in range(n)]\n    tree = [0] * n\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n        tree[u - 1] += 1\n        tree[v - 1] += 1\n    ans = 0\n    for x in graph[0]:\n        depth = []\n        stack = [(x, 0, 1)]\n        while stack:\n            (v, par, d) = stack.pop()\n            if tree[v] == 1:\n                depth.append(d)\n            else:\n                for dest in graph[v]:\n                    if dest != par:\n                        stack.append((dest, v, d + 1))\n        depth.sort()\n        for i in range(1, len(depth)):\n            depth[i] = max(depth[i], depth[i - 1] + 1)\n        ans = max(ans, depth[+1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "graph[u - 1].append(v - 1)",
      "mutated_line": "graph[u + 1].append(v - 1)",
      "code": "def find_minimal_time_for_ants(n, edges):\n    graph = [[] for _ in range(n)]\n    tree = [0] * n\n    for (u, v) in edges:\n        graph[u + 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n        tree[u - 1] += 1\n        tree[v - 1] += 1\n    ans = 0\n    for x in graph[0]:\n        depth = []\n        stack = [(x, 0, 1)]\n        while stack:\n            (v, par, d) = stack.pop()\n            if tree[v] == 1:\n                depth.append(d)\n            else:\n                for dest in graph[v]:\n                    if dest != par:\n                        stack.append((dest, v, d + 1))\n        depth.sort()\n        for i in range(1, len(depth)):\n            depth[i] = max(depth[i], depth[i - 1] + 1)\n        ans = max(ans, depth[-1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "graph[u - 1].append(v - 1)",
      "mutated_line": "graph[u * 1].append(v - 1)",
      "code": "def find_minimal_time_for_ants(n, edges):\n    graph = [[] for _ in range(n)]\n    tree = [0] * n\n    for (u, v) in edges:\n        graph[u * 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n        tree[u - 1] += 1\n        tree[v - 1] += 1\n    ans = 0\n    for x in graph[0]:\n        depth = []\n        stack = [(x, 0, 1)]\n        while stack:\n            (v, par, d) = stack.pop()\n            if tree[v] == 1:\n                depth.append(d)\n            else:\n                for dest in graph[v]:\n                    if dest != par:\n                        stack.append((dest, v, d + 1))\n        depth.sort()\n        for i in range(1, len(depth)):\n            depth[i] = max(depth[i], depth[i - 1] + 1)\n        ans = max(ans, depth[-1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "graph[v - 1].append(u - 1)",
      "mutated_line": "graph[v + 1].append(u - 1)",
      "code": "def find_minimal_time_for_ants(n, edges):\n    graph = [[] for _ in range(n)]\n    tree = [0] * n\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v + 1].append(u - 1)\n        tree[u - 1] += 1\n        tree[v - 1] += 1\n    ans = 0\n    for x in graph[0]:\n        depth = []\n        stack = [(x, 0, 1)]\n        while stack:\n            (v, par, d) = stack.pop()\n            if tree[v] == 1:\n                depth.append(d)\n            else:\n                for dest in graph[v]:\n                    if dest != par:\n                        stack.append((dest, v, d + 1))\n        depth.sort()\n        for i in range(1, len(depth)):\n            depth[i] = max(depth[i], depth[i - 1] + 1)\n        ans = max(ans, depth[-1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "graph[v - 1].append(u - 1)",
      "mutated_line": "graph[v * 1].append(u - 1)",
      "code": "def find_minimal_time_for_ants(n, edges):\n    graph = [[] for _ in range(n)]\n    tree = [0] * n\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v * 1].append(u - 1)\n        tree[u - 1] += 1\n        tree[v - 1] += 1\n    ans = 0\n    for x in graph[0]:\n        depth = []\n        stack = [(x, 0, 1)]\n        while stack:\n            (v, par, d) = stack.pop()\n            if tree[v] == 1:\n                depth.append(d)\n            else:\n                for dest in graph[v]:\n                    if dest != par:\n                        stack.append((dest, v, d + 1))\n        depth.sort()\n        for i in range(1, len(depth)):\n            depth[i] = max(depth[i], depth[i - 1] + 1)\n        ans = max(ans, depth[-1])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if dest != par:",
      "mutated_line": "if dest == par:",
      "code": "def find_minimal_time_for_ants(n, edges):\n    graph = [[] for _ in range(n)]\n    tree = [0] * n\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n        tree[u - 1] += 1\n        tree[v - 1] += 1\n    ans = 0\n    for x in graph[0]:\n        depth = []\n        stack = [(x, 0, 1)]\n        while stack:\n            (v, par, d) = stack.pop()\n            if tree[v] == 1:\n                depth.append(d)\n            else:\n                for dest in graph[v]:\n                    if dest == par:\n                        stack.append((dest, v, d + 1))\n        depth.sort()\n        for i in range(1, len(depth)):\n            depth[i] = max(depth[i], depth[i - 1] + 1)\n        ans = max(ans, depth[-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "depth[i] = max(depth[i], depth[i - 1] + 1)",
      "mutated_line": "depth[i] = max(depth[i], depth[i - 1] + 2)",
      "code": "def find_minimal_time_for_ants(n, edges):\n    graph = [[] for _ in range(n)]\n    tree = [0] * n\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n        tree[u - 1] += 1\n        tree[v - 1] += 1\n    ans = 0\n    for x in graph[0]:\n        depth = []\n        stack = [(x, 0, 1)]\n        while stack:\n            (v, par, d) = stack.pop()\n            if tree[v] == 1:\n                depth.append(d)\n            else:\n                for dest in graph[v]:\n                    if dest != par:\n                        stack.append((dest, v, d + 1))\n        depth.sort()\n        for i in range(1, len(depth)):\n            depth[i] = max(depth[i], depth[i - 1] + 2)\n        ans = max(ans, depth[-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "depth[i] = max(depth[i], depth[i - 1] + 1)",
      "mutated_line": "depth[i] = max(depth[i], depth[i - 1] + 0)",
      "code": "def find_minimal_time_for_ants(n, edges):\n    graph = [[] for _ in range(n)]\n    tree = [0] * n\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n        tree[u - 1] += 1\n        tree[v - 1] += 1\n    ans = 0\n    for x in graph[0]:\n        depth = []\n        stack = [(x, 0, 1)]\n        while stack:\n            (v, par, d) = stack.pop()\n            if tree[v] == 1:\n                depth.append(d)\n            else:\n                for dest in graph[v]:\n                    if dest != par:\n                        stack.append((dest, v, d + 1))\n        depth.sort()\n        for i in range(1, len(depth)):\n            depth[i] = max(depth[i], depth[i - 1] + 0)\n        ans = max(ans, depth[-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "depth[i] = max(depth[i], depth[i - 1] + 1)",
      "mutated_line": "depth[i] = max(depth[i], depth[i - 1] + 0)",
      "code": "def find_minimal_time_for_ants(n, edges):\n    graph = [[] for _ in range(n)]\n    tree = [0] * n\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n        tree[u - 1] += 1\n        tree[v - 1] += 1\n    ans = 0\n    for x in graph[0]:\n        depth = []\n        stack = [(x, 0, 1)]\n        while stack:\n            (v, par, d) = stack.pop()\n            if tree[v] == 1:\n                depth.append(d)\n            else:\n                for dest in graph[v]:\n                    if dest != par:\n                        stack.append((dest, v, d + 1))\n        depth.sort()\n        for i in range(1, len(depth)):\n            depth[i] = max(depth[i], depth[i - 1] + 0)\n        ans = max(ans, depth[-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "depth[i] = max(depth[i], depth[i - 1] + 1)",
      "mutated_line": "depth[i] = max(depth[i], depth[i - 1] + -1)",
      "code": "def find_minimal_time_for_ants(n, edges):\n    graph = [[] for _ in range(n)]\n    tree = [0] * n\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n        tree[u - 1] += 1\n        tree[v - 1] += 1\n    ans = 0\n    for x in graph[0]:\n        depth = []\n        stack = [(x, 0, 1)]\n        while stack:\n            (v, par, d) = stack.pop()\n            if tree[v] == 1:\n                depth.append(d)\n            else:\n                for dest in graph[v]:\n                    if dest != par:\n                        stack.append((dest, v, d + 1))\n        depth.sort()\n        for i in range(1, len(depth)):\n            depth[i] = max(depth[i], depth[i - 1] + -1)\n        ans = max(ans, depth[-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ans = max(ans, depth[-1])",
      "mutated_line": "ans = max(ans, depth[-2])",
      "code": "def find_minimal_time_for_ants(n, edges):\n    graph = [[] for _ in range(n)]\n    tree = [0] * n\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n        tree[u - 1] += 1\n        tree[v - 1] += 1\n    ans = 0\n    for x in graph[0]:\n        depth = []\n        stack = [(x, 0, 1)]\n        while stack:\n            (v, par, d) = stack.pop()\n            if tree[v] == 1:\n                depth.append(d)\n            else:\n                for dest in graph[v]:\n                    if dest != par:\n                        stack.append((dest, v, d + 1))\n        depth.sort()\n        for i in range(1, len(depth)):\n            depth[i] = max(depth[i], depth[i - 1] + 1)\n        ans = max(ans, depth[-2])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ans = max(ans, depth[-1])",
      "mutated_line": "ans = max(ans, depth[-0])",
      "code": "def find_minimal_time_for_ants(n, edges):\n    graph = [[] for _ in range(n)]\n    tree = [0] * n\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n        tree[u - 1] += 1\n        tree[v - 1] += 1\n    ans = 0\n    for x in graph[0]:\n        depth = []\n        stack = [(x, 0, 1)]\n        while stack:\n            (v, par, d) = stack.pop()\n            if tree[v] == 1:\n                depth.append(d)\n            else:\n                for dest in graph[v]:\n                    if dest != par:\n                        stack.append((dest, v, d + 1))\n        depth.sort()\n        for i in range(1, len(depth)):\n            depth[i] = max(depth[i], depth[i - 1] + 1)\n        ans = max(ans, depth[-0])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ans = max(ans, depth[-1])",
      "mutated_line": "ans = max(ans, depth[-0])",
      "code": "def find_minimal_time_for_ants(n, edges):\n    graph = [[] for _ in range(n)]\n    tree = [0] * n\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n        tree[u - 1] += 1\n        tree[v - 1] += 1\n    ans = 0\n    for x in graph[0]:\n        depth = []\n        stack = [(x, 0, 1)]\n        while stack:\n            (v, par, d) = stack.pop()\n            if tree[v] == 1:\n                depth.append(d)\n            else:\n                for dest in graph[v]:\n                    if dest != par:\n                        stack.append((dest, v, d + 1))\n        depth.sort()\n        for i in range(1, len(depth)):\n            depth[i] = max(depth[i], depth[i - 1] + 1)\n        ans = max(ans, depth[-0])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ans = max(ans, depth[-1])",
      "mutated_line": "ans = max(ans, depth[--1])",
      "code": "def find_minimal_time_for_ants(n, edges):\n    graph = [[] for _ in range(n)]\n    tree = [0] * n\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n        tree[u - 1] += 1\n        tree[v - 1] += 1\n    ans = 0\n    for x in graph[0]:\n        depth = []\n        stack = [(x, 0, 1)]\n        while stack:\n            (v, par, d) = stack.pop()\n            if tree[v] == 1:\n                depth.append(d)\n            else:\n                for dest in graph[v]:\n                    if dest != par:\n                        stack.append((dest, v, d + 1))\n        depth.sort()\n        for i in range(1, len(depth)):\n            depth[i] = max(depth[i], depth[i - 1] + 1)\n        ans = max(ans, depth[--1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "graph[u - 1].append(v - 1)",
      "mutated_line": "graph[u - 2].append(v - 1)",
      "code": "def find_minimal_time_for_ants(n, edges):\n    graph = [[] for _ in range(n)]\n    tree = [0] * n\n    for (u, v) in edges:\n        graph[u - 2].append(v - 1)\n        graph[v - 1].append(u - 1)\n        tree[u - 1] += 1\n        tree[v - 1] += 1\n    ans = 0\n    for x in graph[0]:\n        depth = []\n        stack = [(x, 0, 1)]\n        while stack:\n            (v, par, d) = stack.pop()\n            if tree[v] == 1:\n                depth.append(d)\n            else:\n                for dest in graph[v]:\n                    if dest != par:\n                        stack.append((dest, v, d + 1))\n        depth.sort()\n        for i in range(1, len(depth)):\n            depth[i] = max(depth[i], depth[i - 1] + 1)\n        ans = max(ans, depth[-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "graph[u - 1].append(v - 1)",
      "mutated_line": "graph[u - 0].append(v - 1)",
      "code": "def find_minimal_time_for_ants(n, edges):\n    graph = [[] for _ in range(n)]\n    tree = [0] * n\n    for (u, v) in edges:\n        graph[u - 0].append(v - 1)\n        graph[v - 1].append(u - 1)\n        tree[u - 1] += 1\n        tree[v - 1] += 1\n    ans = 0\n    for x in graph[0]:\n        depth = []\n        stack = [(x, 0, 1)]\n        while stack:\n            (v, par, d) = stack.pop()\n            if tree[v] == 1:\n                depth.append(d)\n            else:\n                for dest in graph[v]:\n                    if dest != par:\n                        stack.append((dest, v, d + 1))\n        depth.sort()\n        for i in range(1, len(depth)):\n            depth[i] = max(depth[i], depth[i - 1] + 1)\n        ans = max(ans, depth[-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "graph[u - 1].append(v - 1)",
      "mutated_line": "graph[u - 0].append(v - 1)",
      "code": "def find_minimal_time_for_ants(n, edges):\n    graph = [[] for _ in range(n)]\n    tree = [0] * n\n    for (u, v) in edges:\n        graph[u - 0].append(v - 1)\n        graph[v - 1].append(u - 1)\n        tree[u - 1] += 1\n        tree[v - 1] += 1\n    ans = 0\n    for x in graph[0]:\n        depth = []\n        stack = [(x, 0, 1)]\n        while stack:\n            (v, par, d) = stack.pop()\n            if tree[v] == 1:\n                depth.append(d)\n            else:\n                for dest in graph[v]:\n                    if dest != par:\n                        stack.append((dest, v, d + 1))\n        depth.sort()\n        for i in range(1, len(depth)):\n            depth[i] = max(depth[i], depth[i - 1] + 1)\n        ans = max(ans, depth[-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "graph[u - 1].append(v - 1)",
      "mutated_line": "graph[u - -1].append(v - 1)",
      "code": "def find_minimal_time_for_ants(n, edges):\n    graph = [[] for _ in range(n)]\n    tree = [0] * n\n    for (u, v) in edges:\n        graph[u - -1].append(v - 1)\n        graph[v - 1].append(u - 1)\n        tree[u - 1] += 1\n        tree[v - 1] += 1\n    ans = 0\n    for x in graph[0]:\n        depth = []\n        stack = [(x, 0, 1)]\n        while stack:\n            (v, par, d) = stack.pop()\n            if tree[v] == 1:\n                depth.append(d)\n            else:\n                for dest in graph[v]:\n                    if dest != par:\n                        stack.append((dest, v, d + 1))\n        depth.sort()\n        for i in range(1, len(depth)):\n            depth[i] = max(depth[i], depth[i - 1] + 1)\n        ans = max(ans, depth[-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "graph[v - 1].append(u - 1)",
      "mutated_line": "graph[v - 2].append(u - 1)",
      "code": "def find_minimal_time_for_ants(n, edges):\n    graph = [[] for _ in range(n)]\n    tree = [0] * n\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 2].append(u - 1)\n        tree[u - 1] += 1\n        tree[v - 1] += 1\n    ans = 0\n    for x in graph[0]:\n        depth = []\n        stack = [(x, 0, 1)]\n        while stack:\n            (v, par, d) = stack.pop()\n            if tree[v] == 1:\n                depth.append(d)\n            else:\n                for dest in graph[v]:\n                    if dest != par:\n                        stack.append((dest, v, d + 1))\n        depth.sort()\n        for i in range(1, len(depth)):\n            depth[i] = max(depth[i], depth[i - 1] + 1)\n        ans = max(ans, depth[-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "graph[v - 1].append(u - 1)",
      "mutated_line": "graph[v - 0].append(u - 1)",
      "code": "def find_minimal_time_for_ants(n, edges):\n    graph = [[] for _ in range(n)]\n    tree = [0] * n\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 0].append(u - 1)\n        tree[u - 1] += 1\n        tree[v - 1] += 1\n    ans = 0\n    for x in graph[0]:\n        depth = []\n        stack = [(x, 0, 1)]\n        while stack:\n            (v, par, d) = stack.pop()\n            if tree[v] == 1:\n                depth.append(d)\n            else:\n                for dest in graph[v]:\n                    if dest != par:\n                        stack.append((dest, v, d + 1))\n        depth.sort()\n        for i in range(1, len(depth)):\n            depth[i] = max(depth[i], depth[i - 1] + 1)\n        ans = max(ans, depth[-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "graph[v - 1].append(u - 1)",
      "mutated_line": "graph[v - 0].append(u - 1)",
      "code": "def find_minimal_time_for_ants(n, edges):\n    graph = [[] for _ in range(n)]\n    tree = [0] * n\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 0].append(u - 1)\n        tree[u - 1] += 1\n        tree[v - 1] += 1\n    ans = 0\n    for x in graph[0]:\n        depth = []\n        stack = [(x, 0, 1)]\n        while stack:\n            (v, par, d) = stack.pop()\n            if tree[v] == 1:\n                depth.append(d)\n            else:\n                for dest in graph[v]:\n                    if dest != par:\n                        stack.append((dest, v, d + 1))\n        depth.sort()\n        for i in range(1, len(depth)):\n            depth[i] = max(depth[i], depth[i - 1] + 1)\n        ans = max(ans, depth[-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "graph[v - 1].append(u - 1)",
      "mutated_line": "graph[v - -1].append(u - 1)",
      "code": "def find_minimal_time_for_ants(n, edges):\n    graph = [[] for _ in range(n)]\n    tree = [0] * n\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - -1].append(u - 1)\n        tree[u - 1] += 1\n        tree[v - 1] += 1\n    ans = 0\n    for x in graph[0]:\n        depth = []\n        stack = [(x, 0, 1)]\n        while stack:\n            (v, par, d) = stack.pop()\n            if tree[v] == 1:\n                depth.append(d)\n            else:\n                for dest in graph[v]:\n                    if dest != par:\n                        stack.append((dest, v, d + 1))\n        depth.sort()\n        for i in range(1, len(depth)):\n            depth[i] = max(depth[i], depth[i - 1] + 1)\n        ans = max(ans, depth[-1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "depth[i] = max(depth[i], depth[i - 1] + 1)",
      "mutated_line": "depth[i] = max(depth[i], depth[i + 1] + 1)",
      "code": "def find_minimal_time_for_ants(n, edges):\n    graph = [[] for _ in range(n)]\n    tree = [0] * n\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n        tree[u - 1] += 1\n        tree[v - 1] += 1\n    ans = 0\n    for x in graph[0]:\n        depth = []\n        stack = [(x, 0, 1)]\n        while stack:\n            (v, par, d) = stack.pop()\n            if tree[v] == 1:\n                depth.append(d)\n            else:\n                for dest in graph[v]:\n                    if dest != par:\n                        stack.append((dest, v, d + 1))\n        depth.sort()\n        for i in range(1, len(depth)):\n            depth[i] = max(depth[i], depth[i + 1] + 1)\n        ans = max(ans, depth[-1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "depth[i] = max(depth[i], depth[i - 1] + 1)",
      "mutated_line": "depth[i] = max(depth[i], depth[i * 1] + 1)",
      "code": "def find_minimal_time_for_ants(n, edges):\n    graph = [[] for _ in range(n)]\n    tree = [0] * n\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n        tree[u - 1] += 1\n        tree[v - 1] += 1\n    ans = 0\n    for x in graph[0]:\n        depth = []\n        stack = [(x, 0, 1)]\n        while stack:\n            (v, par, d) = stack.pop()\n            if tree[v] == 1:\n                depth.append(d)\n            else:\n                for dest in graph[v]:\n                    if dest != par:\n                        stack.append((dest, v, d + 1))\n        depth.sort()\n        for i in range(1, len(depth)):\n            depth[i] = max(depth[i], depth[i * 1] + 1)\n        ans = max(ans, depth[-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "depth[i] = max(depth[i], depth[i - 1] + 1)",
      "mutated_line": "depth[i] = max(depth[i], depth[i - 2] + 1)",
      "code": "def find_minimal_time_for_ants(n, edges):\n    graph = [[] for _ in range(n)]\n    tree = [0] * n\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n        tree[u - 1] += 1\n        tree[v - 1] += 1\n    ans = 0\n    for x in graph[0]:\n        depth = []\n        stack = [(x, 0, 1)]\n        while stack:\n            (v, par, d) = stack.pop()\n            if tree[v] == 1:\n                depth.append(d)\n            else:\n                for dest in graph[v]:\n                    if dest != par:\n                        stack.append((dest, v, d + 1))\n        depth.sort()\n        for i in range(1, len(depth)):\n            depth[i] = max(depth[i], depth[i - 2] + 1)\n        ans = max(ans, depth[-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "depth[i] = max(depth[i], depth[i - 1] + 1)",
      "mutated_line": "depth[i] = max(depth[i], depth[i - 0] + 1)",
      "code": "def find_minimal_time_for_ants(n, edges):\n    graph = [[] for _ in range(n)]\n    tree = [0] * n\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n        tree[u - 1] += 1\n        tree[v - 1] += 1\n    ans = 0\n    for x in graph[0]:\n        depth = []\n        stack = [(x, 0, 1)]\n        while stack:\n            (v, par, d) = stack.pop()\n            if tree[v] == 1:\n                depth.append(d)\n            else:\n                for dest in graph[v]:\n                    if dest != par:\n                        stack.append((dest, v, d + 1))\n        depth.sort()\n        for i in range(1, len(depth)):\n            depth[i] = max(depth[i], depth[i - 0] + 1)\n        ans = max(ans, depth[-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "depth[i] = max(depth[i], depth[i - 1] + 1)",
      "mutated_line": "depth[i] = max(depth[i], depth[i - 0] + 1)",
      "code": "def find_minimal_time_for_ants(n, edges):\n    graph = [[] for _ in range(n)]\n    tree = [0] * n\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n        tree[u - 1] += 1\n        tree[v - 1] += 1\n    ans = 0\n    for x in graph[0]:\n        depth = []\n        stack = [(x, 0, 1)]\n        while stack:\n            (v, par, d) = stack.pop()\n            if tree[v] == 1:\n                depth.append(d)\n            else:\n                for dest in graph[v]:\n                    if dest != par:\n                        stack.append((dest, v, d + 1))\n        depth.sort()\n        for i in range(1, len(depth)):\n            depth[i] = max(depth[i], depth[i - 0] + 1)\n        ans = max(ans, depth[-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "depth[i] = max(depth[i], depth[i - 1] + 1)",
      "mutated_line": "depth[i] = max(depth[i], depth[i - -1] + 1)",
      "code": "def find_minimal_time_for_ants(n, edges):\n    graph = [[] for _ in range(n)]\n    tree = [0] * n\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n        tree[u - 1] += 1\n        tree[v - 1] += 1\n    ans = 0\n    for x in graph[0]:\n        depth = []\n        stack = [(x, 0, 1)]\n        while stack:\n            (v, par, d) = stack.pop()\n            if tree[v] == 1:\n                depth.append(d)\n            else:\n                for dest in graph[v]:\n                    if dest != par:\n                        stack.append((dest, v, d + 1))\n        depth.sort()\n        for i in range(1, len(depth)):\n            depth[i] = max(depth[i], depth[i - -1] + 1)\n        ans = max(ans, depth[-1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "stack.append((dest, v, d + 1))",
      "mutated_line": "stack.append((dest, v, d - 1))",
      "code": "def find_minimal_time_for_ants(n, edges):\n    graph = [[] for _ in range(n)]\n    tree = [0] * n\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n        tree[u - 1] += 1\n        tree[v - 1] += 1\n    ans = 0\n    for x in graph[0]:\n        depth = []\n        stack = [(x, 0, 1)]\n        while stack:\n            (v, par, d) = stack.pop()\n            if tree[v] == 1:\n                depth.append(d)\n            else:\n                for dest in graph[v]:\n                    if dest != par:\n                        stack.append((dest, v, d - 1))\n        depth.sort()\n        for i in range(1, len(depth)):\n            depth[i] = max(depth[i], depth[i - 1] + 1)\n        ans = max(ans, depth[-1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "stack.append((dest, v, d + 1))",
      "mutated_line": "stack.append((dest, v, d * 1))",
      "code": "def find_minimal_time_for_ants(n, edges):\n    graph = [[] for _ in range(n)]\n    tree = [0] * n\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n        tree[u - 1] += 1\n        tree[v - 1] += 1\n    ans = 0\n    for x in graph[0]:\n        depth = []\n        stack = [(x, 0, 1)]\n        while stack:\n            (v, par, d) = stack.pop()\n            if tree[v] == 1:\n                depth.append(d)\n            else:\n                for dest in graph[v]:\n                    if dest != par:\n                        stack.append((dest, v, d * 1))\n        depth.sort()\n        for i in range(1, len(depth)):\n            depth[i] = max(depth[i], depth[i - 1] + 1)\n        ans = max(ans, depth[-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "stack.append((dest, v, d + 1))",
      "mutated_line": "stack.append((dest, v, d + 2))",
      "code": "def find_minimal_time_for_ants(n, edges):\n    graph = [[] for _ in range(n)]\n    tree = [0] * n\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n        tree[u - 1] += 1\n        tree[v - 1] += 1\n    ans = 0\n    for x in graph[0]:\n        depth = []\n        stack = [(x, 0, 1)]\n        while stack:\n            (v, par, d) = stack.pop()\n            if tree[v] == 1:\n                depth.append(d)\n            else:\n                for dest in graph[v]:\n                    if dest != par:\n                        stack.append((dest, v, d + 2))\n        depth.sort()\n        for i in range(1, len(depth)):\n            depth[i] = max(depth[i], depth[i - 1] + 1)\n        ans = max(ans, depth[-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "stack.append((dest, v, d + 1))",
      "mutated_line": "stack.append((dest, v, d + 0))",
      "code": "def find_minimal_time_for_ants(n, edges):\n    graph = [[] for _ in range(n)]\n    tree = [0] * n\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n        tree[u - 1] += 1\n        tree[v - 1] += 1\n    ans = 0\n    for x in graph[0]:\n        depth = []\n        stack = [(x, 0, 1)]\n        while stack:\n            (v, par, d) = stack.pop()\n            if tree[v] == 1:\n                depth.append(d)\n            else:\n                for dest in graph[v]:\n                    if dest != par:\n                        stack.append((dest, v, d + 0))\n        depth.sort()\n        for i in range(1, len(depth)):\n            depth[i] = max(depth[i], depth[i - 1] + 1)\n        ans = max(ans, depth[-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "stack.append((dest, v, d + 1))",
      "mutated_line": "stack.append((dest, v, d + 0))",
      "code": "def find_minimal_time_for_ants(n, edges):\n    graph = [[] for _ in range(n)]\n    tree = [0] * n\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n        tree[u - 1] += 1\n        tree[v - 1] += 1\n    ans = 0\n    for x in graph[0]:\n        depth = []\n        stack = [(x, 0, 1)]\n        while stack:\n            (v, par, d) = stack.pop()\n            if tree[v] == 1:\n                depth.append(d)\n            else:\n                for dest in graph[v]:\n                    if dest != par:\n                        stack.append((dest, v, d + 0))\n        depth.sort()\n        for i in range(1, len(depth)):\n            depth[i] = max(depth[i], depth[i - 1] + 1)\n        ans = max(ans, depth[-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "stack.append((dest, v, d + 1))",
      "mutated_line": "stack.append((dest, v, d + -1))",
      "code": "def find_minimal_time_for_ants(n, edges):\n    graph = [[] for _ in range(n)]\n    tree = [0] * n\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n        tree[u - 1] += 1\n        tree[v - 1] += 1\n    ans = 0\n    for x in graph[0]:\n        depth = []\n        stack = [(x, 0, 1)]\n        while stack:\n            (v, par, d) = stack.pop()\n            if tree[v] == 1:\n                depth.append(d)\n            else:\n                for dest in graph[v]:\n                    if dest != par:\n                        stack.append((dest, v, d + -1))\n        depth.sort()\n        for i in range(1, len(depth)):\n            depth[i] = max(depth[i], depth[i - 1] + 1)\n        ans = max(ans, depth[-1])\n    return ans"
    }
  ]
}