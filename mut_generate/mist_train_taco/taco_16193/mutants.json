{
  "task_id": "taco_16193",
  "entry_point": "calculate_highest_training_score",
  "mutant_count": 61,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "import heapq\n\ndef calculate_highest_training_score(T, N, A, B):\n    results = []\n    for t in range(T):\n        number = N[t]\n        eff = A[t]\n        b = B[t]\n        heap = []\n        tempheap = []\n        ans = 1\n        realans = [0.0]\n        k = 1\n        for i in range(number):\n            heapq.heappush(heap, [b[i], eff[i]])\n        condition1 = True\n        while tempheap or (condition1 and heap[0][0] < k):\n            condition = True\n            if not heap:\n                condition = False\n            while condition and heap[0][0] == k - 1:\n                mn = heapq.heappop(heap)\n                heapq.heappush(tempheap, [-mn[1], mn[0]])\n                if not heap:\n                    condition = False\n            if not heap:\n                condition1 = False\n            m = heapq.heappop(tempheap)\n            ans = ans + -m[0]\n            realans.append(ans / k)\n            k += 1\n        results.append(max(realans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "ans = 0",
      "mutated_line": "ans = -1",
      "code": "import heapq\n\ndef calculate_highest_training_score(T, N, A, B):\n    results = []\n    for t in range(T):\n        number = N[t]\n        eff = A[t]\n        b = B[t]\n        heap = []\n        tempheap = []\n        ans = -1\n        realans = [0.0]\n        k = 1\n        for i in range(number):\n            heapq.heappush(heap, [b[i], eff[i]])\n        condition1 = True\n        while tempheap or (condition1 and heap[0][0] < k):\n            condition = True\n            if not heap:\n                condition = False\n            while condition and heap[0][0] == k - 1:\n                mn = heapq.heappop(heap)\n                heapq.heappush(tempheap, [-mn[1], mn[0]])\n                if not heap:\n                    condition = False\n            if not heap:\n                condition1 = False\n            m = heapq.heappop(tempheap)\n            ans = ans + -m[0]\n            realans.append(ans / k)\n            k += 1\n        results.append(max(realans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "import heapq\n\ndef calculate_highest_training_score(T, N, A, B):\n    results = []\n    for t in range(T):\n        number = N[t]\n        eff = A[t]\n        b = B[t]\n        heap = []\n        tempheap = []\n        ans = 1\n        realans = [0.0]\n        k = 1\n        for i in range(number):\n            heapq.heappush(heap, [b[i], eff[i]])\n        condition1 = True\n        while tempheap or (condition1 and heap[0][0] < k):\n            condition = True\n            if not heap:\n                condition = False\n            while condition and heap[0][0] == k - 1:\n                mn = heapq.heappop(heap)\n                heapq.heappush(tempheap, [-mn[1], mn[0]])\n                if not heap:\n                    condition = False\n            if not heap:\n                condition1 = False\n            m = heapq.heappop(tempheap)\n            ans = ans + -m[0]\n            realans.append(ans / k)\n            k += 1\n        results.append(max(realans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "k = 1",
      "mutated_line": "k = 2",
      "code": "import heapq\n\ndef calculate_highest_training_score(T, N, A, B):\n    results = []\n    for t in range(T):\n        number = N[t]\n        eff = A[t]\n        b = B[t]\n        heap = []\n        tempheap = []\n        ans = 0\n        realans = [0.0]\n        k = 2\n        for i in range(number):\n            heapq.heappush(heap, [b[i], eff[i]])\n        condition1 = True\n        while tempheap or (condition1 and heap[0][0] < k):\n            condition = True\n            if not heap:\n                condition = False\n            while condition and heap[0][0] == k - 1:\n                mn = heapq.heappop(heap)\n                heapq.heappush(tempheap, [-mn[1], mn[0]])\n                if not heap:\n                    condition = False\n            if not heap:\n                condition1 = False\n            m = heapq.heappop(tempheap)\n            ans = ans + -m[0]\n            realans.append(ans / k)\n            k += 1\n        results.append(max(realans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "k = 1",
      "mutated_line": "k = 0",
      "code": "import heapq\n\ndef calculate_highest_training_score(T, N, A, B):\n    results = []\n    for t in range(T):\n        number = N[t]\n        eff = A[t]\n        b = B[t]\n        heap = []\n        tempheap = []\n        ans = 0\n        realans = [0.0]\n        k = 0\n        for i in range(number):\n            heapq.heappush(heap, [b[i], eff[i]])\n        condition1 = True\n        while tempheap or (condition1 and heap[0][0] < k):\n            condition = True\n            if not heap:\n                condition = False\n            while condition and heap[0][0] == k - 1:\n                mn = heapq.heappop(heap)\n                heapq.heappush(tempheap, [-mn[1], mn[0]])\n                if not heap:\n                    condition = False\n            if not heap:\n                condition1 = False\n            m = heapq.heappop(tempheap)\n            ans = ans + -m[0]\n            realans.append(ans / k)\n            k += 1\n        results.append(max(realans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "k = 1",
      "mutated_line": "k = 0",
      "code": "import heapq\n\ndef calculate_highest_training_score(T, N, A, B):\n    results = []\n    for t in range(T):\n        number = N[t]\n        eff = A[t]\n        b = B[t]\n        heap = []\n        tempheap = []\n        ans = 0\n        realans = [0.0]\n        k = 0\n        for i in range(number):\n            heapq.heappush(heap, [b[i], eff[i]])\n        condition1 = True\n        while tempheap or (condition1 and heap[0][0] < k):\n            condition = True\n            if not heap:\n                condition = False\n            while condition and heap[0][0] == k - 1:\n                mn = heapq.heappop(heap)\n                heapq.heappush(tempheap, [-mn[1], mn[0]])\n                if not heap:\n                    condition = False\n            if not heap:\n                condition1 = False\n            m = heapq.heappop(tempheap)\n            ans = ans + -m[0]\n            realans.append(ans / k)\n            k += 1\n        results.append(max(realans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "k = 1",
      "mutated_line": "k = -1",
      "code": "import heapq\n\ndef calculate_highest_training_score(T, N, A, B):\n    results = []\n    for t in range(T):\n        number = N[t]\n        eff = A[t]\n        b = B[t]\n        heap = []\n        tempheap = []\n        ans = 0\n        realans = [0.0]\n        k = -1\n        for i in range(number):\n            heapq.heappush(heap, [b[i], eff[i]])\n        condition1 = True\n        while tempheap or (condition1 and heap[0][0] < k):\n            condition = True\n            if not heap:\n                condition = False\n            while condition and heap[0][0] == k - 1:\n                mn = heapq.heappop(heap)\n                heapq.heappush(tempheap, [-mn[1], mn[0]])\n                if not heap:\n                    condition = False\n            if not heap:\n                condition1 = False\n            m = heapq.heappop(tempheap)\n            ans = ans + -m[0]\n            realans.append(ans / k)\n            k += 1\n        results.append(max(realans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "condition1 = True",
      "mutated_line": "condition1 = False",
      "code": "import heapq\n\ndef calculate_highest_training_score(T, N, A, B):\n    results = []\n    for t in range(T):\n        number = N[t]\n        eff = A[t]\n        b = B[t]\n        heap = []\n        tempheap = []\n        ans = 0\n        realans = [0.0]\n        k = 1\n        for i in range(number):\n            heapq.heappush(heap, [b[i], eff[i]])\n        condition1 = False\n        while tempheap or (condition1 and heap[0][0] < k):\n            condition = True\n            if not heap:\n                condition = False\n            while condition and heap[0][0] == k - 1:\n                mn = heapq.heappop(heap)\n                heapq.heappush(tempheap, [-mn[1], mn[0]])\n                if not heap:\n                    condition = False\n            if not heap:\n                condition1 = False\n            m = heapq.heappop(tempheap)\n            ans = ans + -m[0]\n            realans.append(ans / k)\n            k += 1\n        results.append(max(realans))\n    return results"
    },
    {
      "operator": "LCR",
      "lineno": 21,
      "original_line": "while tempheap or (condition1 and heap[0][0] < k):",
      "mutated_line": "while tempheap and (condition1 and heap[0][0] < k):",
      "code": "import heapq\n\ndef calculate_highest_training_score(T, N, A, B):\n    results = []\n    for t in range(T):\n        number = N[t]\n        eff = A[t]\n        b = B[t]\n        heap = []\n        tempheap = []\n        ans = 0\n        realans = [0.0]\n        k = 1\n        for i in range(number):\n            heapq.heappush(heap, [b[i], eff[i]])\n        condition1 = True\n        while tempheap and (condition1 and heap[0][0] < k):\n            condition = True\n            if not heap:\n                condition = False\n            while condition and heap[0][0] == k - 1:\n                mn = heapq.heappop(heap)\n                heapq.heappush(tempheap, [-mn[1], mn[0]])\n                if not heap:\n                    condition = False\n            if not heap:\n                condition1 = False\n            m = heapq.heappop(tempheap)\n            ans = ans + -m[0]\n            realans.append(ans / k)\n            k += 1\n        results.append(max(realans))\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 35,
      "original_line": "k += 1",
      "mutated_line": "k -= 1",
      "code": "import heapq\n\ndef calculate_highest_training_score(T, N, A, B):\n    results = []\n    for t in range(T):\n        number = N[t]\n        eff = A[t]\n        b = B[t]\n        heap = []\n        tempheap = []\n        ans = 0\n        realans = [0.0]\n        k = 1\n        for i in range(number):\n            heapq.heappush(heap, [b[i], eff[i]])\n        condition1 = True\n        while tempheap or (condition1 and heap[0][0] < k):\n            condition = True\n            if not heap:\n                condition = False\n            while condition and heap[0][0] == k - 1:\n                mn = heapq.heappop(heap)\n                heapq.heappush(tempheap, [-mn[1], mn[0]])\n                if not heap:\n                    condition = False\n            if not heap:\n                condition1 = False\n            m = heapq.heappop(tempheap)\n            ans = ans + -m[0]\n            realans.append(ans / k)\n            k -= 1\n        results.append(max(realans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "realans = [0.0]",
      "mutated_line": "realans = [1.0]",
      "code": "import heapq\n\ndef calculate_highest_training_score(T, N, A, B):\n    results = []\n    for t in range(T):\n        number = N[t]\n        eff = A[t]\n        b = B[t]\n        heap = []\n        tempheap = []\n        ans = 0\n        realans = [1.0]\n        k = 1\n        for i in range(number):\n            heapq.heappush(heap, [b[i], eff[i]])\n        condition1 = True\n        while tempheap or (condition1 and heap[0][0] < k):\n            condition = True\n            if not heap:\n                condition = False\n            while condition and heap[0][0] == k - 1:\n                mn = heapq.heappop(heap)\n                heapq.heappush(tempheap, [-mn[1], mn[0]])\n                if not heap:\n                    condition = False\n            if not heap:\n                condition1 = False\n            m = heapq.heappop(tempheap)\n            ans = ans + -m[0]\n            realans.append(ans / k)\n            k += 1\n        results.append(max(realans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "realans = [0.0]",
      "mutated_line": "realans = [-1.0]",
      "code": "import heapq\n\ndef calculate_highest_training_score(T, N, A, B):\n    results = []\n    for t in range(T):\n        number = N[t]\n        eff = A[t]\n        b = B[t]\n        heap = []\n        tempheap = []\n        ans = 0\n        realans = [-1.0]\n        k = 1\n        for i in range(number):\n            heapq.heappush(heap, [b[i], eff[i]])\n        condition1 = True\n        while tempheap or (condition1 and heap[0][0] < k):\n            condition = True\n            if not heap:\n                condition = False\n            while condition and heap[0][0] == k - 1:\n                mn = heapq.heappop(heap)\n                heapq.heappush(tempheap, [-mn[1], mn[0]])\n                if not heap:\n                    condition = False\n            if not heap:\n                condition1 = False\n            m = heapq.heappop(tempheap)\n            ans = ans + -m[0]\n            realans.append(ans / k)\n            k += 1\n        results.append(max(realans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "realans = [0.0]",
      "mutated_line": "realans = [1]",
      "code": "import heapq\n\ndef calculate_highest_training_score(T, N, A, B):\n    results = []\n    for t in range(T):\n        number = N[t]\n        eff = A[t]\n        b = B[t]\n        heap = []\n        tempheap = []\n        ans = 0\n        realans = [1]\n        k = 1\n        for i in range(number):\n            heapq.heappush(heap, [b[i], eff[i]])\n        condition1 = True\n        while tempheap or (condition1 and heap[0][0] < k):\n            condition = True\n            if not heap:\n                condition = False\n            while condition and heap[0][0] == k - 1:\n                mn = heapq.heappop(heap)\n                heapq.heappush(tempheap, [-mn[1], mn[0]])\n                if not heap:\n                    condition = False\n            if not heap:\n                condition1 = False\n            m = heapq.heappop(tempheap)\n            ans = ans + -m[0]\n            realans.append(ans / k)\n            k += 1\n        results.append(max(realans))\n    return results"
    },
    {
      "operator": "LCR",
      "lineno": 21,
      "original_line": "while tempheap or (condition1 and heap[0][0] < k):",
      "mutated_line": "while tempheap or (condition1 or heap[0][0] < k):",
      "code": "import heapq\n\ndef calculate_highest_training_score(T, N, A, B):\n    results = []\n    for t in range(T):\n        number = N[t]\n        eff = A[t]\n        b = B[t]\n        heap = []\n        tempheap = []\n        ans = 0\n        realans = [0.0]\n        k = 1\n        for i in range(number):\n            heapq.heappush(heap, [b[i], eff[i]])\n        condition1 = True\n        while tempheap or (condition1 or heap[0][0] < k):\n            condition = True\n            if not heap:\n                condition = False\n            while condition and heap[0][0] == k - 1:\n                mn = heapq.heappop(heap)\n                heapq.heappush(tempheap, [-mn[1], mn[0]])\n                if not heap:\n                    condition = False\n            if not heap:\n                condition1 = False\n            m = heapq.heappop(tempheap)\n            ans = ans + -m[0]\n            realans.append(ans / k)\n            k += 1\n        results.append(max(realans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "condition = True",
      "mutated_line": "condition = False",
      "code": "import heapq\n\ndef calculate_highest_training_score(T, N, A, B):\n    results = []\n    for t in range(T):\n        number = N[t]\n        eff = A[t]\n        b = B[t]\n        heap = []\n        tempheap = []\n        ans = 0\n        realans = [0.0]\n        k = 1\n        for i in range(number):\n            heapq.heappush(heap, [b[i], eff[i]])\n        condition1 = True\n        while tempheap or (condition1 and heap[0][0] < k):\n            condition = False\n            if not heap:\n                condition = False\n            while condition and heap[0][0] == k - 1:\n                mn = heapq.heappop(heap)\n                heapq.heappush(tempheap, [-mn[1], mn[0]])\n                if not heap:\n                    condition = False\n            if not heap:\n                condition1 = False\n            m = heapq.heappop(tempheap)\n            ans = ans + -m[0]\n            realans.append(ans / k)\n            k += 1\n        results.append(max(realans))\n    return results"
    },
    {
      "operator": "LCR",
      "lineno": 25,
      "original_line": "while condition and heap[0][0] == k - 1:",
      "mutated_line": "while condition or heap[0][0] == k - 1:",
      "code": "import heapq\n\ndef calculate_highest_training_score(T, N, A, B):\n    results = []\n    for t in range(T):\n        number = N[t]\n        eff = A[t]\n        b = B[t]\n        heap = []\n        tempheap = []\n        ans = 0\n        realans = [0.0]\n        k = 1\n        for i in range(number):\n            heapq.heappush(heap, [b[i], eff[i]])\n        condition1 = True\n        while tempheap or (condition1 and heap[0][0] < k):\n            condition = True\n            if not heap:\n                condition = False\n            while condition or heap[0][0] == k - 1:\n                mn = heapq.heappop(heap)\n                heapq.heappush(tempheap, [-mn[1], mn[0]])\n                if not heap:\n                    condition = False\n            if not heap:\n                condition1 = False\n            m = heapq.heappop(tempheap)\n            ans = ans + -m[0]\n            realans.append(ans / k)\n            k += 1\n        results.append(max(realans))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "ans = ans + -m[0]",
      "mutated_line": "ans = ans - -m[0]",
      "code": "import heapq\n\ndef calculate_highest_training_score(T, N, A, B):\n    results = []\n    for t in range(T):\n        number = N[t]\n        eff = A[t]\n        b = B[t]\n        heap = []\n        tempheap = []\n        ans = 0\n        realans = [0.0]\n        k = 1\n        for i in range(number):\n            heapq.heappush(heap, [b[i], eff[i]])\n        condition1 = True\n        while tempheap or (condition1 and heap[0][0] < k):\n            condition = True\n            if not heap:\n                condition = False\n            while condition and heap[0][0] == k - 1:\n                mn = heapq.heappop(heap)\n                heapq.heappush(tempheap, [-mn[1], mn[0]])\n                if not heap:\n                    condition = False\n            if not heap:\n                condition1 = False\n            m = heapq.heappop(tempheap)\n            ans = ans - -m[0]\n            realans.append(ans / k)\n            k += 1\n        results.append(max(realans))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "ans = ans + -m[0]",
      "mutated_line": "ans = ans * -m[0]",
      "code": "import heapq\n\ndef calculate_highest_training_score(T, N, A, B):\n    results = []\n    for t in range(T):\n        number = N[t]\n        eff = A[t]\n        b = B[t]\n        heap = []\n        tempheap = []\n        ans = 0\n        realans = [0.0]\n        k = 1\n        for i in range(number):\n            heapq.heappush(heap, [b[i], eff[i]])\n        condition1 = True\n        while tempheap or (condition1 and heap[0][0] < k):\n            condition = True\n            if not heap:\n                condition = False\n            while condition and heap[0][0] == k - 1:\n                mn = heapq.heappop(heap)\n                heapq.heappush(tempheap, [-mn[1], mn[0]])\n                if not heap:\n                    condition = False\n            if not heap:\n                condition1 = False\n            m = heapq.heappop(tempheap)\n            ans = ans * -m[0]\n            realans.append(ans / k)\n            k += 1\n        results.append(max(realans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "k += 1",
      "mutated_line": "k += 2",
      "code": "import heapq\n\ndef calculate_highest_training_score(T, N, A, B):\n    results = []\n    for t in range(T):\n        number = N[t]\n        eff = A[t]\n        b = B[t]\n        heap = []\n        tempheap = []\n        ans = 0\n        realans = [0.0]\n        k = 1\n        for i in range(number):\n            heapq.heappush(heap, [b[i], eff[i]])\n        condition1 = True\n        while tempheap or (condition1 and heap[0][0] < k):\n            condition = True\n            if not heap:\n                condition = False\n            while condition and heap[0][0] == k - 1:\n                mn = heapq.heappop(heap)\n                heapq.heappush(tempheap, [-mn[1], mn[0]])\n                if not heap:\n                    condition = False\n            if not heap:\n                condition1 = False\n            m = heapq.heappop(tempheap)\n            ans = ans + -m[0]\n            realans.append(ans / k)\n            k += 2\n        results.append(max(realans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "k += 1",
      "mutated_line": "k += 0",
      "code": "import heapq\n\ndef calculate_highest_training_score(T, N, A, B):\n    results = []\n    for t in range(T):\n        number = N[t]\n        eff = A[t]\n        b = B[t]\n        heap = []\n        tempheap = []\n        ans = 0\n        realans = [0.0]\n        k = 1\n        for i in range(number):\n            heapq.heappush(heap, [b[i], eff[i]])\n        condition1 = True\n        while tempheap or (condition1 and heap[0][0] < k):\n            condition = True\n            if not heap:\n                condition = False\n            while condition and heap[0][0] == k - 1:\n                mn = heapq.heappop(heap)\n                heapq.heappush(tempheap, [-mn[1], mn[0]])\n                if not heap:\n                    condition = False\n            if not heap:\n                condition1 = False\n            m = heapq.heappop(tempheap)\n            ans = ans + -m[0]\n            realans.append(ans / k)\n            k += 0\n        results.append(max(realans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "k += 1",
      "mutated_line": "k += 0",
      "code": "import heapq\n\ndef calculate_highest_training_score(T, N, A, B):\n    results = []\n    for t in range(T):\n        number = N[t]\n        eff = A[t]\n        b = B[t]\n        heap = []\n        tempheap = []\n        ans = 0\n        realans = [0.0]\n        k = 1\n        for i in range(number):\n            heapq.heappush(heap, [b[i], eff[i]])\n        condition1 = True\n        while tempheap or (condition1 and heap[0][0] < k):\n            condition = True\n            if not heap:\n                condition = False\n            while condition and heap[0][0] == k - 1:\n                mn = heapq.heappop(heap)\n                heapq.heappush(tempheap, [-mn[1], mn[0]])\n                if not heap:\n                    condition = False\n            if not heap:\n                condition1 = False\n            m = heapq.heappop(tempheap)\n            ans = ans + -m[0]\n            realans.append(ans / k)\n            k += 0\n        results.append(max(realans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "k += 1",
      "mutated_line": "k += -1",
      "code": "import heapq\n\ndef calculate_highest_training_score(T, N, A, B):\n    results = []\n    for t in range(T):\n        number = N[t]\n        eff = A[t]\n        b = B[t]\n        heap = []\n        tempheap = []\n        ans = 0\n        realans = [0.0]\n        k = 1\n        for i in range(number):\n            heapq.heappush(heap, [b[i], eff[i]])\n        condition1 = True\n        while tempheap or (condition1 and heap[0][0] < k):\n            condition = True\n            if not heap:\n                condition = False\n            while condition and heap[0][0] == k - 1:\n                mn = heapq.heappop(heap)\n                heapq.heappush(tempheap, [-mn[1], mn[0]])\n                if not heap:\n                    condition = False\n            if not heap:\n                condition1 = False\n            m = heapq.heappop(tempheap)\n            ans = ans + -m[0]\n            realans.append(ans / k)\n            k += -1\n        results.append(max(realans))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "while tempheap or (condition1 and heap[0][0] < k):",
      "mutated_line": "while tempheap or (condition1 and heap[0][0] <= k):",
      "code": "import heapq\n\ndef calculate_highest_training_score(T, N, A, B):\n    results = []\n    for t in range(T):\n        number = N[t]\n        eff = A[t]\n        b = B[t]\n        heap = []\n        tempheap = []\n        ans = 0\n        realans = [0.0]\n        k = 1\n        for i in range(number):\n            heapq.heappush(heap, [b[i], eff[i]])\n        condition1 = True\n        while tempheap or (condition1 and heap[0][0] <= k):\n            condition = True\n            if not heap:\n                condition = False\n            while condition and heap[0][0] == k - 1:\n                mn = heapq.heappop(heap)\n                heapq.heappush(tempheap, [-mn[1], mn[0]])\n                if not heap:\n                    condition = False\n            if not heap:\n                condition1 = False\n            m = heapq.heappop(tempheap)\n            ans = ans + -m[0]\n            realans.append(ans / k)\n            k += 1\n        results.append(max(realans))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "while tempheap or (condition1 and heap[0][0] < k):",
      "mutated_line": "while tempheap or (condition1 and heap[0][0] >= k):",
      "code": "import heapq\n\ndef calculate_highest_training_score(T, N, A, B):\n    results = []\n    for t in range(T):\n        number = N[t]\n        eff = A[t]\n        b = B[t]\n        heap = []\n        tempheap = []\n        ans = 0\n        realans = [0.0]\n        k = 1\n        for i in range(number):\n            heapq.heappush(heap, [b[i], eff[i]])\n        condition1 = True\n        while tempheap or (condition1 and heap[0][0] >= k):\n            condition = True\n            if not heap:\n                condition = False\n            while condition and heap[0][0] == k - 1:\n                mn = heapq.heappop(heap)\n                heapq.heappush(tempheap, [-mn[1], mn[0]])\n                if not heap:\n                    condition = False\n            if not heap:\n                condition1 = False\n            m = heapq.heappop(tempheap)\n            ans = ans + -m[0]\n            realans.append(ans / k)\n            k += 1\n        results.append(max(realans))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "while tempheap or (condition1 and heap[0][0] < k):",
      "mutated_line": "while tempheap or (condition1 and heap[0][0] != k):",
      "code": "import heapq\n\ndef calculate_highest_training_score(T, N, A, B):\n    results = []\n    for t in range(T):\n        number = N[t]\n        eff = A[t]\n        b = B[t]\n        heap = []\n        tempheap = []\n        ans = 0\n        realans = [0.0]\n        k = 1\n        for i in range(number):\n            heapq.heappush(heap, [b[i], eff[i]])\n        condition1 = True\n        while tempheap or (condition1 and heap[0][0] != k):\n            condition = True\n            if not heap:\n                condition = False\n            while condition and heap[0][0] == k - 1:\n                mn = heapq.heappop(heap)\n                heapq.heappush(tempheap, [-mn[1], mn[0]])\n                if not heap:\n                    condition = False\n            if not heap:\n                condition1 = False\n            m = heapq.heappop(tempheap)\n            ans = ans + -m[0]\n            realans.append(ans / k)\n            k += 1\n        results.append(max(realans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "condition = False",
      "mutated_line": "condition = True",
      "code": "import heapq\n\ndef calculate_highest_training_score(T, N, A, B):\n    results = []\n    for t in range(T):\n        number = N[t]\n        eff = A[t]\n        b = B[t]\n        heap = []\n        tempheap = []\n        ans = 0\n        realans = [0.0]\n        k = 1\n        for i in range(number):\n            heapq.heappush(heap, [b[i], eff[i]])\n        condition1 = True\n        while tempheap or (condition1 and heap[0][0] < k):\n            condition = True\n            if not heap:\n                condition = True\n            while condition and heap[0][0] == k - 1:\n                mn = heapq.heappop(heap)\n                heapq.heappush(tempheap, [-mn[1], mn[0]])\n                if not heap:\n                    condition = False\n            if not heap:\n                condition1 = False\n            m = heapq.heappop(tempheap)\n            ans = ans + -m[0]\n            realans.append(ans / k)\n            k += 1\n        results.append(max(realans))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "while condition and heap[0][0] == k - 1:",
      "mutated_line": "while condition and heap[0][0] != k - 1:",
      "code": "import heapq\n\ndef calculate_highest_training_score(T, N, A, B):\n    results = []\n    for t in range(T):\n        number = N[t]\n        eff = A[t]\n        b = B[t]\n        heap = []\n        tempheap = []\n        ans = 0\n        realans = [0.0]\n        k = 1\n        for i in range(number):\n            heapq.heappush(heap, [b[i], eff[i]])\n        condition1 = True\n        while tempheap or (condition1 and heap[0][0] < k):\n            condition = True\n            if not heap:\n                condition = False\n            while condition and heap[0][0] != k - 1:\n                mn = heapq.heappop(heap)\n                heapq.heappush(tempheap, [-mn[1], mn[0]])\n                if not heap:\n                    condition = False\n            if not heap:\n                condition1 = False\n            m = heapq.heappop(tempheap)\n            ans = ans + -m[0]\n            realans.append(ans / k)\n            k += 1\n        results.append(max(realans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "condition1 = False",
      "mutated_line": "condition1 = True",
      "code": "import heapq\n\ndef calculate_highest_training_score(T, N, A, B):\n    results = []\n    for t in range(T):\n        number = N[t]\n        eff = A[t]\n        b = B[t]\n        heap = []\n        tempheap = []\n        ans = 0\n        realans = [0.0]\n        k = 1\n        for i in range(number):\n            heapq.heappush(heap, [b[i], eff[i]])\n        condition1 = True\n        while tempheap or (condition1 and heap[0][0] < k):\n            condition = True\n            if not heap:\n                condition = False\n            while condition and heap[0][0] == k - 1:\n                mn = heapq.heappop(heap)\n                heapq.heappush(tempheap, [-mn[1], mn[0]])\n                if not heap:\n                    condition = False\n            if not heap:\n                condition1 = True\n            m = heapq.heappop(tempheap)\n            ans = ans + -m[0]\n            realans.append(ans / k)\n            k += 1\n        results.append(max(realans))\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 33,
      "original_line": "ans = ans + -m[0]",
      "mutated_line": "ans = ans + +m[0]",
      "code": "import heapq\n\ndef calculate_highest_training_score(T, N, A, B):\n    results = []\n    for t in range(T):\n        number = N[t]\n        eff = A[t]\n        b = B[t]\n        heap = []\n        tempheap = []\n        ans = 0\n        realans = [0.0]\n        k = 1\n        for i in range(number):\n            heapq.heappush(heap, [b[i], eff[i]])\n        condition1 = True\n        while tempheap or (condition1 and heap[0][0] < k):\n            condition = True\n            if not heap:\n                condition = False\n            while condition and heap[0][0] == k - 1:\n                mn = heapq.heappop(heap)\n                heapq.heappush(tempheap, [-mn[1], mn[0]])\n                if not heap:\n                    condition = False\n            if not heap:\n                condition1 = False\n            m = heapq.heappop(tempheap)\n            ans = ans + +m[0]\n            realans.append(ans / k)\n            k += 1\n        results.append(max(realans))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "realans.append(ans / k)",
      "mutated_line": "realans.append(ans * k)",
      "code": "import heapq\n\ndef calculate_highest_training_score(T, N, A, B):\n    results = []\n    for t in range(T):\n        number = N[t]\n        eff = A[t]\n        b = B[t]\n        heap = []\n        tempheap = []\n        ans = 0\n        realans = [0.0]\n        k = 1\n        for i in range(number):\n            heapq.heappush(heap, [b[i], eff[i]])\n        condition1 = True\n        while tempheap or (condition1 and heap[0][0] < k):\n            condition = True\n            if not heap:\n                condition = False\n            while condition and heap[0][0] == k - 1:\n                mn = heapq.heappop(heap)\n                heapq.heappush(tempheap, [-mn[1], mn[0]])\n                if not heap:\n                    condition = False\n            if not heap:\n                condition1 = False\n            m = heapq.heappop(tempheap)\n            ans = ans + -m[0]\n            realans.append(ans * k)\n            k += 1\n        results.append(max(realans))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "realans.append(ans / k)",
      "mutated_line": "realans.append(ans // k)",
      "code": "import heapq\n\ndef calculate_highest_training_score(T, N, A, B):\n    results = []\n    for t in range(T):\n        number = N[t]\n        eff = A[t]\n        b = B[t]\n        heap = []\n        tempheap = []\n        ans = 0\n        realans = [0.0]\n        k = 1\n        for i in range(number):\n            heapq.heappush(heap, [b[i], eff[i]])\n        condition1 = True\n        while tempheap or (condition1 and heap[0][0] < k):\n            condition = True\n            if not heap:\n                condition = False\n            while condition and heap[0][0] == k - 1:\n                mn = heapq.heappop(heap)\n                heapq.heappush(tempheap, [-mn[1], mn[0]])\n                if not heap:\n                    condition = False\n            if not heap:\n                condition1 = False\n            m = heapq.heappop(tempheap)\n            ans = ans + -m[0]\n            realans.append(ans // k)\n            k += 1\n        results.append(max(realans))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "while condition and heap[0][0] == k - 1:",
      "mutated_line": "while condition and heap[0][0] == k + 1:",
      "code": "import heapq\n\ndef calculate_highest_training_score(T, N, A, B):\n    results = []\n    for t in range(T):\n        number = N[t]\n        eff = A[t]\n        b = B[t]\n        heap = []\n        tempheap = []\n        ans = 0\n        realans = [0.0]\n        k = 1\n        for i in range(number):\n            heapq.heappush(heap, [b[i], eff[i]])\n        condition1 = True\n        while tempheap or (condition1 and heap[0][0] < k):\n            condition = True\n            if not heap:\n                condition = False\n            while condition and heap[0][0] == k + 1:\n                mn = heapq.heappop(heap)\n                heapq.heappush(tempheap, [-mn[1], mn[0]])\n                if not heap:\n                    condition = False\n            if not heap:\n                condition1 = False\n            m = heapq.heappop(tempheap)\n            ans = ans + -m[0]\n            realans.append(ans / k)\n            k += 1\n        results.append(max(realans))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "while condition and heap[0][0] == k - 1:",
      "mutated_line": "while condition and heap[0][0] == k * 1:",
      "code": "import heapq\n\ndef calculate_highest_training_score(T, N, A, B):\n    results = []\n    for t in range(T):\n        number = N[t]\n        eff = A[t]\n        b = B[t]\n        heap = []\n        tempheap = []\n        ans = 0\n        realans = [0.0]\n        k = 1\n        for i in range(number):\n            heapq.heappush(heap, [b[i], eff[i]])\n        condition1 = True\n        while tempheap or (condition1 and heap[0][0] < k):\n            condition = True\n            if not heap:\n                condition = False\n            while condition and heap[0][0] == k * 1:\n                mn = heapq.heappop(heap)\n                heapq.heappush(tempheap, [-mn[1], mn[0]])\n                if not heap:\n                    condition = False\n            if not heap:\n                condition1 = False\n            m = heapq.heappop(tempheap)\n            ans = ans + -m[0]\n            realans.append(ans / k)\n            k += 1\n        results.append(max(realans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "condition = False",
      "mutated_line": "condition = True",
      "code": "import heapq\n\ndef calculate_highest_training_score(T, N, A, B):\n    results = []\n    for t in range(T):\n        number = N[t]\n        eff = A[t]\n        b = B[t]\n        heap = []\n        tempheap = []\n        ans = 0\n        realans = [0.0]\n        k = 1\n        for i in range(number):\n            heapq.heappush(heap, [b[i], eff[i]])\n        condition1 = True\n        while tempheap or (condition1 and heap[0][0] < k):\n            condition = True\n            if not heap:\n                condition = False\n            while condition and heap[0][0] == k - 1:\n                mn = heapq.heappop(heap)\n                heapq.heappush(tempheap, [-mn[1], mn[0]])\n                if not heap:\n                    condition = True\n            if not heap:\n                condition1 = False\n            m = heapq.heappop(tempheap)\n            ans = ans + -m[0]\n            realans.append(ans / k)\n            k += 1\n        results.append(max(realans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "while tempheap or (condition1 and heap[0][0] < k):",
      "mutated_line": "while tempheap or (condition1 and heap[0][1] < k):",
      "code": "import heapq\n\ndef calculate_highest_training_score(T, N, A, B):\n    results = []\n    for t in range(T):\n        number = N[t]\n        eff = A[t]\n        b = B[t]\n        heap = []\n        tempheap = []\n        ans = 0\n        realans = [0.0]\n        k = 1\n        for i in range(number):\n            heapq.heappush(heap, [b[i], eff[i]])\n        condition1 = True\n        while tempheap or (condition1 and heap[0][1] < k):\n            condition = True\n            if not heap:\n                condition = False\n            while condition and heap[0][0] == k - 1:\n                mn = heapq.heappop(heap)\n                heapq.heappush(tempheap, [-mn[1], mn[0]])\n                if not heap:\n                    condition = False\n            if not heap:\n                condition1 = False\n            m = heapq.heappop(tempheap)\n            ans = ans + -m[0]\n            realans.append(ans / k)\n            k += 1\n        results.append(max(realans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "while tempheap or (condition1 and heap[0][0] < k):",
      "mutated_line": "while tempheap or (condition1 and heap[0][-1] < k):",
      "code": "import heapq\n\ndef calculate_highest_training_score(T, N, A, B):\n    results = []\n    for t in range(T):\n        number = N[t]\n        eff = A[t]\n        b = B[t]\n        heap = []\n        tempheap = []\n        ans = 0\n        realans = [0.0]\n        k = 1\n        for i in range(number):\n            heapq.heappush(heap, [b[i], eff[i]])\n        condition1 = True\n        while tempheap or (condition1 and heap[0][-1] < k):\n            condition = True\n            if not heap:\n                condition = False\n            while condition and heap[0][0] == k - 1:\n                mn = heapq.heappop(heap)\n                heapq.heappush(tempheap, [-mn[1], mn[0]])\n                if not heap:\n                    condition = False\n            if not heap:\n                condition1 = False\n            m = heapq.heappop(tempheap)\n            ans = ans + -m[0]\n            realans.append(ans / k)\n            k += 1\n        results.append(max(realans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "while tempheap or (condition1 and heap[0][0] < k):",
      "mutated_line": "while tempheap or (condition1 and heap[0][1] < k):",
      "code": "import heapq\n\ndef calculate_highest_training_score(T, N, A, B):\n    results = []\n    for t in range(T):\n        number = N[t]\n        eff = A[t]\n        b = B[t]\n        heap = []\n        tempheap = []\n        ans = 0\n        realans = [0.0]\n        k = 1\n        for i in range(number):\n            heapq.heappush(heap, [b[i], eff[i]])\n        condition1 = True\n        while tempheap or (condition1 and heap[0][1] < k):\n            condition = True\n            if not heap:\n                condition = False\n            while condition and heap[0][0] == k - 1:\n                mn = heapq.heappop(heap)\n                heapq.heappush(tempheap, [-mn[1], mn[0]])\n                if not heap:\n                    condition = False\n            if not heap:\n                condition1 = False\n            m = heapq.heappop(tempheap)\n            ans = ans + -m[0]\n            realans.append(ans / k)\n            k += 1\n        results.append(max(realans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "while condition and heap[0][0] == k - 1:",
      "mutated_line": "while condition and heap[0][1] == k - 1:",
      "code": "import heapq\n\ndef calculate_highest_training_score(T, N, A, B):\n    results = []\n    for t in range(T):\n        number = N[t]\n        eff = A[t]\n        b = B[t]\n        heap = []\n        tempheap = []\n        ans = 0\n        realans = [0.0]\n        k = 1\n        for i in range(number):\n            heapq.heappush(heap, [b[i], eff[i]])\n        condition1 = True\n        while tempheap or (condition1 and heap[0][0] < k):\n            condition = True\n            if not heap:\n                condition = False\n            while condition and heap[0][1] == k - 1:\n                mn = heapq.heappop(heap)\n                heapq.heappush(tempheap, [-mn[1], mn[0]])\n                if not heap:\n                    condition = False\n            if not heap:\n                condition1 = False\n            m = heapq.heappop(tempheap)\n            ans = ans + -m[0]\n            realans.append(ans / k)\n            k += 1\n        results.append(max(realans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "while condition and heap[0][0] == k - 1:",
      "mutated_line": "while condition and heap[0][-1] == k - 1:",
      "code": "import heapq\n\ndef calculate_highest_training_score(T, N, A, B):\n    results = []\n    for t in range(T):\n        number = N[t]\n        eff = A[t]\n        b = B[t]\n        heap = []\n        tempheap = []\n        ans = 0\n        realans = [0.0]\n        k = 1\n        for i in range(number):\n            heapq.heappush(heap, [b[i], eff[i]])\n        condition1 = True\n        while tempheap or (condition1 and heap[0][0] < k):\n            condition = True\n            if not heap:\n                condition = False\n            while condition and heap[0][-1] == k - 1:\n                mn = heapq.heappop(heap)\n                heapq.heappush(tempheap, [-mn[1], mn[0]])\n                if not heap:\n                    condition = False\n            if not heap:\n                condition1 = False\n            m = heapq.heappop(tempheap)\n            ans = ans + -m[0]\n            realans.append(ans / k)\n            k += 1\n        results.append(max(realans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "while condition and heap[0][0] == k - 1:",
      "mutated_line": "while condition and heap[0][1] == k - 1:",
      "code": "import heapq\n\ndef calculate_highest_training_score(T, N, A, B):\n    results = []\n    for t in range(T):\n        number = N[t]\n        eff = A[t]\n        b = B[t]\n        heap = []\n        tempheap = []\n        ans = 0\n        realans = [0.0]\n        k = 1\n        for i in range(number):\n            heapq.heappush(heap, [b[i], eff[i]])\n        condition1 = True\n        while tempheap or (condition1 and heap[0][0] < k):\n            condition = True\n            if not heap:\n                condition = False\n            while condition and heap[0][1] == k - 1:\n                mn = heapq.heappop(heap)\n                heapq.heappush(tempheap, [-mn[1], mn[0]])\n                if not heap:\n                    condition = False\n            if not heap:\n                condition1 = False\n            m = heapq.heappop(tempheap)\n            ans = ans + -m[0]\n            realans.append(ans / k)\n            k += 1\n        results.append(max(realans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "while condition and heap[0][0] == k - 1:",
      "mutated_line": "while condition and heap[0][0] == k - 2:",
      "code": "import heapq\n\ndef calculate_highest_training_score(T, N, A, B):\n    results = []\n    for t in range(T):\n        number = N[t]\n        eff = A[t]\n        b = B[t]\n        heap = []\n        tempheap = []\n        ans = 0\n        realans = [0.0]\n        k = 1\n        for i in range(number):\n            heapq.heappush(heap, [b[i], eff[i]])\n        condition1 = True\n        while tempheap or (condition1 and heap[0][0] < k):\n            condition = True\n            if not heap:\n                condition = False\n            while condition and heap[0][0] == k - 2:\n                mn = heapq.heappop(heap)\n                heapq.heappush(tempheap, [-mn[1], mn[0]])\n                if not heap:\n                    condition = False\n            if not heap:\n                condition1 = False\n            m = heapq.heappop(tempheap)\n            ans = ans + -m[0]\n            realans.append(ans / k)\n            k += 1\n        results.append(max(realans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "while condition and heap[0][0] == k - 1:",
      "mutated_line": "while condition and heap[0][0] == k - 0:",
      "code": "import heapq\n\ndef calculate_highest_training_score(T, N, A, B):\n    results = []\n    for t in range(T):\n        number = N[t]\n        eff = A[t]\n        b = B[t]\n        heap = []\n        tempheap = []\n        ans = 0\n        realans = [0.0]\n        k = 1\n        for i in range(number):\n            heapq.heappush(heap, [b[i], eff[i]])\n        condition1 = True\n        while tempheap or (condition1 and heap[0][0] < k):\n            condition = True\n            if not heap:\n                condition = False\n            while condition and heap[0][0] == k - 0:\n                mn = heapq.heappop(heap)\n                heapq.heappush(tempheap, [-mn[1], mn[0]])\n                if not heap:\n                    condition = False\n            if not heap:\n                condition1 = False\n            m = heapq.heappop(tempheap)\n            ans = ans + -m[0]\n            realans.append(ans / k)\n            k += 1\n        results.append(max(realans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "while condition and heap[0][0] == k - 1:",
      "mutated_line": "while condition and heap[0][0] == k - 0:",
      "code": "import heapq\n\ndef calculate_highest_training_score(T, N, A, B):\n    results = []\n    for t in range(T):\n        number = N[t]\n        eff = A[t]\n        b = B[t]\n        heap = []\n        tempheap = []\n        ans = 0\n        realans = [0.0]\n        k = 1\n        for i in range(number):\n            heapq.heappush(heap, [b[i], eff[i]])\n        condition1 = True\n        while tempheap or (condition1 and heap[0][0] < k):\n            condition = True\n            if not heap:\n                condition = False\n            while condition and heap[0][0] == k - 0:\n                mn = heapq.heappop(heap)\n                heapq.heappush(tempheap, [-mn[1], mn[0]])\n                if not heap:\n                    condition = False\n            if not heap:\n                condition1 = False\n            m = heapq.heappop(tempheap)\n            ans = ans + -m[0]\n            realans.append(ans / k)\n            k += 1\n        results.append(max(realans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "while condition and heap[0][0] == k - 1:",
      "mutated_line": "while condition and heap[0][0] == k - -1:",
      "code": "import heapq\n\ndef calculate_highest_training_score(T, N, A, B):\n    results = []\n    for t in range(T):\n        number = N[t]\n        eff = A[t]\n        b = B[t]\n        heap = []\n        tempheap = []\n        ans = 0\n        realans = [0.0]\n        k = 1\n        for i in range(number):\n            heapq.heappush(heap, [b[i], eff[i]])\n        condition1 = True\n        while tempheap or (condition1 and heap[0][0] < k):\n            condition = True\n            if not heap:\n                condition = False\n            while condition and heap[0][0] == k - -1:\n                mn = heapq.heappop(heap)\n                heapq.heappush(tempheap, [-mn[1], mn[0]])\n                if not heap:\n                    condition = False\n            if not heap:\n                condition1 = False\n            m = heapq.heappop(tempheap)\n            ans = ans + -m[0]\n            realans.append(ans / k)\n            k += 1\n        results.append(max(realans))\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 27,
      "original_line": "heapq.heappush(tempheap, [-mn[1], mn[0]])",
      "mutated_line": "heapq.heappush(tempheap, [+mn[1], mn[0]])",
      "code": "import heapq\n\ndef calculate_highest_training_score(T, N, A, B):\n    results = []\n    for t in range(T):\n        number = N[t]\n        eff = A[t]\n        b = B[t]\n        heap = []\n        tempheap = []\n        ans = 0\n        realans = [0.0]\n        k = 1\n        for i in range(number):\n            heapq.heappush(heap, [b[i], eff[i]])\n        condition1 = True\n        while tempheap or (condition1 and heap[0][0] < k):\n            condition = True\n            if not heap:\n                condition = False\n            while condition and heap[0][0] == k - 1:\n                mn = heapq.heappop(heap)\n                heapq.heappush(tempheap, [+mn[1], mn[0]])\n                if not heap:\n                    condition = False\n            if not heap:\n                condition1 = False\n            m = heapq.heappop(tempheap)\n            ans = ans + -m[0]\n            realans.append(ans / k)\n            k += 1\n        results.append(max(realans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "ans = ans + -m[0]",
      "mutated_line": "ans = ans + -m[1]",
      "code": "import heapq\n\ndef calculate_highest_training_score(T, N, A, B):\n    results = []\n    for t in range(T):\n        number = N[t]\n        eff = A[t]\n        b = B[t]\n        heap = []\n        tempheap = []\n        ans = 0\n        realans = [0.0]\n        k = 1\n        for i in range(number):\n            heapq.heappush(heap, [b[i], eff[i]])\n        condition1 = True\n        while tempheap or (condition1 and heap[0][0] < k):\n            condition = True\n            if not heap:\n                condition = False\n            while condition and heap[0][0] == k - 1:\n                mn = heapq.heappop(heap)\n                heapq.heappush(tempheap, [-mn[1], mn[0]])\n                if not heap:\n                    condition = False\n            if not heap:\n                condition1 = False\n            m = heapq.heappop(tempheap)\n            ans = ans + -m[1]\n            realans.append(ans / k)\n            k += 1\n        results.append(max(realans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "ans = ans + -m[0]",
      "mutated_line": "ans = ans + -m[-1]",
      "code": "import heapq\n\ndef calculate_highest_training_score(T, N, A, B):\n    results = []\n    for t in range(T):\n        number = N[t]\n        eff = A[t]\n        b = B[t]\n        heap = []\n        tempheap = []\n        ans = 0\n        realans = [0.0]\n        k = 1\n        for i in range(number):\n            heapq.heappush(heap, [b[i], eff[i]])\n        condition1 = True\n        while tempheap or (condition1 and heap[0][0] < k):\n            condition = True\n            if not heap:\n                condition = False\n            while condition and heap[0][0] == k - 1:\n                mn = heapq.heappop(heap)\n                heapq.heappush(tempheap, [-mn[1], mn[0]])\n                if not heap:\n                    condition = False\n            if not heap:\n                condition1 = False\n            m = heapq.heappop(tempheap)\n            ans = ans + -m[-1]\n            realans.append(ans / k)\n            k += 1\n        results.append(max(realans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "ans = ans + -m[0]",
      "mutated_line": "ans = ans + -m[1]",
      "code": "import heapq\n\ndef calculate_highest_training_score(T, N, A, B):\n    results = []\n    for t in range(T):\n        number = N[t]\n        eff = A[t]\n        b = B[t]\n        heap = []\n        tempheap = []\n        ans = 0\n        realans = [0.0]\n        k = 1\n        for i in range(number):\n            heapq.heappush(heap, [b[i], eff[i]])\n        condition1 = True\n        while tempheap or (condition1 and heap[0][0] < k):\n            condition = True\n            if not heap:\n                condition = False\n            while condition and heap[0][0] == k - 1:\n                mn = heapq.heappop(heap)\n                heapq.heappush(tempheap, [-mn[1], mn[0]])\n                if not heap:\n                    condition = False\n            if not heap:\n                condition1 = False\n            m = heapq.heappop(tempheap)\n            ans = ans + -m[1]\n            realans.append(ans / k)\n            k += 1\n        results.append(max(realans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "while tempheap or (condition1 and heap[0][0] < k):",
      "mutated_line": "while tempheap or (condition1 and heap[1][0] < k):",
      "code": "import heapq\n\ndef calculate_highest_training_score(T, N, A, B):\n    results = []\n    for t in range(T):\n        number = N[t]\n        eff = A[t]\n        b = B[t]\n        heap = []\n        tempheap = []\n        ans = 0\n        realans = [0.0]\n        k = 1\n        for i in range(number):\n            heapq.heappush(heap, [b[i], eff[i]])\n        condition1 = True\n        while tempheap or (condition1 and heap[1][0] < k):\n            condition = True\n            if not heap:\n                condition = False\n            while condition and heap[0][0] == k - 1:\n                mn = heapq.heappop(heap)\n                heapq.heappush(tempheap, [-mn[1], mn[0]])\n                if not heap:\n                    condition = False\n            if not heap:\n                condition1 = False\n            m = heapq.heappop(tempheap)\n            ans = ans + -m[0]\n            realans.append(ans / k)\n            k += 1\n        results.append(max(realans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "while tempheap or (condition1 and heap[0][0] < k):",
      "mutated_line": "while tempheap or (condition1 and heap[-1][0] < k):",
      "code": "import heapq\n\ndef calculate_highest_training_score(T, N, A, B):\n    results = []\n    for t in range(T):\n        number = N[t]\n        eff = A[t]\n        b = B[t]\n        heap = []\n        tempheap = []\n        ans = 0\n        realans = [0.0]\n        k = 1\n        for i in range(number):\n            heapq.heappush(heap, [b[i], eff[i]])\n        condition1 = True\n        while tempheap or (condition1 and heap[-1][0] < k):\n            condition = True\n            if not heap:\n                condition = False\n            while condition and heap[0][0] == k - 1:\n                mn = heapq.heappop(heap)\n                heapq.heappush(tempheap, [-mn[1], mn[0]])\n                if not heap:\n                    condition = False\n            if not heap:\n                condition1 = False\n            m = heapq.heappop(tempheap)\n            ans = ans + -m[0]\n            realans.append(ans / k)\n            k += 1\n        results.append(max(realans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "while tempheap or (condition1 and heap[0][0] < k):",
      "mutated_line": "while tempheap or (condition1 and heap[1][0] < k):",
      "code": "import heapq\n\ndef calculate_highest_training_score(T, N, A, B):\n    results = []\n    for t in range(T):\n        number = N[t]\n        eff = A[t]\n        b = B[t]\n        heap = []\n        tempheap = []\n        ans = 0\n        realans = [0.0]\n        k = 1\n        for i in range(number):\n            heapq.heappush(heap, [b[i], eff[i]])\n        condition1 = True\n        while tempheap or (condition1 and heap[1][0] < k):\n            condition = True\n            if not heap:\n                condition = False\n            while condition and heap[0][0] == k - 1:\n                mn = heapq.heappop(heap)\n                heapq.heappush(tempheap, [-mn[1], mn[0]])\n                if not heap:\n                    condition = False\n            if not heap:\n                condition1 = False\n            m = heapq.heappop(tempheap)\n            ans = ans + -m[0]\n            realans.append(ans / k)\n            k += 1\n        results.append(max(realans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "while condition and heap[0][0] == k - 1:",
      "mutated_line": "while condition and heap[1][0] == k - 1:",
      "code": "import heapq\n\ndef calculate_highest_training_score(T, N, A, B):\n    results = []\n    for t in range(T):\n        number = N[t]\n        eff = A[t]\n        b = B[t]\n        heap = []\n        tempheap = []\n        ans = 0\n        realans = [0.0]\n        k = 1\n        for i in range(number):\n            heapq.heappush(heap, [b[i], eff[i]])\n        condition1 = True\n        while tempheap or (condition1 and heap[0][0] < k):\n            condition = True\n            if not heap:\n                condition = False\n            while condition and heap[1][0] == k - 1:\n                mn = heapq.heappop(heap)\n                heapq.heappush(tempheap, [-mn[1], mn[0]])\n                if not heap:\n                    condition = False\n            if not heap:\n                condition1 = False\n            m = heapq.heappop(tempheap)\n            ans = ans + -m[0]\n            realans.append(ans / k)\n            k += 1\n        results.append(max(realans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "while condition and heap[0][0] == k - 1:",
      "mutated_line": "while condition and heap[-1][0] == k - 1:",
      "code": "import heapq\n\ndef calculate_highest_training_score(T, N, A, B):\n    results = []\n    for t in range(T):\n        number = N[t]\n        eff = A[t]\n        b = B[t]\n        heap = []\n        tempheap = []\n        ans = 0\n        realans = [0.0]\n        k = 1\n        for i in range(number):\n            heapq.heappush(heap, [b[i], eff[i]])\n        condition1 = True\n        while tempheap or (condition1 and heap[0][0] < k):\n            condition = True\n            if not heap:\n                condition = False\n            while condition and heap[-1][0] == k - 1:\n                mn = heapq.heappop(heap)\n                heapq.heappush(tempheap, [-mn[1], mn[0]])\n                if not heap:\n                    condition = False\n            if not heap:\n                condition1 = False\n            m = heapq.heappop(tempheap)\n            ans = ans + -m[0]\n            realans.append(ans / k)\n            k += 1\n        results.append(max(realans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "while condition and heap[0][0] == k - 1:",
      "mutated_line": "while condition and heap[1][0] == k - 1:",
      "code": "import heapq\n\ndef calculate_highest_training_score(T, N, A, B):\n    results = []\n    for t in range(T):\n        number = N[t]\n        eff = A[t]\n        b = B[t]\n        heap = []\n        tempheap = []\n        ans = 0\n        realans = [0.0]\n        k = 1\n        for i in range(number):\n            heapq.heappush(heap, [b[i], eff[i]])\n        condition1 = True\n        while tempheap or (condition1 and heap[0][0] < k):\n            condition = True\n            if not heap:\n                condition = False\n            while condition and heap[1][0] == k - 1:\n                mn = heapq.heappop(heap)\n                heapq.heappush(tempheap, [-mn[1], mn[0]])\n                if not heap:\n                    condition = False\n            if not heap:\n                condition1 = False\n            m = heapq.heappop(tempheap)\n            ans = ans + -m[0]\n            realans.append(ans / k)\n            k += 1\n        results.append(max(realans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "heapq.heappush(tempheap, [-mn[1], mn[0]])",
      "mutated_line": "heapq.heappush(tempheap, [-mn[1], mn[1]])",
      "code": "import heapq\n\ndef calculate_highest_training_score(T, N, A, B):\n    results = []\n    for t in range(T):\n        number = N[t]\n        eff = A[t]\n        b = B[t]\n        heap = []\n        tempheap = []\n        ans = 0\n        realans = [0.0]\n        k = 1\n        for i in range(number):\n            heapq.heappush(heap, [b[i], eff[i]])\n        condition1 = True\n        while tempheap or (condition1 and heap[0][0] < k):\n            condition = True\n            if not heap:\n                condition = False\n            while condition and heap[0][0] == k - 1:\n                mn = heapq.heappop(heap)\n                heapq.heappush(tempheap, [-mn[1], mn[1]])\n                if not heap:\n                    condition = False\n            if not heap:\n                condition1 = False\n            m = heapq.heappop(tempheap)\n            ans = ans + -m[0]\n            realans.append(ans / k)\n            k += 1\n        results.append(max(realans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "heapq.heappush(tempheap, [-mn[1], mn[0]])",
      "mutated_line": "heapq.heappush(tempheap, [-mn[1], mn[-1]])",
      "code": "import heapq\n\ndef calculate_highest_training_score(T, N, A, B):\n    results = []\n    for t in range(T):\n        number = N[t]\n        eff = A[t]\n        b = B[t]\n        heap = []\n        tempheap = []\n        ans = 0\n        realans = [0.0]\n        k = 1\n        for i in range(number):\n            heapq.heappush(heap, [b[i], eff[i]])\n        condition1 = True\n        while tempheap or (condition1 and heap[0][0] < k):\n            condition = True\n            if not heap:\n                condition = False\n            while condition and heap[0][0] == k - 1:\n                mn = heapq.heappop(heap)\n                heapq.heappush(tempheap, [-mn[1], mn[-1]])\n                if not heap:\n                    condition = False\n            if not heap:\n                condition1 = False\n            m = heapq.heappop(tempheap)\n            ans = ans + -m[0]\n            realans.append(ans / k)\n            k += 1\n        results.append(max(realans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "heapq.heappush(tempheap, [-mn[1], mn[0]])",
      "mutated_line": "heapq.heappush(tempheap, [-mn[1], mn[1]])",
      "code": "import heapq\n\ndef calculate_highest_training_score(T, N, A, B):\n    results = []\n    for t in range(T):\n        number = N[t]\n        eff = A[t]\n        b = B[t]\n        heap = []\n        tempheap = []\n        ans = 0\n        realans = [0.0]\n        k = 1\n        for i in range(number):\n            heapq.heappush(heap, [b[i], eff[i]])\n        condition1 = True\n        while tempheap or (condition1 and heap[0][0] < k):\n            condition = True\n            if not heap:\n                condition = False\n            while condition and heap[0][0] == k - 1:\n                mn = heapq.heappop(heap)\n                heapq.heappush(tempheap, [-mn[1], mn[1]])\n                if not heap:\n                    condition = False\n            if not heap:\n                condition1 = False\n            m = heapq.heappop(tempheap)\n            ans = ans + -m[0]\n            realans.append(ans / k)\n            k += 1\n        results.append(max(realans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "heapq.heappush(tempheap, [-mn[1], mn[0]])",
      "mutated_line": "heapq.heappush(tempheap, [-mn[2], mn[0]])",
      "code": "import heapq\n\ndef calculate_highest_training_score(T, N, A, B):\n    results = []\n    for t in range(T):\n        number = N[t]\n        eff = A[t]\n        b = B[t]\n        heap = []\n        tempheap = []\n        ans = 0\n        realans = [0.0]\n        k = 1\n        for i in range(number):\n            heapq.heappush(heap, [b[i], eff[i]])\n        condition1 = True\n        while tempheap or (condition1 and heap[0][0] < k):\n            condition = True\n            if not heap:\n                condition = False\n            while condition and heap[0][0] == k - 1:\n                mn = heapq.heappop(heap)\n                heapq.heappush(tempheap, [-mn[2], mn[0]])\n                if not heap:\n                    condition = False\n            if not heap:\n                condition1 = False\n            m = heapq.heappop(tempheap)\n            ans = ans + -m[0]\n            realans.append(ans / k)\n            k += 1\n        results.append(max(realans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "heapq.heappush(tempheap, [-mn[1], mn[0]])",
      "mutated_line": "heapq.heappush(tempheap, [-mn[0], mn[0]])",
      "code": "import heapq\n\ndef calculate_highest_training_score(T, N, A, B):\n    results = []\n    for t in range(T):\n        number = N[t]\n        eff = A[t]\n        b = B[t]\n        heap = []\n        tempheap = []\n        ans = 0\n        realans = [0.0]\n        k = 1\n        for i in range(number):\n            heapq.heappush(heap, [b[i], eff[i]])\n        condition1 = True\n        while tempheap or (condition1 and heap[0][0] < k):\n            condition = True\n            if not heap:\n                condition = False\n            while condition and heap[0][0] == k - 1:\n                mn = heapq.heappop(heap)\n                heapq.heappush(tempheap, [-mn[0], mn[0]])\n                if not heap:\n                    condition = False\n            if not heap:\n                condition1 = False\n            m = heapq.heappop(tempheap)\n            ans = ans + -m[0]\n            realans.append(ans / k)\n            k += 1\n        results.append(max(realans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "heapq.heappush(tempheap, [-mn[1], mn[0]])",
      "mutated_line": "heapq.heappush(tempheap, [-mn[0], mn[0]])",
      "code": "import heapq\n\ndef calculate_highest_training_score(T, N, A, B):\n    results = []\n    for t in range(T):\n        number = N[t]\n        eff = A[t]\n        b = B[t]\n        heap = []\n        tempheap = []\n        ans = 0\n        realans = [0.0]\n        k = 1\n        for i in range(number):\n            heapq.heappush(heap, [b[i], eff[i]])\n        condition1 = True\n        while tempheap or (condition1 and heap[0][0] < k):\n            condition = True\n            if not heap:\n                condition = False\n            while condition and heap[0][0] == k - 1:\n                mn = heapq.heappop(heap)\n                heapq.heappush(tempheap, [-mn[0], mn[0]])\n                if not heap:\n                    condition = False\n            if not heap:\n                condition1 = False\n            m = heapq.heappop(tempheap)\n            ans = ans + -m[0]\n            realans.append(ans / k)\n            k += 1\n        results.append(max(realans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "heapq.heappush(tempheap, [-mn[1], mn[0]])",
      "mutated_line": "heapq.heappush(tempheap, [-mn[-1], mn[0]])",
      "code": "import heapq\n\ndef calculate_highest_training_score(T, N, A, B):\n    results = []\n    for t in range(T):\n        number = N[t]\n        eff = A[t]\n        b = B[t]\n        heap = []\n        tempheap = []\n        ans = 0\n        realans = [0.0]\n        k = 1\n        for i in range(number):\n            heapq.heappush(heap, [b[i], eff[i]])\n        condition1 = True\n        while tempheap or (condition1 and heap[0][0] < k):\n            condition = True\n            if not heap:\n                condition = False\n            while condition and heap[0][0] == k - 1:\n                mn = heapq.heappop(heap)\n                heapq.heappush(tempheap, [-mn[-1], mn[0]])\n                if not heap:\n                    condition = False\n            if not heap:\n                condition1 = False\n            m = heapq.heappop(tempheap)\n            ans = ans + -m[0]\n            realans.append(ans / k)\n            k += 1\n        results.append(max(realans))\n    return results"
    }
  ]
}