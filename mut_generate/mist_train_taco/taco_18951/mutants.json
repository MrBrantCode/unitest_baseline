{
  "task_id": "taco_18951",
  "entry_point": "determine_winner",
  "mutant_count": 176,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "d = 0",
      "mutated_line": "d = 1",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 1\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "d = 0",
      "mutated_line": "d = -1",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = -1\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "d = 0",
      "mutated_line": "d = 1",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 1\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "used = [0] * N",
      "mutated_line": "used = [0] / N",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] / N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "used = [0] * N",
      "mutated_line": "used = [0] + N",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] + N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "used = [0] * N",
      "mutated_line": "used = [0] ** N",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] ** N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "ASR",
      "lineno": 16,
      "original_line": "d += len(G[i])",
      "mutated_line": "d -= len(G[i])",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d -= len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "ASR",
      "lineno": 30,
      "original_line": "C[c % 2] += 1",
      "mutated_line": "C[c % 2] -= 1",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] -= 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "r0 = N * (N - 1) // 2 - d // 2 & 1",
      "mutated_line": "r0 = N * (N - 1) // 2 - d // 2 | 1",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 | 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "C = [0, 0]",
      "mutated_line": "C = [1, 0]",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [1, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "C = [0, 0]",
      "mutated_line": "C = [-1, 0]",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [-1, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "C = [0, 0]",
      "mutated_line": "C = [1, 0]",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [1, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "C = [0, 0]",
      "mutated_line": "C = [0, 1]",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 1]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "C = [0, 0]",
      "mutated_line": "C = [0, -1]",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, -1]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "C = [0, 0]",
      "mutated_line": "C = [0, 1]",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 1]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "used[i] = 1",
      "mutated_line": "used[i] = 2",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 2\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "used[i] = 1",
      "mutated_line": "used[i] = 0",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 0\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "used[i] = 1",
      "mutated_line": "used[i] = 0",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 0\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "used[i] = 1",
      "mutated_line": "used[i] = -1",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = -1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "c = 0",
      "mutated_line": "c = 1",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 1\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "c = 0",
      "mutated_line": "c = -1",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = -1\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "c = 0",
      "mutated_line": "c = 1",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 1\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "ASR",
      "lineno": 24,
      "original_line": "c += 1",
      "mutated_line": "c -= 1",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c -= 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "C[c % 2] += 1",
      "mutated_line": "C[c % 2] += 2",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 2\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "C[c % 2] += 1",
      "mutated_line": "C[c % 2] += 0",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 0\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "C[c % 2] += 1",
      "mutated_line": "C[c % 2] += 0",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 0\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "C[c % 2] += 1",
      "mutated_line": "C[c % 2] += -1",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += -1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "r0 = N * (N - 1) // 2 - d // 2 & 1",
      "mutated_line": "r0 = N * (N - 1) // 2 + d // 2 & 1",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 + d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "r0 = N * (N - 1) // 2 - d // 2 & 1",
      "mutated_line": "r0 = N * (N - 1) // 2 * (d // 2) & 1",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 * (d // 2) & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "r0 = N * (N - 1) // 2 - d // 2 & 1",
      "mutated_line": "r0 = N * (N - 1) // 2 - d // 2 & 2",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 2\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "r0 = N * (N - 1) // 2 - d // 2 & 1",
      "mutated_line": "r0 = N * (N - 1) // 2 - d // 2 & 0",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 0\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "r0 = N * (N - 1) // 2 - d // 2 & 1",
      "mutated_line": "r0 = N * (N - 1) // 2 - d // 2 & 0",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 0\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "r0 = N * (N - 1) // 2 - d // 2 & 1",
      "mutated_line": "r0 = N * (N - 1) // 2 - d // 2 & -1",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & -1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if key in memo:",
      "mutated_line": "if key not in memo:",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key not in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if p + q == 2:",
      "mutated_line": "if p + q != 2:",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q != 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "r = 0",
      "mutated_line": "r = 1",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 1\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "r = 0",
      "mutated_line": "r = -1",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = -1\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "r = 0",
      "mutated_line": "r = 1",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 1\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "LCR",
      "lineno": 44,
      "original_line": "if p > 1 or (p and q):",
      "mutated_line": "if p > 1 and (p and q):",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 and (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "ROR",
      "lineno": 47,
      "original_line": "if q > 1:",
      "mutated_line": "if q >= 1:",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q >= 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "ROR",
      "lineno": 47,
      "original_line": "if q > 1:",
      "mutated_line": "if q <= 1:",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q <= 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "ROR",
      "lineno": 47,
      "original_line": "if q > 1:",
      "mutated_line": "if q != 1:",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q != 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "if dfs(0, C[0], C[1]):",
      "mutated_line": "if dfs(1, C[0], C[1]):",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(1, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "if dfs(0, C[0], C[1]):",
      "mutated_line": "if dfs(-1, C[0], C[1]):",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(-1, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "if dfs(0, C[0], C[1]):",
      "mutated_line": "if dfs(1, C[0], C[1]):",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(1, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "return 'Taro'",
      "mutated_line": "return ''",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return ''\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 57,
      "original_line": "return 'Hanako'",
      "mutated_line": "return ''",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return ''"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if grid[i][j] == 'Y':",
      "mutated_line": "if grid[i][j] != 'Y':",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] != 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "used = [0] * N",
      "mutated_line": "used = [1] * N",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [1] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "used = [0] * N",
      "mutated_line": "used = [-1] * N",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [-1] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "used = [0] * N",
      "mutated_line": "used = [1] * N",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [1] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "c += 1",
      "mutated_line": "c += 2",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 2\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "c += 1",
      "mutated_line": "c += 0",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 0\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "c += 1",
      "mutated_line": "c += 0",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 0\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "c += 1",
      "mutated_line": "c += -1",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += -1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "C[c % 2] += 1",
      "mutated_line": "C[c * 2] += 1",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c * 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "C[c % 2] += 1",
      "mutated_line": "C[c + 2] += 1",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c + 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "r0 = N * (N - 1) // 2 - d // 2 & 1",
      "mutated_line": "r0 = N * (N - 1) / 2 - d // 2 & 1",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) / 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "r0 = N * (N - 1) // 2 - d // 2 & 1",
      "mutated_line": "r0 = N * (N - 1) * 2 - d // 2 & 1",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) * 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "r0 = N * (N - 1) // 2 - d // 2 & 1",
      "mutated_line": "r0 = N * (N - 1) // 2 - d / 2 & 1",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d / 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "r0 = N * (N - 1) // 2 - d // 2 & 1",
      "mutated_line": "r0 = N * (N - 1) // 2 - d * 2 & 1",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d * 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "if p + q == 2:",
      "mutated_line": "if p - q == 2:",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p - q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "if p + q == 2:",
      "mutated_line": "if p * q == 2:",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p * q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if p + q == 2:",
      "mutated_line": "if p + q == 3:",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 3:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if p + q == 2:",
      "mutated_line": "if p + q == 1:",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 1:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if p + q == 2:",
      "mutated_line": "if p + q == 0:",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 0:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if p + q == 2:",
      "mutated_line": "if p + q == 1:",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 1:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if p + q == 2:",
      "mutated_line": "if p + q == -2:",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == -2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "r = (q == 2) ^ r0",
      "mutated_line": "r = (q == 2) | r0",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) | r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "memo[key] = e = r ^ i & 1",
      "mutated_line": "memo[key] = e = r | i & 1",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r | i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "if p > 1 or (p and q):",
      "mutated_line": "if p >= 1 or (p and q):",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p >= 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "if p > 1 or (p and q):",
      "mutated_line": "if p <= 1 or (p and q):",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p <= 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "if p > 1 or (p and q):",
      "mutated_line": "if p != 1 or (p and q):",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p != 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "LCR",
      "lineno": 44,
      "original_line": "if p > 1 or (p and q):",
      "mutated_line": "if p > 1 or (p or q):",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p or q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "if dfs(i + 1, p - 1, q) == 0:",
      "mutated_line": "if dfs(i + 1, p - 1, q) != 0:",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) != 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "if q > 1:",
      "mutated_line": "if q > 2:",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 2:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "if q > 1:",
      "mutated_line": "if q > 0:",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 0:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "if q > 1:",
      "mutated_line": "if q > 0:",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 0:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "if q > 1:",
      "mutated_line": "if q > -1:",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > -1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "ROR",
      "lineno": 48,
      "original_line": "if dfs(i + 1, p + 1, q - 2) == 0:",
      "mutated_line": "if dfs(i + 1, p + 1, q - 2) != 0:",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) != 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "if dfs(0, C[0], C[1]):",
      "mutated_line": "if dfs(0, C[1], C[1]):",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[1], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "if dfs(0, C[0], C[1]):",
      "mutated_line": "if dfs(0, C[-1], C[1]):",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[-1], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "if dfs(0, C[0], C[1]):",
      "mutated_line": "if dfs(0, C[1], C[1]):",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[1], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "if dfs(0, C[0], C[1]):",
      "mutated_line": "if dfs(0, C[0], C[2]):",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[2]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "if dfs(0, C[0], C[1]):",
      "mutated_line": "if dfs(0, C[0], C[0]):",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[0]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "if dfs(0, C[0], C[1]):",
      "mutated_line": "if dfs(0, C[0], C[0]):",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[0]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "if dfs(0, C[0], C[1]):",
      "mutated_line": "if dfs(0, C[0], C[-1]):",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[-1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if grid[i][j] == 'Y':",
      "mutated_line": "if grid[i][j] == '':",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == '':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "used[w] = 1",
      "mutated_line": "used[w] = 2",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 2\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "used[w] = 1",
      "mutated_line": "used[w] = 0",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 0\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "used[w] = 1",
      "mutated_line": "used[w] = 0",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 0\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "used[w] = 1",
      "mutated_line": "used[w] = -1",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = -1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "C[c % 2] += 1",
      "mutated_line": "C[c % 3] += 1",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 3] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "C[c % 2] += 1",
      "mutated_line": "C[c % 1] += 1",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 1] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "C[c % 2] += 1",
      "mutated_line": "C[c % 0] += 1",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 0] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "C[c % 2] += 1",
      "mutated_line": "C[c % 1] += 1",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 1] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "C[c % 2] += 1",
      "mutated_line": "C[c % -2] += 1",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % -2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "r0 = N * (N - 1) // 2 - d // 2 & 1",
      "mutated_line": "r0 = N / (N - 1) // 2 - d // 2 & 1",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N / (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "r0 = N * (N - 1) // 2 - d // 2 & 1",
      "mutated_line": "r0 = (N + (N - 1)) // 2 - d // 2 & 1",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = (N + (N - 1)) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "r0 = N * (N - 1) // 2 - d // 2 & 1",
      "mutated_line": "r0 = N ** (N - 1) // 2 - d // 2 & 1",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N ** (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "r0 = N * (N - 1) // 2 - d // 2 & 1",
      "mutated_line": "r0 = N * (N - 1) // 3 - d // 2 & 1",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 3 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "r0 = N * (N - 1) // 2 - d // 2 & 1",
      "mutated_line": "r0 = N * (N - 1) // 1 - d // 2 & 1",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 1 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "r0 = N * (N - 1) // 2 - d // 2 & 1",
      "mutated_line": "r0 = N * (N - 1) // 0 - d // 2 & 1",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 0 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "r0 = N * (N - 1) // 2 - d // 2 & 1",
      "mutated_line": "r0 = N * (N - 1) // 1 - d // 2 & 1",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 1 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "r0 = N * (N - 1) // 2 - d // 2 & 1",
      "mutated_line": "r0 = N * (N - 1) // -2 - d // 2 & 1",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // -2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "r0 = N * (N - 1) // 2 - d // 2 & 1",
      "mutated_line": "r0 = N * (N - 1) // 2 - d // 3 & 1",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 3 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "r0 = N * (N - 1) // 2 - d // 2 & 1",
      "mutated_line": "r0 = N * (N - 1) // 2 - d // 1 & 1",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 1 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "r0 = N * (N - 1) // 2 - d // 2 & 1",
      "mutated_line": "r0 = N * (N - 1) // 2 - d // 0 & 1",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 0 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "r0 = N * (N - 1) // 2 - d // 2 & 1",
      "mutated_line": "r0 = N * (N - 1) // 2 - d // 1 & 1",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 1 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "r0 = N * (N - 1) // 2 - d // 2 & 1",
      "mutated_line": "r0 = N * (N - 1) // 2 - d // -2 & 1",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // -2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "r = (q == 2) ^ r0",
      "mutated_line": "r = (q != 2) ^ r0",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q != 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "memo[key] = e = r ^ i & 1",
      "mutated_line": "memo[key] = e = r ^ (i | 1)",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ (i | 1)\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if p > 1 or (p and q):",
      "mutated_line": "if p > 2 or (p and q):",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 2 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if p > 1 or (p and q):",
      "mutated_line": "if p > 0 or (p and q):",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 0 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if p > 1 or (p and q):",
      "mutated_line": "if p > 0 or (p and q):",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 0 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if p > 1 or (p and q):",
      "mutated_line": "if p > -1 or (p and q):",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > -1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if dfs(i + 1, p - 1, q) == 0:",
      "mutated_line": "if dfs(i + 1, p - 1, q) == 1:",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 1:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if dfs(i + 1, p - 1, q) == 0:",
      "mutated_line": "if dfs(i + 1, p - 1, q) == -1:",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == -1:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if dfs(i + 1, p - 1, q) == 0:",
      "mutated_line": "if dfs(i + 1, p - 1, q) == 1:",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 1:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "r = 1",
      "mutated_line": "r = 2",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 2\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "r = 1",
      "mutated_line": "r = 0",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 0\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "r = 1",
      "mutated_line": "r = 0",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 0\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "r = 1",
      "mutated_line": "r = -1",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = -1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "if dfs(i + 1, p + 1, q - 2) == 0:",
      "mutated_line": "if dfs(i + 1, p + 1, q - 2) == 1:",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 1:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "if dfs(i + 1, p + 1, q - 2) == 0:",
      "mutated_line": "if dfs(i + 1, p + 1, q - 2) == -1:",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == -1:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "if dfs(i + 1, p + 1, q - 2) == 0:",
      "mutated_line": "if dfs(i + 1, p + 1, q - 2) == 1:",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 1:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "r = 1",
      "mutated_line": "r = 2",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 2\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "r = 1",
      "mutated_line": "r = 0",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 0\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "r = 1",
      "mutated_line": "r = 0",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 0\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "r = 1",
      "mutated_line": "r = -1",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = -1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "r0 = N * (N - 1) // 2 - d // 2 & 1",
      "mutated_line": "r0 = N * (N + 1) // 2 - d // 2 & 1",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N + 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "r0 = N * (N - 1) // 2 - d // 2 & 1",
      "mutated_line": "r0 = N * (N * 1) // 2 - d // 2 & 1",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N * 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "r = (q == 2) ^ r0",
      "mutated_line": "r = (q == 3) ^ r0",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 3) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "r = (q == 2) ^ r0",
      "mutated_line": "r = (q == 1) ^ r0",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 1) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "r = (q == 2) ^ r0",
      "mutated_line": "r = (q == 0) ^ r0",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 0) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "r = (q == 2) ^ r0",
      "mutated_line": "r = (q == 1) ^ r0",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 1) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "r = (q == 2) ^ r0",
      "mutated_line": "r = (q == -2) ^ r0",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == -2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "memo[key] = e = r ^ i & 1",
      "mutated_line": "memo[key] = e = r ^ i & 2",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 2\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "memo[key] = e = r ^ i & 1",
      "mutated_line": "memo[key] = e = r ^ i & 0",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 0\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "memo[key] = e = r ^ i & 1",
      "mutated_line": "memo[key] = e = r ^ i & 0",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 0\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "memo[key] = e = r ^ i & 1",
      "mutated_line": "memo[key] = e = r ^ i & -1",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & -1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "if dfs(i + 1, p - 1, q) == 0:",
      "mutated_line": "if dfs(i - 1, p - 1, q) == 0:",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i - 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "if dfs(i + 1, p - 1, q) == 0:",
      "mutated_line": "if dfs(i * 1, p - 1, q) == 0:",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i * 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "if dfs(i + 1, p - 1, q) == 0:",
      "mutated_line": "if dfs(i + 1, p + 1, q) == 0:",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p + 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "if dfs(i + 1, p - 1, q) == 0:",
      "mutated_line": "if dfs(i + 1, p * 1, q) == 0:",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p * 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "if dfs(i + 1, p + 1, q - 2) == 0:",
      "mutated_line": "if dfs(i - 1, p + 1, q - 2) == 0:",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i - 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "if dfs(i + 1, p + 1, q - 2) == 0:",
      "mutated_line": "if dfs(i * 1, p + 1, q - 2) == 0:",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i * 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "if dfs(i + 1, p + 1, q - 2) == 0:",
      "mutated_line": "if dfs(i + 1, p - 1, q - 2) == 0:",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p - 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "if dfs(i + 1, p + 1, q - 2) == 0:",
      "mutated_line": "if dfs(i + 1, p * 1, q - 2) == 0:",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p * 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "if dfs(i + 1, p + 1, q - 2) == 0:",
      "mutated_line": "if dfs(i + 1, p + 1, q + 2) == 0:",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q + 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "if dfs(i + 1, p + 1, q - 2) == 0:",
      "mutated_line": "if dfs(i + 1, p + 1, q * 2) == 0:",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q * 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "r0 = N * (N - 1) // 2 - d // 2 & 1",
      "mutated_line": "r0 = N * (N - 2) // 2 - d // 2 & 1",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 2) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "r0 = N * (N - 1) // 2 - d // 2 & 1",
      "mutated_line": "r0 = N * (N - 0) // 2 - d // 2 & 1",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 0) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "r0 = N * (N - 1) // 2 - d // 2 & 1",
      "mutated_line": "r0 = N * (N - 0) // 2 - d // 2 & 1",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 0) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "r0 = N * (N - 1) // 2 - d // 2 & 1",
      "mutated_line": "r0 = N * (N - -1) // 2 - d // 2 & 1",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - -1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if dfs(i + 1, p - 1, q) == 0:",
      "mutated_line": "if dfs(i + 2, p - 1, q) == 0:",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 2, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if dfs(i + 1, p - 1, q) == 0:",
      "mutated_line": "if dfs(i + 0, p - 1, q) == 0:",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 0, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if dfs(i + 1, p - 1, q) == 0:",
      "mutated_line": "if dfs(i + 0, p - 1, q) == 0:",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 0, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if dfs(i + 1, p - 1, q) == 0:",
      "mutated_line": "if dfs(i + -1, p - 1, q) == 0:",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + -1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if dfs(i + 1, p - 1, q) == 0:",
      "mutated_line": "if dfs(i + 1, p - 2, q) == 0:",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 2, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if dfs(i + 1, p - 1, q) == 0:",
      "mutated_line": "if dfs(i + 1, p - 0, q) == 0:",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 0, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if dfs(i + 1, p - 1, q) == 0:",
      "mutated_line": "if dfs(i + 1, p - 0, q) == 0:",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 0, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if dfs(i + 1, p - 1, q) == 0:",
      "mutated_line": "if dfs(i + 1, p - -1, q) == 0:",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - -1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "if dfs(i + 1, p + 1, q - 2) == 0:",
      "mutated_line": "if dfs(i + 2, p + 1, q - 2) == 0:",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 2, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "if dfs(i + 1, p + 1, q - 2) == 0:",
      "mutated_line": "if dfs(i + 0, p + 1, q - 2) == 0:",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 0, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "if dfs(i + 1, p + 1, q - 2) == 0:",
      "mutated_line": "if dfs(i + 0, p + 1, q - 2) == 0:",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 0, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "if dfs(i + 1, p + 1, q - 2) == 0:",
      "mutated_line": "if dfs(i + -1, p + 1, q - 2) == 0:",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + -1, p + 1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "if dfs(i + 1, p + 1, q - 2) == 0:",
      "mutated_line": "if dfs(i + 1, p + 2, q - 2) == 0:",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 2, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "if dfs(i + 1, p + 1, q - 2) == 0:",
      "mutated_line": "if dfs(i + 1, p + 0, q - 2) == 0:",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 0, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "if dfs(i + 1, p + 1, q - 2) == 0:",
      "mutated_line": "if dfs(i + 1, p + 0, q - 2) == 0:",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 0, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "if dfs(i + 1, p + 1, q - 2) == 0:",
      "mutated_line": "if dfs(i + 1, p + -1, q - 2) == 0:",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + -1, q - 2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "if dfs(i + 1, p + 1, q - 2) == 0:",
      "mutated_line": "if dfs(i + 1, p + 1, q - 3) == 0:",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 3) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "if dfs(i + 1, p + 1, q - 2) == 0:",
      "mutated_line": "if dfs(i + 1, p + 1, q - 1) == 0:",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 1) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "if dfs(i + 1, p + 1, q - 2) == 0:",
      "mutated_line": "if dfs(i + 1, p + 1, q - 0) == 0:",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 0) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "if dfs(i + 1, p + 1, q - 2) == 0:",
      "mutated_line": "if dfs(i + 1, p + 1, q - 1) == 0:",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - 1) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "if dfs(i + 1, p + 1, q - 2) == 0:",
      "mutated_line": "if dfs(i + 1, p + 1, q - -2) == 0:",
      "code": "def determine_winner(N, grid):\n    from collections import deque\n    G = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'Y':\n                G[i].append(j)\n    d = 0\n    C = [0, 0]\n    used = [0] * N\n    for i in range(N):\n        d += len(G[i])\n        if used[i]:\n            continue\n        used[i] = 1\n        que = deque([i])\n        c = 0\n        while que:\n            v = que.popleft()\n            c += 1\n            for w in G[v]:\n                if used[w]:\n                    continue\n                used[w] = 1\n                que.append(w)\n        C[c % 2] += 1\n    r0 = N * (N - 1) // 2 - d // 2 & 1\n    memo = {}\n\n    def dfs(i, p, q):\n        key = (p, q)\n        if key in memo:\n            return memo[key]\n        if p + q == 2:\n            r = (q == 2) ^ r0\n            memo[key] = e = r ^ i & 1\n            return e\n        r = 0\n        if p > 1 or (p and q):\n            if dfs(i + 1, p - 1, q) == 0:\n                r = 1\n        if q > 1:\n            if dfs(i + 1, p + 1, q - -2) == 0:\n                r = 1\n        memo[key] = r\n        return r\n    if dfs(0, C[0], C[1]):\n        return 'Taro'\n    else:\n        return 'Hanako'"
    }
  ]
}