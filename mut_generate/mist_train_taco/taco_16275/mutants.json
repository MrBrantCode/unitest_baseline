{
  "task_id": "taco_16275",
  "entry_point": "lexicographically_smallest_permutation",
  "mutant_count": 119,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "in_degree = [0] * (n + 1)",
      "mutated_line": "in_degree = [0] / (n + 1)",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] / (n + 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += 1\n    result = [0] * (n + 1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n + 1)]\n    return permutation"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "in_degree = [0] * (n + 1)",
      "mutated_line": "in_degree = [0] + (n + 1)",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] + (n + 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += 1\n    result = [0] * (n + 1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n + 1)]\n    return permutation"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "in_degree = [0] * (n + 1)",
      "mutated_line": "in_degree = [0] ** (n + 1)",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] ** (n + 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += 1\n    result = [0] * (n + 1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n + 1)]\n    return permutation"
    },
    {
      "operator": "ASR",
      "lineno": 11,
      "original_line": "in_degree[v] += 1",
      "mutated_line": "in_degree[v] -= 1",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] -= 1\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += 1\n    result = [0] * (n + 1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n + 1)]\n    return permutation"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "cnt = 0",
      "mutated_line": "cnt = 1",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 1\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += 1\n    result = [0] * (n + 1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n + 1)]\n    return permutation"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "cnt = 0",
      "mutated_line": "cnt = -1",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = -1\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += 1\n    result = [0] * (n + 1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n + 1)]\n    return permutation"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "cnt = 0",
      "mutated_line": "cnt = 1",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 1\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += 1\n    result = [0] * (n + 1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n + 1)]\n    return permutation"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "result = [0] * (n + 1)",
      "mutated_line": "result = [0] / (n + 1)",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += 1\n    result = [0] / (n + 1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n + 1)]\n    return permutation"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "result = [0] * (n + 1)",
      "mutated_line": "result = [0] + (n + 1)",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += 1\n    result = [0] + (n + 1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n + 1)]\n    return permutation"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "result = [0] * (n + 1)",
      "mutated_line": "result = [0] ** (n + 1)",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += 1\n    result = [0] ** (n + 1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n + 1)]\n    return permutation"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "while cnt > 0:",
      "mutated_line": "while cnt >= 0:",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += 1\n    result = [0] * (n + 1)\n    num = n\n    while cnt >= 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n + 1)]\n    return permutation"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "while cnt > 0:",
      "mutated_line": "while cnt <= 0:",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += 1\n    result = [0] * (n + 1)\n    num = n\n    while cnt <= 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n + 1)]\n    return permutation"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "while cnt > 0:",
      "mutated_line": "while cnt != 0:",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += 1\n    result = [0] * (n + 1)\n    num = n\n    while cnt != 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n + 1)]\n    return permutation"
    },
    {
      "operator": "ASR",
      "lineno": 30,
      "original_line": "v *= -1",
      "mutated_line": "v /= -1",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += 1\n    result = [0] * (n + 1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v /= -1\n        result[v] = num\n        cnt -= 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n + 1)]\n    return permutation"
    },
    {
      "operator": "ASR",
      "lineno": 32,
      "original_line": "cnt -= 1",
      "mutated_line": "cnt += 1",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += 1\n    result = [0] * (n + 1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt += 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n + 1)]\n    return permutation"
    },
    {
      "operator": "ASR",
      "lineno": 33,
      "original_line": "num -= 1",
      "mutated_line": "num += 1",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += 1\n    result = [0] * (n + 1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 1\n        num += 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n + 1)]\n    return permutation"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "in_degree = [0] * (n + 1)",
      "mutated_line": "in_degree = [0] * (n - 1)",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n - 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += 1\n    result = [0] * (n + 1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n + 1)]\n    return permutation"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "in_degree = [0] * (n + 1)",
      "mutated_line": "in_degree = [0] * (n * 1)",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n * 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += 1\n    result = [0] * (n + 1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n + 1)]\n    return permutation"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "in_degree[v] += 1",
      "mutated_line": "in_degree[v] += 2",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 2\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += 1\n    result = [0] * (n + 1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n + 1)]\n    return permutation"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "in_degree[v] += 1",
      "mutated_line": "in_degree[v] += 0",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 0\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += 1\n    result = [0] * (n + 1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n + 1)]\n    return permutation"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "in_degree[v] += 1",
      "mutated_line": "in_degree[v] += 0",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 0\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += 1\n    result = [0] * (n + 1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n + 1)]\n    return permutation"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "in_degree[v] += 1",
      "mutated_line": "in_degree[v] += -1",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += -1\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += 1\n    result = [0] * (n + 1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n + 1)]\n    return permutation"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(2, n + 1):",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(2, n + 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += 1\n    result = [0] * (n + 1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n + 1)]\n    return permutation"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(0, n + 1):",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(0, n + 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += 1\n    result = [0] * (n + 1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n + 1)]\n    return permutation"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(0, n + 1):",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(0, n + 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += 1\n    result = [0] * (n + 1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n + 1)]\n    return permutation"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(-1, n + 1):",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(-1, n + 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += 1\n    result = [0] * (n + 1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n + 1)]\n    return permutation"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n - 1):",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n - 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += 1\n    result = [0] * (n + 1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n + 1)]\n    return permutation"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n * 1):",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n * 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += 1\n    result = [0] * (n + 1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n + 1)]\n    return permutation"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if in_degree[i] == 0:",
      "mutated_line": "if in_degree[i] != 0:",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + 1):\n        if in_degree[i] != 0:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += 1\n    result = [0] * (n + 1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n + 1)]\n    return permutation"
    },
    {
      "operator": "ASR",
      "lineno": 21,
      "original_line": "cnt += 1",
      "mutated_line": "cnt -= 1",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt -= 1\n    result = [0] * (n + 1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n + 1)]\n    return permutation"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "result = [0] * (n + 1)",
      "mutated_line": "result = [0] * (n - 1)",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += 1\n    result = [0] * (n - 1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n + 1)]\n    return permutation"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "result = [0] * (n + 1)",
      "mutated_line": "result = [0] * (n * 1)",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += 1\n    result = [0] * (n * 1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n + 1)]\n    return permutation"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "while cnt > 0:",
      "mutated_line": "while cnt > 1:",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += 1\n    result = [0] * (n + 1)\n    num = n\n    while cnt > 1:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n + 1)]\n    return permutation"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "while cnt > 0:",
      "mutated_line": "while cnt > -1:",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += 1\n    result = [0] * (n + 1)\n    num = n\n    while cnt > -1:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n + 1)]\n    return permutation"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "while cnt > 0:",
      "mutated_line": "while cnt > 1:",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += 1\n    result = [0] * (n + 1)\n    num = n\n    while cnt > 1:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n + 1)]\n    return permutation"
    },
    {
      "operator": "UOI",
      "lineno": 30,
      "original_line": "v *= -1",
      "mutated_line": "v *= +1",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += 1\n    result = [0] * (n + 1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= +1\n        result[v] = num\n        cnt -= 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n + 1)]\n    return permutation"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "cnt -= 1",
      "mutated_line": "cnt -= 2",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += 1\n    result = [0] * (n + 1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 2\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n + 1)]\n    return permutation"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "cnt -= 1",
      "mutated_line": "cnt -= 0",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += 1\n    result = [0] * (n + 1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 0\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n + 1)]\n    return permutation"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "cnt -= 1",
      "mutated_line": "cnt -= 0",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += 1\n    result = [0] * (n + 1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 0\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n + 1)]\n    return permutation"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "cnt -= 1",
      "mutated_line": "cnt -= -1",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += 1\n    result = [0] * (n + 1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= -1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n + 1)]\n    return permutation"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "num -= 1",
      "mutated_line": "num -= 2",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += 1\n    result = [0] * (n + 1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 1\n        num -= 2\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n + 1)]\n    return permutation"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "num -= 1",
      "mutated_line": "num -= 0",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += 1\n    result = [0] * (n + 1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 1\n        num -= 0\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n + 1)]\n    return permutation"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "num -= 1",
      "mutated_line": "num -= 0",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += 1\n    result = [0] * (n + 1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 1\n        num -= 0\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n + 1)]\n    return permutation"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "num -= 1",
      "mutated_line": "num -= -1",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += 1\n    result = [0] * (n + 1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 1\n        num -= -1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n + 1)]\n    return permutation"
    },
    {
      "operator": "ASR",
      "lineno": 36,
      "original_line": "in_degree[to] -= 1",
      "mutated_line": "in_degree[to] += 1",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += 1\n    result = [0] * (n + 1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] += 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n + 1)]\n    return permutation"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "in_degree = [0] * (n + 1)",
      "mutated_line": "in_degree = [1] * (n + 1)",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [1] * (n + 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += 1\n    result = [0] * (n + 1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n + 1)]\n    return permutation"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "in_degree = [0] * (n + 1)",
      "mutated_line": "in_degree = [-1] * (n + 1)",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [-1] * (n + 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += 1\n    result = [0] * (n + 1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n + 1)]\n    return permutation"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "in_degree = [0] * (n + 1)",
      "mutated_line": "in_degree = [1] * (n + 1)",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [1] * (n + 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += 1\n    result = [0] * (n + 1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n + 1)]\n    return permutation"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "in_degree = [0] * (n + 1)",
      "mutated_line": "in_degree = [0] * (n + 2)",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 2)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += 1\n    result = [0] * (n + 1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n + 1)]\n    return permutation"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "in_degree = [0] * (n + 1)",
      "mutated_line": "in_degree = [0] * (n + 0)",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 0)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += 1\n    result = [0] * (n + 1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n + 1)]\n    return permutation"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "in_degree = [0] * (n + 1)",
      "mutated_line": "in_degree = [0] * (n + 0)",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 0)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += 1\n    result = [0] * (n + 1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n + 1)]\n    return permutation"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "in_degree = [0] * (n + 1)",
      "mutated_line": "in_degree = [0] * (n + -1)",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + -1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += 1\n    result = [0] * (n + 1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n + 1)]\n    return permutation"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + 2):",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + 2):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += 1\n    result = [0] * (n + 1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n + 1)]\n    return permutation"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + 0):",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + 0):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += 1\n    result = [0] * (n + 1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n + 1)]\n    return permutation"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + 0):",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + 0):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += 1\n    result = [0] * (n + 1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n + 1)]\n    return permutation"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + -1):",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + -1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += 1\n    result = [0] * (n + 1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n + 1)]\n    return permutation"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if in_degree[i] == 0:",
      "mutated_line": "if in_degree[i] == 1:",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + 1):\n        if in_degree[i] == 1:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += 1\n    result = [0] * (n + 1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n + 1)]\n    return permutation"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if in_degree[i] == 0:",
      "mutated_line": "if in_degree[i] == -1:",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + 1):\n        if in_degree[i] == -1:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += 1\n    result = [0] * (n + 1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n + 1)]\n    return permutation"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if in_degree[i] == 0:",
      "mutated_line": "if in_degree[i] == 1:",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + 1):\n        if in_degree[i] == 1:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += 1\n    result = [0] * (n + 1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n + 1)]\n    return permutation"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "cnt += 1",
      "mutated_line": "cnt += 2",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += 2\n    result = [0] * (n + 1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n + 1)]\n    return permutation"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "cnt += 1",
      "mutated_line": "cnt += 0",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += 0\n    result = [0] * (n + 1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n + 1)]\n    return permutation"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "cnt += 1",
      "mutated_line": "cnt += 0",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += 0\n    result = [0] * (n + 1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n + 1)]\n    return permutation"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "cnt += 1",
      "mutated_line": "cnt += -1",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += -1\n    result = [0] * (n + 1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n + 1)]\n    return permutation"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "result = [0] * (n + 1)",
      "mutated_line": "result = [1] * (n + 1)",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += 1\n    result = [1] * (n + 1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n + 1)]\n    return permutation"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "result = [0] * (n + 1)",
      "mutated_line": "result = [-1] * (n + 1)",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += 1\n    result = [-1] * (n + 1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n + 1)]\n    return permutation"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "result = [0] * (n + 1)",
      "mutated_line": "result = [1] * (n + 1)",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += 1\n    result = [1] * (n + 1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n + 1)]\n    return permutation"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "result = [0] * (n + 1)",
      "mutated_line": "result = [0] * (n + 2)",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += 1\n    result = [0] * (n + 2)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n + 1)]\n    return permutation"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "result = [0] * (n + 1)",
      "mutated_line": "result = [0] * (n + 0)",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += 1\n    result = [0] * (n + 0)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n + 1)]\n    return permutation"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "result = [0] * (n + 1)",
      "mutated_line": "result = [0] * (n + 0)",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += 1\n    result = [0] * (n + 0)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n + 1)]\n    return permutation"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "result = [0] * (n + 1)",
      "mutated_line": "result = [0] * (n + -1)",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += 1\n    result = [0] * (n + -1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n + 1)]\n    return permutation"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "v *= -1",
      "mutated_line": "v *= -2",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += 1\n    result = [0] * (n + 1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -2\n        result[v] = num\n        cnt -= 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n + 1)]\n    return permutation"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "v *= -1",
      "mutated_line": "v *= -0",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += 1\n    result = [0] * (n + 1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -0\n        result[v] = num\n        cnt -= 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n + 1)]\n    return permutation"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "v *= -1",
      "mutated_line": "v *= -0",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += 1\n    result = [0] * (n + 1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -0\n        result[v] = num\n        cnt -= 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n + 1)]\n    return permutation"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "v *= -1",
      "mutated_line": "v *= --1",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += 1\n    result = [0] * (n + 1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= --1\n        result[v] = num\n        cnt -= 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n + 1)]\n    return permutation"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "in_degree[to] -= 1",
      "mutated_line": "in_degree[to] -= 2",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += 1\n    result = [0] * (n + 1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 2\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n + 1)]\n    return permutation"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "in_degree[to] -= 1",
      "mutated_line": "in_degree[to] -= 0",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += 1\n    result = [0] * (n + 1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 0\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n + 1)]\n    return permutation"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "in_degree[to] -= 1",
      "mutated_line": "in_degree[to] -= 0",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += 1\n    result = [0] * (n + 1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 0\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n + 1)]\n    return permutation"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "in_degree[to] -= 1",
      "mutated_line": "in_degree[to] -= -1",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += 1\n    result = [0] * (n + 1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= -1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n + 1)]\n    return permutation"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if in_degree[to] == 0:",
      "mutated_line": "if in_degree[to] != 0:",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += 1\n    result = [0] * (n + 1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] != 0:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n + 1)]\n    return permutation"
    },
    {
      "operator": "ASR",
      "lineno": 39,
      "original_line": "cnt += 1",
      "mutated_line": "cnt -= 1",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += 1\n    result = [0] * (n + 1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt -= 1\n    permutation = [result[i] for i in range(1, n + 1)]\n    return permutation"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "adjacency_list = [[] for _ in range(n + 1)]",
      "mutated_line": "adjacency_list = [[] for _ in range(n - 1)]",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 1)\n    adjacency_list = [[] for _ in range(n - 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += 1\n    result = [0] * (n + 1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n + 1)]\n    return permutation"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "adjacency_list = [[] for _ in range(n + 1)]",
      "mutated_line": "adjacency_list = [[] for _ in range(n * 1)]",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 1)\n    adjacency_list = [[] for _ in range(n * 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += 1\n    result = [0] * (n + 1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n + 1)]\n    return permutation"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "heapq.heappush(priority_queue, -1 * i)",
      "mutated_line": "heapq.heappush(priority_queue, -1 / i)",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -1 / i)\n            cnt += 1\n    result = [0] * (n + 1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n + 1)]\n    return permutation"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "heapq.heappush(priority_queue, -1 * i)",
      "mutated_line": "heapq.heappush(priority_queue, -1 + i)",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -1 + i)\n            cnt += 1\n    result = [0] * (n + 1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n + 1)]\n    return permutation"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "heapq.heappush(priority_queue, -1 * i)",
      "mutated_line": "heapq.heappush(priority_queue, (-1) ** i)",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, (-1) ** i)\n            cnt += 1\n    result = [0] * (n + 1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n + 1)]\n    return permutation"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if in_degree[to] == 0:",
      "mutated_line": "if in_degree[to] == 1:",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += 1\n    result = [0] * (n + 1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 1:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n + 1)]\n    return permutation"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if in_degree[to] == 0:",
      "mutated_line": "if in_degree[to] == -1:",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += 1\n    result = [0] * (n + 1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == -1:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n + 1)]\n    return permutation"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if in_degree[to] == 0:",
      "mutated_line": "if in_degree[to] == 1:",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += 1\n    result = [0] * (n + 1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 1:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n + 1)]\n    return permutation"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "cnt += 1",
      "mutated_line": "cnt += 2",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += 1\n    result = [0] * (n + 1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += 2\n    permutation = [result[i] for i in range(1, n + 1)]\n    return permutation"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "cnt += 1",
      "mutated_line": "cnt += 0",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += 1\n    result = [0] * (n + 1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += 0\n    permutation = [result[i] for i in range(1, n + 1)]\n    return permutation"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "cnt += 1",
      "mutated_line": "cnt += 0",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += 1\n    result = [0] * (n + 1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += 0\n    permutation = [result[i] for i in range(1, n + 1)]\n    return permutation"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "cnt += 1",
      "mutated_line": "cnt += -1",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += 1\n    result = [0] * (n + 1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += -1\n    permutation = [result[i] for i in range(1, n + 1)]\n    return permutation"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "permutation = [result[i] for i in range(1, n + 1)]",
      "mutated_line": "permutation = [result[i] for i in range(2, n + 1)]",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += 1\n    result = [0] * (n + 1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(2, n + 1)]\n    return permutation"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "permutation = [result[i] for i in range(1, n + 1)]",
      "mutated_line": "permutation = [result[i] for i in range(0, n + 1)]",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += 1\n    result = [0] * (n + 1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(0, n + 1)]\n    return permutation"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "permutation = [result[i] for i in range(1, n + 1)]",
      "mutated_line": "permutation = [result[i] for i in range(0, n + 1)]",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += 1\n    result = [0] * (n + 1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(0, n + 1)]\n    return permutation"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "permutation = [result[i] for i in range(1, n + 1)]",
      "mutated_line": "permutation = [result[i] for i in range(-1, n + 1)]",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += 1\n    result = [0] * (n + 1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(-1, n + 1)]\n    return permutation"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "permutation = [result[i] for i in range(1, n + 1)]",
      "mutated_line": "permutation = [result[i] for i in range(1, n - 1)]",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += 1\n    result = [0] * (n + 1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n - 1)]\n    return permutation"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "permutation = [result[i] for i in range(1, n + 1)]",
      "mutated_line": "permutation = [result[i] for i in range(1, n * 1)]",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += 1\n    result = [0] * (n + 1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n * 1)]\n    return permutation"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "adjacency_list = [[] for _ in range(n + 1)]",
      "mutated_line": "adjacency_list = [[] for _ in range(n + 2)]",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 1)\n    adjacency_list = [[] for _ in range(n + 2)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += 1\n    result = [0] * (n + 1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n + 1)]\n    return permutation"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "adjacency_list = [[] for _ in range(n + 1)]",
      "mutated_line": "adjacency_list = [[] for _ in range(n + 0)]",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 1)\n    adjacency_list = [[] for _ in range(n + 0)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += 1\n    result = [0] * (n + 1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n + 1)]\n    return permutation"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "adjacency_list = [[] for _ in range(n + 1)]",
      "mutated_line": "adjacency_list = [[] for _ in range(n + 0)]",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 1)\n    adjacency_list = [[] for _ in range(n + 0)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += 1\n    result = [0] * (n + 1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n + 1)]\n    return permutation"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "adjacency_list = [[] for _ in range(n + 1)]",
      "mutated_line": "adjacency_list = [[] for _ in range(n + -1)]",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 1)\n    adjacency_list = [[] for _ in range(n + -1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += 1\n    result = [0] * (n + 1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n + 1)]\n    return permutation"
    },
    {
      "operator": "UOI",
      "lineno": 20,
      "original_line": "heapq.heappush(priority_queue, -1 * i)",
      "mutated_line": "heapq.heappush(priority_queue, +1 * i)",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, +1 * i)\n            cnt += 1\n    result = [0] * (n + 1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n + 1)]\n    return permutation"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "heapq.heappush(priority_queue, -1 * to)",
      "mutated_line": "heapq.heappush(priority_queue, -1 / to)",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += 1\n    result = [0] * (n + 1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -1 / to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n + 1)]\n    return permutation"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "heapq.heappush(priority_queue, -1 * to)",
      "mutated_line": "heapq.heappush(priority_queue, -1 + to)",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += 1\n    result = [0] * (n + 1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -1 + to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n + 1)]\n    return permutation"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "heapq.heappush(priority_queue, -1 * to)",
      "mutated_line": "heapq.heappush(priority_queue, (-1) ** to)",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += 1\n    result = [0] * (n + 1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, (-1) ** to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n + 1)]\n    return permutation"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "permutation = [result[i] for i in range(1, n + 1)]",
      "mutated_line": "permutation = [result[i] for i in range(1, n + 2)]",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += 1\n    result = [0] * (n + 1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n + 2)]\n    return permutation"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "permutation = [result[i] for i in range(1, n + 1)]",
      "mutated_line": "permutation = [result[i] for i in range(1, n + 0)]",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += 1\n    result = [0] * (n + 1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n + 0)]\n    return permutation"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "permutation = [result[i] for i in range(1, n + 1)]",
      "mutated_line": "permutation = [result[i] for i in range(1, n + 0)]",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += 1\n    result = [0] * (n + 1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n + 0)]\n    return permutation"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "permutation = [result[i] for i in range(1, n + 1)]",
      "mutated_line": "permutation = [result[i] for i in range(1, n + -1)]",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += 1\n    result = [0] * (n + 1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n + -1)]\n    return permutation"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "heapq.heappush(priority_queue, -1 * i)",
      "mutated_line": "heapq.heappush(priority_queue, -2 * i)",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -2 * i)\n            cnt += 1\n    result = [0] * (n + 1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n + 1)]\n    return permutation"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "heapq.heappush(priority_queue, -1 * i)",
      "mutated_line": "heapq.heappush(priority_queue, -0 * i)",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -0 * i)\n            cnt += 1\n    result = [0] * (n + 1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n + 1)]\n    return permutation"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "heapq.heappush(priority_queue, -1 * i)",
      "mutated_line": "heapq.heappush(priority_queue, -0 * i)",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -0 * i)\n            cnt += 1\n    result = [0] * (n + 1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n + 1)]\n    return permutation"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "heapq.heappush(priority_queue, -1 * i)",
      "mutated_line": "heapq.heappush(priority_queue, --1 * i)",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, --1 * i)\n            cnt += 1\n    result = [0] * (n + 1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -1 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n + 1)]\n    return permutation"
    },
    {
      "operator": "UOI",
      "lineno": 38,
      "original_line": "heapq.heappush(priority_queue, -1 * to)",
      "mutated_line": "heapq.heappush(priority_queue, +1 * to)",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += 1\n    result = [0] * (n + 1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, +1 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n + 1)]\n    return permutation"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "heapq.heappush(priority_queue, -1 * to)",
      "mutated_line": "heapq.heappush(priority_queue, -2 * to)",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += 1\n    result = [0] * (n + 1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -2 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n + 1)]\n    return permutation"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "heapq.heappush(priority_queue, -1 * to)",
      "mutated_line": "heapq.heappush(priority_queue, -0 * to)",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += 1\n    result = [0] * (n + 1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -0 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n + 1)]\n    return permutation"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "heapq.heappush(priority_queue, -1 * to)",
      "mutated_line": "heapq.heappush(priority_queue, -0 * to)",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += 1\n    result = [0] * (n + 1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, -0 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n + 1)]\n    return permutation"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "heapq.heappush(priority_queue, -1 * to)",
      "mutated_line": "heapq.heappush(priority_queue, --1 * to)",
      "code": "import heapq\n\ndef lexicographically_smallest_permutation(n, m, edges):\n    in_degree = [0] * (n + 1)\n    adjacency_list = [[] for _ in range(n + 1)]\n    for (v, u) in edges:\n        adjacency_list[u].append(v)\n        in_degree[v] += 1\n    priority_queue = []\n    cnt = 0\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            heapq.heappush(priority_queue, -1 * i)\n            cnt += 1\n    result = [0] * (n + 1)\n    num = n\n    while cnt > 0:\n        v = heapq.heappop(priority_queue)\n        v *= -1\n        result[v] = num\n        cnt -= 1\n        num -= 1\n        for to in adjacency_list[v]:\n            in_degree[to] -= 1\n            if in_degree[to] == 0:\n                heapq.heappush(priority_queue, --1 * to)\n                cnt += 1\n    permutation = [result[i] for i in range(1, n + 1)]\n    return permutation"
    }
  ]
}