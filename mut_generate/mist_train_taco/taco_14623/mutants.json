{
  "task_id": "taco_14623",
  "entry_point": "min_extensions_needed",
  "mutant_count": 74,
  "mutants": [
    {
      "operator": "UOI",
      "lineno": 31,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "def min_extensions_needed(a: int, b: int, h: int, w: int, n: int, extensions: list[int]) -> int:\n\n    def isin(a, b, h, w):\n        return h >= a and w >= b or (h >= b and w >= a)\n    extensions.sort(reverse=True)\n    if isin(a, b, h, w):\n        return 0\n    vis = {h: w}\n    for i in range(len(extensions)):\n        nc = extensions[i]\n        pairs = []\n        for l in list(vis.keys()):\n            pair = (l, vis[l] * nc)\n            if isin(a, b, pair[0], pair[1]):\n                return i + 1\n            pairs.append(pair)\n            if nc * l not in vis or vis[l] > vis[nc * l]:\n                pair = (nc * l, vis[l])\n                if isin(a, b, pair[0], pair[1]):\n                    return i + 1\n                pairs.append(pair)\n        for p in pairs:\n            vis[p[0]] = p[1]\n    return +1"
    },
    {
      "operator": "LCR",
      "lineno": 3,
      "original_line": "return h >= a and w >= b or (h >= b and w >= a)",
      "mutated_line": "return (h >= a and w >= b) and (h >= b and w >= a)",
      "code": "def min_extensions_needed(a: int, b: int, h: int, w: int, n: int, extensions: list[int]) -> int:\n\n    def isin(a, b, h, w):\n        return (h >= a and w >= b) and (h >= b and w >= a)\n    extensions.sort(reverse=True)\n    if isin(a, b, h, w):\n        return 0\n    vis = {h: w}\n    for i in range(len(extensions)):\n        nc = extensions[i]\n        pairs = []\n        for l in list(vis.keys()):\n            pair = (l, vis[l] * nc)\n            if isin(a, b, pair[0], pair[1]):\n                return i + 1\n            pairs.append(pair)\n            if nc * l not in vis or vis[l] > vis[nc * l]:\n                pair = (nc * l, vis[l])\n                if isin(a, b, pair[0], pair[1]):\n                    return i + 1\n                pairs.append(pair)\n        for p in pairs:\n            vis[p[0]] = p[1]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def min_extensions_needed(a: int, b: int, h: int, w: int, n: int, extensions: list[int]) -> int:\n\n    def isin(a, b, h, w):\n        return h >= a and w >= b or (h >= b and w >= a)\n    extensions.sort(reverse=True)\n    if isin(a, b, h, w):\n        return 1\n    vis = {h: w}\n    for i in range(len(extensions)):\n        nc = extensions[i]\n        pairs = []\n        for l in list(vis.keys()):\n            pair = (l, vis[l] * nc)\n            if isin(a, b, pair[0], pair[1]):\n                return i + 1\n            pairs.append(pair)\n            if nc * l not in vis or vis[l] > vis[nc * l]:\n                pair = (nc * l, vis[l])\n                if isin(a, b, pair[0], pair[1]):\n                    return i + 1\n                pairs.append(pair)\n        for p in pairs:\n            vis[p[0]] = p[1]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "def min_extensions_needed(a: int, b: int, h: int, w: int, n: int, extensions: list[int]) -> int:\n\n    def isin(a, b, h, w):\n        return h >= a and w >= b or (h >= b and w >= a)\n    extensions.sort(reverse=True)\n    if isin(a, b, h, w):\n        return -1\n    vis = {h: w}\n    for i in range(len(extensions)):\n        nc = extensions[i]\n        pairs = []\n        for l in list(vis.keys()):\n            pair = (l, vis[l] * nc)\n            if isin(a, b, pair[0], pair[1]):\n                return i + 1\n            pairs.append(pair)\n            if nc * l not in vis or vis[l] > vis[nc * l]:\n                pair = (nc * l, vis[l])\n                if isin(a, b, pair[0], pair[1]):\n                    return i + 1\n                pairs.append(pair)\n        for p in pairs:\n            vis[p[0]] = p[1]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def min_extensions_needed(a: int, b: int, h: int, w: int, n: int, extensions: list[int]) -> int:\n\n    def isin(a, b, h, w):\n        return h >= a and w >= b or (h >= b and w >= a)\n    extensions.sort(reverse=True)\n    if isin(a, b, h, w):\n        return 1\n    vis = {h: w}\n    for i in range(len(extensions)):\n        nc = extensions[i]\n        pairs = []\n        for l in list(vis.keys()):\n            pair = (l, vis[l] * nc)\n            if isin(a, b, pair[0], pair[1]):\n                return i + 1\n            pairs.append(pair)\n            if nc * l not in vis or vis[l] > vis[nc * l]:\n                pair = (nc * l, vis[l])\n                if isin(a, b, pair[0], pair[1]):\n                    return i + 1\n                pairs.append(pair)\n        for p in pairs:\n            vis[p[0]] = p[1]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "def min_extensions_needed(a: int, b: int, h: int, w: int, n: int, extensions: list[int]) -> int:\n\n    def isin(a, b, h, w):\n        return h >= a and w >= b or (h >= b and w >= a)\n    extensions.sort(reverse=True)\n    if isin(a, b, h, w):\n        return 0\n    vis = {h: w}\n    for i in range(len(extensions)):\n        nc = extensions[i]\n        pairs = []\n        for l in list(vis.keys()):\n            pair = (l, vis[l] * nc)\n            if isin(a, b, pair[0], pair[1]):\n                return i + 1\n            pairs.append(pair)\n            if nc * l not in vis or vis[l] > vis[nc * l]:\n                pair = (nc * l, vis[l])\n                if isin(a, b, pair[0], pair[1]):\n                    return i + 1\n                pairs.append(pair)\n        for p in pairs:\n            vis[p[0]] = p[1]\n    return -2"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def min_extensions_needed(a: int, b: int, h: int, w: int, n: int, extensions: list[int]) -> int:\n\n    def isin(a, b, h, w):\n        return h >= a and w >= b or (h >= b and w >= a)\n    extensions.sort(reverse=True)\n    if isin(a, b, h, w):\n        return 0\n    vis = {h: w}\n    for i in range(len(extensions)):\n        nc = extensions[i]\n        pairs = []\n        for l in list(vis.keys()):\n            pair = (l, vis[l] * nc)\n            if isin(a, b, pair[0], pair[1]):\n                return i + 1\n            pairs.append(pair)\n            if nc * l not in vis or vis[l] > vis[nc * l]:\n                pair = (nc * l, vis[l])\n                if isin(a, b, pair[0], pair[1]):\n                    return i + 1\n                pairs.append(pair)\n        for p in pairs:\n            vis[p[0]] = p[1]\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def min_extensions_needed(a: int, b: int, h: int, w: int, n: int, extensions: list[int]) -> int:\n\n    def isin(a, b, h, w):\n        return h >= a and w >= b or (h >= b and w >= a)\n    extensions.sort(reverse=True)\n    if isin(a, b, h, w):\n        return 0\n    vis = {h: w}\n    for i in range(len(extensions)):\n        nc = extensions[i]\n        pairs = []\n        for l in list(vis.keys()):\n            pair = (l, vis[l] * nc)\n            if isin(a, b, pair[0], pair[1]):\n                return i + 1\n            pairs.append(pair)\n            if nc * l not in vis or vis[l] > vis[nc * l]:\n                pair = (nc * l, vis[l])\n                if isin(a, b, pair[0], pair[1]):\n                    return i + 1\n                pairs.append(pair)\n        for p in pairs:\n            vis[p[0]] = p[1]\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "def min_extensions_needed(a: int, b: int, h: int, w: int, n: int, extensions: list[int]) -> int:\n\n    def isin(a, b, h, w):\n        return h >= a and w >= b or (h >= b and w >= a)\n    extensions.sort(reverse=True)\n    if isin(a, b, h, w):\n        return 0\n    vis = {h: w}\n    for i in range(len(extensions)):\n        nc = extensions[i]\n        pairs = []\n        for l in list(vis.keys()):\n            pair = (l, vis[l] * nc)\n            if isin(a, b, pair[0], pair[1]):\n                return i + 1\n            pairs.append(pair)\n            if nc * l not in vis or vis[l] > vis[nc * l]:\n                pair = (nc * l, vis[l])\n                if isin(a, b, pair[0], pair[1]):\n                    return i + 1\n                pairs.append(pair)\n        for p in pairs:\n            vis[p[0]] = p[1]\n    return --1"
    },
    {
      "operator": "LCR",
      "lineno": 3,
      "original_line": "return h >= a and w >= b or (h >= b and w >= a)",
      "mutated_line": "return (h >= a or w >= b) or (h >= b and w >= a)",
      "code": "def min_extensions_needed(a: int, b: int, h: int, w: int, n: int, extensions: list[int]) -> int:\n\n    def isin(a, b, h, w):\n        return (h >= a or w >= b) or (h >= b and w >= a)\n    extensions.sort(reverse=True)\n    if isin(a, b, h, w):\n        return 0\n    vis = {h: w}\n    for i in range(len(extensions)):\n        nc = extensions[i]\n        pairs = []\n        for l in list(vis.keys()):\n            pair = (l, vis[l] * nc)\n            if isin(a, b, pair[0], pair[1]):\n                return i + 1\n            pairs.append(pair)\n            if nc * l not in vis or vis[l] > vis[nc * l]:\n                pair = (nc * l, vis[l])\n                if isin(a, b, pair[0], pair[1]):\n                    return i + 1\n                pairs.append(pair)\n        for p in pairs:\n            vis[p[0]] = p[1]\n    return -1"
    },
    {
      "operator": "LCR",
      "lineno": 3,
      "original_line": "return h >= a and w >= b or (h >= b and w >= a)",
      "mutated_line": "return h >= a and w >= b or (h >= b or w >= a)",
      "code": "def min_extensions_needed(a: int, b: int, h: int, w: int, n: int, extensions: list[int]) -> int:\n\n    def isin(a, b, h, w):\n        return h >= a and w >= b or (h >= b or w >= a)\n    extensions.sort(reverse=True)\n    if isin(a, b, h, w):\n        return 0\n    vis = {h: w}\n    for i in range(len(extensions)):\n        nc = extensions[i]\n        pairs = []\n        for l in list(vis.keys()):\n            pair = (l, vis[l] * nc)\n            if isin(a, b, pair[0], pair[1]):\n                return i + 1\n            pairs.append(pair)\n            if nc * l not in vis or vis[l] > vis[nc * l]:\n                pair = (nc * l, vis[l])\n                if isin(a, b, pair[0], pair[1]):\n                    return i + 1\n                pairs.append(pair)\n        for p in pairs:\n            vis[p[0]] = p[1]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "extensions.sort(reverse=True)",
      "mutated_line": "extensions.sort(reverse=False)",
      "code": "def min_extensions_needed(a: int, b: int, h: int, w: int, n: int, extensions: list[int]) -> int:\n\n    def isin(a, b, h, w):\n        return h >= a and w >= b or (h >= b and w >= a)\n    extensions.sort(reverse=False)\n    if isin(a, b, h, w):\n        return 0\n    vis = {h: w}\n    for i in range(len(extensions)):\n        nc = extensions[i]\n        pairs = []\n        for l in list(vis.keys()):\n            pair = (l, vis[l] * nc)\n            if isin(a, b, pair[0], pair[1]):\n                return i + 1\n            pairs.append(pair)\n            if nc * l not in vis or vis[l] > vis[nc * l]:\n                pair = (nc * l, vis[l])\n                if isin(a, b, pair[0], pair[1]):\n                    return i + 1\n                pairs.append(pair)\n        for p in pairs:\n            vis[p[0]] = p[1]\n    return -1"
    },
    {
      "operator": "LCR",
      "lineno": 22,
      "original_line": "if nc * l not in vis or vis[l] > vis[nc * l]:",
      "mutated_line": "if nc * l not in vis and vis[l] > vis[nc * l]:",
      "code": "def min_extensions_needed(a: int, b: int, h: int, w: int, n: int, extensions: list[int]) -> int:\n\n    def isin(a, b, h, w):\n        return h >= a and w >= b or (h >= b and w >= a)\n    extensions.sort(reverse=True)\n    if isin(a, b, h, w):\n        return 0\n    vis = {h: w}\n    for i in range(len(extensions)):\n        nc = extensions[i]\n        pairs = []\n        for l in list(vis.keys()):\n            pair = (l, vis[l] * nc)\n            if isin(a, b, pair[0], pair[1]):\n                return i + 1\n            pairs.append(pair)\n            if nc * l not in vis and vis[l] > vis[nc * l]:\n                pair = (nc * l, vis[l])\n                if isin(a, b, pair[0], pair[1]):\n                    return i + 1\n                pairs.append(pair)\n        for p in pairs:\n            vis[p[0]] = p[1]\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "return h >= a and w >= b or (h >= b and w >= a)",
      "mutated_line": "return h > a and w >= b or (h >= b and w >= a)",
      "code": "def min_extensions_needed(a: int, b: int, h: int, w: int, n: int, extensions: list[int]) -> int:\n\n    def isin(a, b, h, w):\n        return h > a and w >= b or (h >= b and w >= a)\n    extensions.sort(reverse=True)\n    if isin(a, b, h, w):\n        return 0\n    vis = {h: w}\n    for i in range(len(extensions)):\n        nc = extensions[i]\n        pairs = []\n        for l in list(vis.keys()):\n            pair = (l, vis[l] * nc)\n            if isin(a, b, pair[0], pair[1]):\n                return i + 1\n            pairs.append(pair)\n            if nc * l not in vis or vis[l] > vis[nc * l]:\n                pair = (nc * l, vis[l])\n                if isin(a, b, pair[0], pair[1]):\n                    return i + 1\n                pairs.append(pair)\n        for p in pairs:\n            vis[p[0]] = p[1]\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "return h >= a and w >= b or (h >= b and w >= a)",
      "mutated_line": "return h < a and w >= b or (h >= b and w >= a)",
      "code": "def min_extensions_needed(a: int, b: int, h: int, w: int, n: int, extensions: list[int]) -> int:\n\n    def isin(a, b, h, w):\n        return h < a and w >= b or (h >= b and w >= a)\n    extensions.sort(reverse=True)\n    if isin(a, b, h, w):\n        return 0\n    vis = {h: w}\n    for i in range(len(extensions)):\n        nc = extensions[i]\n        pairs = []\n        for l in list(vis.keys()):\n            pair = (l, vis[l] * nc)\n            if isin(a, b, pair[0], pair[1]):\n                return i + 1\n            pairs.append(pair)\n            if nc * l not in vis or vis[l] > vis[nc * l]:\n                pair = (nc * l, vis[l])\n                if isin(a, b, pair[0], pair[1]):\n                    return i + 1\n                pairs.append(pair)\n        for p in pairs:\n            vis[p[0]] = p[1]\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "return h >= a and w >= b or (h >= b and w >= a)",
      "mutated_line": "return h == a and w >= b or (h >= b and w >= a)",
      "code": "def min_extensions_needed(a: int, b: int, h: int, w: int, n: int, extensions: list[int]) -> int:\n\n    def isin(a, b, h, w):\n        return h == a and w >= b or (h >= b and w >= a)\n    extensions.sort(reverse=True)\n    if isin(a, b, h, w):\n        return 0\n    vis = {h: w}\n    for i in range(len(extensions)):\n        nc = extensions[i]\n        pairs = []\n        for l in list(vis.keys()):\n            pair = (l, vis[l] * nc)\n            if isin(a, b, pair[0], pair[1]):\n                return i + 1\n            pairs.append(pair)\n            if nc * l not in vis or vis[l] > vis[nc * l]:\n                pair = (nc * l, vis[l])\n                if isin(a, b, pair[0], pair[1]):\n                    return i + 1\n                pairs.append(pair)\n        for p in pairs:\n            vis[p[0]] = p[1]\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "return h >= a and w >= b or (h >= b and w >= a)",
      "mutated_line": "return h >= a and w > b or (h >= b and w >= a)",
      "code": "def min_extensions_needed(a: int, b: int, h: int, w: int, n: int, extensions: list[int]) -> int:\n\n    def isin(a, b, h, w):\n        return h >= a and w > b or (h >= b and w >= a)\n    extensions.sort(reverse=True)\n    if isin(a, b, h, w):\n        return 0\n    vis = {h: w}\n    for i in range(len(extensions)):\n        nc = extensions[i]\n        pairs = []\n        for l in list(vis.keys()):\n            pair = (l, vis[l] * nc)\n            if isin(a, b, pair[0], pair[1]):\n                return i + 1\n            pairs.append(pair)\n            if nc * l not in vis or vis[l] > vis[nc * l]:\n                pair = (nc * l, vis[l])\n                if isin(a, b, pair[0], pair[1]):\n                    return i + 1\n                pairs.append(pair)\n        for p in pairs:\n            vis[p[0]] = p[1]\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "return h >= a and w >= b or (h >= b and w >= a)",
      "mutated_line": "return h >= a and w < b or (h >= b and w >= a)",
      "code": "def min_extensions_needed(a: int, b: int, h: int, w: int, n: int, extensions: list[int]) -> int:\n\n    def isin(a, b, h, w):\n        return h >= a and w < b or (h >= b and w >= a)\n    extensions.sort(reverse=True)\n    if isin(a, b, h, w):\n        return 0\n    vis = {h: w}\n    for i in range(len(extensions)):\n        nc = extensions[i]\n        pairs = []\n        for l in list(vis.keys()):\n            pair = (l, vis[l] * nc)\n            if isin(a, b, pair[0], pair[1]):\n                return i + 1\n            pairs.append(pair)\n            if nc * l not in vis or vis[l] > vis[nc * l]:\n                pair = (nc * l, vis[l])\n                if isin(a, b, pair[0], pair[1]):\n                    return i + 1\n                pairs.append(pair)\n        for p in pairs:\n            vis[p[0]] = p[1]\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "return h >= a and w >= b or (h >= b and w >= a)",
      "mutated_line": "return h >= a and w == b or (h >= b and w >= a)",
      "code": "def min_extensions_needed(a: int, b: int, h: int, w: int, n: int, extensions: list[int]) -> int:\n\n    def isin(a, b, h, w):\n        return h >= a and w == b or (h >= b and w >= a)\n    extensions.sort(reverse=True)\n    if isin(a, b, h, w):\n        return 0\n    vis = {h: w}\n    for i in range(len(extensions)):\n        nc = extensions[i]\n        pairs = []\n        for l in list(vis.keys()):\n            pair = (l, vis[l] * nc)\n            if isin(a, b, pair[0], pair[1]):\n                return i + 1\n            pairs.append(pair)\n            if nc * l not in vis or vis[l] > vis[nc * l]:\n                pair = (nc * l, vis[l])\n                if isin(a, b, pair[0], pair[1]):\n                    return i + 1\n                pairs.append(pair)\n        for p in pairs:\n            vis[p[0]] = p[1]\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "return h >= a and w >= b or (h >= b and w >= a)",
      "mutated_line": "return h >= a and w >= b or (h > b and w >= a)",
      "code": "def min_extensions_needed(a: int, b: int, h: int, w: int, n: int, extensions: list[int]) -> int:\n\n    def isin(a, b, h, w):\n        return h >= a and w >= b or (h > b and w >= a)\n    extensions.sort(reverse=True)\n    if isin(a, b, h, w):\n        return 0\n    vis = {h: w}\n    for i in range(len(extensions)):\n        nc = extensions[i]\n        pairs = []\n        for l in list(vis.keys()):\n            pair = (l, vis[l] * nc)\n            if isin(a, b, pair[0], pair[1]):\n                return i + 1\n            pairs.append(pair)\n            if nc * l not in vis or vis[l] > vis[nc * l]:\n                pair = (nc * l, vis[l])\n                if isin(a, b, pair[0], pair[1]):\n                    return i + 1\n                pairs.append(pair)\n        for p in pairs:\n            vis[p[0]] = p[1]\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "return h >= a and w >= b or (h >= b and w >= a)",
      "mutated_line": "return h >= a and w >= b or (h < b and w >= a)",
      "code": "def min_extensions_needed(a: int, b: int, h: int, w: int, n: int, extensions: list[int]) -> int:\n\n    def isin(a, b, h, w):\n        return h >= a and w >= b or (h < b and w >= a)\n    extensions.sort(reverse=True)\n    if isin(a, b, h, w):\n        return 0\n    vis = {h: w}\n    for i in range(len(extensions)):\n        nc = extensions[i]\n        pairs = []\n        for l in list(vis.keys()):\n            pair = (l, vis[l] * nc)\n            if isin(a, b, pair[0], pair[1]):\n                return i + 1\n            pairs.append(pair)\n            if nc * l not in vis or vis[l] > vis[nc * l]:\n                pair = (nc * l, vis[l])\n                if isin(a, b, pair[0], pair[1]):\n                    return i + 1\n                pairs.append(pair)\n        for p in pairs:\n            vis[p[0]] = p[1]\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "return h >= a and w >= b or (h >= b and w >= a)",
      "mutated_line": "return h >= a and w >= b or (h == b and w >= a)",
      "code": "def min_extensions_needed(a: int, b: int, h: int, w: int, n: int, extensions: list[int]) -> int:\n\n    def isin(a, b, h, w):\n        return h >= a and w >= b or (h == b and w >= a)\n    extensions.sort(reverse=True)\n    if isin(a, b, h, w):\n        return 0\n    vis = {h: w}\n    for i in range(len(extensions)):\n        nc = extensions[i]\n        pairs = []\n        for l in list(vis.keys()):\n            pair = (l, vis[l] * nc)\n            if isin(a, b, pair[0], pair[1]):\n                return i + 1\n            pairs.append(pair)\n            if nc * l not in vis or vis[l] > vis[nc * l]:\n                pair = (nc * l, vis[l])\n                if isin(a, b, pair[0], pair[1]):\n                    return i + 1\n                pairs.append(pair)\n        for p in pairs:\n            vis[p[0]] = p[1]\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "return h >= a and w >= b or (h >= b and w >= a)",
      "mutated_line": "return h >= a and w >= b or (h >= b and w > a)",
      "code": "def min_extensions_needed(a: int, b: int, h: int, w: int, n: int, extensions: list[int]) -> int:\n\n    def isin(a, b, h, w):\n        return h >= a and w >= b or (h >= b and w > a)\n    extensions.sort(reverse=True)\n    if isin(a, b, h, w):\n        return 0\n    vis = {h: w}\n    for i in range(len(extensions)):\n        nc = extensions[i]\n        pairs = []\n        for l in list(vis.keys()):\n            pair = (l, vis[l] * nc)\n            if isin(a, b, pair[0], pair[1]):\n                return i + 1\n            pairs.append(pair)\n            if nc * l not in vis or vis[l] > vis[nc * l]:\n                pair = (nc * l, vis[l])\n                if isin(a, b, pair[0], pair[1]):\n                    return i + 1\n                pairs.append(pair)\n        for p in pairs:\n            vis[p[0]] = p[1]\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "return h >= a and w >= b or (h >= b and w >= a)",
      "mutated_line": "return h >= a and w >= b or (h >= b and w < a)",
      "code": "def min_extensions_needed(a: int, b: int, h: int, w: int, n: int, extensions: list[int]) -> int:\n\n    def isin(a, b, h, w):\n        return h >= a and w >= b or (h >= b and w < a)\n    extensions.sort(reverse=True)\n    if isin(a, b, h, w):\n        return 0\n    vis = {h: w}\n    for i in range(len(extensions)):\n        nc = extensions[i]\n        pairs = []\n        for l in list(vis.keys()):\n            pair = (l, vis[l] * nc)\n            if isin(a, b, pair[0], pair[1]):\n                return i + 1\n            pairs.append(pair)\n            if nc * l not in vis or vis[l] > vis[nc * l]:\n                pair = (nc * l, vis[l])\n                if isin(a, b, pair[0], pair[1]):\n                    return i + 1\n                pairs.append(pair)\n        for p in pairs:\n            vis[p[0]] = p[1]\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "return h >= a and w >= b or (h >= b and w >= a)",
      "mutated_line": "return h >= a and w >= b or (h >= b and w == a)",
      "code": "def min_extensions_needed(a: int, b: int, h: int, w: int, n: int, extensions: list[int]) -> int:\n\n    def isin(a, b, h, w):\n        return h >= a and w >= b or (h >= b and w == a)\n    extensions.sort(reverse=True)\n    if isin(a, b, h, w):\n        return 0\n    vis = {h: w}\n    for i in range(len(extensions)):\n        nc = extensions[i]\n        pairs = []\n        for l in list(vis.keys()):\n            pair = (l, vis[l] * nc)\n            if isin(a, b, pair[0], pair[1]):\n                return i + 1\n            pairs.append(pair)\n            if nc * l not in vis or vis[l] > vis[nc * l]:\n                pair = (nc * l, vis[l])\n                if isin(a, b, pair[0], pair[1]):\n                    return i + 1\n                pairs.append(pair)\n        for p in pairs:\n            vis[p[0]] = p[1]\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "pair = (l, vis[l] * nc)",
      "mutated_line": "pair = (l, vis[l] / nc)",
      "code": "def min_extensions_needed(a: int, b: int, h: int, w: int, n: int, extensions: list[int]) -> int:\n\n    def isin(a, b, h, w):\n        return h >= a and w >= b or (h >= b and w >= a)\n    extensions.sort(reverse=True)\n    if isin(a, b, h, w):\n        return 0\n    vis = {h: w}\n    for i in range(len(extensions)):\n        nc = extensions[i]\n        pairs = []\n        for l in list(vis.keys()):\n            pair = (l, vis[l] / nc)\n            if isin(a, b, pair[0], pair[1]):\n                return i + 1\n            pairs.append(pair)\n            if nc * l not in vis or vis[l] > vis[nc * l]:\n                pair = (nc * l, vis[l])\n                if isin(a, b, pair[0], pair[1]):\n                    return i + 1\n                pairs.append(pair)\n        for p in pairs:\n            vis[p[0]] = p[1]\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "pair = (l, vis[l] * nc)",
      "mutated_line": "pair = (l, vis[l] + nc)",
      "code": "def min_extensions_needed(a: int, b: int, h: int, w: int, n: int, extensions: list[int]) -> int:\n\n    def isin(a, b, h, w):\n        return h >= a and w >= b or (h >= b and w >= a)\n    extensions.sort(reverse=True)\n    if isin(a, b, h, w):\n        return 0\n    vis = {h: w}\n    for i in range(len(extensions)):\n        nc = extensions[i]\n        pairs = []\n        for l in list(vis.keys()):\n            pair = (l, vis[l] + nc)\n            if isin(a, b, pair[0], pair[1]):\n                return i + 1\n            pairs.append(pair)\n            if nc * l not in vis or vis[l] > vis[nc * l]:\n                pair = (nc * l, vis[l])\n                if isin(a, b, pair[0], pair[1]):\n                    return i + 1\n                pairs.append(pair)\n        for p in pairs:\n            vis[p[0]] = p[1]\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "pair = (l, vis[l] * nc)",
      "mutated_line": "pair = (l, vis[l] ** nc)",
      "code": "def min_extensions_needed(a: int, b: int, h: int, w: int, n: int, extensions: list[int]) -> int:\n\n    def isin(a, b, h, w):\n        return h >= a and w >= b or (h >= b and w >= a)\n    extensions.sort(reverse=True)\n    if isin(a, b, h, w):\n        return 0\n    vis = {h: w}\n    for i in range(len(extensions)):\n        nc = extensions[i]\n        pairs = []\n        for l in list(vis.keys()):\n            pair = (l, vis[l] ** nc)\n            if isin(a, b, pair[0], pair[1]):\n                return i + 1\n            pairs.append(pair)\n            if nc * l not in vis or vis[l] > vis[nc * l]:\n                pair = (nc * l, vis[l])\n                if isin(a, b, pair[0], pair[1]):\n                    return i + 1\n                pairs.append(pair)\n        for p in pairs:\n            vis[p[0]] = p[1]\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "return i + 1",
      "mutated_line": "return i - 1",
      "code": "def min_extensions_needed(a: int, b: int, h: int, w: int, n: int, extensions: list[int]) -> int:\n\n    def isin(a, b, h, w):\n        return h >= a and w >= b or (h >= b and w >= a)\n    extensions.sort(reverse=True)\n    if isin(a, b, h, w):\n        return 0\n    vis = {h: w}\n    for i in range(len(extensions)):\n        nc = extensions[i]\n        pairs = []\n        for l in list(vis.keys()):\n            pair = (l, vis[l] * nc)\n            if isin(a, b, pair[0], pair[1]):\n                return i - 1\n            pairs.append(pair)\n            if nc * l not in vis or vis[l] > vis[nc * l]:\n                pair = (nc * l, vis[l])\n                if isin(a, b, pair[0], pair[1]):\n                    return i + 1\n                pairs.append(pair)\n        for p in pairs:\n            vis[p[0]] = p[1]\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "return i + 1",
      "mutated_line": "return i * 1",
      "code": "def min_extensions_needed(a: int, b: int, h: int, w: int, n: int, extensions: list[int]) -> int:\n\n    def isin(a, b, h, w):\n        return h >= a and w >= b or (h >= b and w >= a)\n    extensions.sort(reverse=True)\n    if isin(a, b, h, w):\n        return 0\n    vis = {h: w}\n    for i in range(len(extensions)):\n        nc = extensions[i]\n        pairs = []\n        for l in list(vis.keys()):\n            pair = (l, vis[l] * nc)\n            if isin(a, b, pair[0], pair[1]):\n                return i * 1\n            pairs.append(pair)\n            if nc * l not in vis or vis[l] > vis[nc * l]:\n                pair = (nc * l, vis[l])\n                if isin(a, b, pair[0], pair[1]):\n                    return i + 1\n                pairs.append(pair)\n        for p in pairs:\n            vis[p[0]] = p[1]\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if nc * l not in vis or vis[l] > vis[nc * l]:",
      "mutated_line": "if nc * l in vis or vis[l] > vis[nc * l]:",
      "code": "def min_extensions_needed(a: int, b: int, h: int, w: int, n: int, extensions: list[int]) -> int:\n\n    def isin(a, b, h, w):\n        return h >= a and w >= b or (h >= b and w >= a)\n    extensions.sort(reverse=True)\n    if isin(a, b, h, w):\n        return 0\n    vis = {h: w}\n    for i in range(len(extensions)):\n        nc = extensions[i]\n        pairs = []\n        for l in list(vis.keys()):\n            pair = (l, vis[l] * nc)\n            if isin(a, b, pair[0], pair[1]):\n                return i + 1\n            pairs.append(pair)\n            if nc * l in vis or vis[l] > vis[nc * l]:\n                pair = (nc * l, vis[l])\n                if isin(a, b, pair[0], pair[1]):\n                    return i + 1\n                pairs.append(pair)\n        for p in pairs:\n            vis[p[0]] = p[1]\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if nc * l not in vis or vis[l] > vis[nc * l]:",
      "mutated_line": "if nc * l not in vis or vis[l] >= vis[nc * l]:",
      "code": "def min_extensions_needed(a: int, b: int, h: int, w: int, n: int, extensions: list[int]) -> int:\n\n    def isin(a, b, h, w):\n        return h >= a and w >= b or (h >= b and w >= a)\n    extensions.sort(reverse=True)\n    if isin(a, b, h, w):\n        return 0\n    vis = {h: w}\n    for i in range(len(extensions)):\n        nc = extensions[i]\n        pairs = []\n        for l in list(vis.keys()):\n            pair = (l, vis[l] * nc)\n            if isin(a, b, pair[0], pair[1]):\n                return i + 1\n            pairs.append(pair)\n            if nc * l not in vis or vis[l] >= vis[nc * l]:\n                pair = (nc * l, vis[l])\n                if isin(a, b, pair[0], pair[1]):\n                    return i + 1\n                pairs.append(pair)\n        for p in pairs:\n            vis[p[0]] = p[1]\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if nc * l not in vis or vis[l] > vis[nc * l]:",
      "mutated_line": "if nc * l not in vis or vis[l] <= vis[nc * l]:",
      "code": "def min_extensions_needed(a: int, b: int, h: int, w: int, n: int, extensions: list[int]) -> int:\n\n    def isin(a, b, h, w):\n        return h >= a and w >= b or (h >= b and w >= a)\n    extensions.sort(reverse=True)\n    if isin(a, b, h, w):\n        return 0\n    vis = {h: w}\n    for i in range(len(extensions)):\n        nc = extensions[i]\n        pairs = []\n        for l in list(vis.keys()):\n            pair = (l, vis[l] * nc)\n            if isin(a, b, pair[0], pair[1]):\n                return i + 1\n            pairs.append(pair)\n            if nc * l not in vis or vis[l] <= vis[nc * l]:\n                pair = (nc * l, vis[l])\n                if isin(a, b, pair[0], pair[1]):\n                    return i + 1\n                pairs.append(pair)\n        for p in pairs:\n            vis[p[0]] = p[1]\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if nc * l not in vis or vis[l] > vis[nc * l]:",
      "mutated_line": "if nc * l not in vis or vis[l] != vis[nc * l]:",
      "code": "def min_extensions_needed(a: int, b: int, h: int, w: int, n: int, extensions: list[int]) -> int:\n\n    def isin(a, b, h, w):\n        return h >= a and w >= b or (h >= b and w >= a)\n    extensions.sort(reverse=True)\n    if isin(a, b, h, w):\n        return 0\n    vis = {h: w}\n    for i in range(len(extensions)):\n        nc = extensions[i]\n        pairs = []\n        for l in list(vis.keys()):\n            pair = (l, vis[l] * nc)\n            if isin(a, b, pair[0], pair[1]):\n                return i + 1\n            pairs.append(pair)\n            if nc * l not in vis or vis[l] != vis[nc * l]:\n                pair = (nc * l, vis[l])\n                if isin(a, b, pair[0], pair[1]):\n                    return i + 1\n                pairs.append(pair)\n        for p in pairs:\n            vis[p[0]] = p[1]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "vis[p[0]] = p[1]",
      "mutated_line": "vis[p[0]] = p[2]",
      "code": "def min_extensions_needed(a: int, b: int, h: int, w: int, n: int, extensions: list[int]) -> int:\n\n    def isin(a, b, h, w):\n        return h >= a and w >= b or (h >= b and w >= a)\n    extensions.sort(reverse=True)\n    if isin(a, b, h, w):\n        return 0\n    vis = {h: w}\n    for i in range(len(extensions)):\n        nc = extensions[i]\n        pairs = []\n        for l in list(vis.keys()):\n            pair = (l, vis[l] * nc)\n            if isin(a, b, pair[0], pair[1]):\n                return i + 1\n            pairs.append(pair)\n            if nc * l not in vis or vis[l] > vis[nc * l]:\n                pair = (nc * l, vis[l])\n                if isin(a, b, pair[0], pair[1]):\n                    return i + 1\n                pairs.append(pair)\n        for p in pairs:\n            vis[p[0]] = p[2]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "vis[p[0]] = p[1]",
      "mutated_line": "vis[p[0]] = p[0]",
      "code": "def min_extensions_needed(a: int, b: int, h: int, w: int, n: int, extensions: list[int]) -> int:\n\n    def isin(a, b, h, w):\n        return h >= a and w >= b or (h >= b and w >= a)\n    extensions.sort(reverse=True)\n    if isin(a, b, h, w):\n        return 0\n    vis = {h: w}\n    for i in range(len(extensions)):\n        nc = extensions[i]\n        pairs = []\n        for l in list(vis.keys()):\n            pair = (l, vis[l] * nc)\n            if isin(a, b, pair[0], pair[1]):\n                return i + 1\n            pairs.append(pair)\n            if nc * l not in vis or vis[l] > vis[nc * l]:\n                pair = (nc * l, vis[l])\n                if isin(a, b, pair[0], pair[1]):\n                    return i + 1\n                pairs.append(pair)\n        for p in pairs:\n            vis[p[0]] = p[0]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "vis[p[0]] = p[1]",
      "mutated_line": "vis[p[0]] = p[0]",
      "code": "def min_extensions_needed(a: int, b: int, h: int, w: int, n: int, extensions: list[int]) -> int:\n\n    def isin(a, b, h, w):\n        return h >= a and w >= b or (h >= b and w >= a)\n    extensions.sort(reverse=True)\n    if isin(a, b, h, w):\n        return 0\n    vis = {h: w}\n    for i in range(len(extensions)):\n        nc = extensions[i]\n        pairs = []\n        for l in list(vis.keys()):\n            pair = (l, vis[l] * nc)\n            if isin(a, b, pair[0], pair[1]):\n                return i + 1\n            pairs.append(pair)\n            if nc * l not in vis or vis[l] > vis[nc * l]:\n                pair = (nc * l, vis[l])\n                if isin(a, b, pair[0], pair[1]):\n                    return i + 1\n                pairs.append(pair)\n        for p in pairs:\n            vis[p[0]] = p[0]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "vis[p[0]] = p[1]",
      "mutated_line": "vis[p[0]] = p[-1]",
      "code": "def min_extensions_needed(a: int, b: int, h: int, w: int, n: int, extensions: list[int]) -> int:\n\n    def isin(a, b, h, w):\n        return h >= a and w >= b or (h >= b and w >= a)\n    extensions.sort(reverse=True)\n    if isin(a, b, h, w):\n        return 0\n    vis = {h: w}\n    for i in range(len(extensions)):\n        nc = extensions[i]\n        pairs = []\n        for l in list(vis.keys()):\n            pair = (l, vis[l] * nc)\n            if isin(a, b, pair[0], pair[1]):\n                return i + 1\n            pairs.append(pair)\n            if nc * l not in vis or vis[l] > vis[nc * l]:\n                pair = (nc * l, vis[l])\n                if isin(a, b, pair[0], pair[1]):\n                    return i + 1\n                pairs.append(pair)\n        for p in pairs:\n            vis[p[0]] = p[-1]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if isin(a, b, pair[0], pair[1]):",
      "mutated_line": "if isin(a, b, pair[1], pair[1]):",
      "code": "def min_extensions_needed(a: int, b: int, h: int, w: int, n: int, extensions: list[int]) -> int:\n\n    def isin(a, b, h, w):\n        return h >= a and w >= b or (h >= b and w >= a)\n    extensions.sort(reverse=True)\n    if isin(a, b, h, w):\n        return 0\n    vis = {h: w}\n    for i in range(len(extensions)):\n        nc = extensions[i]\n        pairs = []\n        for l in list(vis.keys()):\n            pair = (l, vis[l] * nc)\n            if isin(a, b, pair[1], pair[1]):\n                return i + 1\n            pairs.append(pair)\n            if nc * l not in vis or vis[l] > vis[nc * l]:\n                pair = (nc * l, vis[l])\n                if isin(a, b, pair[0], pair[1]):\n                    return i + 1\n                pairs.append(pair)\n        for p in pairs:\n            vis[p[0]] = p[1]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if isin(a, b, pair[0], pair[1]):",
      "mutated_line": "if isin(a, b, pair[-1], pair[1]):",
      "code": "def min_extensions_needed(a: int, b: int, h: int, w: int, n: int, extensions: list[int]) -> int:\n\n    def isin(a, b, h, w):\n        return h >= a and w >= b or (h >= b and w >= a)\n    extensions.sort(reverse=True)\n    if isin(a, b, h, w):\n        return 0\n    vis = {h: w}\n    for i in range(len(extensions)):\n        nc = extensions[i]\n        pairs = []\n        for l in list(vis.keys()):\n            pair = (l, vis[l] * nc)\n            if isin(a, b, pair[-1], pair[1]):\n                return i + 1\n            pairs.append(pair)\n            if nc * l not in vis or vis[l] > vis[nc * l]:\n                pair = (nc * l, vis[l])\n                if isin(a, b, pair[0], pair[1]):\n                    return i + 1\n                pairs.append(pair)\n        for p in pairs:\n            vis[p[0]] = p[1]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if isin(a, b, pair[0], pair[1]):",
      "mutated_line": "if isin(a, b, pair[1], pair[1]):",
      "code": "def min_extensions_needed(a: int, b: int, h: int, w: int, n: int, extensions: list[int]) -> int:\n\n    def isin(a, b, h, w):\n        return h >= a and w >= b or (h >= b and w >= a)\n    extensions.sort(reverse=True)\n    if isin(a, b, h, w):\n        return 0\n    vis = {h: w}\n    for i in range(len(extensions)):\n        nc = extensions[i]\n        pairs = []\n        for l in list(vis.keys()):\n            pair = (l, vis[l] * nc)\n            if isin(a, b, pair[1], pair[1]):\n                return i + 1\n            pairs.append(pair)\n            if nc * l not in vis or vis[l] > vis[nc * l]:\n                pair = (nc * l, vis[l])\n                if isin(a, b, pair[0], pair[1]):\n                    return i + 1\n                pairs.append(pair)\n        for p in pairs:\n            vis[p[0]] = p[1]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if isin(a, b, pair[0], pair[1]):",
      "mutated_line": "if isin(a, b, pair[0], pair[2]):",
      "code": "def min_extensions_needed(a: int, b: int, h: int, w: int, n: int, extensions: list[int]) -> int:\n\n    def isin(a, b, h, w):\n        return h >= a and w >= b or (h >= b and w >= a)\n    extensions.sort(reverse=True)\n    if isin(a, b, h, w):\n        return 0\n    vis = {h: w}\n    for i in range(len(extensions)):\n        nc = extensions[i]\n        pairs = []\n        for l in list(vis.keys()):\n            pair = (l, vis[l] * nc)\n            if isin(a, b, pair[0], pair[2]):\n                return i + 1\n            pairs.append(pair)\n            if nc * l not in vis or vis[l] > vis[nc * l]:\n                pair = (nc * l, vis[l])\n                if isin(a, b, pair[0], pair[1]):\n                    return i + 1\n                pairs.append(pair)\n        for p in pairs:\n            vis[p[0]] = p[1]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if isin(a, b, pair[0], pair[1]):",
      "mutated_line": "if isin(a, b, pair[0], pair[0]):",
      "code": "def min_extensions_needed(a: int, b: int, h: int, w: int, n: int, extensions: list[int]) -> int:\n\n    def isin(a, b, h, w):\n        return h >= a and w >= b or (h >= b and w >= a)\n    extensions.sort(reverse=True)\n    if isin(a, b, h, w):\n        return 0\n    vis = {h: w}\n    for i in range(len(extensions)):\n        nc = extensions[i]\n        pairs = []\n        for l in list(vis.keys()):\n            pair = (l, vis[l] * nc)\n            if isin(a, b, pair[0], pair[0]):\n                return i + 1\n            pairs.append(pair)\n            if nc * l not in vis or vis[l] > vis[nc * l]:\n                pair = (nc * l, vis[l])\n                if isin(a, b, pair[0], pair[1]):\n                    return i + 1\n                pairs.append(pair)\n        for p in pairs:\n            vis[p[0]] = p[1]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if isin(a, b, pair[0], pair[1]):",
      "mutated_line": "if isin(a, b, pair[0], pair[0]):",
      "code": "def min_extensions_needed(a: int, b: int, h: int, w: int, n: int, extensions: list[int]) -> int:\n\n    def isin(a, b, h, w):\n        return h >= a and w >= b or (h >= b and w >= a)\n    extensions.sort(reverse=True)\n    if isin(a, b, h, w):\n        return 0\n    vis = {h: w}\n    for i in range(len(extensions)):\n        nc = extensions[i]\n        pairs = []\n        for l in list(vis.keys()):\n            pair = (l, vis[l] * nc)\n            if isin(a, b, pair[0], pair[0]):\n                return i + 1\n            pairs.append(pair)\n            if nc * l not in vis or vis[l] > vis[nc * l]:\n                pair = (nc * l, vis[l])\n                if isin(a, b, pair[0], pair[1]):\n                    return i + 1\n                pairs.append(pair)\n        for p in pairs:\n            vis[p[0]] = p[1]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if isin(a, b, pair[0], pair[1]):",
      "mutated_line": "if isin(a, b, pair[0], pair[-1]):",
      "code": "def min_extensions_needed(a: int, b: int, h: int, w: int, n: int, extensions: list[int]) -> int:\n\n    def isin(a, b, h, w):\n        return h >= a and w >= b or (h >= b and w >= a)\n    extensions.sort(reverse=True)\n    if isin(a, b, h, w):\n        return 0\n    vis = {h: w}\n    for i in range(len(extensions)):\n        nc = extensions[i]\n        pairs = []\n        for l in list(vis.keys()):\n            pair = (l, vis[l] * nc)\n            if isin(a, b, pair[0], pair[-1]):\n                return i + 1\n            pairs.append(pair)\n            if nc * l not in vis or vis[l] > vis[nc * l]:\n                pair = (nc * l, vis[l])\n                if isin(a, b, pair[0], pair[1]):\n                    return i + 1\n                pairs.append(pair)\n        for p in pairs:\n            vis[p[0]] = p[1]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return i + 1",
      "mutated_line": "return i + 2",
      "code": "def min_extensions_needed(a: int, b: int, h: int, w: int, n: int, extensions: list[int]) -> int:\n\n    def isin(a, b, h, w):\n        return h >= a and w >= b or (h >= b and w >= a)\n    extensions.sort(reverse=True)\n    if isin(a, b, h, w):\n        return 0\n    vis = {h: w}\n    for i in range(len(extensions)):\n        nc = extensions[i]\n        pairs = []\n        for l in list(vis.keys()):\n            pair = (l, vis[l] * nc)\n            if isin(a, b, pair[0], pair[1]):\n                return i + 2\n            pairs.append(pair)\n            if nc * l not in vis or vis[l] > vis[nc * l]:\n                pair = (nc * l, vis[l])\n                if isin(a, b, pair[0], pair[1]):\n                    return i + 1\n                pairs.append(pair)\n        for p in pairs:\n            vis[p[0]] = p[1]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return i + 1",
      "mutated_line": "return i + 0",
      "code": "def min_extensions_needed(a: int, b: int, h: int, w: int, n: int, extensions: list[int]) -> int:\n\n    def isin(a, b, h, w):\n        return h >= a and w >= b or (h >= b and w >= a)\n    extensions.sort(reverse=True)\n    if isin(a, b, h, w):\n        return 0\n    vis = {h: w}\n    for i in range(len(extensions)):\n        nc = extensions[i]\n        pairs = []\n        for l in list(vis.keys()):\n            pair = (l, vis[l] * nc)\n            if isin(a, b, pair[0], pair[1]):\n                return i + 0\n            pairs.append(pair)\n            if nc * l not in vis or vis[l] > vis[nc * l]:\n                pair = (nc * l, vis[l])\n                if isin(a, b, pair[0], pair[1]):\n                    return i + 1\n                pairs.append(pair)\n        for p in pairs:\n            vis[p[0]] = p[1]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return i + 1",
      "mutated_line": "return i + 0",
      "code": "def min_extensions_needed(a: int, b: int, h: int, w: int, n: int, extensions: list[int]) -> int:\n\n    def isin(a, b, h, w):\n        return h >= a and w >= b or (h >= b and w >= a)\n    extensions.sort(reverse=True)\n    if isin(a, b, h, w):\n        return 0\n    vis = {h: w}\n    for i in range(len(extensions)):\n        nc = extensions[i]\n        pairs = []\n        for l in list(vis.keys()):\n            pair = (l, vis[l] * nc)\n            if isin(a, b, pair[0], pair[1]):\n                return i + 0\n            pairs.append(pair)\n            if nc * l not in vis or vis[l] > vis[nc * l]:\n                pair = (nc * l, vis[l])\n                if isin(a, b, pair[0], pair[1]):\n                    return i + 1\n                pairs.append(pair)\n        for p in pairs:\n            vis[p[0]] = p[1]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return i + 1",
      "mutated_line": "return i + -1",
      "code": "def min_extensions_needed(a: int, b: int, h: int, w: int, n: int, extensions: list[int]) -> int:\n\n    def isin(a, b, h, w):\n        return h >= a and w >= b or (h >= b and w >= a)\n    extensions.sort(reverse=True)\n    if isin(a, b, h, w):\n        return 0\n    vis = {h: w}\n    for i in range(len(extensions)):\n        nc = extensions[i]\n        pairs = []\n        for l in list(vis.keys()):\n            pair = (l, vis[l] * nc)\n            if isin(a, b, pair[0], pair[1]):\n                return i + -1\n            pairs.append(pair)\n            if nc * l not in vis or vis[l] > vis[nc * l]:\n                pair = (nc * l, vis[l])\n                if isin(a, b, pair[0], pair[1]):\n                    return i + 1\n                pairs.append(pair)\n        for p in pairs:\n            vis[p[0]] = p[1]\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "if nc * l not in vis or vis[l] > vis[nc * l]:",
      "mutated_line": "if nc / l not in vis or vis[l] > vis[nc * l]:",
      "code": "def min_extensions_needed(a: int, b: int, h: int, w: int, n: int, extensions: list[int]) -> int:\n\n    def isin(a, b, h, w):\n        return h >= a and w >= b or (h >= b and w >= a)\n    extensions.sort(reverse=True)\n    if isin(a, b, h, w):\n        return 0\n    vis = {h: w}\n    for i in range(len(extensions)):\n        nc = extensions[i]\n        pairs = []\n        for l in list(vis.keys()):\n            pair = (l, vis[l] * nc)\n            if isin(a, b, pair[0], pair[1]):\n                return i + 1\n            pairs.append(pair)\n            if nc / l not in vis or vis[l] > vis[nc * l]:\n                pair = (nc * l, vis[l])\n                if isin(a, b, pair[0], pair[1]):\n                    return i + 1\n                pairs.append(pair)\n        for p in pairs:\n            vis[p[0]] = p[1]\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "if nc * l not in vis or vis[l] > vis[nc * l]:",
      "mutated_line": "if nc + l not in vis or vis[l] > vis[nc * l]:",
      "code": "def min_extensions_needed(a: int, b: int, h: int, w: int, n: int, extensions: list[int]) -> int:\n\n    def isin(a, b, h, w):\n        return h >= a and w >= b or (h >= b and w >= a)\n    extensions.sort(reverse=True)\n    if isin(a, b, h, w):\n        return 0\n    vis = {h: w}\n    for i in range(len(extensions)):\n        nc = extensions[i]\n        pairs = []\n        for l in list(vis.keys()):\n            pair = (l, vis[l] * nc)\n            if isin(a, b, pair[0], pair[1]):\n                return i + 1\n            pairs.append(pair)\n            if nc + l not in vis or vis[l] > vis[nc * l]:\n                pair = (nc * l, vis[l])\n                if isin(a, b, pair[0], pair[1]):\n                    return i + 1\n                pairs.append(pair)\n        for p in pairs:\n            vis[p[0]] = p[1]\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "if nc * l not in vis or vis[l] > vis[nc * l]:",
      "mutated_line": "if nc ** l not in vis or vis[l] > vis[nc * l]:",
      "code": "def min_extensions_needed(a: int, b: int, h: int, w: int, n: int, extensions: list[int]) -> int:\n\n    def isin(a, b, h, w):\n        return h >= a and w >= b or (h >= b and w >= a)\n    extensions.sort(reverse=True)\n    if isin(a, b, h, w):\n        return 0\n    vis = {h: w}\n    for i in range(len(extensions)):\n        nc = extensions[i]\n        pairs = []\n        for l in list(vis.keys()):\n            pair = (l, vis[l] * nc)\n            if isin(a, b, pair[0], pair[1]):\n                return i + 1\n            pairs.append(pair)\n            if nc ** l not in vis or vis[l] > vis[nc * l]:\n                pair = (nc * l, vis[l])\n                if isin(a, b, pair[0], pair[1]):\n                    return i + 1\n                pairs.append(pair)\n        for p in pairs:\n            vis[p[0]] = p[1]\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "pair = (nc * l, vis[l])",
      "mutated_line": "pair = (nc / l, vis[l])",
      "code": "def min_extensions_needed(a: int, b: int, h: int, w: int, n: int, extensions: list[int]) -> int:\n\n    def isin(a, b, h, w):\n        return h >= a and w >= b or (h >= b and w >= a)\n    extensions.sort(reverse=True)\n    if isin(a, b, h, w):\n        return 0\n    vis = {h: w}\n    for i in range(len(extensions)):\n        nc = extensions[i]\n        pairs = []\n        for l in list(vis.keys()):\n            pair = (l, vis[l] * nc)\n            if isin(a, b, pair[0], pair[1]):\n                return i + 1\n            pairs.append(pair)\n            if nc * l not in vis or vis[l] > vis[nc * l]:\n                pair = (nc / l, vis[l])\n                if isin(a, b, pair[0], pair[1]):\n                    return i + 1\n                pairs.append(pair)\n        for p in pairs:\n            vis[p[0]] = p[1]\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "pair = (nc * l, vis[l])",
      "mutated_line": "pair = (nc + l, vis[l])",
      "code": "def min_extensions_needed(a: int, b: int, h: int, w: int, n: int, extensions: list[int]) -> int:\n\n    def isin(a, b, h, w):\n        return h >= a and w >= b or (h >= b and w >= a)\n    extensions.sort(reverse=True)\n    if isin(a, b, h, w):\n        return 0\n    vis = {h: w}\n    for i in range(len(extensions)):\n        nc = extensions[i]\n        pairs = []\n        for l in list(vis.keys()):\n            pair = (l, vis[l] * nc)\n            if isin(a, b, pair[0], pair[1]):\n                return i + 1\n            pairs.append(pair)\n            if nc * l not in vis or vis[l] > vis[nc * l]:\n                pair = (nc + l, vis[l])\n                if isin(a, b, pair[0], pair[1]):\n                    return i + 1\n                pairs.append(pair)\n        for p in pairs:\n            vis[p[0]] = p[1]\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "pair = (nc * l, vis[l])",
      "mutated_line": "pair = (nc ** l, vis[l])",
      "code": "def min_extensions_needed(a: int, b: int, h: int, w: int, n: int, extensions: list[int]) -> int:\n\n    def isin(a, b, h, w):\n        return h >= a and w >= b or (h >= b and w >= a)\n    extensions.sort(reverse=True)\n    if isin(a, b, h, w):\n        return 0\n    vis = {h: w}\n    for i in range(len(extensions)):\n        nc = extensions[i]\n        pairs = []\n        for l in list(vis.keys()):\n            pair = (l, vis[l] * nc)\n            if isin(a, b, pair[0], pair[1]):\n                return i + 1\n            pairs.append(pair)\n            if nc * l not in vis or vis[l] > vis[nc * l]:\n                pair = (nc ** l, vis[l])\n                if isin(a, b, pair[0], pair[1]):\n                    return i + 1\n                pairs.append(pair)\n        for p in pairs:\n            vis[p[0]] = p[1]\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "return i + 1",
      "mutated_line": "return i - 1",
      "code": "def min_extensions_needed(a: int, b: int, h: int, w: int, n: int, extensions: list[int]) -> int:\n\n    def isin(a, b, h, w):\n        return h >= a and w >= b or (h >= b and w >= a)\n    extensions.sort(reverse=True)\n    if isin(a, b, h, w):\n        return 0\n    vis = {h: w}\n    for i in range(len(extensions)):\n        nc = extensions[i]\n        pairs = []\n        for l in list(vis.keys()):\n            pair = (l, vis[l] * nc)\n            if isin(a, b, pair[0], pair[1]):\n                return i + 1\n            pairs.append(pair)\n            if nc * l not in vis or vis[l] > vis[nc * l]:\n                pair = (nc * l, vis[l])\n                if isin(a, b, pair[0], pair[1]):\n                    return i - 1\n                pairs.append(pair)\n        for p in pairs:\n            vis[p[0]] = p[1]\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "return i + 1",
      "mutated_line": "return i * 1",
      "code": "def min_extensions_needed(a: int, b: int, h: int, w: int, n: int, extensions: list[int]) -> int:\n\n    def isin(a, b, h, w):\n        return h >= a and w >= b or (h >= b and w >= a)\n    extensions.sort(reverse=True)\n    if isin(a, b, h, w):\n        return 0\n    vis = {h: w}\n    for i in range(len(extensions)):\n        nc = extensions[i]\n        pairs = []\n        for l in list(vis.keys()):\n            pair = (l, vis[l] * nc)\n            if isin(a, b, pair[0], pair[1]):\n                return i + 1\n            pairs.append(pair)\n            if nc * l not in vis or vis[l] > vis[nc * l]:\n                pair = (nc * l, vis[l])\n                if isin(a, b, pair[0], pair[1]):\n                    return i * 1\n                pairs.append(pair)\n        for p in pairs:\n            vis[p[0]] = p[1]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "vis[p[0]] = p[1]",
      "mutated_line": "vis[p[1]] = p[1]",
      "code": "def min_extensions_needed(a: int, b: int, h: int, w: int, n: int, extensions: list[int]) -> int:\n\n    def isin(a, b, h, w):\n        return h >= a and w >= b or (h >= b and w >= a)\n    extensions.sort(reverse=True)\n    if isin(a, b, h, w):\n        return 0\n    vis = {h: w}\n    for i in range(len(extensions)):\n        nc = extensions[i]\n        pairs = []\n        for l in list(vis.keys()):\n            pair = (l, vis[l] * nc)\n            if isin(a, b, pair[0], pair[1]):\n                return i + 1\n            pairs.append(pair)\n            if nc * l not in vis or vis[l] > vis[nc * l]:\n                pair = (nc * l, vis[l])\n                if isin(a, b, pair[0], pair[1]):\n                    return i + 1\n                pairs.append(pair)\n        for p in pairs:\n            vis[p[1]] = p[1]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "vis[p[0]] = p[1]",
      "mutated_line": "vis[p[-1]] = p[1]",
      "code": "def min_extensions_needed(a: int, b: int, h: int, w: int, n: int, extensions: list[int]) -> int:\n\n    def isin(a, b, h, w):\n        return h >= a and w >= b or (h >= b and w >= a)\n    extensions.sort(reverse=True)\n    if isin(a, b, h, w):\n        return 0\n    vis = {h: w}\n    for i in range(len(extensions)):\n        nc = extensions[i]\n        pairs = []\n        for l in list(vis.keys()):\n            pair = (l, vis[l] * nc)\n            if isin(a, b, pair[0], pair[1]):\n                return i + 1\n            pairs.append(pair)\n            if nc * l not in vis or vis[l] > vis[nc * l]:\n                pair = (nc * l, vis[l])\n                if isin(a, b, pair[0], pair[1]):\n                    return i + 1\n                pairs.append(pair)\n        for p in pairs:\n            vis[p[-1]] = p[1]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "vis[p[0]] = p[1]",
      "mutated_line": "vis[p[1]] = p[1]",
      "code": "def min_extensions_needed(a: int, b: int, h: int, w: int, n: int, extensions: list[int]) -> int:\n\n    def isin(a, b, h, w):\n        return h >= a and w >= b or (h >= b and w >= a)\n    extensions.sort(reverse=True)\n    if isin(a, b, h, w):\n        return 0\n    vis = {h: w}\n    for i in range(len(extensions)):\n        nc = extensions[i]\n        pairs = []\n        for l in list(vis.keys()):\n            pair = (l, vis[l] * nc)\n            if isin(a, b, pair[0], pair[1]):\n                return i + 1\n            pairs.append(pair)\n            if nc * l not in vis or vis[l] > vis[nc * l]:\n                pair = (nc * l, vis[l])\n                if isin(a, b, pair[0], pair[1]):\n                    return i + 1\n                pairs.append(pair)\n        for p in pairs:\n            vis[p[1]] = p[1]\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "if nc * l not in vis or vis[l] > vis[nc * l]:",
      "mutated_line": "if nc * l not in vis or vis[l] > vis[nc / l]:",
      "code": "def min_extensions_needed(a: int, b: int, h: int, w: int, n: int, extensions: list[int]) -> int:\n\n    def isin(a, b, h, w):\n        return h >= a and w >= b or (h >= b and w >= a)\n    extensions.sort(reverse=True)\n    if isin(a, b, h, w):\n        return 0\n    vis = {h: w}\n    for i in range(len(extensions)):\n        nc = extensions[i]\n        pairs = []\n        for l in list(vis.keys()):\n            pair = (l, vis[l] * nc)\n            if isin(a, b, pair[0], pair[1]):\n                return i + 1\n            pairs.append(pair)\n            if nc * l not in vis or vis[l] > vis[nc / l]:\n                pair = (nc * l, vis[l])\n                if isin(a, b, pair[0], pair[1]):\n                    return i + 1\n                pairs.append(pair)\n        for p in pairs:\n            vis[p[0]] = p[1]\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "if nc * l not in vis or vis[l] > vis[nc * l]:",
      "mutated_line": "if nc * l not in vis or vis[l] > vis[nc + l]:",
      "code": "def min_extensions_needed(a: int, b: int, h: int, w: int, n: int, extensions: list[int]) -> int:\n\n    def isin(a, b, h, w):\n        return h >= a and w >= b or (h >= b and w >= a)\n    extensions.sort(reverse=True)\n    if isin(a, b, h, w):\n        return 0\n    vis = {h: w}\n    for i in range(len(extensions)):\n        nc = extensions[i]\n        pairs = []\n        for l in list(vis.keys()):\n            pair = (l, vis[l] * nc)\n            if isin(a, b, pair[0], pair[1]):\n                return i + 1\n            pairs.append(pair)\n            if nc * l not in vis or vis[l] > vis[nc + l]:\n                pair = (nc * l, vis[l])\n                if isin(a, b, pair[0], pair[1]):\n                    return i + 1\n                pairs.append(pair)\n        for p in pairs:\n            vis[p[0]] = p[1]\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "if nc * l not in vis or vis[l] > vis[nc * l]:",
      "mutated_line": "if nc * l not in vis or vis[l] > vis[nc ** l]:",
      "code": "def min_extensions_needed(a: int, b: int, h: int, w: int, n: int, extensions: list[int]) -> int:\n\n    def isin(a, b, h, w):\n        return h >= a and w >= b or (h >= b and w >= a)\n    extensions.sort(reverse=True)\n    if isin(a, b, h, w):\n        return 0\n    vis = {h: w}\n    for i in range(len(extensions)):\n        nc = extensions[i]\n        pairs = []\n        for l in list(vis.keys()):\n            pair = (l, vis[l] * nc)\n            if isin(a, b, pair[0], pair[1]):\n                return i + 1\n            pairs.append(pair)\n            if nc * l not in vis or vis[l] > vis[nc ** l]:\n                pair = (nc * l, vis[l])\n                if isin(a, b, pair[0], pair[1]):\n                    return i + 1\n                pairs.append(pair)\n        for p in pairs:\n            vis[p[0]] = p[1]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if isin(a, b, pair[0], pair[1]):",
      "mutated_line": "if isin(a, b, pair[1], pair[1]):",
      "code": "def min_extensions_needed(a: int, b: int, h: int, w: int, n: int, extensions: list[int]) -> int:\n\n    def isin(a, b, h, w):\n        return h >= a and w >= b or (h >= b and w >= a)\n    extensions.sort(reverse=True)\n    if isin(a, b, h, w):\n        return 0\n    vis = {h: w}\n    for i in range(len(extensions)):\n        nc = extensions[i]\n        pairs = []\n        for l in list(vis.keys()):\n            pair = (l, vis[l] * nc)\n            if isin(a, b, pair[0], pair[1]):\n                return i + 1\n            pairs.append(pair)\n            if nc * l not in vis or vis[l] > vis[nc * l]:\n                pair = (nc * l, vis[l])\n                if isin(a, b, pair[1], pair[1]):\n                    return i + 1\n                pairs.append(pair)\n        for p in pairs:\n            vis[p[0]] = p[1]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if isin(a, b, pair[0], pair[1]):",
      "mutated_line": "if isin(a, b, pair[-1], pair[1]):",
      "code": "def min_extensions_needed(a: int, b: int, h: int, w: int, n: int, extensions: list[int]) -> int:\n\n    def isin(a, b, h, w):\n        return h >= a and w >= b or (h >= b and w >= a)\n    extensions.sort(reverse=True)\n    if isin(a, b, h, w):\n        return 0\n    vis = {h: w}\n    for i in range(len(extensions)):\n        nc = extensions[i]\n        pairs = []\n        for l in list(vis.keys()):\n            pair = (l, vis[l] * nc)\n            if isin(a, b, pair[0], pair[1]):\n                return i + 1\n            pairs.append(pair)\n            if nc * l not in vis or vis[l] > vis[nc * l]:\n                pair = (nc * l, vis[l])\n                if isin(a, b, pair[-1], pair[1]):\n                    return i + 1\n                pairs.append(pair)\n        for p in pairs:\n            vis[p[0]] = p[1]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if isin(a, b, pair[0], pair[1]):",
      "mutated_line": "if isin(a, b, pair[1], pair[1]):",
      "code": "def min_extensions_needed(a: int, b: int, h: int, w: int, n: int, extensions: list[int]) -> int:\n\n    def isin(a, b, h, w):\n        return h >= a and w >= b or (h >= b and w >= a)\n    extensions.sort(reverse=True)\n    if isin(a, b, h, w):\n        return 0\n    vis = {h: w}\n    for i in range(len(extensions)):\n        nc = extensions[i]\n        pairs = []\n        for l in list(vis.keys()):\n            pair = (l, vis[l] * nc)\n            if isin(a, b, pair[0], pair[1]):\n                return i + 1\n            pairs.append(pair)\n            if nc * l not in vis or vis[l] > vis[nc * l]:\n                pair = (nc * l, vis[l])\n                if isin(a, b, pair[1], pair[1]):\n                    return i + 1\n                pairs.append(pair)\n        for p in pairs:\n            vis[p[0]] = p[1]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if isin(a, b, pair[0], pair[1]):",
      "mutated_line": "if isin(a, b, pair[0], pair[2]):",
      "code": "def min_extensions_needed(a: int, b: int, h: int, w: int, n: int, extensions: list[int]) -> int:\n\n    def isin(a, b, h, w):\n        return h >= a and w >= b or (h >= b and w >= a)\n    extensions.sort(reverse=True)\n    if isin(a, b, h, w):\n        return 0\n    vis = {h: w}\n    for i in range(len(extensions)):\n        nc = extensions[i]\n        pairs = []\n        for l in list(vis.keys()):\n            pair = (l, vis[l] * nc)\n            if isin(a, b, pair[0], pair[1]):\n                return i + 1\n            pairs.append(pair)\n            if nc * l not in vis or vis[l] > vis[nc * l]:\n                pair = (nc * l, vis[l])\n                if isin(a, b, pair[0], pair[2]):\n                    return i + 1\n                pairs.append(pair)\n        for p in pairs:\n            vis[p[0]] = p[1]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if isin(a, b, pair[0], pair[1]):",
      "mutated_line": "if isin(a, b, pair[0], pair[0]):",
      "code": "def min_extensions_needed(a: int, b: int, h: int, w: int, n: int, extensions: list[int]) -> int:\n\n    def isin(a, b, h, w):\n        return h >= a and w >= b or (h >= b and w >= a)\n    extensions.sort(reverse=True)\n    if isin(a, b, h, w):\n        return 0\n    vis = {h: w}\n    for i in range(len(extensions)):\n        nc = extensions[i]\n        pairs = []\n        for l in list(vis.keys()):\n            pair = (l, vis[l] * nc)\n            if isin(a, b, pair[0], pair[1]):\n                return i + 1\n            pairs.append(pair)\n            if nc * l not in vis or vis[l] > vis[nc * l]:\n                pair = (nc * l, vis[l])\n                if isin(a, b, pair[0], pair[0]):\n                    return i + 1\n                pairs.append(pair)\n        for p in pairs:\n            vis[p[0]] = p[1]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if isin(a, b, pair[0], pair[1]):",
      "mutated_line": "if isin(a, b, pair[0], pair[0]):",
      "code": "def min_extensions_needed(a: int, b: int, h: int, w: int, n: int, extensions: list[int]) -> int:\n\n    def isin(a, b, h, w):\n        return h >= a and w >= b or (h >= b and w >= a)\n    extensions.sort(reverse=True)\n    if isin(a, b, h, w):\n        return 0\n    vis = {h: w}\n    for i in range(len(extensions)):\n        nc = extensions[i]\n        pairs = []\n        for l in list(vis.keys()):\n            pair = (l, vis[l] * nc)\n            if isin(a, b, pair[0], pair[1]):\n                return i + 1\n            pairs.append(pair)\n            if nc * l not in vis or vis[l] > vis[nc * l]:\n                pair = (nc * l, vis[l])\n                if isin(a, b, pair[0], pair[0]):\n                    return i + 1\n                pairs.append(pair)\n        for p in pairs:\n            vis[p[0]] = p[1]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if isin(a, b, pair[0], pair[1]):",
      "mutated_line": "if isin(a, b, pair[0], pair[-1]):",
      "code": "def min_extensions_needed(a: int, b: int, h: int, w: int, n: int, extensions: list[int]) -> int:\n\n    def isin(a, b, h, w):\n        return h >= a and w >= b or (h >= b and w >= a)\n    extensions.sort(reverse=True)\n    if isin(a, b, h, w):\n        return 0\n    vis = {h: w}\n    for i in range(len(extensions)):\n        nc = extensions[i]\n        pairs = []\n        for l in list(vis.keys()):\n            pair = (l, vis[l] * nc)\n            if isin(a, b, pair[0], pair[1]):\n                return i + 1\n            pairs.append(pair)\n            if nc * l not in vis or vis[l] > vis[nc * l]:\n                pair = (nc * l, vis[l])\n                if isin(a, b, pair[0], pair[-1]):\n                    return i + 1\n                pairs.append(pair)\n        for p in pairs:\n            vis[p[0]] = p[1]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return i + 1",
      "mutated_line": "return i + 2",
      "code": "def min_extensions_needed(a: int, b: int, h: int, w: int, n: int, extensions: list[int]) -> int:\n\n    def isin(a, b, h, w):\n        return h >= a and w >= b or (h >= b and w >= a)\n    extensions.sort(reverse=True)\n    if isin(a, b, h, w):\n        return 0\n    vis = {h: w}\n    for i in range(len(extensions)):\n        nc = extensions[i]\n        pairs = []\n        for l in list(vis.keys()):\n            pair = (l, vis[l] * nc)\n            if isin(a, b, pair[0], pair[1]):\n                return i + 1\n            pairs.append(pair)\n            if nc * l not in vis or vis[l] > vis[nc * l]:\n                pair = (nc * l, vis[l])\n                if isin(a, b, pair[0], pair[1]):\n                    return i + 2\n                pairs.append(pair)\n        for p in pairs:\n            vis[p[0]] = p[1]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return i + 1",
      "mutated_line": "return i + 0",
      "code": "def min_extensions_needed(a: int, b: int, h: int, w: int, n: int, extensions: list[int]) -> int:\n\n    def isin(a, b, h, w):\n        return h >= a and w >= b or (h >= b and w >= a)\n    extensions.sort(reverse=True)\n    if isin(a, b, h, w):\n        return 0\n    vis = {h: w}\n    for i in range(len(extensions)):\n        nc = extensions[i]\n        pairs = []\n        for l in list(vis.keys()):\n            pair = (l, vis[l] * nc)\n            if isin(a, b, pair[0], pair[1]):\n                return i + 1\n            pairs.append(pair)\n            if nc * l not in vis or vis[l] > vis[nc * l]:\n                pair = (nc * l, vis[l])\n                if isin(a, b, pair[0], pair[1]):\n                    return i + 0\n                pairs.append(pair)\n        for p in pairs:\n            vis[p[0]] = p[1]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return i + 1",
      "mutated_line": "return i + 0",
      "code": "def min_extensions_needed(a: int, b: int, h: int, w: int, n: int, extensions: list[int]) -> int:\n\n    def isin(a, b, h, w):\n        return h >= a and w >= b or (h >= b and w >= a)\n    extensions.sort(reverse=True)\n    if isin(a, b, h, w):\n        return 0\n    vis = {h: w}\n    for i in range(len(extensions)):\n        nc = extensions[i]\n        pairs = []\n        for l in list(vis.keys()):\n            pair = (l, vis[l] * nc)\n            if isin(a, b, pair[0], pair[1]):\n                return i + 1\n            pairs.append(pair)\n            if nc * l not in vis or vis[l] > vis[nc * l]:\n                pair = (nc * l, vis[l])\n                if isin(a, b, pair[0], pair[1]):\n                    return i + 0\n                pairs.append(pair)\n        for p in pairs:\n            vis[p[0]] = p[1]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return i + 1",
      "mutated_line": "return i + -1",
      "code": "def min_extensions_needed(a: int, b: int, h: int, w: int, n: int, extensions: list[int]) -> int:\n\n    def isin(a, b, h, w):\n        return h >= a and w >= b or (h >= b and w >= a)\n    extensions.sort(reverse=True)\n    if isin(a, b, h, w):\n        return 0\n    vis = {h: w}\n    for i in range(len(extensions)):\n        nc = extensions[i]\n        pairs = []\n        for l in list(vis.keys()):\n            pair = (l, vis[l] * nc)\n            if isin(a, b, pair[0], pair[1]):\n                return i + 1\n            pairs.append(pair)\n            if nc * l not in vis or vis[l] > vis[nc * l]:\n                pair = (nc * l, vis[l])\n                if isin(a, b, pair[0], pair[1]):\n                    return i + -1\n                pairs.append(pair)\n        for p in pairs:\n            vis[p[0]] = p[1]\n    return -1"
    }
  ]
}