{
  "task_id": "taco_8797",
  "entry_point": "count_valid_Z",
  "mutant_count": 319,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "index = 0",
      "mutated_line": "index = 1",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 1\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "index = 0",
      "mutated_line": "index = -1",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = -1\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "index = 0",
      "mutated_line": "index = 1",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 1\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "flag = 2",
      "mutated_line": "flag = 3",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 3\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "flag = 2",
      "mutated_line": "flag = 1",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 1\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "flag = 2",
      "mutated_line": "flag = 0",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 0\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "flag = 2",
      "mutated_line": "flag = 1",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 1\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "flag = 2",
      "mutated_line": "flag = -2",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = -2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "UOI",
      "lineno": 10,
      "original_line": "k = -1",
      "mutated_line": "k = +1",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = +1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if lx != ly:",
      "mutated_line": "if lx == ly:",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx == ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "k = -1",
      "mutated_line": "k = -2",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -2\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "k = -1",
      "mutated_line": "k = -0",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -0\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "k = -1",
      "mutated_line": "k = -0",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -0\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "k = -1",
      "mutated_line": "k = --1",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = --1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if (N + 1) % 2 ** index >= 2 ** (index - 1):",
      "mutated_line": "if (N + 1) % 2 ** index > 2 ** (index - 1):",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index > 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if (N + 1) % 2 ** index >= 2 ** (index - 1):",
      "mutated_line": "if (N + 1) % 2 ** index < 2 ** (index - 1):",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index < 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if (N + 1) % 2 ** index >= 2 ** (index - 1):",
      "mutated_line": "if (N + 1) % 2 ** index == 2 ** (index - 1):",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index == 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if lx < ly:",
      "mutated_line": "if lx <= ly:",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx <= ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if lx < ly:",
      "mutated_line": "if lx >= ly:",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx >= ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if lx < ly:",
      "mutated_line": "if lx != ly:",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx != ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if (N + 1) % 2 ** index >= 2 ** (index - 1):",
      "mutated_line": "if (N + 1) % 2 ** index > 2 ** (index - 1):",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index > 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if (N + 1) % 2 ** index >= 2 ** (index - 1):",
      "mutated_line": "if (N + 1) % 2 ** index < 2 ** (index - 1):",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index < 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if (N + 1) % 2 ** index >= 2 ** (index - 1):",
      "mutated_line": "if (N + 1) % 2 ** index == 2 ** (index - 1):",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index == 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if flag == 2:",
      "mutated_line": "if flag != 2:",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag != 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "bx = list(bin(X))[2:]  # Convert X to binary and remove the '0b' prefix",
      "mutated_line": "bx = list(bin(X))[3:]",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[3:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "bx = list(bin(X))[2:]  # Convert X to binary and remove the '0b' prefix",
      "mutated_line": "bx = list(bin(X))[1:]",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[1:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "bx = list(bin(X))[2:]  # Convert X to binary and remove the '0b' prefix",
      "mutated_line": "bx = list(bin(X))[0:]",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[0:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "bx = list(bin(X))[2:]  # Convert X to binary and remove the '0b' prefix",
      "mutated_line": "bx = list(bin(X))[1:]",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[1:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "bx = list(bin(X))[2:]  # Convert X to binary and remove the '0b' prefix",
      "mutated_line": "bx = list(bin(X))[-2:]",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[-2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "by = list(bin(Y))[2:]  # Convert Y to binary and remove the '0b' prefix",
      "mutated_line": "by = list(bin(Y))[3:]",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[3:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "by = list(bin(Y))[2:]  # Convert Y to binary and remove the '0b' prefix",
      "mutated_line": "by = list(bin(Y))[1:]",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[1:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "by = list(bin(Y))[2:]  # Convert Y to binary and remove the '0b' prefix",
      "mutated_line": "by = list(bin(Y))[0:]",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[0:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "by = list(bin(Y))[2:]  # Convert Y to binary and remove the '0b' prefix",
      "mutated_line": "by = list(bin(Y))[1:]",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[1:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "by = list(bin(Y))[2:]  # Convert Y to binary and remove the '0b' prefix",
      "mutated_line": "by = list(bin(Y))[-2:]",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[-2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "if (N + 1) % 2 ** index >= 2 ** (index - 1):",
      "mutated_line": "if (N + 1) * 2 ** index >= 2 ** (index - 1):",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) * 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "if (N + 1) % 2 ** index >= 2 ** (index - 1):",
      "mutated_line": "if N + 1 + 2 ** index >= 2 ** (index - 1):",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if N + 1 + 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "if (N + 1) % 2 ** index >= 2 ** (index - 1):",
      "mutated_line": "if (N + 1) % 2 ** index >= 2 * (index - 1):",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 * (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "if (N + 1) % 2 ** index >= 2 ** (index - 1):",
      "mutated_line": "if (N + 1) % 2 ** index >= 2 + (index - 1):",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 + (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "k = 2 ** (index - 1)",
      "mutated_line": "k = 2 * (index - 1)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 * (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "k = 2 ** (index - 1)",
      "mutated_line": "k = 2 + (index - 1)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 + (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "k = (N + 1) % 2 ** index",
      "mutated_line": "k = (N + 1) * 2 ** index",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) * 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "k = (N + 1) % 2 ** index",
      "mutated_line": "k = N + 1 + 2 ** index",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = N + 1 + 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k",
      "mutated_line": "return int((N + 1) / 2 ** index) * 2 ** (index - 1) - k",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) - k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k",
      "mutated_line": "return int((N + 1) / 2 ** index) * 2 ** (index - 1) * k",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) * k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)",
      "mutated_line": "return N + 1 + (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 + (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)",
      "mutated_line": "return (N + 1) * (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return (N + 1) * (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if bx[j] != by[j]:",
      "mutated_line": "if bx[j] == by[j]:",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] == by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "if (N + 1) % 2 ** index >= 2 ** (index - 1):",
      "mutated_line": "if (N + 1) * 2 ** index >= 2 ** (index - 1):",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) * 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "if (N + 1) % 2 ** index >= 2 ** (index - 1):",
      "mutated_line": "if N + 1 + 2 ** index >= 2 ** (index - 1):",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if N + 1 + 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "if (N + 1) % 2 ** index >= 2 ** (index - 1):",
      "mutated_line": "if (N + 1) % 2 ** index >= 2 * (index - 1):",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 * (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "if (N + 1) % 2 ** index >= 2 ** (index - 1):",
      "mutated_line": "if (N + 1) % 2 ** index >= 2 + (index - 1):",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 + (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "k = 2 ** (index - 1)",
      "mutated_line": "k = 2 * (index - 1)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 * (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "k = 2 ** (index - 1)",
      "mutated_line": "k = 2 + (index - 1)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 + (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "k = (N + 1) % 2 ** index",
      "mutated_line": "k = (N + 1) * 2 ** index",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) * 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "k = (N + 1) % 2 ** index",
      "mutated_line": "k = N + 1 + 2 ** index",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = N + 1 + 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if flag == 2:",
      "mutated_line": "if flag == 3:",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 3:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if flag == 2:",
      "mutated_line": "if flag == 1:",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 1:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if flag == 2:",
      "mutated_line": "if flag == 0:",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 0:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if flag == 2:",
      "mutated_line": "if flag == 1:",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 1:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if flag == 2:",
      "mutated_line": "if flag == -2:",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == -2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 1\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return -1\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 1\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "elif flag == 1:",
      "mutated_line": "elif flag != 1:",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag != 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "if (N + 1) % 2 ** index >= 2 ** (index - 1):",
      "mutated_line": "if (N - 1) % 2 ** index >= 2 ** (index - 1):",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N - 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "if (N + 1) % 2 ** index >= 2 ** (index - 1):",
      "mutated_line": "if N * 1 % 2 ** index >= 2 ** (index - 1):",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if N * 1 % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "if (N + 1) % 2 ** index >= 2 ** (index - 1):",
      "mutated_line": "if (N + 1) % (2 * index) >= 2 ** (index - 1):",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % (2 * index) >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "if (N + 1) % 2 ** index >= 2 ** (index - 1):",
      "mutated_line": "if (N + 1) % (2 + index) >= 2 ** (index - 1):",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % (2 + index) >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if (N + 1) % 2 ** index >= 2 ** (index - 1):",
      "mutated_line": "if (N + 1) % 2 ** index >= 3 ** (index - 1):",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 3 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if (N + 1) % 2 ** index >= 2 ** (index - 1):",
      "mutated_line": "if (N + 1) % 2 ** index >= 1 ** (index - 1):",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 1 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if (N + 1) % 2 ** index >= 2 ** (index - 1):",
      "mutated_line": "if (N + 1) % 2 ** index >= 0 ** (index - 1):",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 0 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if (N + 1) % 2 ** index >= 2 ** (index - 1):",
      "mutated_line": "if (N + 1) % 2 ** index >= 1 ** (index - 1):",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 1 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if (N + 1) % 2 ** index >= 2 ** (index - 1):",
      "mutated_line": "if (N + 1) % 2 ** index >= -2 ** (index - 1):",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= -2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "if (N + 1) % 2 ** index >= 2 ** (index - 1):",
      "mutated_line": "if (N + 1) % 2 ** index >= 2 ** (index + 1):",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index + 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "if (N + 1) % 2 ** index >= 2 ** (index - 1):",
      "mutated_line": "if (N + 1) % 2 ** index >= 2 ** (index * 1):",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index * 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "k = 2 ** (index - 1)",
      "mutated_line": "k = 3 ** (index - 1)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 3 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "k = 2 ** (index - 1)",
      "mutated_line": "k = 1 ** (index - 1)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 1 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "k = 2 ** (index - 1)",
      "mutated_line": "k = 0 ** (index - 1)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 0 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "k = 2 ** (index - 1)",
      "mutated_line": "k = 1 ** (index - 1)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 1 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "k = 2 ** (index - 1)",
      "mutated_line": "k = -2 ** (index - 1)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = -2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "k = 2 ** (index - 1)",
      "mutated_line": "k = 2 ** (index + 1)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index + 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "k = 2 ** (index - 1)",
      "mutated_line": "k = 2 ** (index * 1)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index * 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "k = (N + 1) % 2 ** index",
      "mutated_line": "k = (N - 1) % 2 ** index",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N - 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "k = (N + 1) % 2 ** index",
      "mutated_line": "k = N * 1 % 2 ** index",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = N * 1 % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "k = (N + 1) % 2 ** index",
      "mutated_line": "k = (N + 1) % (2 * index)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % (2 * index)\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "k = (N + 1) % 2 ** index",
      "mutated_line": "k = (N + 1) % (2 + index)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % (2 + index)\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k",
      "mutated_line": "return int((N + 1) / 2 ** index) / 2 ** (index - 1) + k",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) / 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k",
      "mutated_line": "return int((N + 1) / 2 ** index) + 2 ** (index - 1) + k",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) + 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k",
      "mutated_line": "return int((N + 1) / 2 ** index) ** 2 ** (index - 1) + k",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) ** 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)",
      "mutated_line": "return N - 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N - 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)",
      "mutated_line": "return N * 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N * 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)",
      "mutated_line": "return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) - k)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) - k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)",
      "mutated_line": "return N + 1 - int((N + 1) / 2 ** index) * 2 ** (index - 1) * k",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - int((N + 1) / 2 ** index) * 2 ** (index - 1) * k\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "index = lx - j",
      "mutated_line": "index = lx + j",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx + j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "index = lx - j",
      "mutated_line": "index = lx * j",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx * j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if bx[j] == '0':",
      "mutated_line": "if bx[j] != '0':",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] != '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "if (N + 1) % 2 ** index >= 2 ** (index - 1):",
      "mutated_line": "if (N - 1) % 2 ** index >= 2 ** (index - 1):",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N - 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "if (N + 1) % 2 ** index >= 2 ** (index - 1):",
      "mutated_line": "if N * 1 % 2 ** index >= 2 ** (index - 1):",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if N * 1 % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "if (N + 1) % 2 ** index >= 2 ** (index - 1):",
      "mutated_line": "if (N + 1) % (2 * index) >= 2 ** (index - 1):",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % (2 * index) >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "if (N + 1) % 2 ** index >= 2 ** (index - 1):",
      "mutated_line": "if (N + 1) % (2 + index) >= 2 ** (index - 1):",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % (2 + index) >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if (N + 1) % 2 ** index >= 2 ** (index - 1):",
      "mutated_line": "if (N + 1) % 2 ** index >= 3 ** (index - 1):",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 3 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if (N + 1) % 2 ** index >= 2 ** (index - 1):",
      "mutated_line": "if (N + 1) % 2 ** index >= 1 ** (index - 1):",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 1 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if (N + 1) % 2 ** index >= 2 ** (index - 1):",
      "mutated_line": "if (N + 1) % 2 ** index >= 0 ** (index - 1):",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 0 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if (N + 1) % 2 ** index >= 2 ** (index - 1):",
      "mutated_line": "if (N + 1) % 2 ** index >= 1 ** (index - 1):",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 1 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if (N + 1) % 2 ** index >= 2 ** (index - 1):",
      "mutated_line": "if (N + 1) % 2 ** index >= -2 ** (index - 1):",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= -2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "if (N + 1) % 2 ** index >= 2 ** (index - 1):",
      "mutated_line": "if (N + 1) % 2 ** index >= 2 ** (index + 1):",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index + 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "if (N + 1) % 2 ** index >= 2 ** (index - 1):",
      "mutated_line": "if (N + 1) % 2 ** index >= 2 ** (index * 1):",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index * 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "k = 2 ** (index - 1)",
      "mutated_line": "k = 3 ** (index - 1)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 3 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "k = 2 ** (index - 1)",
      "mutated_line": "k = 1 ** (index - 1)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 1 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "k = 2 ** (index - 1)",
      "mutated_line": "k = 0 ** (index - 1)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 0 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "k = 2 ** (index - 1)",
      "mutated_line": "k = 1 ** (index - 1)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 1 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "k = 2 ** (index - 1)",
      "mutated_line": "k = -2 ** (index - 1)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = -2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "k = 2 ** (index - 1)",
      "mutated_line": "k = 2 ** (index + 1)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index + 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "k = 2 ** (index - 1)",
      "mutated_line": "k = 2 ** (index * 1)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index * 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "k = (N + 1) % 2 ** index",
      "mutated_line": "k = (N - 1) % 2 ** index",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N - 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "k = (N + 1) % 2 ** index",
      "mutated_line": "k = N * 1 % 2 ** index",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = N * 1 % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "k = (N + 1) % 2 ** index",
      "mutated_line": "k = (N + 1) % (2 * index)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % (2 * index)\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "k = (N + 1) % 2 ** index",
      "mutated_line": "k = (N + 1) % (2 + index)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % (2 + index)\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "elif flag == 1:",
      "mutated_line": "elif flag == 2:",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 2:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "elif flag == 1:",
      "mutated_line": "elif flag == 0:",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 0:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "elif flag == 1:",
      "mutated_line": "elif flag == 0:",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 0:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "elif flag == 1:",
      "mutated_line": "elif flag == -1:",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == -1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)",
      "mutated_line": "return N + 1 + (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 + (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)",
      "mutated_line": "return (N + 1) * (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return (N + 1) * (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k",
      "mutated_line": "return int((N + 1) / 2 ** index) * 2 ** (index - 1) - k",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) - k"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k",
      "mutated_line": "return int((N + 1) / 2 ** index) * 2 ** (index - 1) * k",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) * k"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if (N + 1) % 2 ** index >= 2 ** (index - 1):",
      "mutated_line": "if (N + 2) % 2 ** index >= 2 ** (index - 1):",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 2) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if (N + 1) % 2 ** index >= 2 ** (index - 1):",
      "mutated_line": "if (N + 0) % 2 ** index >= 2 ** (index - 1):",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 0) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if (N + 1) % 2 ** index >= 2 ** (index - 1):",
      "mutated_line": "if (N + 0) % 2 ** index >= 2 ** (index - 1):",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 0) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if (N + 1) % 2 ** index >= 2 ** (index - 1):",
      "mutated_line": "if (N + -1) % 2 ** index >= 2 ** (index - 1):",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + -1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if (N + 1) % 2 ** index >= 2 ** (index - 1):",
      "mutated_line": "if (N + 1) % 3 ** index >= 2 ** (index - 1):",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 3 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if (N + 1) % 2 ** index >= 2 ** (index - 1):",
      "mutated_line": "if (N + 1) % 1 ** index >= 2 ** (index - 1):",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 1 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if (N + 1) % 2 ** index >= 2 ** (index - 1):",
      "mutated_line": "if (N + 1) % 0 ** index >= 2 ** (index - 1):",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 0 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if (N + 1) % 2 ** index >= 2 ** (index - 1):",
      "mutated_line": "if (N + 1) % 1 ** index >= 2 ** (index - 1):",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 1 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if (N + 1) % 2 ** index >= 2 ** (index - 1):",
      "mutated_line": "if (N + 1) % -2 ** index >= 2 ** (index - 1):",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % -2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if (N + 1) % 2 ** index >= 2 ** (index - 1):",
      "mutated_line": "if (N + 1) % 2 ** index >= 2 ** (index - 2):",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 2):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if (N + 1) % 2 ** index >= 2 ** (index - 1):",
      "mutated_line": "if (N + 1) % 2 ** index >= 2 ** (index - 0):",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 0):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if (N + 1) % 2 ** index >= 2 ** (index - 1):",
      "mutated_line": "if (N + 1) % 2 ** index >= 2 ** (index - 0):",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 0):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if (N + 1) % 2 ** index >= 2 ** (index - 1):",
      "mutated_line": "if (N + 1) % 2 ** index >= 2 ** (index - -1):",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - -1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "k = 2 ** (index - 1)",
      "mutated_line": "k = 2 ** (index - 2)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 2)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "k = 2 ** (index - 1)",
      "mutated_line": "k = 2 ** (index - 0)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 0)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "k = 2 ** (index - 1)",
      "mutated_line": "k = 2 ** (index - 0)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 0)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "k = 2 ** (index - 1)",
      "mutated_line": "k = 2 ** (index - -1)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - -1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "k = (N + 1) % 2 ** index",
      "mutated_line": "k = (N + 2) % 2 ** index",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 2) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "k = (N + 1) % 2 ** index",
      "mutated_line": "k = (N + 0) % 2 ** index",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 0) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "k = (N + 1) % 2 ** index",
      "mutated_line": "k = (N + 0) % 2 ** index",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 0) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "k = (N + 1) % 2 ** index",
      "mutated_line": "k = (N + -1) % 2 ** index",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + -1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "k = (N + 1) % 2 ** index",
      "mutated_line": "k = (N + 1) % 3 ** index",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 3 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "k = (N + 1) % 2 ** index",
      "mutated_line": "k = (N + 1) % 1 ** index",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 1 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "k = (N + 1) % 2 ** index",
      "mutated_line": "k = (N + 1) % 0 ** index",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 0 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "k = (N + 1) % 2 ** index",
      "mutated_line": "k = (N + 1) % 1 ** index",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 1 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "k = (N + 1) % 2 ** index",
      "mutated_line": "k = (N + 1) % -2 ** index",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % -2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k",
      "mutated_line": "return int((N + 1) / 2 ** index) * (2 * (index - 1)) + k",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * (2 * (index - 1)) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k",
      "mutated_line": "return int((N + 1) / 2 ** index) * (2 + (index - 1)) + k",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * (2 + (index - 1)) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)",
      "mutated_line": "return N + 2 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 2 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)",
      "mutated_line": "return N + 0 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 0 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)",
      "mutated_line": "return N + 0 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 0 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)",
      "mutated_line": "return N + -1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + -1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)",
      "mutated_line": "return N + 1 - (int((N + 1) / 2 ** index) / 2 ** (index - 1) + k)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) / 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)",
      "mutated_line": "return N + 1 - (int((N + 1) / 2 ** index) + 2 ** (index - 1) + k)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) + 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)",
      "mutated_line": "return N + 1 - (int((N + 1) / 2 ** index) ** 2 ** (index - 1) + k)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) ** 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if bx[j] == '0':",
      "mutated_line": "if bx[j] == '':",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "flag = 0",
      "mutated_line": "flag = 1",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 1\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "flag = 0",
      "mutated_line": "flag = -1",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = -1\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "flag = 0",
      "mutated_line": "flag = 1",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 1\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "flag = 1",
      "mutated_line": "flag = 2",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 2\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "flag = 1",
      "mutated_line": "flag = 0",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 0\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "flag = 1",
      "mutated_line": "flag = 0",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 0\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "flag = 1",
      "mutated_line": "flag = -1",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = -1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if (N + 1) % 2 ** index >= 2 ** (index - 1):",
      "mutated_line": "if (N + 2) % 2 ** index >= 2 ** (index - 1):",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 2) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if (N + 1) % 2 ** index >= 2 ** (index - 1):",
      "mutated_line": "if (N + 0) % 2 ** index >= 2 ** (index - 1):",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 0) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if (N + 1) % 2 ** index >= 2 ** (index - 1):",
      "mutated_line": "if (N + 0) % 2 ** index >= 2 ** (index - 1):",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 0) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if (N + 1) % 2 ** index >= 2 ** (index - 1):",
      "mutated_line": "if (N + -1) % 2 ** index >= 2 ** (index - 1):",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + -1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if (N + 1) % 2 ** index >= 2 ** (index - 1):",
      "mutated_line": "if (N + 1) % 3 ** index >= 2 ** (index - 1):",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 3 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if (N + 1) % 2 ** index >= 2 ** (index - 1):",
      "mutated_line": "if (N + 1) % 1 ** index >= 2 ** (index - 1):",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 1 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if (N + 1) % 2 ** index >= 2 ** (index - 1):",
      "mutated_line": "if (N + 1) % 0 ** index >= 2 ** (index - 1):",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 0 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if (N + 1) % 2 ** index >= 2 ** (index - 1):",
      "mutated_line": "if (N + 1) % 1 ** index >= 2 ** (index - 1):",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 1 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if (N + 1) % 2 ** index >= 2 ** (index - 1):",
      "mutated_line": "if (N + 1) % -2 ** index >= 2 ** (index - 1):",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % -2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if (N + 1) % 2 ** index >= 2 ** (index - 1):",
      "mutated_line": "if (N + 1) % 2 ** index >= 2 ** (index - 2):",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 2):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if (N + 1) % 2 ** index >= 2 ** (index - 1):",
      "mutated_line": "if (N + 1) % 2 ** index >= 2 ** (index - 0):",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 0):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if (N + 1) % 2 ** index >= 2 ** (index - 1):",
      "mutated_line": "if (N + 1) % 2 ** index >= 2 ** (index - 0):",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 0):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if (N + 1) % 2 ** index >= 2 ** (index - 1):",
      "mutated_line": "if (N + 1) % 2 ** index >= 2 ** (index - -1):",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - -1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "k = 2 ** (index - 1)",
      "mutated_line": "k = 2 ** (index - 2)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 2)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "k = 2 ** (index - 1)",
      "mutated_line": "k = 2 ** (index - 0)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 0)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "k = 2 ** (index - 1)",
      "mutated_line": "k = 2 ** (index - 0)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 0)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "k = 2 ** (index - 1)",
      "mutated_line": "k = 2 ** (index - -1)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - -1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "k = (N + 1) % 2 ** index",
      "mutated_line": "k = (N + 2) % 2 ** index",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 2) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "k = (N + 1) % 2 ** index",
      "mutated_line": "k = (N + 0) % 2 ** index",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 0) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "k = (N + 1) % 2 ** index",
      "mutated_line": "k = (N + 0) % 2 ** index",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 0) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "k = (N + 1) % 2 ** index",
      "mutated_line": "k = (N + -1) % 2 ** index",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + -1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "k = (N + 1) % 2 ** index",
      "mutated_line": "k = (N + 1) % 3 ** index",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 3 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "k = (N + 1) % 2 ** index",
      "mutated_line": "k = (N + 1) % 1 ** index",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 1 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "k = (N + 1) % 2 ** index",
      "mutated_line": "k = (N + 1) % 0 ** index",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 0 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "k = (N + 1) % 2 ** index",
      "mutated_line": "k = (N + 1) % 1 ** index",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 1 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "k = (N + 1) % 2 ** index",
      "mutated_line": "k = (N + 1) % -2 ** index",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % -2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)",
      "mutated_line": "return N - 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N - 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)",
      "mutated_line": "return N * 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N * 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)",
      "mutated_line": "return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) - k)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) - k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)",
      "mutated_line": "return N + 1 - int((N + 1) / 2 ** index) * 2 ** (index - 1) * k",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - int((N + 1) / 2 ** index) * 2 ** (index - 1) * k\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k",
      "mutated_line": "return int((N + 1) / 2 ** index) / 2 ** (index - 1) + k",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) / 2 ** (index - 1) + k"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k",
      "mutated_line": "return int((N + 1) / 2 ** index) + 2 ** (index - 1) + k",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) + 2 ** (index - 1) + k"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k",
      "mutated_line": "return int((N + 1) / 2 ** index) ** 2 ** (index - 1) + k",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) ** 2 ** (index - 1) + k"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k",
      "mutated_line": "return int((N + 1) * 2 ** index) * 2 ** (index - 1) + k",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) * 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k",
      "mutated_line": "return int((N + 1) // 2 ** index) * 2 ** (index - 1) + k",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) // 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k",
      "mutated_line": "return int((N + 1) / 2 ** index) * 3 ** (index - 1) + k",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 3 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k",
      "mutated_line": "return int((N + 1) / 2 ** index) * 1 ** (index - 1) + k",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 1 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k",
      "mutated_line": "return int((N + 1) / 2 ** index) * 0 ** (index - 1) + k",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 0 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k",
      "mutated_line": "return int((N + 1) / 2 ** index) * 1 ** (index - 1) + k",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 1 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k",
      "mutated_line": "return int((N + 1) / 2 ** index) * -2 ** (index - 1) + k",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * -2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k",
      "mutated_line": "return int((N + 1) / 2 ** index) * 2 ** (index + 1) + k",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index + 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k",
      "mutated_line": "return int((N + 1) / 2 ** index) * 2 ** (index * 1) + k",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index * 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)",
      "mutated_line": "return N + 1 - (int((N + 1) / 2 ** index) * (2 * (index - 1)) + k)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * (2 * (index - 1)) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)",
      "mutated_line": "return N + 1 - (int((N + 1) / 2 ** index) * (2 + (index - 1)) + k)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * (2 + (index - 1)) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)",
      "mutated_line": "return N + 2 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 2 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)",
      "mutated_line": "return N + 0 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 0 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)",
      "mutated_line": "return N + 0 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 0 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)",
      "mutated_line": "return N + -1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + -1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)",
      "mutated_line": "return N + 1 - (int((N + 1) / 2 ** index) / 2 ** (index - 1) + k)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) / 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)",
      "mutated_line": "return N + 1 - (int((N + 1) / 2 ** index) + 2 ** (index - 1) + k)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) + 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)",
      "mutated_line": "return N + 1 - (int((N + 1) / 2 ** index) ** 2 ** (index - 1) + k)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) ** 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k",
      "mutated_line": "return int((N + 1) / 2 ** index) * (2 * (index - 1)) + k",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * (2 * (index - 1)) + k"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k",
      "mutated_line": "return int((N + 1) / 2 ** index) * (2 + (index - 1)) + k",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * (2 + (index - 1)) + k"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k",
      "mutated_line": "return int((N - 1) / 2 ** index) * 2 ** (index - 1) + k",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N - 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k",
      "mutated_line": "return int(N * 1 / 2 ** index) * 2 ** (index - 1) + k",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int(N * 1 / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k",
      "mutated_line": "return int((N + 1) / (2 * index)) * 2 ** (index - 1) + k",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / (2 * index)) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k",
      "mutated_line": "return int((N + 1) / (2 + index)) * 2 ** (index - 1) + k",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / (2 + index)) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k",
      "mutated_line": "return int((N + 1) / 2 ** index) * 2 ** (index - 2) + k",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 2) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k",
      "mutated_line": "return int((N + 1) / 2 ** index) * 2 ** (index - 0) + k",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 0) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k",
      "mutated_line": "return int((N + 1) / 2 ** index) * 2 ** (index - 0) + k",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 0) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k",
      "mutated_line": "return int((N + 1) / 2 ** index) * 2 ** (index - -1) + k",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - -1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)",
      "mutated_line": "return N + 1 - (int((N + 1) * 2 ** index) * 2 ** (index - 1) + k)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) * 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)",
      "mutated_line": "return N + 1 - (int((N + 1) // 2 ** index) * 2 ** (index - 1) + k)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) // 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)",
      "mutated_line": "return N + 1 - (int((N + 1) / 2 ** index) * 3 ** (index - 1) + k)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 3 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)",
      "mutated_line": "return N + 1 - (int((N + 1) / 2 ** index) * 1 ** (index - 1) + k)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 1 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)",
      "mutated_line": "return N + 1 - (int((N + 1) / 2 ** index) * 0 ** (index - 1) + k)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 0 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)",
      "mutated_line": "return N + 1 - (int((N + 1) / 2 ** index) * 1 ** (index - 1) + k)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 1 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)",
      "mutated_line": "return N + 1 - (int((N + 1) / 2 ** index) * -2 ** (index - 1) + k)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * -2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)",
      "mutated_line": "return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index + 1) + k)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index + 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)",
      "mutated_line": "return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index * 1) + k)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index * 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)",
      "mutated_line": "return N + 1 - (int((N + 1) / 2 ** index) * (2 * (index - 1)) + k)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * (2 * (index - 1)) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)",
      "mutated_line": "return N + 1 - (int((N + 1) / 2 ** index) * (2 + (index - 1)) + k)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * (2 + (index - 1)) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k",
      "mutated_line": "return int((N + 1) * 2 ** index) * 2 ** (index - 1) + k",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) * 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k",
      "mutated_line": "return int((N + 1) // 2 ** index) * 2 ** (index - 1) + k",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) // 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k",
      "mutated_line": "return int((N + 1) / 2 ** index) * 3 ** (index - 1) + k",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 3 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k",
      "mutated_line": "return int((N + 1) / 2 ** index) * 1 ** (index - 1) + k",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 1 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k",
      "mutated_line": "return int((N + 1) / 2 ** index) * 0 ** (index - 1) + k",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 0 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k",
      "mutated_line": "return int((N + 1) / 2 ** index) * 1 ** (index - 1) + k",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 1 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k",
      "mutated_line": "return int((N + 1) / 2 ** index) * -2 ** (index - 1) + k",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * -2 ** (index - 1) + k"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k",
      "mutated_line": "return int((N + 1) / 2 ** index) * 2 ** (index + 1) + k",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index + 1) + k"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k",
      "mutated_line": "return int((N + 1) / 2 ** index) * 2 ** (index * 1) + k",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index * 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k",
      "mutated_line": "return int((N + 2) / 2 ** index) * 2 ** (index - 1) + k",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 2) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k",
      "mutated_line": "return int((N + 0) / 2 ** index) * 2 ** (index - 1) + k",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 0) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k",
      "mutated_line": "return int((N + 0) / 2 ** index) * 2 ** (index - 1) + k",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 0) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k",
      "mutated_line": "return int((N + -1) / 2 ** index) * 2 ** (index - 1) + k",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + -1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k",
      "mutated_line": "return int((N + 1) / 3 ** index) * 2 ** (index - 1) + k",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 3 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k",
      "mutated_line": "return int((N + 1) / 1 ** index) * 2 ** (index - 1) + k",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 1 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k",
      "mutated_line": "return int((N + 1) / 0 ** index) * 2 ** (index - 1) + k",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 0 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k",
      "mutated_line": "return int((N + 1) / 1 ** index) * 2 ** (index - 1) + k",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 1 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k",
      "mutated_line": "return int((N + 1) / -2 ** index) * 2 ** (index - 1) + k",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / -2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)",
      "mutated_line": "return N + 1 - (int((N - 1) / 2 ** index) * 2 ** (index - 1) + k)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N - 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)",
      "mutated_line": "return N + 1 - (int(N * 1 / 2 ** index) * 2 ** (index - 1) + k)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int(N * 1 / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)",
      "mutated_line": "return N + 1 - (int((N + 1) / (2 * index)) * 2 ** (index - 1) + k)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / (2 * index)) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)",
      "mutated_line": "return N + 1 - (int((N + 1) / (2 + index)) * 2 ** (index - 1) + k)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / (2 + index)) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)",
      "mutated_line": "return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 2) + k)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 2) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)",
      "mutated_line": "return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 0) + k)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 0) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)",
      "mutated_line": "return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 0) + k)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 0) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)",
      "mutated_line": "return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - -1) + k)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - -1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)",
      "mutated_line": "return N + 1 - (int((N + 1) * 2 ** index) * 2 ** (index - 1) + k)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) * 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)",
      "mutated_line": "return N + 1 - (int((N + 1) // 2 ** index) * 2 ** (index - 1) + k)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) // 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)",
      "mutated_line": "return N + 1 - (int((N + 1) / 2 ** index) * 3 ** (index - 1) + k)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 3 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)",
      "mutated_line": "return N + 1 - (int((N + 1) / 2 ** index) * 1 ** (index - 1) + k)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 1 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)",
      "mutated_line": "return N + 1 - (int((N + 1) / 2 ** index) * 0 ** (index - 1) + k)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 0 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)",
      "mutated_line": "return N + 1 - (int((N + 1) / 2 ** index) * 1 ** (index - 1) + k)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 1 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)",
      "mutated_line": "return N + 1 - (int((N + 1) / 2 ** index) * -2 ** (index - 1) + k)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * -2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)",
      "mutated_line": "return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index + 1) + k)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index + 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)",
      "mutated_line": "return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index * 1) + k)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index * 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k",
      "mutated_line": "return int((N - 1) / 2 ** index) * 2 ** (index - 1) + k",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N - 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k",
      "mutated_line": "return int(N * 1 / 2 ** index) * 2 ** (index - 1) + k",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int(N * 1 / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k",
      "mutated_line": "return int((N + 1) / (2 * index)) * 2 ** (index - 1) + k",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / (2 * index)) * 2 ** (index - 1) + k"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k",
      "mutated_line": "return int((N + 1) / (2 + index)) * 2 ** (index - 1) + k",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / (2 + index)) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k",
      "mutated_line": "return int((N + 1) / 2 ** index) * 2 ** (index - 2) + k",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 2) + k"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k",
      "mutated_line": "return int((N + 1) / 2 ** index) * 2 ** (index - 0) + k",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 0) + k"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k",
      "mutated_line": "return int((N + 1) / 2 ** index) * 2 ** (index - 0) + k",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 0) + k"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k",
      "mutated_line": "return int((N + 1) / 2 ** index) * 2 ** (index - -1) + k",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - -1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)",
      "mutated_line": "return N + 1 - (int((N + 2) / 2 ** index) * 2 ** (index - 1) + k)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 2) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)",
      "mutated_line": "return N + 1 - (int((N + 0) / 2 ** index) * 2 ** (index - 1) + k)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 0) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)",
      "mutated_line": "return N + 1 - (int((N + 0) / 2 ** index) * 2 ** (index - 1) + k)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 0) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)",
      "mutated_line": "return N + 1 - (int((N + -1) / 2 ** index) * 2 ** (index - 1) + k)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + -1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)",
      "mutated_line": "return N + 1 - (int((N + 1) / 3 ** index) * 2 ** (index - 1) + k)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 3 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)",
      "mutated_line": "return N + 1 - (int((N + 1) / 1 ** index) * 2 ** (index - 1) + k)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 1 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)",
      "mutated_line": "return N + 1 - (int((N + 1) / 0 ** index) * 2 ** (index - 1) + k)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 0 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)",
      "mutated_line": "return N + 1 - (int((N + 1) / 1 ** index) * 2 ** (index - 1) + k)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 1 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)",
      "mutated_line": "return N + 1 - (int((N + 1) / -2 ** index) * 2 ** (index - 1) + k)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / -2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)",
      "mutated_line": "return N + 1 - (int((N - 1) / 2 ** index) * 2 ** (index - 1) + k)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N - 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)",
      "mutated_line": "return N + 1 - (int(N * 1 / 2 ** index) * 2 ** (index - 1) + k)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int(N * 1 / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)",
      "mutated_line": "return N + 1 - (int((N + 1) / (2 * index)) * 2 ** (index - 1) + k)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / (2 * index)) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)",
      "mutated_line": "return N + 1 - (int((N + 1) / (2 + index)) * 2 ** (index - 1) + k)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / (2 + index)) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)",
      "mutated_line": "return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 2) + k)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 2) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)",
      "mutated_line": "return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 0) + k)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 0) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)",
      "mutated_line": "return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 0) + k)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 0) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)",
      "mutated_line": "return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - -1) + k)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - -1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k",
      "mutated_line": "return int((N + 2) / 2 ** index) * 2 ** (index - 1) + k",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 2) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k",
      "mutated_line": "return int((N + 0) / 2 ** index) * 2 ** (index - 1) + k",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 0) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k",
      "mutated_line": "return int((N + 0) / 2 ** index) * 2 ** (index - 1) + k",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 0) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k",
      "mutated_line": "return int((N + -1) / 2 ** index) * 2 ** (index - 1) + k",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + -1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k",
      "mutated_line": "return int((N + 1) / 3 ** index) * 2 ** (index - 1) + k",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 3 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k",
      "mutated_line": "return int((N + 1) / 1 ** index) * 2 ** (index - 1) + k",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 1 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k",
      "mutated_line": "return int((N + 1) / 0 ** index) * 2 ** (index - 1) + k",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 0 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k",
      "mutated_line": "return int((N + 1) / 1 ** index) * 2 ** (index - 1) + k",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 1 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k",
      "mutated_line": "return int((N + 1) / -2 ** index) * 2 ** (index - 1) + k",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / -2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)",
      "mutated_line": "return N + 1 - (int((N + 2) / 2 ** index) * 2 ** (index - 1) + k)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 2) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)",
      "mutated_line": "return N + 1 - (int((N + 0) / 2 ** index) * 2 ** (index - 1) + k)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 0) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)",
      "mutated_line": "return N + 1 - (int((N + 0) / 2 ** index) * 2 ** (index - 1) + k)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 0) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)",
      "mutated_line": "return N + 1 - (int((N + -1) / 2 ** index) * 2 ** (index - 1) + k)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + -1) / 2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)",
      "mutated_line": "return N + 1 - (int((N + 1) / 3 ** index) * 2 ** (index - 1) + k)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 3 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)",
      "mutated_line": "return N + 1 - (int((N + 1) / 1 ** index) * 2 ** (index - 1) + k)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 1 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)",
      "mutated_line": "return N + 1 - (int((N + 1) / 0 ** index) * 2 ** (index - 1) + k)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 0 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)",
      "mutated_line": "return N + 1 - (int((N + 1) / 1 ** index) * 2 ** (index - 1) + k)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / 1 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)",
      "mutated_line": "return N + 1 - (int((N + 1) / -2 ** index) * 2 ** (index - 1) + k)",
      "code": "def count_valid_Z(X, Y, N):\n    bx = list(bin(X))[2:]\n    by = list(bin(Y))[2:]\n    lx = len(bx)\n    ly = len(by)\n    index = 0\n    flag = 2\n    k = -1\n    if lx != ly:\n        index = max(lx, ly)\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if lx < ly:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k\n        else:\n            return N + 1 - (int((N + 1) / 2 ** index) * 2 ** (index - 1) + k)\n    else:\n        for j in range(lx):\n            if bx[j] != by[j]:\n                index = lx - j\n                if bx[j] == '0':\n                    flag = 0\n                else:\n                    flag = 1\n                break\n        if (N + 1) % 2 ** index >= 2 ** (index - 1):\n            k = 2 ** (index - 1)\n        else:\n            k = (N + 1) % 2 ** index\n        if flag == 2:\n            return 0\n        elif flag == 1:\n            return N + 1 - (int((N + 1) / -2 ** index) * 2 ** (index - 1) + k)\n        else:\n            return int((N + 1) / 2 ** index) * 2 ** (index - 1) + k"
    }
  ]
}