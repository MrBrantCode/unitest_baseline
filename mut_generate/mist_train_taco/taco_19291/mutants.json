{
  "task_id": "taco_19291",
  "entry_point": "eulen",
  "mutant_count": 179,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "curTime = 0",
      "mutated_line": "curTime = 1",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 1\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "curTime = 0",
      "mutated_line": "curTime = -1",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = -1\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "curTime = 0",
      "mutated_line": "curTime = 1",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 1\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return \"NO\"",
      "mutated_line": "return ''",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return ''"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "mutated_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 < (t * vp) ** 2 + 1e-07",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 < (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "mutated_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 > (t * vp) ** 2 + 1e-07",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 > (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "mutated_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 == (t * vp) ** 2 + 1e-07",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 == (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "endTime = curTime + eulen(points[i], points[i + 1]) / vs",
      "mutated_line": "endTime = curTime - eulen(points[i], points[i + 1]) / vs",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime - eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "endTime = curTime + eulen(points[i], points[i + 1]) / vs",
      "mutated_line": "endTime = curTime * (eulen(points[i], points[i + 1]) / vs)",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime * (eulen(points[i], points[i + 1]) / vs)\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))",
      "mutated_line": "r = functools.reduce(lambda x, y: x - y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x - y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))",
      "mutated_line": "r = functools.reduce(lambda x, y: x * y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x * y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "mutated_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 - (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 - (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "mutated_line": "return ((harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2) * (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return ((harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2) * (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "mutated_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 - 1e-07",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 - 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "mutated_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 * 1e-07",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 * 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "endTime = curTime + eulen(points[i], points[i + 1]) / vs",
      "mutated_line": "endTime = curTime + eulen(points[i], points[i + 1]) * vs",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) * vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "endTime = curTime + eulen(points[i], points[i + 1]) / vs",
      "mutated_line": "endTime = curTime + eulen(points[i], points[i + 1]) // vs",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) // vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))",
      "mutated_line": "r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) * 2, zip(x, y)))",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) * 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))",
      "mutated_line": "r = functools.reduce(lambda x, y: x + y, map(lambda x: x[0] - x[1] + 2, zip(x, y)))",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: x[0] - x[1] + 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "mutated_line": "return (harry_position[0] - p[0]) ** 2 - (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 - (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "mutated_line": "return (harry_position[0] - p[0]) ** 2 * (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 * (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "mutated_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) * 2 <= (t * vp) ** 2 + 1e-07",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) * 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "mutated_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2] + 2) <= (t * vp) ** 2 + 1e-07",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2] + 2) <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "mutated_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= t * vp * 2 + 1e-07",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= t * vp * 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "mutated_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= t * vp + 2 + 1e-07",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= t * vp + 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "mutated_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1.0000001",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1.0000001\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "mutated_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + -0.9999999",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + -0.9999999\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "mutated_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 0",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 0\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "mutated_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "mutated_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + -1e-07",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + -1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "if lies_in(points[i + 1], endTime):",
      "mutated_line": "if lies_in(points[i - 1], endTime):",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i - 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "if lies_in(points[i + 1], endTime):",
      "mutated_line": "if lies_in(points[i * 1], endTime):",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i * 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "(left, right) = (0, endTime - curTime + 1e-08)",
      "mutated_line": "(left, right) = (1, endTime - curTime + 1e-08)",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (1, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "(left, right) = (0, endTime - curTime + 1e-08)",
      "mutated_line": "(left, right) = (-1, endTime - curTime + 1e-08)",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (-1, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "(left, right) = (0, endTime - curTime + 1e-08)",
      "mutated_line": "(left, right) = (1, endTime - curTime + 1e-08)",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (1, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "(left, right) = (0, endTime - curTime + 1e-08)",
      "mutated_line": "(left, right) = (0, endTime - curTime - 1e-08)",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime - 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "(left, right) = (0, endTime - curTime + 1e-08)",
      "mutated_line": "(left, right) = (0, (endTime - curTime) * 1e-08)",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, (endTime - curTime) * 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for j in range(100):",
      "mutated_line": "for j in range(101):",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(101):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for j in range(100):",
      "mutated_line": "for j in range(99):",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(99):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for j in range(100):",
      "mutated_line": "for j in range(0):",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(0):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for j in range(100):",
      "mutated_line": "for j in range(1):",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(1):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for j in range(100):",
      "mutated_line": "for j in range(-100):",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(-100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "mid = (left + right) / 2.0",
      "mutated_line": "mid = (left + right) * 2.0",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) * 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "mid = (left + right) / 2.0",
      "mutated_line": "mid = (left + right) // 2.0",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) // 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return \"YES\", curTime + right, answer",
      "mutated_line": "return ('', curTime + right, answer)",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "return \"YES\", curTime + right, answer",
      "mutated_line": "return ('YES', curTime - right, answer)",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime - right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "return \"YES\", curTime + right, answer",
      "mutated_line": "return ('YES', curTime * right, answer)",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime * right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))",
      "mutated_line": "r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] + x[1]) ** 2, zip(x, y)))",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] + x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))",
      "mutated_line": "r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] * x[1]) ** 2, zip(x, y)))",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] * x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))",
      "mutated_line": "r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 3, zip(x, y)))",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 3, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))",
      "mutated_line": "r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 1, zip(x, y)))",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 1, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))",
      "mutated_line": "r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 0, zip(x, y)))",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 0, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))",
      "mutated_line": "r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 1, zip(x, y)))",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 1, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))",
      "mutated_line": "r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** -2, zip(x, y)))",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** -2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "mutated_line": "return (harry_position[0] - p[0]) * 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) * 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "mutated_line": "return harry_position[0] - p[0] + 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return harry_position[0] - p[0] + 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "mutated_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) * 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) * 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "mutated_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1] + 2) + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1] + 2) + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "mutated_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] + p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] + p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "mutated_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] * p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] * p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "mutated_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 3 <= (t * vp) ** 2 + 1e-07",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 3 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "mutated_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 1 <= (t * vp) ** 2 + 1e-07",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 1 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "mutated_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 0 <= (t * vp) ** 2 + 1e-07",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 0 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "mutated_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 1 <= (t * vp) ** 2 + 1e-07",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 1 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "mutated_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** -2 <= (t * vp) ** 2 + 1e-07",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** -2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "mutated_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t / vp) ** 2 + 1e-07",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t / vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "mutated_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t + vp) ** 2 + 1e-07",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t + vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "mutated_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t ** vp) ** 2 + 1e-07",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t ** vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "mutated_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 3 + 1e-07",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 3 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "mutated_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 1 + 1e-07",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 1 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "mutated_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 0 + 1e-07",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 0 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "mutated_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 1 + 1e-07",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 1 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "mutated_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** -2 + 1e-07",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** -2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if lies_in(points[i + 1], endTime):",
      "mutated_line": "if lies_in(points[i + 2], endTime):",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 2], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if lies_in(points[i + 1], endTime):",
      "mutated_line": "if lies_in(points[i + 0], endTime):",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 0], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if lies_in(points[i + 1], endTime):",
      "mutated_line": "if lies_in(points[i + 0], endTime):",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 0], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if lies_in(points[i + 1], endTime):",
      "mutated_line": "if lies_in(points[i + -1], endTime):",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + -1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return \"YES\", curTime, points[i]",
      "mutated_line": "return ('', curTime, points[i])",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "(left, right) = (0, endTime - curTime + 1e-08)",
      "mutated_line": "(left, right) = (0, endTime + curTime + 1e-08)",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime + curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "(left, right) = (0, endTime - curTime + 1e-08)",
      "mutated_line": "(left, right) = (0, endTime * curTime + 1e-08)",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime * curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "(left, right) = (0, endTime - curTime + 1e-08)",
      "mutated_line": "(left, right) = (0, endTime - curTime + 1.00000001)",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1.00000001)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "(left, right) = (0, endTime - curTime + 1e-08)",
      "mutated_line": "(left, right) = (0, endTime - curTime + -0.99999999)",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + -0.99999999)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "(left, right) = (0, endTime - curTime + 1e-08)",
      "mutated_line": "(left, right) = (0, endTime - curTime + 0)",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 0)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "(left, right) = (0, endTime - curTime + 1e-08)",
      "mutated_line": "(left, right) = (0, endTime - curTime + 1)",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "(left, right) = (0, endTime - curTime + 1e-08)",
      "mutated_line": "(left, right) = (0, endTime - curTime + -1e-08)",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + -1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "fc = eulen(points[i], points[i + 1])",
      "mutated_line": "fc = eulen(points[i], points[i - 1])",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i - 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "fc = eulen(points[i], points[i + 1])",
      "mutated_line": "fc = eulen(points[i], points[i * 1])",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i * 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "mid = (left + right) / 2.0",
      "mutated_line": "mid = (left - right) / 2.0",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left - right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "mid = (left + right) / 2.0",
      "mutated_line": "mid = left * right / 2.0",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = left * right / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "mid = (left + right) / 2.0",
      "mutated_line": "mid = (left + right) / 3.0",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 3.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "mid = (left + right) / 2.0",
      "mutated_line": "mid = (left + right) / 1.0",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 1.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "mid = (left + right) / 2.0",
      "mutated_line": "mid = (left + right) / 0",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "mid = (left + right) / 2.0",
      "mutated_line": "mid = (left + right) / 1",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 1\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "mid = (left + right) / 2.0",
      "mutated_line": "mid = (left + right) / -2.0",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / -2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "if lies_in(endPoint, curTime + mid):",
      "mutated_line": "if lies_in(endPoint, curTime - mid):",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime - mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "if lies_in(endPoint, curTime + mid):",
      "mutated_line": "if lies_in(endPoint, curTime * mid):",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime * mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "mutated_line": "return (harry_position[0] + p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] + p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "mutated_line": "return (harry_position[0] * p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] * p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "mutated_line": "return (harry_position[0] - p[0]) ** 3 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 3 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "mutated_line": "return (harry_position[0] - p[0]) ** 1 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 1 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "mutated_line": "return (harry_position[0] - p[0]) ** 0 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 0 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "mutated_line": "return (harry_position[0] - p[0]) ** 1 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 1 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "mutated_line": "return (harry_position[0] - p[0]) ** -2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** -2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "mutated_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] + p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] + p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "mutated_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] * p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] * p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "mutated_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 3 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 3 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "mutated_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 1 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 1 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "mutated_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 0 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 0 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "mutated_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 1 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 1 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "mutated_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** -2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** -2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "endTime = curTime + eulen(points[i], points[i + 1]) / vs",
      "mutated_line": "endTime = curTime + eulen(points[i], points[i - 1]) / vs",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i - 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "endTime = curTime + eulen(points[i], points[i + 1]) / vs",
      "mutated_line": "endTime = curTime + eulen(points[i], points[i * 1]) / vs",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i * 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "fc = eulen(points[i], points[i + 1])",
      "mutated_line": "fc = eulen(points[i], points[i + 2])",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 2])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "fc = eulen(points[i], points[i + 1])",
      "mutated_line": "fc = eulen(points[i], points[i + 0])",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 0])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "fc = eulen(points[i], points[i + 1])",
      "mutated_line": "fc = eulen(points[i], points[i + 0])",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 0])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "fc = eulen(points[i], points[i + 1])",
      "mutated_line": "fc = eulen(points[i], points[i + -1])",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + -1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))",
      "mutated_line": "r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[1] - x[1]) ** 2, zip(x, y)))",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[1] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))",
      "mutated_line": "r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[-1] - x[1]) ** 2, zip(x, y)))",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[-1] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))",
      "mutated_line": "r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[1] - x[1]) ** 2, zip(x, y)))",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[1] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))",
      "mutated_line": "r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[2]) ** 2, zip(x, y)))",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[2]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))",
      "mutated_line": "r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[0]) ** 2, zip(x, y)))",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[0]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))",
      "mutated_line": "r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[0]) ** 2, zip(x, y)))",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[0]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))",
      "mutated_line": "r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[-1]) ** 2, zip(x, y)))",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[-1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "mutated_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[3] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[3] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "mutated_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[1] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[1] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "mutated_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[0] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[0] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "mutated_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[1] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[1] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "mutated_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[-2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[-2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "mutated_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[3]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[3]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "mutated_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[1]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[1]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "mutated_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[0]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[0]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "mutated_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[1]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[1]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "mutated_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[-2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[-2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "endTime = curTime + eulen(points[i], points[i + 1]) / vs",
      "mutated_line": "endTime = curTime + eulen(points[i], points[i + 2]) / vs",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 2]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "endTime = curTime + eulen(points[i], points[i + 1]) / vs",
      "mutated_line": "endTime = curTime + eulen(points[i], points[i + 0]) / vs",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 0]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "endTime = curTime + eulen(points[i], points[i + 1]) / vs",
      "mutated_line": "endTime = curTime + eulen(points[i], points[i + 0]) / vs",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 0]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "endTime = curTime + eulen(points[i], points[i + 1]) / vs",
      "mutated_line": "endTime = curTime + eulen(points[i], points[i + -1]) / vs",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + -1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))",
      "mutated_line": "endPoint = tuple(map(lambda x: x[0] - (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] - (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))",
      "mutated_line": "endPoint = tuple(map(lambda x: x[0] * ((x[1] - x[0]) / fc * mid * vs), zip(points[i], points[i + 1])))",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] * ((x[1] - x[0]) / fc * mid * vs), zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "mutated_line": "return (harry_position[1] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[1] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "mutated_line": "return (harry_position[-1] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[-1] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "mutated_line": "return (harry_position[1] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[1] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "mutated_line": "return (harry_position[0] - p[1]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[1]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "mutated_line": "return (harry_position[0] - p[-1]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[-1]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "mutated_line": "return (harry_position[0] - p[1]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[1]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "mutated_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[2] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[2] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "mutated_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[0] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[0] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "mutated_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[0] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[0] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "mutated_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[-1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[-1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "mutated_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[2]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[2]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "mutated_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[0]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[0]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "mutated_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[0]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[0]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "mutated_line": "return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[-1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[-1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))",
      "mutated_line": "endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid / vs, zip(points[i], points[i + 1])))",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid / vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))",
      "mutated_line": "endPoint = tuple(map(lambda x: x[0] + ((x[1] - x[0]) / fc * mid + vs), zip(points[i], points[i + 1])))",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + ((x[1] - x[0]) / fc * mid + vs), zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))",
      "mutated_line": "endPoint = tuple(map(lambda x: x[0] + ((x[1] - x[0]) / fc * mid) ** vs, zip(points[i], points[i + 1])))",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + ((x[1] - x[0]) / fc * mid) ** vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))",
      "mutated_line": "endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i - 1])))",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i - 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))",
      "mutated_line": "endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i * 1])))",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i * 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))",
      "mutated_line": "endPoint = tuple(map(lambda x: x[1] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[1] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))",
      "mutated_line": "endPoint = tuple(map(lambda x: x[-1] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[-1] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))",
      "mutated_line": "endPoint = tuple(map(lambda x: x[1] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[1] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))",
      "mutated_line": "endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc / mid * vs, zip(points[i], points[i + 1])))",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc / mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))",
      "mutated_line": "endPoint = tuple(map(lambda x: x[0] + ((x[1] - x[0]) / fc + mid) * vs, zip(points[i], points[i + 1])))",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + ((x[1] - x[0]) / fc + mid) * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))",
      "mutated_line": "endPoint = tuple(map(lambda x: x[0] + ((x[1] - x[0]) / fc) ** mid * vs, zip(points[i], points[i + 1])))",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + ((x[1] - x[0]) / fc) ** mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))",
      "mutated_line": "endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 2])))",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 2])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))",
      "mutated_line": "endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 0])))",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 0])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))",
      "mutated_line": "endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 0])))",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 0])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))",
      "mutated_line": "endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + -1])))",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + -1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))",
      "mutated_line": "endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) * fc * mid * vs, zip(points[i], points[i + 1])))",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) * fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))",
      "mutated_line": "endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) // fc * mid * vs, zip(points[i], points[i + 1])))",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) // fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))",
      "mutated_line": "endPoint = tuple(map(lambda x: x[0] + (x[1] + x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] + x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))",
      "mutated_line": "endPoint = tuple(map(lambda x: x[0] + x[1] * x[0] / fc * mid * vs, zip(points[i], points[i + 1])))",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + x[1] * x[0] / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))",
      "mutated_line": "endPoint = tuple(map(lambda x: x[0] + (x[2] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[2] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))",
      "mutated_line": "endPoint = tuple(map(lambda x: x[0] + (x[0] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[0] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))",
      "mutated_line": "endPoint = tuple(map(lambda x: x[0] + (x[0] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[0] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))",
      "mutated_line": "endPoint = tuple(map(lambda x: x[0] + (x[-1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[-1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))",
      "mutated_line": "endPoint = tuple(map(lambda x: x[0] + (x[1] - x[1]) / fc * mid * vs, zip(points[i], points[i + 1])))",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[1]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))",
      "mutated_line": "endPoint = tuple(map(lambda x: x[0] + (x[1] - x[-1]) / fc * mid * vs, zip(points[i], points[i + 1])))",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[-1]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "endPoint = tuple(map(lambda x: x[0] + (x[1] - x[0]) / fc * mid * vs, zip(points[i], points[i + 1])))",
      "mutated_line": "endPoint = tuple(map(lambda x: x[0] + (x[1] - x[1]) / fc * mid * vs, zip(points[i], points[i + 1])))",
      "code": "import math\nimport functools\n\ndef eulen(x, y):\n    r = functools.reduce(lambda x, y: x + y, map(lambda x: (x[0] - x[1]) ** 2, zip(x, y)))\n    return math.sqrt(r)\n\ndef can_harry_catch_snitch(n, points, vp, vs, harry_position):\n\n    def lies_in(p, t):\n        return (harry_position[0] - p[0]) ** 2 + (harry_position[1] - p[1]) ** 2 + (harry_position[2] - p[2]) ** 2 <= (t * vp) ** 2 + 1e-07\n    curTime = 0\n    for i in range(n):\n        endTime = curTime + eulen(points[i], points[i + 1]) / vs\n        if lies_in(points[i + 1], endTime):\n            if lies_in(points[i], curTime):\n                return ('YES', curTime, points[i])\n            (left, right) = (0, endTime - curTime + 1e-08)\n            fc = eulen(points[i], points[i + 1])\n            answer = None\n            for j in range(100):\n                mid = (left + right) / 2.0\n                endPoint = tuple(map(lambda x: x[0] + (x[1] - x[1]) / fc * mid * vs, zip(points[i], points[i + 1])))\n                if lies_in(endPoint, curTime + mid):\n                    answer = endPoint\n                    right = mid\n                else:\n                    left = mid\n            return ('YES', curTime + right, answer)\n        curTime = endTime\n    return 'NO'"
    }
  ]
}