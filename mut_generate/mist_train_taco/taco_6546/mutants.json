{
  "task_id": "taco_6546",
  "entry_point": "calculate_compound_interest_floor",
  "mutant_count": 21,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "return math.floor(P * math.pow(1 + R / 100 / N, N * T))",
      "mutated_line": "return math.floor(P / math.pow(1 + R / 100 / N, N * T))",
      "code": "import math\n\ndef calculate_compound_interest_floor(P: int, T: int, N: int, R: int) -> int:\n    return math.floor(P / math.pow(1 + R / 100 / N, N * T))"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "return math.floor(P * math.pow(1 + R / 100 / N, N * T))",
      "mutated_line": "return math.floor(P + math.pow(1 + R / 100 / N, N * T))",
      "code": "import math\n\ndef calculate_compound_interest_floor(P: int, T: int, N: int, R: int) -> int:\n    return math.floor(P + math.pow(1 + R / 100 / N, N * T))"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "return math.floor(P * math.pow(1 + R / 100 / N, N * T))",
      "mutated_line": "return math.floor(P ** math.pow(1 + R / 100 / N, N * T))",
      "code": "import math\n\ndef calculate_compound_interest_floor(P: int, T: int, N: int, R: int) -> int:\n    return math.floor(P ** math.pow(1 + R / 100 / N, N * T))"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "return math.floor(P * math.pow(1 + R / 100 / N, N * T))",
      "mutated_line": "return math.floor(P * math.pow(1 - R / 100 / N, N * T))",
      "code": "import math\n\ndef calculate_compound_interest_floor(P: int, T: int, N: int, R: int) -> int:\n    return math.floor(P * math.pow(1 - R / 100 / N, N * T))"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "return math.floor(P * math.pow(1 + R / 100 / N, N * T))",
      "mutated_line": "return math.floor(P * math.pow(1 * (R / 100 / N), N * T))",
      "code": "import math\n\ndef calculate_compound_interest_floor(P: int, T: int, N: int, R: int) -> int:\n    return math.floor(P * math.pow(1 * (R / 100 / N), N * T))"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "return math.floor(P * math.pow(1 + R / 100 / N, N * T))",
      "mutated_line": "return math.floor(P * math.pow(1 + R / 100 / N, N / T))",
      "code": "import math\n\ndef calculate_compound_interest_floor(P: int, T: int, N: int, R: int) -> int:\n    return math.floor(P * math.pow(1 + R / 100 / N, N / T))"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "return math.floor(P * math.pow(1 + R / 100 / N, N * T))",
      "mutated_line": "return math.floor(P * math.pow(1 + R / 100 / N, N + T))",
      "code": "import math\n\ndef calculate_compound_interest_floor(P: int, T: int, N: int, R: int) -> int:\n    return math.floor(P * math.pow(1 + R / 100 / N, N + T))"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "return math.floor(P * math.pow(1 + R / 100 / N, N * T))",
      "mutated_line": "return math.floor(P * math.pow(1 + R / 100 / N, N ** T))",
      "code": "import math\n\ndef calculate_compound_interest_floor(P: int, T: int, N: int, R: int) -> int:\n    return math.floor(P * math.pow(1 + R / 100 / N, N ** T))"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return math.floor(P * math.pow(1 + R / 100 / N, N * T))",
      "mutated_line": "return math.floor(P * math.pow(2 + R / 100 / N, N * T))",
      "code": "import math\n\ndef calculate_compound_interest_floor(P: int, T: int, N: int, R: int) -> int:\n    return math.floor(P * math.pow(2 + R / 100 / N, N * T))"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return math.floor(P * math.pow(1 + R / 100 / N, N * T))",
      "mutated_line": "return math.floor(P * math.pow(0 + R / 100 / N, N * T))",
      "code": "import math\n\ndef calculate_compound_interest_floor(P: int, T: int, N: int, R: int) -> int:\n    return math.floor(P * math.pow(0 + R / 100 / N, N * T))"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return math.floor(P * math.pow(1 + R / 100 / N, N * T))",
      "mutated_line": "return math.floor(P * math.pow(0 + R / 100 / N, N * T))",
      "code": "import math\n\ndef calculate_compound_interest_floor(P: int, T: int, N: int, R: int) -> int:\n    return math.floor(P * math.pow(0 + R / 100 / N, N * T))"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return math.floor(P * math.pow(1 + R / 100 / N, N * T))",
      "mutated_line": "return math.floor(P * math.pow(-1 + R / 100 / N, N * T))",
      "code": "import math\n\ndef calculate_compound_interest_floor(P: int, T: int, N: int, R: int) -> int:\n    return math.floor(P * math.pow(-1 + R / 100 / N, N * T))"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "return math.floor(P * math.pow(1 + R / 100 / N, N * T))",
      "mutated_line": "return math.floor(P * math.pow(1 + R / 100 * N, N * T))",
      "code": "import math\n\ndef calculate_compound_interest_floor(P: int, T: int, N: int, R: int) -> int:\n    return math.floor(P * math.pow(1 + R / 100 * N, N * T))"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "return math.floor(P * math.pow(1 + R / 100 / N, N * T))",
      "mutated_line": "return math.floor(P * math.pow(1 + R / 100 // N, N * T))",
      "code": "import math\n\ndef calculate_compound_interest_floor(P: int, T: int, N: int, R: int) -> int:\n    return math.floor(P * math.pow(1 + R / 100 // N, N * T))"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "return math.floor(P * math.pow(1 + R / 100 / N, N * T))",
      "mutated_line": "return math.floor(P * math.pow(1 + R * 100 / N, N * T))",
      "code": "import math\n\ndef calculate_compound_interest_floor(P: int, T: int, N: int, R: int) -> int:\n    return math.floor(P * math.pow(1 + R * 100 / N, N * T))"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "return math.floor(P * math.pow(1 + R / 100 / N, N * T))",
      "mutated_line": "return math.floor(P * math.pow(1 + R // 100 / N, N * T))",
      "code": "import math\n\ndef calculate_compound_interest_floor(P: int, T: int, N: int, R: int) -> int:\n    return math.floor(P * math.pow(1 + R // 100 / N, N * T))"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return math.floor(P * math.pow(1 + R / 100 / N, N * T))",
      "mutated_line": "return math.floor(P * math.pow(1 + R / 101 / N, N * T))",
      "code": "import math\n\ndef calculate_compound_interest_floor(P: int, T: int, N: int, R: int) -> int:\n    return math.floor(P * math.pow(1 + R / 101 / N, N * T))"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return math.floor(P * math.pow(1 + R / 100 / N, N * T))",
      "mutated_line": "return math.floor(P * math.pow(1 + R / 99 / N, N * T))",
      "code": "import math\n\ndef calculate_compound_interest_floor(P: int, T: int, N: int, R: int) -> int:\n    return math.floor(P * math.pow(1 + R / 99 / N, N * T))"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return math.floor(P * math.pow(1 + R / 100 / N, N * T))",
      "mutated_line": "return math.floor(P * math.pow(1 + R / 0 / N, N * T))",
      "code": "import math\n\ndef calculate_compound_interest_floor(P: int, T: int, N: int, R: int) -> int:\n    return math.floor(P * math.pow(1 + R / 0 / N, N * T))"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return math.floor(P * math.pow(1 + R / 100 / N, N * T))",
      "mutated_line": "return math.floor(P * math.pow(1 + R / 1 / N, N * T))",
      "code": "import math\n\ndef calculate_compound_interest_floor(P: int, T: int, N: int, R: int) -> int:\n    return math.floor(P * math.pow(1 + R / 1 / N, N * T))"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return math.floor(P * math.pow(1 + R / 100 / N, N * T))",
      "mutated_line": "return math.floor(P * math.pow(1 + R / -100 / N, N * T))",
      "code": "import math\n\ndef calculate_compound_interest_floor(P: int, T: int, N: int, R: int) -> int:\n    return math.floor(P * math.pow(1 + R / -100 / N, N * T))"
    }
  ]
}