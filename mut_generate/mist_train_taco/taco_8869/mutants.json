{
  "task_id": "taco_8869",
  "entry_point": "min_operations_to_equalize",
  "mutant_count": 138,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "sa = '0' * (len(sb) - len(sa)) + sa",
      "mutated_line": "sa = '0' * (len(sb) - len(sa)) - sa",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) - sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "sa = '0' * (len(sb) - len(sa)) + sa",
      "mutated_line": "sa = '0' * (len(sb) - len(sa)) * sa",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) * sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "res = b - a",
      "mutated_line": "res = b + a",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b + a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "res = b - a",
      "mutated_line": "res = b * a",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b * a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "found = False",
      "mutated_line": "found = True",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = True\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "sa = '0' * (len(sb) - len(sa)) + sa",
      "mutated_line": "sa = '0' / (len(sb) - len(sa)) + sa",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' / (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "sa = '0' * (len(sb) - len(sa)) + sa",
      "mutated_line": "sa = '0' + (len(sb) - len(sa)) + sa",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' + (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "sa = '0' * (len(sb) - len(sa)) + sa",
      "mutated_line": "sa = '0' ** (len(sb) - len(sa)) + sa",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' ** (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "state = sa[i] + sb[i]",
      "mutated_line": "state = sa[i] - sb[i]",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] - sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "state = sa[i] + sb[i]",
      "mutated_line": "state = sa[i] * sb[i]",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] * sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if state == '10':",
      "mutated_line": "if state != '10':",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state != '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return res if found else 1",
      "mutated_line": "return res if found else 2",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 2"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return res if found else 1",
      "mutated_line": "return res if found else 0",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return res if found else 1",
      "mutated_line": "return res if found else 0",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return res if found else 1",
      "mutated_line": "return res if found else -1",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else -1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "sa = bin(a)[2:]",
      "mutated_line": "sa = bin(a)[3:]",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[3:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "sa = bin(a)[2:]",
      "mutated_line": "sa = bin(a)[1:]",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[1:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "sa = bin(a)[2:]",
      "mutated_line": "sa = bin(a)[0:]",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[0:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "sa = bin(a)[2:]",
      "mutated_line": "sa = bin(a)[1:]",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[1:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "sa = bin(a)[2:]",
      "mutated_line": "sa = bin(a)[-2:]",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[-2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "sb = bin(b)[2:]",
      "mutated_line": "sb = bin(b)[3:]",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[3:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "sb = bin(b)[2:]",
      "mutated_line": "sb = bin(b)[1:]",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[1:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "sb = bin(b)[2:]",
      "mutated_line": "sb = bin(b)[0:]",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[0:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "sb = bin(b)[2:]",
      "mutated_line": "sb = bin(b)[1:]",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[1:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "sb = bin(b)[2:]",
      "mutated_line": "sb = bin(b)[-2:]",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[-2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "sa = '0' * (len(sb) - len(sa)) + sa",
      "mutated_line": "sa = '' * (len(sb) - len(sa)) + sa",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "sa = '0' * (len(sb) - len(sa)) + sa",
      "mutated_line": "sa = '0' * (len(sb) + len(sa)) + sa",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) + len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "sa = '0' * (len(sb) - len(sa)) + sa",
      "mutated_line": "sa = '0' * (len(sb) * len(sa)) + sa",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) * len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if state == '10':",
      "mutated_line": "if state == '':",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "found = True",
      "mutated_line": "found = False",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = False\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "sbb = sb[:i] + sa[i:]",
      "mutated_line": "sbb = sb[:i] - sa[i:]",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] - sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "sbb = sb[:i] + sa[i:]",
      "mutated_line": "sbb = sb[:i] * sa[i:]",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] * sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "cur = int(sbb, 2) - b + 1",
      "mutated_line": "cur = int(sbb, 2) - b - 1",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b - 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "cur = int(sbb, 2) - b + 1",
      "mutated_line": "cur = (int(sbb, 2) - b) * 1",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = (int(sbb, 2) - b) * 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "while sa[j] == '1':",
      "mutated_line": "while sa[j] != '1':",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] != '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "ASR",
      "lineno": 16,
      "original_line": "j -= 1",
      "mutated_line": "j += 1",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j += 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)",
      "mutated_line": "saa = sa[:j] + '1' - '0' * (len(sa) - j - 1)",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' - '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)",
      "mutated_line": "saa = (sa[:j] + '1') * ('0' * (len(sa) - j - 1))",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = (sa[:j] + '1') * ('0' * (len(sa) - j - 1))\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if sb[j] == '1':",
      "mutated_line": "if sb[j] != '1':",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] != '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "cur = int(sbb, 2) - b + 1",
      "mutated_line": "cur = int(sbb, 2) + b + 1",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) + b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "cur = int(sbb, 2) - b + 1",
      "mutated_line": "cur = int(sbb, 2) * b + 1",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) * b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "cur = int(sbb, 2) - b + 1",
      "mutated_line": "cur = int(sbb, 2) - b + 2",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 2\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "cur = int(sbb, 2) - b + 1",
      "mutated_line": "cur = int(sbb, 2) - b + 0",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 0\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "cur = int(sbb, 2) - b + 1",
      "mutated_line": "cur = int(sbb, 2) - b + 0",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 0\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "cur = int(sbb, 2) - b + 1",
      "mutated_line": "cur = int(sbb, 2) - b + -1",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + -1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "while sa[j] == '1':",
      "mutated_line": "while sa[j] == '':",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "j -= 1",
      "mutated_line": "j -= 2",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 2\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "j -= 1",
      "mutated_line": "j -= 0",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 0\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "j -= 1",
      "mutated_line": "j -= 0",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 0\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "j -= 1",
      "mutated_line": "j -= -1",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= -1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)",
      "mutated_line": "saa = sa[:j] - '1' + '0' * (len(sa) - j - 1)",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] - '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)",
      "mutated_line": "saa = sa[:j] * '1' + '0' * (len(sa) - j - 1)",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] * '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)",
      "mutated_line": "saa = sa[:j] + '1' + '0' / (len(sa) - j - 1)",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' / (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)",
      "mutated_line": "saa = sa[:j] + '1' + ('0' + (len(sa) - j - 1))",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + ('0' + (len(sa) - j - 1))\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)",
      "mutated_line": "saa = sa[:j] + '1' + '0' ** (len(sa) - j - 1)",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' ** (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if sb[j] == '1':",
      "mutated_line": "if sb[j] == '':",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "cur = int(saa, 2) - a",
      "mutated_line": "cur = int(saa, 2) + a",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) + a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "cur = int(saa, 2) - a",
      "mutated_line": "cur = int(saa, 2) * a",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) * a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if int(saa, 2) != b:",
      "mutated_line": "if int(saa, 2) == b:",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) == b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "ASR",
      "lineno": 21,
      "original_line": "cur += 1",
      "mutated_line": "cur -= 1",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur -= 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)",
      "mutated_line": "sbb = sb[:j] + '1' - '0' * (len(sb) - j - 1)",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' - '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)",
      "mutated_line": "sbb = (sb[:j] + '1') * ('0' * (len(sb) - j - 1))",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = (sb[:j] + '1') * ('0' * (len(sb) - j - 1))\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "cur = int(saa, 2) - a + int(sbb, 2) - b",
      "mutated_line": "cur = int(saa, 2) - a + int(sbb, 2) + b",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) + b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "cur = int(saa, 2) - a + int(sbb, 2) - b",
      "mutated_line": "cur = (int(saa, 2) - a + int(sbb, 2)) * b",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = (int(saa, 2) - a + int(sbb, 2)) * b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if int(saa, 2) != int(sbb, 2):",
      "mutated_line": "if int(saa, 2) == int(sbb, 2):",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) == int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "ASR",
      "lineno": 27,
      "original_line": "cur += 1",
      "mutated_line": "cur -= 1",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur -= 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)",
      "mutated_line": "saa = sa[:j] + '' + '0' * (len(sa) - j - 1)",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)",
      "mutated_line": "saa = sa[:j] + '1' + '' * (len(sa) - j - 1)",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)",
      "mutated_line": "saa = sa[:j] + '1' + '0' * (len(sa) - j + 1)",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j + 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)",
      "mutated_line": "saa = sa[:j] + '1' + '0' * ((len(sa) - j) * 1)",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * ((len(sa) - j) * 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "cur += 1",
      "mutated_line": "cur += 2",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 2\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "cur += 1",
      "mutated_line": "cur += 0",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 0\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "cur += 1",
      "mutated_line": "cur += 0",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 0\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "cur += 1",
      "mutated_line": "cur += -1",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += -1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)",
      "mutated_line": "sbb = sb[:j] - '1' + '0' * (len(sb) - j - 1)",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] - '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)",
      "mutated_line": "sbb = sb[:j] * '1' + '0' * (len(sb) - j - 1)",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] * '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)",
      "mutated_line": "sbb = sb[:j] + '1' + '0' / (len(sb) - j - 1)",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' / (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)",
      "mutated_line": "sbb = sb[:j] + '1' + ('0' + (len(sb) - j - 1))",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + ('0' + (len(sb) - j - 1))\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)",
      "mutated_line": "sbb = sb[:j] + '1' + '0' ** (len(sb) - j - 1)",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' ** (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "cur = int(saa, 2) - a + int(sbb, 2) - b",
      "mutated_line": "cur = int(saa, 2) - a - int(sbb, 2) - b",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a - int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "cur = int(saa, 2) - a + int(sbb, 2) - b",
      "mutated_line": "cur = (int(saa, 2) - a) * int(sbb, 2) - b",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = (int(saa, 2) - a) * int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "cur += 1",
      "mutated_line": "cur += 2",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 2\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "cur += 1",
      "mutated_line": "cur += 0",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 0\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "cur += 1",
      "mutated_line": "cur += 0",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 0\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "cur += 1",
      "mutated_line": "cur += -1",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += -1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "cur = int(sbb, 2) - b + 1",
      "mutated_line": "cur = int(sbb, 3) - b + 1",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 3) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "cur = int(sbb, 2) - b + 1",
      "mutated_line": "cur = int(sbb, 1) - b + 1",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 1) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "cur = int(sbb, 2) - b + 1",
      "mutated_line": "cur = int(sbb, 0) - b + 1",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 0) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "cur = int(sbb, 2) - b + 1",
      "mutated_line": "cur = int(sbb, 1) - b + 1",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 1) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "cur = int(sbb, 2) - b + 1",
      "mutated_line": "cur = int(sbb, -2) - b + 1",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, -2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)",
      "mutated_line": "saa = sa[:j] + '1' + '0' * (len(sa) + j - 1)",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) + j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)",
      "mutated_line": "saa = sa[:j] + '1' + '0' * (len(sa) * j - 1)",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) * j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)",
      "mutated_line": "saa = sa[:j] + '1' + '0' * (len(sa) - j - 2)",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 2)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)",
      "mutated_line": "saa = sa[:j] + '1' + '0' * (len(sa) - j - 0)",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 0)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)",
      "mutated_line": "saa = sa[:j] + '1' + '0' * (len(sa) - j - 0)",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 0)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)",
      "mutated_line": "saa = sa[:j] + '1' + '0' * (len(sa) - j - -1)",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - -1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "cur = int(saa, 2) - a",
      "mutated_line": "cur = int(saa, 3) - a",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 3) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "cur = int(saa, 2) - a",
      "mutated_line": "cur = int(saa, 1) - a",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 1) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "cur = int(saa, 2) - a",
      "mutated_line": "cur = int(saa, 0) - a",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 0) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "cur = int(saa, 2) - a",
      "mutated_line": "cur = int(saa, 1) - a",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 1) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "cur = int(saa, 2) - a",
      "mutated_line": "cur = int(saa, -2) - a",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, -2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if int(saa, 2) != b:",
      "mutated_line": "if int(saa, 3) != b:",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 3) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if int(saa, 2) != b:",
      "mutated_line": "if int(saa, 1) != b:",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 1) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if int(saa, 2) != b:",
      "mutated_line": "if int(saa, 0) != b:",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 0) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if int(saa, 2) != b:",
      "mutated_line": "if int(saa, 1) != b:",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 1) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if int(saa, 2) != b:",
      "mutated_line": "if int(saa, -2) != b:",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, -2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)",
      "mutated_line": "sbb = sb[:j] + '' + '0' * (len(sb) - j - 1)",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)",
      "mutated_line": "sbb = sb[:j] + '1' + '' * (len(sb) - j - 1)",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)",
      "mutated_line": "sbb = sb[:j] + '1' + '0' * (len(sb) - j + 1)",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j + 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)",
      "mutated_line": "sbb = sb[:j] + '1' + '0' * ((len(sb) - j) * 1)",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * ((len(sb) - j) * 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "cur = int(saa, 2) - a + int(sbb, 2) - b",
      "mutated_line": "cur = int(saa, 2) + a + int(sbb, 2) - b",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) + a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "cur = int(saa, 2) - a + int(sbb, 2) - b",
      "mutated_line": "cur = int(saa, 2) * a + int(sbb, 2) - b",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) * a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if int(saa, 2) != int(sbb, 2):",
      "mutated_line": "if int(saa, 3) != int(sbb, 2):",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 3) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if int(saa, 2) != int(sbb, 2):",
      "mutated_line": "if int(saa, 1) != int(sbb, 2):",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 1) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if int(saa, 2) != int(sbb, 2):",
      "mutated_line": "if int(saa, 0) != int(sbb, 2):",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 0) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if int(saa, 2) != int(sbb, 2):",
      "mutated_line": "if int(saa, 1) != int(sbb, 2):",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 1) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if int(saa, 2) != int(sbb, 2):",
      "mutated_line": "if int(saa, -2) != int(sbb, 2):",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, -2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if int(saa, 2) != int(sbb, 2):",
      "mutated_line": "if int(saa, 2) != int(sbb, 3):",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 3):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if int(saa, 2) != int(sbb, 2):",
      "mutated_line": "if int(saa, 2) != int(sbb, 1):",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 1):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if int(saa, 2) != int(sbb, 2):",
      "mutated_line": "if int(saa, 2) != int(sbb, 0):",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 0):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if int(saa, 2) != int(sbb, 2):",
      "mutated_line": "if int(saa, 2) != int(sbb, 1):",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 1):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if int(saa, 2) != int(sbb, 2):",
      "mutated_line": "if int(saa, 2) != int(sbb, -2):",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, -2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)",
      "mutated_line": "sbb = sb[:j] + '1' + '0' * (len(sb) + j - 1)",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) + j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)",
      "mutated_line": "sbb = sb[:j] + '1' + '0' * (len(sb) * j - 1)",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) * j - 1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)",
      "mutated_line": "sbb = sb[:j] + '1' + '0' * (len(sb) - j - 2)",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 2)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)",
      "mutated_line": "sbb = sb[:j] + '1' + '0' * (len(sb) - j - 0)",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 0)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)",
      "mutated_line": "sbb = sb[:j] + '1' + '0' * (len(sb) - j - 0)",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 0)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)",
      "mutated_line": "sbb = sb[:j] + '1' + '0' * (len(sb) - j - -1)",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - -1)\n                cur = int(saa, 2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "cur = int(saa, 2) - a + int(sbb, 2) - b",
      "mutated_line": "cur = int(saa, 2) - a + int(sbb, 3) - b",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 3) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "cur = int(saa, 2) - a + int(sbb, 2) - b",
      "mutated_line": "cur = int(saa, 2) - a + int(sbb, 1) - b",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 1) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "cur = int(saa, 2) - a + int(sbb, 2) - b",
      "mutated_line": "cur = int(saa, 2) - a + int(sbb, 0) - b",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 0) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "cur = int(saa, 2) - a + int(sbb, 2) - b",
      "mutated_line": "cur = int(saa, 2) - a + int(sbb, 1) - b",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, 1) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "cur = int(saa, 2) - a + int(sbb, 2) - b",
      "mutated_line": "cur = int(saa, 2) - a + int(sbb, -2) - b",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 2) - a + int(sbb, -2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "cur = int(saa, 2) - a + int(sbb, 2) - b",
      "mutated_line": "cur = int(saa, 3) - a + int(sbb, 2) - b",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 3) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "cur = int(saa, 2) - a + int(sbb, 2) - b",
      "mutated_line": "cur = int(saa, 1) - a + int(sbb, 2) - b",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 1) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "cur = int(saa, 2) - a + int(sbb, 2) - b",
      "mutated_line": "cur = int(saa, 0) - a + int(sbb, 2) - b",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 0) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "cur = int(saa, 2) - a + int(sbb, 2) - b",
      "mutated_line": "cur = int(saa, 1) - a + int(sbb, 2) - b",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, 1) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "cur = int(saa, 2) - a + int(sbb, 2) - b",
      "mutated_line": "cur = int(saa, -2) - a + int(sbb, 2) - b",
      "code": "def min_operations_to_equalize(a: int, b: int) -> int:\n    sa = bin(a)[2:]\n    sb = bin(b)[2:]\n    sa = '0' * (len(sb) - len(sa)) + sa\n    res = b - a\n    found = False\n    for i in range(len(sa)):\n        state = sa[i] + sb[i]\n        if state == '10':\n            found = True\n            sbb = sb[:i] + sa[i:]\n            cur = int(sbb, 2) - b + 1\n            res = min(res, cur)\n            j = i\n            while sa[j] == '1':\n                j -= 1\n            saa = sa[:j] + '1' + '0' * (len(sa) - j - 1)\n            if sb[j] == '1':\n                cur = int(saa, 2) - a\n                if int(saa, 2) != b:\n                    cur += 1\n                res = min(res, cur)\n            else:\n                sbb = sb[:j] + '1' + '0' * (len(sb) - j - 1)\n                cur = int(saa, -2) - a + int(sbb, 2) - b\n                if int(saa, 2) != int(sbb, 2):\n                    cur += 1\n                res = min(res, cur)\n            break\n    return res if found else 1"
    }
  ]
}