{
  "task_id": "taco_1170",
  "entry_point": "calculate_binomial_coefficients_counts",
  "mutant_count": 60,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "from collections import Counter\n\ndef calculate_binomial_coefficients_counts(n, p):\n    \"\"\"\"\"\"\n    d = []\n    nn = n\n    while nn != 0:\n        d.append(nn % p)\n        nn //= p\n    pprev = Counter()\n    nprev = Counter([0])\n    for di in d:\n        ncur = Counter({k: di * v for (k, v) in pprev.items()}) + Counter({k: (di + 1) * v for (k, v) in nprev.items()})\n        pcur = Counter({k + 1: (p - di) * v for (k, v) in pprev.items()}) + Counter({k + 1: (p - di - 1) * v for (k, v) in nprev.items()})\n        (pprev, nprev) = (pcur, ncur)\n    return [ncur[i] for i in range(1 + max(ncur.keys()))]"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "while nn != 0:",
      "mutated_line": "while nn == 0:",
      "code": "from collections import Counter\n\ndef calculate_binomial_coefficients_counts(n, p):\n    \"\"\"\n    Calculate the counts A_0, A_1, ..., A_M for the binomial coefficients C(N, K)\n    where P^L divides C(N, K) but P^(L+1) does not, for 0 ≤ K ≤ N.\n\n    Parameters:\n    n (int): The integer N in the binomial coefficient C(N, K).\n    p (int): The prime number P.\n\n    Returns:\n    list: A list of integers representing the counts [A_0, A_1, ..., A_M].\n    \"\"\"\n    d = []\n    nn = n\n    while nn == 0:\n        d.append(nn % p)\n        nn //= p\n    pprev = Counter()\n    nprev = Counter([0])\n    for di in d:\n        ncur = Counter({k: di * v for (k, v) in pprev.items()}) + Counter({k: (di + 1) * v for (k, v) in nprev.items()})\n        pcur = Counter({k + 1: (p - di) * v for (k, v) in pprev.items()}) + Counter({k + 1: (p - di - 1) * v for (k, v) in nprev.items()})\n        (pprev, nprev) = (pcur, ncur)\n    return [ncur[i] for i in range(1 + max(ncur.keys()))]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "while nn != 0:",
      "mutated_line": "while nn != 1:",
      "code": "from collections import Counter\n\ndef calculate_binomial_coefficients_counts(n, p):\n    \"\"\"\n    Calculate the counts A_0, A_1, ..., A_M for the binomial coefficients C(N, K)\n    where P^L divides C(N, K) but P^(L+1) does not, for 0 ≤ K ≤ N.\n\n    Parameters:\n    n (int): The integer N in the binomial coefficient C(N, K).\n    p (int): The prime number P.\n\n    Returns:\n    list: A list of integers representing the counts [A_0, A_1, ..., A_M].\n    \"\"\"\n    d = []\n    nn = n\n    while nn != 1:\n        d.append(nn % p)\n        nn //= p\n    pprev = Counter()\n    nprev = Counter([0])\n    for di in d:\n        ncur = Counter({k: di * v for (k, v) in pprev.items()}) + Counter({k: (di + 1) * v for (k, v) in nprev.items()})\n        pcur = Counter({k + 1: (p - di) * v for (k, v) in pprev.items()}) + Counter({k + 1: (p - di - 1) * v for (k, v) in nprev.items()})\n        (pprev, nprev) = (pcur, ncur)\n    return [ncur[i] for i in range(1 + max(ncur.keys()))]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "while nn != 0:",
      "mutated_line": "while nn != -1:",
      "code": "from collections import Counter\n\ndef calculate_binomial_coefficients_counts(n, p):\n    \"\"\"\n    Calculate the counts A_0, A_1, ..., A_M for the binomial coefficients C(N, K)\n    where P^L divides C(N, K) but P^(L+1) does not, for 0 ≤ K ≤ N.\n\n    Parameters:\n    n (int): The integer N in the binomial coefficient C(N, K).\n    p (int): The prime number P.\n\n    Returns:\n    list: A list of integers representing the counts [A_0, A_1, ..., A_M].\n    \"\"\"\n    d = []\n    nn = n\n    while nn != -1:\n        d.append(nn % p)\n        nn //= p\n    pprev = Counter()\n    nprev = Counter([0])\n    for di in d:\n        ncur = Counter({k: di * v for (k, v) in pprev.items()}) + Counter({k: (di + 1) * v for (k, v) in nprev.items()})\n        pcur = Counter({k + 1: (p - di) * v for (k, v) in pprev.items()}) + Counter({k + 1: (p - di - 1) * v for (k, v) in nprev.items()})\n        (pprev, nprev) = (pcur, ncur)\n    return [ncur[i] for i in range(1 + max(ncur.keys()))]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "while nn != 0:",
      "mutated_line": "while nn != 1:",
      "code": "from collections import Counter\n\ndef calculate_binomial_coefficients_counts(n, p):\n    \"\"\"\n    Calculate the counts A_0, A_1, ..., A_M for the binomial coefficients C(N, K)\n    where P^L divides C(N, K) but P^(L+1) does not, for 0 ≤ K ≤ N.\n\n    Parameters:\n    n (int): The integer N in the binomial coefficient C(N, K).\n    p (int): The prime number P.\n\n    Returns:\n    list: A list of integers representing the counts [A_0, A_1, ..., A_M].\n    \"\"\"\n    d = []\n    nn = n\n    while nn != 1:\n        d.append(nn % p)\n        nn //= p\n    pprev = Counter()\n    nprev = Counter([0])\n    for di in d:\n        ncur = Counter({k: di * v for (k, v) in pprev.items()}) + Counter({k: (di + 1) * v for (k, v) in nprev.items()})\n        pcur = Counter({k + 1: (p - di) * v for (k, v) in pprev.items()}) + Counter({k + 1: (p - di - 1) * v for (k, v) in nprev.items()})\n        (pprev, nprev) = (pcur, ncur)\n    return [ncur[i] for i in range(1 + max(ncur.keys()))]"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "ncur = Counter({k: di * v for (k, v) in pprev.items()}) + Counter({k: (di + 1) * v for (k, v) in nprev.items()})",
      "mutated_line": "ncur = Counter({k: di * v for (k, v) in pprev.items()}) - Counter({k: (di + 1) * v for (k, v) in nprev.items()})",
      "code": "from collections import Counter\n\ndef calculate_binomial_coefficients_counts(n, p):\n    \"\"\"\n    Calculate the counts A_0, A_1, ..., A_M for the binomial coefficients C(N, K)\n    where P^L divides C(N, K) but P^(L+1) does not, for 0 ≤ K ≤ N.\n\n    Parameters:\n    n (int): The integer N in the binomial coefficient C(N, K).\n    p (int): The prime number P.\n\n    Returns:\n    list: A list of integers representing the counts [A_0, A_1, ..., A_M].\n    \"\"\"\n    d = []\n    nn = n\n    while nn != 0:\n        d.append(nn % p)\n        nn //= p\n    pprev = Counter()\n    nprev = Counter([0])\n    for di in d:\n        ncur = Counter({k: di * v for (k, v) in pprev.items()}) - Counter({k: (di + 1) * v for (k, v) in nprev.items()})\n        pcur = Counter({k + 1: (p - di) * v for (k, v) in pprev.items()}) + Counter({k + 1: (p - di - 1) * v for (k, v) in nprev.items()})\n        (pprev, nprev) = (pcur, ncur)\n    return [ncur[i] for i in range(1 + max(ncur.keys()))]"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "ncur = Counter({k: di * v for (k, v) in pprev.items()}) + Counter({k: (di + 1) * v for (k, v) in nprev.items()})",
      "mutated_line": "ncur = Counter({k: di * v for (k, v) in pprev.items()}) * Counter({k: (di + 1) * v for (k, v) in nprev.items()})",
      "code": "from collections import Counter\n\ndef calculate_binomial_coefficients_counts(n, p):\n    \"\"\"\n    Calculate the counts A_0, A_1, ..., A_M for the binomial coefficients C(N, K)\n    where P^L divides C(N, K) but P^(L+1) does not, for 0 ≤ K ≤ N.\n\n    Parameters:\n    n (int): The integer N in the binomial coefficient C(N, K).\n    p (int): The prime number P.\n\n    Returns:\n    list: A list of integers representing the counts [A_0, A_1, ..., A_M].\n    \"\"\"\n    d = []\n    nn = n\n    while nn != 0:\n        d.append(nn % p)\n        nn //= p\n    pprev = Counter()\n    nprev = Counter([0])\n    for di in d:\n        ncur = Counter({k: di * v for (k, v) in pprev.items()}) * Counter({k: (di + 1) * v for (k, v) in nprev.items()})\n        pcur = Counter({k + 1: (p - di) * v for (k, v) in pprev.items()}) + Counter({k + 1: (p - di - 1) * v for (k, v) in nprev.items()})\n        (pprev, nprev) = (pcur, ncur)\n    return [ncur[i] for i in range(1 + max(ncur.keys()))]"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "pcur = Counter({k + 1: (p - di) * v for (k, v) in pprev.items()}) + Counter({k + 1: (p - di - 1) * v for (k, v) in nprev.items()})",
      "mutated_line": "pcur = Counter({k + 1: (p - di) * v for (k, v) in pprev.items()}) - Counter({k + 1: (p - di - 1) * v for (k, v) in nprev.items()})",
      "code": "from collections import Counter\n\ndef calculate_binomial_coefficients_counts(n, p):\n    \"\"\"\n    Calculate the counts A_0, A_1, ..., A_M for the binomial coefficients C(N, K)\n    where P^L divides C(N, K) but P^(L+1) does not, for 0 ≤ K ≤ N.\n\n    Parameters:\n    n (int): The integer N in the binomial coefficient C(N, K).\n    p (int): The prime number P.\n\n    Returns:\n    list: A list of integers representing the counts [A_0, A_1, ..., A_M].\n    \"\"\"\n    d = []\n    nn = n\n    while nn != 0:\n        d.append(nn % p)\n        nn //= p\n    pprev = Counter()\n    nprev = Counter([0])\n    for di in d:\n        ncur = Counter({k: di * v for (k, v) in pprev.items()}) + Counter({k: (di + 1) * v for (k, v) in nprev.items()})\n        pcur = Counter({k + 1: (p - di) * v for (k, v) in pprev.items()}) - Counter({k + 1: (p - di - 1) * v for (k, v) in nprev.items()})\n        (pprev, nprev) = (pcur, ncur)\n    return [ncur[i] for i in range(1 + max(ncur.keys()))]"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "pcur = Counter({k + 1: (p - di) * v for (k, v) in pprev.items()}) + Counter({k + 1: (p - di - 1) * v for (k, v) in nprev.items()})",
      "mutated_line": "pcur = Counter({k + 1: (p - di) * v for (k, v) in pprev.items()}) * Counter({k + 1: (p - di - 1) * v for (k, v) in nprev.items()})",
      "code": "from collections import Counter\n\ndef calculate_binomial_coefficients_counts(n, p):\n    \"\"\"\n    Calculate the counts A_0, A_1, ..., A_M for the binomial coefficients C(N, K)\n    where P^L divides C(N, K) but P^(L+1) does not, for 0 ≤ K ≤ N.\n\n    Parameters:\n    n (int): The integer N in the binomial coefficient C(N, K).\n    p (int): The prime number P.\n\n    Returns:\n    list: A list of integers representing the counts [A_0, A_1, ..., A_M].\n    \"\"\"\n    d = []\n    nn = n\n    while nn != 0:\n        d.append(nn % p)\n        nn //= p\n    pprev = Counter()\n    nprev = Counter([0])\n    for di in d:\n        ncur = Counter({k: di * v for (k, v) in pprev.items()}) + Counter({k: (di + 1) * v for (k, v) in nprev.items()})\n        pcur = Counter({k + 1: (p - di) * v for (k, v) in pprev.items()}) * Counter({k + 1: (p - di - 1) * v for (k, v) in nprev.items()})\n        (pprev, nprev) = (pcur, ncur)\n    return [ncur[i] for i in range(1 + max(ncur.keys()))]"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "d.append(nn % p)",
      "mutated_line": "d.append(nn * p)",
      "code": "from collections import Counter\n\ndef calculate_binomial_coefficients_counts(n, p):\n    \"\"\"\n    Calculate the counts A_0, A_1, ..., A_M for the binomial coefficients C(N, K)\n    where P^L divides C(N, K) but P^(L+1) does not, for 0 ≤ K ≤ N.\n\n    Parameters:\n    n (int): The integer N in the binomial coefficient C(N, K).\n    p (int): The prime number P.\n\n    Returns:\n    list: A list of integers representing the counts [A_0, A_1, ..., A_M].\n    \"\"\"\n    d = []\n    nn = n\n    while nn != 0:\n        d.append(nn * p)\n        nn //= p\n    pprev = Counter()\n    nprev = Counter([0])\n    for di in d:\n        ncur = Counter({k: di * v for (k, v) in pprev.items()}) + Counter({k: (di + 1) * v for (k, v) in nprev.items()})\n        pcur = Counter({k + 1: (p - di) * v for (k, v) in pprev.items()}) + Counter({k + 1: (p - di - 1) * v for (k, v) in nprev.items()})\n        (pprev, nprev) = (pcur, ncur)\n    return [ncur[i] for i in range(1 + max(ncur.keys()))]"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "d.append(nn % p)",
      "mutated_line": "d.append(nn + p)",
      "code": "from collections import Counter\n\ndef calculate_binomial_coefficients_counts(n, p):\n    \"\"\"\n    Calculate the counts A_0, A_1, ..., A_M for the binomial coefficients C(N, K)\n    where P^L divides C(N, K) but P^(L+1) does not, for 0 ≤ K ≤ N.\n\n    Parameters:\n    n (int): The integer N in the binomial coefficient C(N, K).\n    p (int): The prime number P.\n\n    Returns:\n    list: A list of integers representing the counts [A_0, A_1, ..., A_M].\n    \"\"\"\n    d = []\n    nn = n\n    while nn != 0:\n        d.append(nn + p)\n        nn //= p\n    pprev = Counter()\n    nprev = Counter([0])\n    for di in d:\n        ncur = Counter({k: di * v for (k, v) in pprev.items()}) + Counter({k: (di + 1) * v for (k, v) in nprev.items()})\n        pcur = Counter({k + 1: (p - di) * v for (k, v) in pprev.items()}) + Counter({k + 1: (p - di - 1) * v for (k, v) in nprev.items()})\n        (pprev, nprev) = (pcur, ncur)\n    return [ncur[i] for i in range(1 + max(ncur.keys()))]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "nprev = Counter([0])",
      "mutated_line": "nprev = Counter([1])",
      "code": "from collections import Counter\n\ndef calculate_binomial_coefficients_counts(n, p):\n    \"\"\"\n    Calculate the counts A_0, A_1, ..., A_M for the binomial coefficients C(N, K)\n    where P^L divides C(N, K) but P^(L+1) does not, for 0 ≤ K ≤ N.\n\n    Parameters:\n    n (int): The integer N in the binomial coefficient C(N, K).\n    p (int): The prime number P.\n\n    Returns:\n    list: A list of integers representing the counts [A_0, A_1, ..., A_M].\n    \"\"\"\n    d = []\n    nn = n\n    while nn != 0:\n        d.append(nn % p)\n        nn //= p\n    pprev = Counter()\n    nprev = Counter([1])\n    for di in d:\n        ncur = Counter({k: di * v for (k, v) in pprev.items()}) + Counter({k: (di + 1) * v for (k, v) in nprev.items()})\n        pcur = Counter({k + 1: (p - di) * v for (k, v) in pprev.items()}) + Counter({k + 1: (p - di - 1) * v for (k, v) in nprev.items()})\n        (pprev, nprev) = (pcur, ncur)\n    return [ncur[i] for i in range(1 + max(ncur.keys()))]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "nprev = Counter([0])",
      "mutated_line": "nprev = Counter([-1])",
      "code": "from collections import Counter\n\ndef calculate_binomial_coefficients_counts(n, p):\n    \"\"\"\n    Calculate the counts A_0, A_1, ..., A_M for the binomial coefficients C(N, K)\n    where P^L divides C(N, K) but P^(L+1) does not, for 0 ≤ K ≤ N.\n\n    Parameters:\n    n (int): The integer N in the binomial coefficient C(N, K).\n    p (int): The prime number P.\n\n    Returns:\n    list: A list of integers representing the counts [A_0, A_1, ..., A_M].\n    \"\"\"\n    d = []\n    nn = n\n    while nn != 0:\n        d.append(nn % p)\n        nn //= p\n    pprev = Counter()\n    nprev = Counter([-1])\n    for di in d:\n        ncur = Counter({k: di * v for (k, v) in pprev.items()}) + Counter({k: (di + 1) * v for (k, v) in nprev.items()})\n        pcur = Counter({k + 1: (p - di) * v for (k, v) in pprev.items()}) + Counter({k + 1: (p - di - 1) * v for (k, v) in nprev.items()})\n        (pprev, nprev) = (pcur, ncur)\n    return [ncur[i] for i in range(1 + max(ncur.keys()))]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "nprev = Counter([0])",
      "mutated_line": "nprev = Counter([1])",
      "code": "from collections import Counter\n\ndef calculate_binomial_coefficients_counts(n, p):\n    \"\"\"\n    Calculate the counts A_0, A_1, ..., A_M for the binomial coefficients C(N, K)\n    where P^L divides C(N, K) but P^(L+1) does not, for 0 ≤ K ≤ N.\n\n    Parameters:\n    n (int): The integer N in the binomial coefficient C(N, K).\n    p (int): The prime number P.\n\n    Returns:\n    list: A list of integers representing the counts [A_0, A_1, ..., A_M].\n    \"\"\"\n    d = []\n    nn = n\n    while nn != 0:\n        d.append(nn % p)\n        nn //= p\n    pprev = Counter()\n    nprev = Counter([1])\n    for di in d:\n        ncur = Counter({k: di * v for (k, v) in pprev.items()}) + Counter({k: (di + 1) * v for (k, v) in nprev.items()})\n        pcur = Counter({k + 1: (p - di) * v for (k, v) in pprev.items()}) + Counter({k + 1: (p - di - 1) * v for (k, v) in nprev.items()})\n        (pprev, nprev) = (pcur, ncur)\n    return [ncur[i] for i in range(1 + max(ncur.keys()))]"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "return [ncur[i] for i in range(1 + max(ncur.keys()))]",
      "mutated_line": "return [ncur[i] for i in range(1 - max(ncur.keys()))]",
      "code": "from collections import Counter\n\ndef calculate_binomial_coefficients_counts(n, p):\n    \"\"\"\n    Calculate the counts A_0, A_1, ..., A_M for the binomial coefficients C(N, K)\n    where P^L divides C(N, K) but P^(L+1) does not, for 0 ≤ K ≤ N.\n\n    Parameters:\n    n (int): The integer N in the binomial coefficient C(N, K).\n    p (int): The prime number P.\n\n    Returns:\n    list: A list of integers representing the counts [A_0, A_1, ..., A_M].\n    \"\"\"\n    d = []\n    nn = n\n    while nn != 0:\n        d.append(nn % p)\n        nn //= p\n    pprev = Counter()\n    nprev = Counter([0])\n    for di in d:\n        ncur = Counter({k: di * v for (k, v) in pprev.items()}) + Counter({k: (di + 1) * v for (k, v) in nprev.items()})\n        pcur = Counter({k + 1: (p - di) * v for (k, v) in pprev.items()}) + Counter({k + 1: (p - di - 1) * v for (k, v) in nprev.items()})\n        (pprev, nprev) = (pcur, ncur)\n    return [ncur[i] for i in range(1 - max(ncur.keys()))]"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "return [ncur[i] for i in range(1 + max(ncur.keys()))]",
      "mutated_line": "return [ncur[i] for i in range(1 * max(ncur.keys()))]",
      "code": "from collections import Counter\n\ndef calculate_binomial_coefficients_counts(n, p):\n    \"\"\"\n    Calculate the counts A_0, A_1, ..., A_M for the binomial coefficients C(N, K)\n    where P^L divides C(N, K) but P^(L+1) does not, for 0 ≤ K ≤ N.\n\n    Parameters:\n    n (int): The integer N in the binomial coefficient C(N, K).\n    p (int): The prime number P.\n\n    Returns:\n    list: A list of integers representing the counts [A_0, A_1, ..., A_M].\n    \"\"\"\n    d = []\n    nn = n\n    while nn != 0:\n        d.append(nn % p)\n        nn //= p\n    pprev = Counter()\n    nprev = Counter([0])\n    for di in d:\n        ncur = Counter({k: di * v for (k, v) in pprev.items()}) + Counter({k: (di + 1) * v for (k, v) in nprev.items()})\n        pcur = Counter({k + 1: (p - di) * v for (k, v) in pprev.items()}) + Counter({k + 1: (p - di - 1) * v for (k, v) in nprev.items()})\n        (pprev, nprev) = (pcur, ncur)\n    return [ncur[i] for i in range(1 * max(ncur.keys()))]"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "ncur = Counter({k: di * v for (k, v) in pprev.items()}) + Counter({k: (di + 1) * v for (k, v) in nprev.items()})",
      "mutated_line": "ncur = Counter({k: di / v for (k, v) in pprev.items()}) + Counter({k: (di + 1) * v for (k, v) in nprev.items()})",
      "code": "from collections import Counter\n\ndef calculate_binomial_coefficients_counts(n, p):\n    \"\"\"\n    Calculate the counts A_0, A_1, ..., A_M for the binomial coefficients C(N, K)\n    where P^L divides C(N, K) but P^(L+1) does not, for 0 ≤ K ≤ N.\n\n    Parameters:\n    n (int): The integer N in the binomial coefficient C(N, K).\n    p (int): The prime number P.\n\n    Returns:\n    list: A list of integers representing the counts [A_0, A_1, ..., A_M].\n    \"\"\"\n    d = []\n    nn = n\n    while nn != 0:\n        d.append(nn % p)\n        nn //= p\n    pprev = Counter()\n    nprev = Counter([0])\n    for di in d:\n        ncur = Counter({k: di / v for (k, v) in pprev.items()}) + Counter({k: (di + 1) * v for (k, v) in nprev.items()})\n        pcur = Counter({k + 1: (p - di) * v for (k, v) in pprev.items()}) + Counter({k + 1: (p - di - 1) * v for (k, v) in nprev.items()})\n        (pprev, nprev) = (pcur, ncur)\n    return [ncur[i] for i in range(1 + max(ncur.keys()))]"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "ncur = Counter({k: di * v for (k, v) in pprev.items()}) + Counter({k: (di + 1) * v for (k, v) in nprev.items()})",
      "mutated_line": "ncur = Counter({k: di + v for (k, v) in pprev.items()}) + Counter({k: (di + 1) * v for (k, v) in nprev.items()})",
      "code": "from collections import Counter\n\ndef calculate_binomial_coefficients_counts(n, p):\n    \"\"\"\n    Calculate the counts A_0, A_1, ..., A_M for the binomial coefficients C(N, K)\n    where P^L divides C(N, K) but P^(L+1) does not, for 0 ≤ K ≤ N.\n\n    Parameters:\n    n (int): The integer N in the binomial coefficient C(N, K).\n    p (int): The prime number P.\n\n    Returns:\n    list: A list of integers representing the counts [A_0, A_1, ..., A_M].\n    \"\"\"\n    d = []\n    nn = n\n    while nn != 0:\n        d.append(nn % p)\n        nn //= p\n    pprev = Counter()\n    nprev = Counter([0])\n    for di in d:\n        ncur = Counter({k: di + v for (k, v) in pprev.items()}) + Counter({k: (di + 1) * v for (k, v) in nprev.items()})\n        pcur = Counter({k + 1: (p - di) * v for (k, v) in pprev.items()}) + Counter({k + 1: (p - di - 1) * v for (k, v) in nprev.items()})\n        (pprev, nprev) = (pcur, ncur)\n    return [ncur[i] for i in range(1 + max(ncur.keys()))]"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "ncur = Counter({k: di * v for (k, v) in pprev.items()}) + Counter({k: (di + 1) * v for (k, v) in nprev.items()})",
      "mutated_line": "ncur = Counter({k: di ** v for (k, v) in pprev.items()}) + Counter({k: (di + 1) * v for (k, v) in nprev.items()})",
      "code": "from collections import Counter\n\ndef calculate_binomial_coefficients_counts(n, p):\n    \"\"\"\n    Calculate the counts A_0, A_1, ..., A_M for the binomial coefficients C(N, K)\n    where P^L divides C(N, K) but P^(L+1) does not, for 0 ≤ K ≤ N.\n\n    Parameters:\n    n (int): The integer N in the binomial coefficient C(N, K).\n    p (int): The prime number P.\n\n    Returns:\n    list: A list of integers representing the counts [A_0, A_1, ..., A_M].\n    \"\"\"\n    d = []\n    nn = n\n    while nn != 0:\n        d.append(nn % p)\n        nn //= p\n    pprev = Counter()\n    nprev = Counter([0])\n    for di in d:\n        ncur = Counter({k: di ** v for (k, v) in pprev.items()}) + Counter({k: (di + 1) * v for (k, v) in nprev.items()})\n        pcur = Counter({k + 1: (p - di) * v for (k, v) in pprev.items()}) + Counter({k + 1: (p - di - 1) * v for (k, v) in nprev.items()})\n        (pprev, nprev) = (pcur, ncur)\n    return [ncur[i] for i in range(1 + max(ncur.keys()))]"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "ncur = Counter({k: di * v for (k, v) in pprev.items()}) + Counter({k: (di + 1) * v for (k, v) in nprev.items()})",
      "mutated_line": "ncur = Counter({k: di * v for (k, v) in pprev.items()}) + Counter({k: (di + 1) / v for (k, v) in nprev.items()})",
      "code": "from collections import Counter\n\ndef calculate_binomial_coefficients_counts(n, p):\n    \"\"\"\n    Calculate the counts A_0, A_1, ..., A_M for the binomial coefficients C(N, K)\n    where P^L divides C(N, K) but P^(L+1) does not, for 0 ≤ K ≤ N.\n\n    Parameters:\n    n (int): The integer N in the binomial coefficient C(N, K).\n    p (int): The prime number P.\n\n    Returns:\n    list: A list of integers representing the counts [A_0, A_1, ..., A_M].\n    \"\"\"\n    d = []\n    nn = n\n    while nn != 0:\n        d.append(nn % p)\n        nn //= p\n    pprev = Counter()\n    nprev = Counter([0])\n    for di in d:\n        ncur = Counter({k: di * v for (k, v) in pprev.items()}) + Counter({k: (di + 1) / v for (k, v) in nprev.items()})\n        pcur = Counter({k + 1: (p - di) * v for (k, v) in pprev.items()}) + Counter({k + 1: (p - di - 1) * v for (k, v) in nprev.items()})\n        (pprev, nprev) = (pcur, ncur)\n    return [ncur[i] for i in range(1 + max(ncur.keys()))]"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "ncur = Counter({k: di * v for (k, v) in pprev.items()}) + Counter({k: (di + 1) * v for (k, v) in nprev.items()})",
      "mutated_line": "ncur = Counter({k: di * v for (k, v) in pprev.items()}) + Counter({k: di + 1 + v for (k, v) in nprev.items()})",
      "code": "from collections import Counter\n\ndef calculate_binomial_coefficients_counts(n, p):\n    \"\"\"\n    Calculate the counts A_0, A_1, ..., A_M for the binomial coefficients C(N, K)\n    where P^L divides C(N, K) but P^(L+1) does not, for 0 ≤ K ≤ N.\n\n    Parameters:\n    n (int): The integer N in the binomial coefficient C(N, K).\n    p (int): The prime number P.\n\n    Returns:\n    list: A list of integers representing the counts [A_0, A_1, ..., A_M].\n    \"\"\"\n    d = []\n    nn = n\n    while nn != 0:\n        d.append(nn % p)\n        nn //= p\n    pprev = Counter()\n    nprev = Counter([0])\n    for di in d:\n        ncur = Counter({k: di * v for (k, v) in pprev.items()}) + Counter({k: di + 1 + v for (k, v) in nprev.items()})\n        pcur = Counter({k + 1: (p - di) * v for (k, v) in pprev.items()}) + Counter({k + 1: (p - di - 1) * v for (k, v) in nprev.items()})\n        (pprev, nprev) = (pcur, ncur)\n    return [ncur[i] for i in range(1 + max(ncur.keys()))]"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "ncur = Counter({k: di * v for (k, v) in pprev.items()}) + Counter({k: (di + 1) * v for (k, v) in nprev.items()})",
      "mutated_line": "ncur = Counter({k: di * v for (k, v) in pprev.items()}) + Counter({k: (di + 1) ** v for (k, v) in nprev.items()})",
      "code": "from collections import Counter\n\ndef calculate_binomial_coefficients_counts(n, p):\n    \"\"\"\n    Calculate the counts A_0, A_1, ..., A_M for the binomial coefficients C(N, K)\n    where P^L divides C(N, K) but P^(L+1) does not, for 0 ≤ K ≤ N.\n\n    Parameters:\n    n (int): The integer N in the binomial coefficient C(N, K).\n    p (int): The prime number P.\n\n    Returns:\n    list: A list of integers representing the counts [A_0, A_1, ..., A_M].\n    \"\"\"\n    d = []\n    nn = n\n    while nn != 0:\n        d.append(nn % p)\n        nn //= p\n    pprev = Counter()\n    nprev = Counter([0])\n    for di in d:\n        ncur = Counter({k: di * v for (k, v) in pprev.items()}) + Counter({k: (di + 1) ** v for (k, v) in nprev.items()})\n        pcur = Counter({k + 1: (p - di) * v for (k, v) in pprev.items()}) + Counter({k + 1: (p - di - 1) * v for (k, v) in nprev.items()})\n        (pprev, nprev) = (pcur, ncur)\n    return [ncur[i] for i in range(1 + max(ncur.keys()))]"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "pcur = Counter({k + 1: (p - di) * v for (k, v) in pprev.items()}) + Counter({k + 1: (p - di - 1) * v for (k, v) in nprev.items()})",
      "mutated_line": "pcur = Counter({k - 1: (p - di) * v for (k, v) in pprev.items()}) + Counter({k + 1: (p - di - 1) * v for (k, v) in nprev.items()})",
      "code": "from collections import Counter\n\ndef calculate_binomial_coefficients_counts(n, p):\n    \"\"\"\n    Calculate the counts A_0, A_1, ..., A_M for the binomial coefficients C(N, K)\n    where P^L divides C(N, K) but P^(L+1) does not, for 0 ≤ K ≤ N.\n\n    Parameters:\n    n (int): The integer N in the binomial coefficient C(N, K).\n    p (int): The prime number P.\n\n    Returns:\n    list: A list of integers representing the counts [A_0, A_1, ..., A_M].\n    \"\"\"\n    d = []\n    nn = n\n    while nn != 0:\n        d.append(nn % p)\n        nn //= p\n    pprev = Counter()\n    nprev = Counter([0])\n    for di in d:\n        ncur = Counter({k: di * v for (k, v) in pprev.items()}) + Counter({k: (di + 1) * v for (k, v) in nprev.items()})\n        pcur = Counter({k - 1: (p - di) * v for (k, v) in pprev.items()}) + Counter({k + 1: (p - di - 1) * v for (k, v) in nprev.items()})\n        (pprev, nprev) = (pcur, ncur)\n    return [ncur[i] for i in range(1 + max(ncur.keys()))]"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "pcur = Counter({k + 1: (p - di) * v for (k, v) in pprev.items()}) + Counter({k + 1: (p - di - 1) * v for (k, v) in nprev.items()})",
      "mutated_line": "pcur = Counter({k * 1: (p - di) * v for (k, v) in pprev.items()}) + Counter({k + 1: (p - di - 1) * v for (k, v) in nprev.items()})",
      "code": "from collections import Counter\n\ndef calculate_binomial_coefficients_counts(n, p):\n    \"\"\"\n    Calculate the counts A_0, A_1, ..., A_M for the binomial coefficients C(N, K)\n    where P^L divides C(N, K) but P^(L+1) does not, for 0 ≤ K ≤ N.\n\n    Parameters:\n    n (int): The integer N in the binomial coefficient C(N, K).\n    p (int): The prime number P.\n\n    Returns:\n    list: A list of integers representing the counts [A_0, A_1, ..., A_M].\n    \"\"\"\n    d = []\n    nn = n\n    while nn != 0:\n        d.append(nn % p)\n        nn //= p\n    pprev = Counter()\n    nprev = Counter([0])\n    for di in d:\n        ncur = Counter({k: di * v for (k, v) in pprev.items()}) + Counter({k: (di + 1) * v for (k, v) in nprev.items()})\n        pcur = Counter({k * 1: (p - di) * v for (k, v) in pprev.items()}) + Counter({k + 1: (p - di - 1) * v for (k, v) in nprev.items()})\n        (pprev, nprev) = (pcur, ncur)\n    return [ncur[i] for i in range(1 + max(ncur.keys()))]"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "pcur = Counter({k + 1: (p - di) * v for (k, v) in pprev.items()}) + Counter({k + 1: (p - di - 1) * v for (k, v) in nprev.items()})",
      "mutated_line": "pcur = Counter({k + 1: (p - di) / v for (k, v) in pprev.items()}) + Counter({k + 1: (p - di - 1) * v for (k, v) in nprev.items()})",
      "code": "from collections import Counter\n\ndef calculate_binomial_coefficients_counts(n, p):\n    \"\"\"\n    Calculate the counts A_0, A_1, ..., A_M for the binomial coefficients C(N, K)\n    where P^L divides C(N, K) but P^(L+1) does not, for 0 ≤ K ≤ N.\n\n    Parameters:\n    n (int): The integer N in the binomial coefficient C(N, K).\n    p (int): The prime number P.\n\n    Returns:\n    list: A list of integers representing the counts [A_0, A_1, ..., A_M].\n    \"\"\"\n    d = []\n    nn = n\n    while nn != 0:\n        d.append(nn % p)\n        nn //= p\n    pprev = Counter()\n    nprev = Counter([0])\n    for di in d:\n        ncur = Counter({k: di * v for (k, v) in pprev.items()}) + Counter({k: (di + 1) * v for (k, v) in nprev.items()})\n        pcur = Counter({k + 1: (p - di) / v for (k, v) in pprev.items()}) + Counter({k + 1: (p - di - 1) * v for (k, v) in nprev.items()})\n        (pprev, nprev) = (pcur, ncur)\n    return [ncur[i] for i in range(1 + max(ncur.keys()))]"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "pcur = Counter({k + 1: (p - di) * v for (k, v) in pprev.items()}) + Counter({k + 1: (p - di - 1) * v for (k, v) in nprev.items()})",
      "mutated_line": "pcur = Counter({k + 1: p - di + v for (k, v) in pprev.items()}) + Counter({k + 1: (p - di - 1) * v for (k, v) in nprev.items()})",
      "code": "from collections import Counter\n\ndef calculate_binomial_coefficients_counts(n, p):\n    \"\"\"\n    Calculate the counts A_0, A_1, ..., A_M for the binomial coefficients C(N, K)\n    where P^L divides C(N, K) but P^(L+1) does not, for 0 ≤ K ≤ N.\n\n    Parameters:\n    n (int): The integer N in the binomial coefficient C(N, K).\n    p (int): The prime number P.\n\n    Returns:\n    list: A list of integers representing the counts [A_0, A_1, ..., A_M].\n    \"\"\"\n    d = []\n    nn = n\n    while nn != 0:\n        d.append(nn % p)\n        nn //= p\n    pprev = Counter()\n    nprev = Counter([0])\n    for di in d:\n        ncur = Counter({k: di * v for (k, v) in pprev.items()}) + Counter({k: (di + 1) * v for (k, v) in nprev.items()})\n        pcur = Counter({k + 1: p - di + v for (k, v) in pprev.items()}) + Counter({k + 1: (p - di - 1) * v for (k, v) in nprev.items()})\n        (pprev, nprev) = (pcur, ncur)\n    return [ncur[i] for i in range(1 + max(ncur.keys()))]"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "pcur = Counter({k + 1: (p - di) * v for (k, v) in pprev.items()}) + Counter({k + 1: (p - di - 1) * v for (k, v) in nprev.items()})",
      "mutated_line": "pcur = Counter({k + 1: (p - di) ** v for (k, v) in pprev.items()}) + Counter({k + 1: (p - di - 1) * v for (k, v) in nprev.items()})",
      "code": "from collections import Counter\n\ndef calculate_binomial_coefficients_counts(n, p):\n    \"\"\"\n    Calculate the counts A_0, A_1, ..., A_M for the binomial coefficients C(N, K)\n    where P^L divides C(N, K) but P^(L+1) does not, for 0 ≤ K ≤ N.\n\n    Parameters:\n    n (int): The integer N in the binomial coefficient C(N, K).\n    p (int): The prime number P.\n\n    Returns:\n    list: A list of integers representing the counts [A_0, A_1, ..., A_M].\n    \"\"\"\n    d = []\n    nn = n\n    while nn != 0:\n        d.append(nn % p)\n        nn //= p\n    pprev = Counter()\n    nprev = Counter([0])\n    for di in d:\n        ncur = Counter({k: di * v for (k, v) in pprev.items()}) + Counter({k: (di + 1) * v for (k, v) in nprev.items()})\n        pcur = Counter({k + 1: (p - di) ** v for (k, v) in pprev.items()}) + Counter({k + 1: (p - di - 1) * v for (k, v) in nprev.items()})\n        (pprev, nprev) = (pcur, ncur)\n    return [ncur[i] for i in range(1 + max(ncur.keys()))]"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "pcur = Counter({k + 1: (p - di) * v for (k, v) in pprev.items()}) + Counter({k + 1: (p - di - 1) * v for (k, v) in nprev.items()})",
      "mutated_line": "pcur = Counter({k + 1: (p - di) * v for (k, v) in pprev.items()}) + Counter({k - 1: (p - di - 1) * v for (k, v) in nprev.items()})",
      "code": "from collections import Counter\n\ndef calculate_binomial_coefficients_counts(n, p):\n    \"\"\"\n    Calculate the counts A_0, A_1, ..., A_M for the binomial coefficients C(N, K)\n    where P^L divides C(N, K) but P^(L+1) does not, for 0 ≤ K ≤ N.\n\n    Parameters:\n    n (int): The integer N in the binomial coefficient C(N, K).\n    p (int): The prime number P.\n\n    Returns:\n    list: A list of integers representing the counts [A_0, A_1, ..., A_M].\n    \"\"\"\n    d = []\n    nn = n\n    while nn != 0:\n        d.append(nn % p)\n        nn //= p\n    pprev = Counter()\n    nprev = Counter([0])\n    for di in d:\n        ncur = Counter({k: di * v for (k, v) in pprev.items()}) + Counter({k: (di + 1) * v for (k, v) in nprev.items()})\n        pcur = Counter({k + 1: (p - di) * v for (k, v) in pprev.items()}) + Counter({k - 1: (p - di - 1) * v for (k, v) in nprev.items()})\n        (pprev, nprev) = (pcur, ncur)\n    return [ncur[i] for i in range(1 + max(ncur.keys()))]"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "pcur = Counter({k + 1: (p - di) * v for (k, v) in pprev.items()}) + Counter({k + 1: (p - di - 1) * v for (k, v) in nprev.items()})",
      "mutated_line": "pcur = Counter({k + 1: (p - di) * v for (k, v) in pprev.items()}) + Counter({k * 1: (p - di - 1) * v for (k, v) in nprev.items()})",
      "code": "from collections import Counter\n\ndef calculate_binomial_coefficients_counts(n, p):\n    \"\"\"\n    Calculate the counts A_0, A_1, ..., A_M for the binomial coefficients C(N, K)\n    where P^L divides C(N, K) but P^(L+1) does not, for 0 ≤ K ≤ N.\n\n    Parameters:\n    n (int): The integer N in the binomial coefficient C(N, K).\n    p (int): The prime number P.\n\n    Returns:\n    list: A list of integers representing the counts [A_0, A_1, ..., A_M].\n    \"\"\"\n    d = []\n    nn = n\n    while nn != 0:\n        d.append(nn % p)\n        nn //= p\n    pprev = Counter()\n    nprev = Counter([0])\n    for di in d:\n        ncur = Counter({k: di * v for (k, v) in pprev.items()}) + Counter({k: (di + 1) * v for (k, v) in nprev.items()})\n        pcur = Counter({k + 1: (p - di) * v for (k, v) in pprev.items()}) + Counter({k * 1: (p - di - 1) * v for (k, v) in nprev.items()})\n        (pprev, nprev) = (pcur, ncur)\n    return [ncur[i] for i in range(1 + max(ncur.keys()))]"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "pcur = Counter({k + 1: (p - di) * v for (k, v) in pprev.items()}) + Counter({k + 1: (p - di - 1) * v for (k, v) in nprev.items()})",
      "mutated_line": "pcur = Counter({k + 1: (p - di) * v for (k, v) in pprev.items()}) + Counter({k + 1: (p - di - 1) / v for (k, v) in nprev.items()})",
      "code": "from collections import Counter\n\ndef calculate_binomial_coefficients_counts(n, p):\n    \"\"\"\n    Calculate the counts A_0, A_1, ..., A_M for the binomial coefficients C(N, K)\n    where P^L divides C(N, K) but P^(L+1) does not, for 0 ≤ K ≤ N.\n\n    Parameters:\n    n (int): The integer N in the binomial coefficient C(N, K).\n    p (int): The prime number P.\n\n    Returns:\n    list: A list of integers representing the counts [A_0, A_1, ..., A_M].\n    \"\"\"\n    d = []\n    nn = n\n    while nn != 0:\n        d.append(nn % p)\n        nn //= p\n    pprev = Counter()\n    nprev = Counter([0])\n    for di in d:\n        ncur = Counter({k: di * v for (k, v) in pprev.items()}) + Counter({k: (di + 1) * v for (k, v) in nprev.items()})\n        pcur = Counter({k + 1: (p - di) * v for (k, v) in pprev.items()}) + Counter({k + 1: (p - di - 1) / v for (k, v) in nprev.items()})\n        (pprev, nprev) = (pcur, ncur)\n    return [ncur[i] for i in range(1 + max(ncur.keys()))]"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "pcur = Counter({k + 1: (p - di) * v for (k, v) in pprev.items()}) + Counter({k + 1: (p - di - 1) * v for (k, v) in nprev.items()})",
      "mutated_line": "pcur = Counter({k + 1: (p - di) * v for (k, v) in pprev.items()}) + Counter({k + 1: p - di - 1 + v for (k, v) in nprev.items()})",
      "code": "from collections import Counter\n\ndef calculate_binomial_coefficients_counts(n, p):\n    \"\"\"\n    Calculate the counts A_0, A_1, ..., A_M for the binomial coefficients C(N, K)\n    where P^L divides C(N, K) but P^(L+1) does not, for 0 ≤ K ≤ N.\n\n    Parameters:\n    n (int): The integer N in the binomial coefficient C(N, K).\n    p (int): The prime number P.\n\n    Returns:\n    list: A list of integers representing the counts [A_0, A_1, ..., A_M].\n    \"\"\"\n    d = []\n    nn = n\n    while nn != 0:\n        d.append(nn % p)\n        nn //= p\n    pprev = Counter()\n    nprev = Counter([0])\n    for di in d:\n        ncur = Counter({k: di * v for (k, v) in pprev.items()}) + Counter({k: (di + 1) * v for (k, v) in nprev.items()})\n        pcur = Counter({k + 1: (p - di) * v for (k, v) in pprev.items()}) + Counter({k + 1: p - di - 1 + v for (k, v) in nprev.items()})\n        (pprev, nprev) = (pcur, ncur)\n    return [ncur[i] for i in range(1 + max(ncur.keys()))]"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "pcur = Counter({k + 1: (p - di) * v for (k, v) in pprev.items()}) + Counter({k + 1: (p - di - 1) * v for (k, v) in nprev.items()})",
      "mutated_line": "pcur = Counter({k + 1: (p - di) * v for (k, v) in pprev.items()}) + Counter({k + 1: (p - di - 1) ** v for (k, v) in nprev.items()})",
      "code": "from collections import Counter\n\ndef calculate_binomial_coefficients_counts(n, p):\n    \"\"\"\n    Calculate the counts A_0, A_1, ..., A_M for the binomial coefficients C(N, K)\n    where P^L divides C(N, K) but P^(L+1) does not, for 0 ≤ K ≤ N.\n\n    Parameters:\n    n (int): The integer N in the binomial coefficient C(N, K).\n    p (int): The prime number P.\n\n    Returns:\n    list: A list of integers representing the counts [A_0, A_1, ..., A_M].\n    \"\"\"\n    d = []\n    nn = n\n    while nn != 0:\n        d.append(nn % p)\n        nn //= p\n    pprev = Counter()\n    nprev = Counter([0])\n    for di in d:\n        ncur = Counter({k: di * v for (k, v) in pprev.items()}) + Counter({k: (di + 1) * v for (k, v) in nprev.items()})\n        pcur = Counter({k + 1: (p - di) * v for (k, v) in pprev.items()}) + Counter({k + 1: (p - di - 1) ** v for (k, v) in nprev.items()})\n        (pprev, nprev) = (pcur, ncur)\n    return [ncur[i] for i in range(1 + max(ncur.keys()))]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return [ncur[i] for i in range(1 + max(ncur.keys()))]",
      "mutated_line": "return [ncur[i] for i in range(2 + max(ncur.keys()))]",
      "code": "from collections import Counter\n\ndef calculate_binomial_coefficients_counts(n, p):\n    \"\"\"\n    Calculate the counts A_0, A_1, ..., A_M for the binomial coefficients C(N, K)\n    where P^L divides C(N, K) but P^(L+1) does not, for 0 ≤ K ≤ N.\n\n    Parameters:\n    n (int): The integer N in the binomial coefficient C(N, K).\n    p (int): The prime number P.\n\n    Returns:\n    list: A list of integers representing the counts [A_0, A_1, ..., A_M].\n    \"\"\"\n    d = []\n    nn = n\n    while nn != 0:\n        d.append(nn % p)\n        nn //= p\n    pprev = Counter()\n    nprev = Counter([0])\n    for di in d:\n        ncur = Counter({k: di * v for (k, v) in pprev.items()}) + Counter({k: (di + 1) * v for (k, v) in nprev.items()})\n        pcur = Counter({k + 1: (p - di) * v for (k, v) in pprev.items()}) + Counter({k + 1: (p - di - 1) * v for (k, v) in nprev.items()})\n        (pprev, nprev) = (pcur, ncur)\n    return [ncur[i] for i in range(2 + max(ncur.keys()))]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return [ncur[i] for i in range(1 + max(ncur.keys()))]",
      "mutated_line": "return [ncur[i] for i in range(0 + max(ncur.keys()))]",
      "code": "from collections import Counter\n\ndef calculate_binomial_coefficients_counts(n, p):\n    \"\"\"\n    Calculate the counts A_0, A_1, ..., A_M for the binomial coefficients C(N, K)\n    where P^L divides C(N, K) but P^(L+1) does not, for 0 ≤ K ≤ N.\n\n    Parameters:\n    n (int): The integer N in the binomial coefficient C(N, K).\n    p (int): The prime number P.\n\n    Returns:\n    list: A list of integers representing the counts [A_0, A_1, ..., A_M].\n    \"\"\"\n    d = []\n    nn = n\n    while nn != 0:\n        d.append(nn % p)\n        nn //= p\n    pprev = Counter()\n    nprev = Counter([0])\n    for di in d:\n        ncur = Counter({k: di * v for (k, v) in pprev.items()}) + Counter({k: (di + 1) * v for (k, v) in nprev.items()})\n        pcur = Counter({k + 1: (p - di) * v for (k, v) in pprev.items()}) + Counter({k + 1: (p - di - 1) * v for (k, v) in nprev.items()})\n        (pprev, nprev) = (pcur, ncur)\n    return [ncur[i] for i in range(0 + max(ncur.keys()))]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return [ncur[i] for i in range(1 + max(ncur.keys()))]",
      "mutated_line": "return [ncur[i] for i in range(0 + max(ncur.keys()))]",
      "code": "from collections import Counter\n\ndef calculate_binomial_coefficients_counts(n, p):\n    \"\"\"\n    Calculate the counts A_0, A_1, ..., A_M for the binomial coefficients C(N, K)\n    where P^L divides C(N, K) but P^(L+1) does not, for 0 ≤ K ≤ N.\n\n    Parameters:\n    n (int): The integer N in the binomial coefficient C(N, K).\n    p (int): The prime number P.\n\n    Returns:\n    list: A list of integers representing the counts [A_0, A_1, ..., A_M].\n    \"\"\"\n    d = []\n    nn = n\n    while nn != 0:\n        d.append(nn % p)\n        nn //= p\n    pprev = Counter()\n    nprev = Counter([0])\n    for di in d:\n        ncur = Counter({k: di * v for (k, v) in pprev.items()}) + Counter({k: (di + 1) * v for (k, v) in nprev.items()})\n        pcur = Counter({k + 1: (p - di) * v for (k, v) in pprev.items()}) + Counter({k + 1: (p - di - 1) * v for (k, v) in nprev.items()})\n        (pprev, nprev) = (pcur, ncur)\n    return [ncur[i] for i in range(0 + max(ncur.keys()))]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return [ncur[i] for i in range(1 + max(ncur.keys()))]",
      "mutated_line": "return [ncur[i] for i in range(-1 + max(ncur.keys()))]",
      "code": "from collections import Counter\n\ndef calculate_binomial_coefficients_counts(n, p):\n    \"\"\"\n    Calculate the counts A_0, A_1, ..., A_M for the binomial coefficients C(N, K)\n    where P^L divides C(N, K) but P^(L+1) does not, for 0 ≤ K ≤ N.\n\n    Parameters:\n    n (int): The integer N in the binomial coefficient C(N, K).\n    p (int): The prime number P.\n\n    Returns:\n    list: A list of integers representing the counts [A_0, A_1, ..., A_M].\n    \"\"\"\n    d = []\n    nn = n\n    while nn != 0:\n        d.append(nn % p)\n        nn //= p\n    pprev = Counter()\n    nprev = Counter([0])\n    for di in d:\n        ncur = Counter({k: di * v for (k, v) in pprev.items()}) + Counter({k: (di + 1) * v for (k, v) in nprev.items()})\n        pcur = Counter({k + 1: (p - di) * v for (k, v) in pprev.items()}) + Counter({k + 1: (p - di - 1) * v for (k, v) in nprev.items()})\n        (pprev, nprev) = (pcur, ncur)\n    return [ncur[i] for i in range(-1 + max(ncur.keys()))]"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "ncur = Counter({k: di * v for (k, v) in pprev.items()}) + Counter({k: (di + 1) * v for (k, v) in nprev.items()})",
      "mutated_line": "ncur = Counter({k: di * v for (k, v) in pprev.items()}) + Counter({k: (di - 1) * v for (k, v) in nprev.items()})",
      "code": "from collections import Counter\n\ndef calculate_binomial_coefficients_counts(n, p):\n    \"\"\"\n    Calculate the counts A_0, A_1, ..., A_M for the binomial coefficients C(N, K)\n    where P^L divides C(N, K) but P^(L+1) does not, for 0 ≤ K ≤ N.\n\n    Parameters:\n    n (int): The integer N in the binomial coefficient C(N, K).\n    p (int): The prime number P.\n\n    Returns:\n    list: A list of integers representing the counts [A_0, A_1, ..., A_M].\n    \"\"\"\n    d = []\n    nn = n\n    while nn != 0:\n        d.append(nn % p)\n        nn //= p\n    pprev = Counter()\n    nprev = Counter([0])\n    for di in d:\n        ncur = Counter({k: di * v for (k, v) in pprev.items()}) + Counter({k: (di - 1) * v for (k, v) in nprev.items()})\n        pcur = Counter({k + 1: (p - di) * v for (k, v) in pprev.items()}) + Counter({k + 1: (p - di - 1) * v for (k, v) in nprev.items()})\n        (pprev, nprev) = (pcur, ncur)\n    return [ncur[i] for i in range(1 + max(ncur.keys()))]"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "ncur = Counter({k: di * v for (k, v) in pprev.items()}) + Counter({k: (di + 1) * v for (k, v) in nprev.items()})",
      "mutated_line": "ncur = Counter({k: di * v for (k, v) in pprev.items()}) + Counter({k: di * 1 * v for (k, v) in nprev.items()})",
      "code": "from collections import Counter\n\ndef calculate_binomial_coefficients_counts(n, p):\n    \"\"\"\n    Calculate the counts A_0, A_1, ..., A_M for the binomial coefficients C(N, K)\n    where P^L divides C(N, K) but P^(L+1) does not, for 0 ≤ K ≤ N.\n\n    Parameters:\n    n (int): The integer N in the binomial coefficient C(N, K).\n    p (int): The prime number P.\n\n    Returns:\n    list: A list of integers representing the counts [A_0, A_1, ..., A_M].\n    \"\"\"\n    d = []\n    nn = n\n    while nn != 0:\n        d.append(nn % p)\n        nn //= p\n    pprev = Counter()\n    nprev = Counter([0])\n    for di in d:\n        ncur = Counter({k: di * v for (k, v) in pprev.items()}) + Counter({k: di * 1 * v for (k, v) in nprev.items()})\n        pcur = Counter({k + 1: (p - di) * v for (k, v) in pprev.items()}) + Counter({k + 1: (p - di - 1) * v for (k, v) in nprev.items()})\n        (pprev, nprev) = (pcur, ncur)\n    return [ncur[i] for i in range(1 + max(ncur.keys()))]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "pcur = Counter({k + 1: (p - di) * v for (k, v) in pprev.items()}) + Counter({k + 1: (p - di - 1) * v for (k, v) in nprev.items()})",
      "mutated_line": "pcur = Counter({k + 2: (p - di) * v for (k, v) in pprev.items()}) + Counter({k + 1: (p - di - 1) * v for (k, v) in nprev.items()})",
      "code": "from collections import Counter\n\ndef calculate_binomial_coefficients_counts(n, p):\n    \"\"\"\n    Calculate the counts A_0, A_1, ..., A_M for the binomial coefficients C(N, K)\n    where P^L divides C(N, K) but P^(L+1) does not, for 0 ≤ K ≤ N.\n\n    Parameters:\n    n (int): The integer N in the binomial coefficient C(N, K).\n    p (int): The prime number P.\n\n    Returns:\n    list: A list of integers representing the counts [A_0, A_1, ..., A_M].\n    \"\"\"\n    d = []\n    nn = n\n    while nn != 0:\n        d.append(nn % p)\n        nn //= p\n    pprev = Counter()\n    nprev = Counter([0])\n    for di in d:\n        ncur = Counter({k: di * v for (k, v) in pprev.items()}) + Counter({k: (di + 1) * v for (k, v) in nprev.items()})\n        pcur = Counter({k + 2: (p - di) * v for (k, v) in pprev.items()}) + Counter({k + 1: (p - di - 1) * v for (k, v) in nprev.items()})\n        (pprev, nprev) = (pcur, ncur)\n    return [ncur[i] for i in range(1 + max(ncur.keys()))]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "pcur = Counter({k + 1: (p - di) * v for (k, v) in pprev.items()}) + Counter({k + 1: (p - di - 1) * v for (k, v) in nprev.items()})",
      "mutated_line": "pcur = Counter({k + 0: (p - di) * v for (k, v) in pprev.items()}) + Counter({k + 1: (p - di - 1) * v for (k, v) in nprev.items()})",
      "code": "from collections import Counter\n\ndef calculate_binomial_coefficients_counts(n, p):\n    \"\"\"\n    Calculate the counts A_0, A_1, ..., A_M for the binomial coefficients C(N, K)\n    where P^L divides C(N, K) but P^(L+1) does not, for 0 ≤ K ≤ N.\n\n    Parameters:\n    n (int): The integer N in the binomial coefficient C(N, K).\n    p (int): The prime number P.\n\n    Returns:\n    list: A list of integers representing the counts [A_0, A_1, ..., A_M].\n    \"\"\"\n    d = []\n    nn = n\n    while nn != 0:\n        d.append(nn % p)\n        nn //= p\n    pprev = Counter()\n    nprev = Counter([0])\n    for di in d:\n        ncur = Counter({k: di * v for (k, v) in pprev.items()}) + Counter({k: (di + 1) * v for (k, v) in nprev.items()})\n        pcur = Counter({k + 0: (p - di) * v for (k, v) in pprev.items()}) + Counter({k + 1: (p - di - 1) * v for (k, v) in nprev.items()})\n        (pprev, nprev) = (pcur, ncur)\n    return [ncur[i] for i in range(1 + max(ncur.keys()))]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "pcur = Counter({k + 1: (p - di) * v for (k, v) in pprev.items()}) + Counter({k + 1: (p - di - 1) * v for (k, v) in nprev.items()})",
      "mutated_line": "pcur = Counter({k + 0: (p - di) * v for (k, v) in pprev.items()}) + Counter({k + 1: (p - di - 1) * v for (k, v) in nprev.items()})",
      "code": "from collections import Counter\n\ndef calculate_binomial_coefficients_counts(n, p):\n    \"\"\"\n    Calculate the counts A_0, A_1, ..., A_M for the binomial coefficients C(N, K)\n    where P^L divides C(N, K) but P^(L+1) does not, for 0 ≤ K ≤ N.\n\n    Parameters:\n    n (int): The integer N in the binomial coefficient C(N, K).\n    p (int): The prime number P.\n\n    Returns:\n    list: A list of integers representing the counts [A_0, A_1, ..., A_M].\n    \"\"\"\n    d = []\n    nn = n\n    while nn != 0:\n        d.append(nn % p)\n        nn //= p\n    pprev = Counter()\n    nprev = Counter([0])\n    for di in d:\n        ncur = Counter({k: di * v for (k, v) in pprev.items()}) + Counter({k: (di + 1) * v for (k, v) in nprev.items()})\n        pcur = Counter({k + 0: (p - di) * v for (k, v) in pprev.items()}) + Counter({k + 1: (p - di - 1) * v for (k, v) in nprev.items()})\n        (pprev, nprev) = (pcur, ncur)\n    return [ncur[i] for i in range(1 + max(ncur.keys()))]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "pcur = Counter({k + 1: (p - di) * v for (k, v) in pprev.items()}) + Counter({k + 1: (p - di - 1) * v for (k, v) in nprev.items()})",
      "mutated_line": "pcur = Counter({k + -1: (p - di) * v for (k, v) in pprev.items()}) + Counter({k + 1: (p - di - 1) * v for (k, v) in nprev.items()})",
      "code": "from collections import Counter\n\ndef calculate_binomial_coefficients_counts(n, p):\n    \"\"\"\n    Calculate the counts A_0, A_1, ..., A_M for the binomial coefficients C(N, K)\n    where P^L divides C(N, K) but P^(L+1) does not, for 0 ≤ K ≤ N.\n\n    Parameters:\n    n (int): The integer N in the binomial coefficient C(N, K).\n    p (int): The prime number P.\n\n    Returns:\n    list: A list of integers representing the counts [A_0, A_1, ..., A_M].\n    \"\"\"\n    d = []\n    nn = n\n    while nn != 0:\n        d.append(nn % p)\n        nn //= p\n    pprev = Counter()\n    nprev = Counter([0])\n    for di in d:\n        ncur = Counter({k: di * v for (k, v) in pprev.items()}) + Counter({k: (di + 1) * v for (k, v) in nprev.items()})\n        pcur = Counter({k + -1: (p - di) * v for (k, v) in pprev.items()}) + Counter({k + 1: (p - di - 1) * v for (k, v) in nprev.items()})\n        (pprev, nprev) = (pcur, ncur)\n    return [ncur[i] for i in range(1 + max(ncur.keys()))]"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "pcur = Counter({k + 1: (p - di) * v for (k, v) in pprev.items()}) + Counter({k + 1: (p - di - 1) * v for (k, v) in nprev.items()})",
      "mutated_line": "pcur = Counter({k + 1: (p + di) * v for (k, v) in pprev.items()}) + Counter({k + 1: (p - di - 1) * v for (k, v) in nprev.items()})",
      "code": "from collections import Counter\n\ndef calculate_binomial_coefficients_counts(n, p):\n    \"\"\"\n    Calculate the counts A_0, A_1, ..., A_M for the binomial coefficients C(N, K)\n    where P^L divides C(N, K) but P^(L+1) does not, for 0 ≤ K ≤ N.\n\n    Parameters:\n    n (int): The integer N in the binomial coefficient C(N, K).\n    p (int): The prime number P.\n\n    Returns:\n    list: A list of integers representing the counts [A_0, A_1, ..., A_M].\n    \"\"\"\n    d = []\n    nn = n\n    while nn != 0:\n        d.append(nn % p)\n        nn //= p\n    pprev = Counter()\n    nprev = Counter([0])\n    for di in d:\n        ncur = Counter({k: di * v for (k, v) in pprev.items()}) + Counter({k: (di + 1) * v for (k, v) in nprev.items()})\n        pcur = Counter({k + 1: (p + di) * v for (k, v) in pprev.items()}) + Counter({k + 1: (p - di - 1) * v for (k, v) in nprev.items()})\n        (pprev, nprev) = (pcur, ncur)\n    return [ncur[i] for i in range(1 + max(ncur.keys()))]"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "pcur = Counter({k + 1: (p - di) * v for (k, v) in pprev.items()}) + Counter({k + 1: (p - di - 1) * v for (k, v) in nprev.items()})",
      "mutated_line": "pcur = Counter({k + 1: p * di * v for (k, v) in pprev.items()}) + Counter({k + 1: (p - di - 1) * v for (k, v) in nprev.items()})",
      "code": "from collections import Counter\n\ndef calculate_binomial_coefficients_counts(n, p):\n    \"\"\"\n    Calculate the counts A_0, A_1, ..., A_M for the binomial coefficients C(N, K)\n    where P^L divides C(N, K) but P^(L+1) does not, for 0 ≤ K ≤ N.\n\n    Parameters:\n    n (int): The integer N in the binomial coefficient C(N, K).\n    p (int): The prime number P.\n\n    Returns:\n    list: A list of integers representing the counts [A_0, A_1, ..., A_M].\n    \"\"\"\n    d = []\n    nn = n\n    while nn != 0:\n        d.append(nn % p)\n        nn //= p\n    pprev = Counter()\n    nprev = Counter([0])\n    for di in d:\n        ncur = Counter({k: di * v for (k, v) in pprev.items()}) + Counter({k: (di + 1) * v for (k, v) in nprev.items()})\n        pcur = Counter({k + 1: p * di * v for (k, v) in pprev.items()}) + Counter({k + 1: (p - di - 1) * v for (k, v) in nprev.items()})\n        (pprev, nprev) = (pcur, ncur)\n    return [ncur[i] for i in range(1 + max(ncur.keys()))]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "pcur = Counter({k + 1: (p - di) * v for (k, v) in pprev.items()}) + Counter({k + 1: (p - di - 1) * v for (k, v) in nprev.items()})",
      "mutated_line": "pcur = Counter({k + 1: (p - di) * v for (k, v) in pprev.items()}) + Counter({k + 2: (p - di - 1) * v for (k, v) in nprev.items()})",
      "code": "from collections import Counter\n\ndef calculate_binomial_coefficients_counts(n, p):\n    \"\"\"\n    Calculate the counts A_0, A_1, ..., A_M for the binomial coefficients C(N, K)\n    where P^L divides C(N, K) but P^(L+1) does not, for 0 ≤ K ≤ N.\n\n    Parameters:\n    n (int): The integer N in the binomial coefficient C(N, K).\n    p (int): The prime number P.\n\n    Returns:\n    list: A list of integers representing the counts [A_0, A_1, ..., A_M].\n    \"\"\"\n    d = []\n    nn = n\n    while nn != 0:\n        d.append(nn % p)\n        nn //= p\n    pprev = Counter()\n    nprev = Counter([0])\n    for di in d:\n        ncur = Counter({k: di * v for (k, v) in pprev.items()}) + Counter({k: (di + 1) * v for (k, v) in nprev.items()})\n        pcur = Counter({k + 1: (p - di) * v for (k, v) in pprev.items()}) + Counter({k + 2: (p - di - 1) * v for (k, v) in nprev.items()})\n        (pprev, nprev) = (pcur, ncur)\n    return [ncur[i] for i in range(1 + max(ncur.keys()))]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "pcur = Counter({k + 1: (p - di) * v for (k, v) in pprev.items()}) + Counter({k + 1: (p - di - 1) * v for (k, v) in nprev.items()})",
      "mutated_line": "pcur = Counter({k + 1: (p - di) * v for (k, v) in pprev.items()}) + Counter({k + 0: (p - di - 1) * v for (k, v) in nprev.items()})",
      "code": "from collections import Counter\n\ndef calculate_binomial_coefficients_counts(n, p):\n    \"\"\"\n    Calculate the counts A_0, A_1, ..., A_M for the binomial coefficients C(N, K)\n    where P^L divides C(N, K) but P^(L+1) does not, for 0 ≤ K ≤ N.\n\n    Parameters:\n    n (int): The integer N in the binomial coefficient C(N, K).\n    p (int): The prime number P.\n\n    Returns:\n    list: A list of integers representing the counts [A_0, A_1, ..., A_M].\n    \"\"\"\n    d = []\n    nn = n\n    while nn != 0:\n        d.append(nn % p)\n        nn //= p\n    pprev = Counter()\n    nprev = Counter([0])\n    for di in d:\n        ncur = Counter({k: di * v for (k, v) in pprev.items()}) + Counter({k: (di + 1) * v for (k, v) in nprev.items()})\n        pcur = Counter({k + 1: (p - di) * v for (k, v) in pprev.items()}) + Counter({k + 0: (p - di - 1) * v for (k, v) in nprev.items()})\n        (pprev, nprev) = (pcur, ncur)\n    return [ncur[i] for i in range(1 + max(ncur.keys()))]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "pcur = Counter({k + 1: (p - di) * v for (k, v) in pprev.items()}) + Counter({k + 1: (p - di - 1) * v for (k, v) in nprev.items()})",
      "mutated_line": "pcur = Counter({k + 1: (p - di) * v for (k, v) in pprev.items()}) + Counter({k + 0: (p - di - 1) * v for (k, v) in nprev.items()})",
      "code": "from collections import Counter\n\ndef calculate_binomial_coefficients_counts(n, p):\n    \"\"\"\n    Calculate the counts A_0, A_1, ..., A_M for the binomial coefficients C(N, K)\n    where P^L divides C(N, K) but P^(L+1) does not, for 0 ≤ K ≤ N.\n\n    Parameters:\n    n (int): The integer N in the binomial coefficient C(N, K).\n    p (int): The prime number P.\n\n    Returns:\n    list: A list of integers representing the counts [A_0, A_1, ..., A_M].\n    \"\"\"\n    d = []\n    nn = n\n    while nn != 0:\n        d.append(nn % p)\n        nn //= p\n    pprev = Counter()\n    nprev = Counter([0])\n    for di in d:\n        ncur = Counter({k: di * v for (k, v) in pprev.items()}) + Counter({k: (di + 1) * v for (k, v) in nprev.items()})\n        pcur = Counter({k + 1: (p - di) * v for (k, v) in pprev.items()}) + Counter({k + 0: (p - di - 1) * v for (k, v) in nprev.items()})\n        (pprev, nprev) = (pcur, ncur)\n    return [ncur[i] for i in range(1 + max(ncur.keys()))]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "pcur = Counter({k + 1: (p - di) * v for (k, v) in pprev.items()}) + Counter({k + 1: (p - di - 1) * v for (k, v) in nprev.items()})",
      "mutated_line": "pcur = Counter({k + 1: (p - di) * v for (k, v) in pprev.items()}) + Counter({k + -1: (p - di - 1) * v for (k, v) in nprev.items()})",
      "code": "from collections import Counter\n\ndef calculate_binomial_coefficients_counts(n, p):\n    \"\"\"\n    Calculate the counts A_0, A_1, ..., A_M for the binomial coefficients C(N, K)\n    where P^L divides C(N, K) but P^(L+1) does not, for 0 ≤ K ≤ N.\n\n    Parameters:\n    n (int): The integer N in the binomial coefficient C(N, K).\n    p (int): The prime number P.\n\n    Returns:\n    list: A list of integers representing the counts [A_0, A_1, ..., A_M].\n    \"\"\"\n    d = []\n    nn = n\n    while nn != 0:\n        d.append(nn % p)\n        nn //= p\n    pprev = Counter()\n    nprev = Counter([0])\n    for di in d:\n        ncur = Counter({k: di * v for (k, v) in pprev.items()}) + Counter({k: (di + 1) * v for (k, v) in nprev.items()})\n        pcur = Counter({k + 1: (p - di) * v for (k, v) in pprev.items()}) + Counter({k + -1: (p - di - 1) * v for (k, v) in nprev.items()})\n        (pprev, nprev) = (pcur, ncur)\n    return [ncur[i] for i in range(1 + max(ncur.keys()))]"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "pcur = Counter({k + 1: (p - di) * v for (k, v) in pprev.items()}) + Counter({k + 1: (p - di - 1) * v for (k, v) in nprev.items()})",
      "mutated_line": "pcur = Counter({k + 1: (p - di) * v for (k, v) in pprev.items()}) + Counter({k + 1: (p - di + 1) * v for (k, v) in nprev.items()})",
      "code": "from collections import Counter\n\ndef calculate_binomial_coefficients_counts(n, p):\n    \"\"\"\n    Calculate the counts A_0, A_1, ..., A_M for the binomial coefficients C(N, K)\n    where P^L divides C(N, K) but P^(L+1) does not, for 0 ≤ K ≤ N.\n\n    Parameters:\n    n (int): The integer N in the binomial coefficient C(N, K).\n    p (int): The prime number P.\n\n    Returns:\n    list: A list of integers representing the counts [A_0, A_1, ..., A_M].\n    \"\"\"\n    d = []\n    nn = n\n    while nn != 0:\n        d.append(nn % p)\n        nn //= p\n    pprev = Counter()\n    nprev = Counter([0])\n    for di in d:\n        ncur = Counter({k: di * v for (k, v) in pprev.items()}) + Counter({k: (di + 1) * v for (k, v) in nprev.items()})\n        pcur = Counter({k + 1: (p - di) * v for (k, v) in pprev.items()}) + Counter({k + 1: (p - di + 1) * v for (k, v) in nprev.items()})\n        (pprev, nprev) = (pcur, ncur)\n    return [ncur[i] for i in range(1 + max(ncur.keys()))]"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "pcur = Counter({k + 1: (p - di) * v for (k, v) in pprev.items()}) + Counter({k + 1: (p - di - 1) * v for (k, v) in nprev.items()})",
      "mutated_line": "pcur = Counter({k + 1: (p - di) * v for (k, v) in pprev.items()}) + Counter({k + 1: (p - di) * 1 * v for (k, v) in nprev.items()})",
      "code": "from collections import Counter\n\ndef calculate_binomial_coefficients_counts(n, p):\n    \"\"\"\n    Calculate the counts A_0, A_1, ..., A_M for the binomial coefficients C(N, K)\n    where P^L divides C(N, K) but P^(L+1) does not, for 0 ≤ K ≤ N.\n\n    Parameters:\n    n (int): The integer N in the binomial coefficient C(N, K).\n    p (int): The prime number P.\n\n    Returns:\n    list: A list of integers representing the counts [A_0, A_1, ..., A_M].\n    \"\"\"\n    d = []\n    nn = n\n    while nn != 0:\n        d.append(nn % p)\n        nn //= p\n    pprev = Counter()\n    nprev = Counter([0])\n    for di in d:\n        ncur = Counter({k: di * v for (k, v) in pprev.items()}) + Counter({k: (di + 1) * v for (k, v) in nprev.items()})\n        pcur = Counter({k + 1: (p - di) * v for (k, v) in pprev.items()}) + Counter({k + 1: (p - di) * 1 * v for (k, v) in nprev.items()})\n        (pprev, nprev) = (pcur, ncur)\n    return [ncur[i] for i in range(1 + max(ncur.keys()))]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ncur = Counter({k: di * v for (k, v) in pprev.items()}) + Counter({k: (di + 1) * v for (k, v) in nprev.items()})",
      "mutated_line": "ncur = Counter({k: di * v for (k, v) in pprev.items()}) + Counter({k: (di + 2) * v for (k, v) in nprev.items()})",
      "code": "from collections import Counter\n\ndef calculate_binomial_coefficients_counts(n, p):\n    \"\"\"\n    Calculate the counts A_0, A_1, ..., A_M for the binomial coefficients C(N, K)\n    where P^L divides C(N, K) but P^(L+1) does not, for 0 ≤ K ≤ N.\n\n    Parameters:\n    n (int): The integer N in the binomial coefficient C(N, K).\n    p (int): The prime number P.\n\n    Returns:\n    list: A list of integers representing the counts [A_0, A_1, ..., A_M].\n    \"\"\"\n    d = []\n    nn = n\n    while nn != 0:\n        d.append(nn % p)\n        nn //= p\n    pprev = Counter()\n    nprev = Counter([0])\n    for di in d:\n        ncur = Counter({k: di * v for (k, v) in pprev.items()}) + Counter({k: (di + 2) * v for (k, v) in nprev.items()})\n        pcur = Counter({k + 1: (p - di) * v for (k, v) in pprev.items()}) + Counter({k + 1: (p - di - 1) * v for (k, v) in nprev.items()})\n        (pprev, nprev) = (pcur, ncur)\n    return [ncur[i] for i in range(1 + max(ncur.keys()))]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ncur = Counter({k: di * v for (k, v) in pprev.items()}) + Counter({k: (di + 1) * v for (k, v) in nprev.items()})",
      "mutated_line": "ncur = Counter({k: di * v for (k, v) in pprev.items()}) + Counter({k: (di + 0) * v for (k, v) in nprev.items()})",
      "code": "from collections import Counter\n\ndef calculate_binomial_coefficients_counts(n, p):\n    \"\"\"\n    Calculate the counts A_0, A_1, ..., A_M for the binomial coefficients C(N, K)\n    where P^L divides C(N, K) but P^(L+1) does not, for 0 ≤ K ≤ N.\n\n    Parameters:\n    n (int): The integer N in the binomial coefficient C(N, K).\n    p (int): The prime number P.\n\n    Returns:\n    list: A list of integers representing the counts [A_0, A_1, ..., A_M].\n    \"\"\"\n    d = []\n    nn = n\n    while nn != 0:\n        d.append(nn % p)\n        nn //= p\n    pprev = Counter()\n    nprev = Counter([0])\n    for di in d:\n        ncur = Counter({k: di * v for (k, v) in pprev.items()}) + Counter({k: (di + 0) * v for (k, v) in nprev.items()})\n        pcur = Counter({k + 1: (p - di) * v for (k, v) in pprev.items()}) + Counter({k + 1: (p - di - 1) * v for (k, v) in nprev.items()})\n        (pprev, nprev) = (pcur, ncur)\n    return [ncur[i] for i in range(1 + max(ncur.keys()))]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ncur = Counter({k: di * v for (k, v) in pprev.items()}) + Counter({k: (di + 1) * v for (k, v) in nprev.items()})",
      "mutated_line": "ncur = Counter({k: di * v for (k, v) in pprev.items()}) + Counter({k: (di + 0) * v for (k, v) in nprev.items()})",
      "code": "from collections import Counter\n\ndef calculate_binomial_coefficients_counts(n, p):\n    \"\"\"\n    Calculate the counts A_0, A_1, ..., A_M for the binomial coefficients C(N, K)\n    where P^L divides C(N, K) but P^(L+1) does not, for 0 ≤ K ≤ N.\n\n    Parameters:\n    n (int): The integer N in the binomial coefficient C(N, K).\n    p (int): The prime number P.\n\n    Returns:\n    list: A list of integers representing the counts [A_0, A_1, ..., A_M].\n    \"\"\"\n    d = []\n    nn = n\n    while nn != 0:\n        d.append(nn % p)\n        nn //= p\n    pprev = Counter()\n    nprev = Counter([0])\n    for di in d:\n        ncur = Counter({k: di * v for (k, v) in pprev.items()}) + Counter({k: (di + 0) * v for (k, v) in nprev.items()})\n        pcur = Counter({k + 1: (p - di) * v for (k, v) in pprev.items()}) + Counter({k + 1: (p - di - 1) * v for (k, v) in nprev.items()})\n        (pprev, nprev) = (pcur, ncur)\n    return [ncur[i] for i in range(1 + max(ncur.keys()))]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ncur = Counter({k: di * v for (k, v) in pprev.items()}) + Counter({k: (di + 1) * v for (k, v) in nprev.items()})",
      "mutated_line": "ncur = Counter({k: di * v for (k, v) in pprev.items()}) + Counter({k: (di + -1) * v for (k, v) in nprev.items()})",
      "code": "from collections import Counter\n\ndef calculate_binomial_coefficients_counts(n, p):\n    \"\"\"\n    Calculate the counts A_0, A_1, ..., A_M for the binomial coefficients C(N, K)\n    where P^L divides C(N, K) but P^(L+1) does not, for 0 ≤ K ≤ N.\n\n    Parameters:\n    n (int): The integer N in the binomial coefficient C(N, K).\n    p (int): The prime number P.\n\n    Returns:\n    list: A list of integers representing the counts [A_0, A_1, ..., A_M].\n    \"\"\"\n    d = []\n    nn = n\n    while nn != 0:\n        d.append(nn % p)\n        nn //= p\n    pprev = Counter()\n    nprev = Counter([0])\n    for di in d:\n        ncur = Counter({k: di * v for (k, v) in pprev.items()}) + Counter({k: (di + -1) * v for (k, v) in nprev.items()})\n        pcur = Counter({k + 1: (p - di) * v for (k, v) in pprev.items()}) + Counter({k + 1: (p - di - 1) * v for (k, v) in nprev.items()})\n        (pprev, nprev) = (pcur, ncur)\n    return [ncur[i] for i in range(1 + max(ncur.keys()))]"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "pcur = Counter({k + 1: (p - di) * v for (k, v) in pprev.items()}) + Counter({k + 1: (p - di - 1) * v for (k, v) in nprev.items()})",
      "mutated_line": "pcur = Counter({k + 1: (p - di) * v for (k, v) in pprev.items()}) + Counter({k + 1: (p + di - 1) * v for (k, v) in nprev.items()})",
      "code": "from collections import Counter\n\ndef calculate_binomial_coefficients_counts(n, p):\n    \"\"\"\n    Calculate the counts A_0, A_1, ..., A_M for the binomial coefficients C(N, K)\n    where P^L divides C(N, K) but P^(L+1) does not, for 0 ≤ K ≤ N.\n\n    Parameters:\n    n (int): The integer N in the binomial coefficient C(N, K).\n    p (int): The prime number P.\n\n    Returns:\n    list: A list of integers representing the counts [A_0, A_1, ..., A_M].\n    \"\"\"\n    d = []\n    nn = n\n    while nn != 0:\n        d.append(nn % p)\n        nn //= p\n    pprev = Counter()\n    nprev = Counter([0])\n    for di in d:\n        ncur = Counter({k: di * v for (k, v) in pprev.items()}) + Counter({k: (di + 1) * v for (k, v) in nprev.items()})\n        pcur = Counter({k + 1: (p - di) * v for (k, v) in pprev.items()}) + Counter({k + 1: (p + di - 1) * v for (k, v) in nprev.items()})\n        (pprev, nprev) = (pcur, ncur)\n    return [ncur[i] for i in range(1 + max(ncur.keys()))]"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "pcur = Counter({k + 1: (p - di) * v for (k, v) in pprev.items()}) + Counter({k + 1: (p - di - 1) * v for (k, v) in nprev.items()})",
      "mutated_line": "pcur = Counter({k + 1: (p - di) * v for (k, v) in pprev.items()}) + Counter({k + 1: (p * di - 1) * v for (k, v) in nprev.items()})",
      "code": "from collections import Counter\n\ndef calculate_binomial_coefficients_counts(n, p):\n    \"\"\"\n    Calculate the counts A_0, A_1, ..., A_M for the binomial coefficients C(N, K)\n    where P^L divides C(N, K) but P^(L+1) does not, for 0 ≤ K ≤ N.\n\n    Parameters:\n    n (int): The integer N in the binomial coefficient C(N, K).\n    p (int): The prime number P.\n\n    Returns:\n    list: A list of integers representing the counts [A_0, A_1, ..., A_M].\n    \"\"\"\n    d = []\n    nn = n\n    while nn != 0:\n        d.append(nn % p)\n        nn //= p\n    pprev = Counter()\n    nprev = Counter([0])\n    for di in d:\n        ncur = Counter({k: di * v for (k, v) in pprev.items()}) + Counter({k: (di + 1) * v for (k, v) in nprev.items()})\n        pcur = Counter({k + 1: (p - di) * v for (k, v) in pprev.items()}) + Counter({k + 1: (p * di - 1) * v for (k, v) in nprev.items()})\n        (pprev, nprev) = (pcur, ncur)\n    return [ncur[i] for i in range(1 + max(ncur.keys()))]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "pcur = Counter({k + 1: (p - di) * v for (k, v) in pprev.items()}) + Counter({k + 1: (p - di - 1) * v for (k, v) in nprev.items()})",
      "mutated_line": "pcur = Counter({k + 1: (p - di) * v for (k, v) in pprev.items()}) + Counter({k + 1: (p - di - 2) * v for (k, v) in nprev.items()})",
      "code": "from collections import Counter\n\ndef calculate_binomial_coefficients_counts(n, p):\n    \"\"\"\n    Calculate the counts A_0, A_1, ..., A_M for the binomial coefficients C(N, K)\n    where P^L divides C(N, K) but P^(L+1) does not, for 0 ≤ K ≤ N.\n\n    Parameters:\n    n (int): The integer N in the binomial coefficient C(N, K).\n    p (int): The prime number P.\n\n    Returns:\n    list: A list of integers representing the counts [A_0, A_1, ..., A_M].\n    \"\"\"\n    d = []\n    nn = n\n    while nn != 0:\n        d.append(nn % p)\n        nn //= p\n    pprev = Counter()\n    nprev = Counter([0])\n    for di in d:\n        ncur = Counter({k: di * v for (k, v) in pprev.items()}) + Counter({k: (di + 1) * v for (k, v) in nprev.items()})\n        pcur = Counter({k + 1: (p - di) * v for (k, v) in pprev.items()}) + Counter({k + 1: (p - di - 2) * v for (k, v) in nprev.items()})\n        (pprev, nprev) = (pcur, ncur)\n    return [ncur[i] for i in range(1 + max(ncur.keys()))]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "pcur = Counter({k + 1: (p - di) * v for (k, v) in pprev.items()}) + Counter({k + 1: (p - di - 1) * v for (k, v) in nprev.items()})",
      "mutated_line": "pcur = Counter({k + 1: (p - di) * v for (k, v) in pprev.items()}) + Counter({k + 1: (p - di - 0) * v for (k, v) in nprev.items()})",
      "code": "from collections import Counter\n\ndef calculate_binomial_coefficients_counts(n, p):\n    \"\"\"\n    Calculate the counts A_0, A_1, ..., A_M for the binomial coefficients C(N, K)\n    where P^L divides C(N, K) but P^(L+1) does not, for 0 ≤ K ≤ N.\n\n    Parameters:\n    n (int): The integer N in the binomial coefficient C(N, K).\n    p (int): The prime number P.\n\n    Returns:\n    list: A list of integers representing the counts [A_0, A_1, ..., A_M].\n    \"\"\"\n    d = []\n    nn = n\n    while nn != 0:\n        d.append(nn % p)\n        nn //= p\n    pprev = Counter()\n    nprev = Counter([0])\n    for di in d:\n        ncur = Counter({k: di * v for (k, v) in pprev.items()}) + Counter({k: (di + 1) * v for (k, v) in nprev.items()})\n        pcur = Counter({k + 1: (p - di) * v for (k, v) in pprev.items()}) + Counter({k + 1: (p - di - 0) * v for (k, v) in nprev.items()})\n        (pprev, nprev) = (pcur, ncur)\n    return [ncur[i] for i in range(1 + max(ncur.keys()))]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "pcur = Counter({k + 1: (p - di) * v for (k, v) in pprev.items()}) + Counter({k + 1: (p - di - 1) * v for (k, v) in nprev.items()})",
      "mutated_line": "pcur = Counter({k + 1: (p - di) * v for (k, v) in pprev.items()}) + Counter({k + 1: (p - di - 0) * v for (k, v) in nprev.items()})",
      "code": "from collections import Counter\n\ndef calculate_binomial_coefficients_counts(n, p):\n    \"\"\"\n    Calculate the counts A_0, A_1, ..., A_M for the binomial coefficients C(N, K)\n    where P^L divides C(N, K) but P^(L+1) does not, for 0 ≤ K ≤ N.\n\n    Parameters:\n    n (int): The integer N in the binomial coefficient C(N, K).\n    p (int): The prime number P.\n\n    Returns:\n    list: A list of integers representing the counts [A_0, A_1, ..., A_M].\n    \"\"\"\n    d = []\n    nn = n\n    while nn != 0:\n        d.append(nn % p)\n        nn //= p\n    pprev = Counter()\n    nprev = Counter([0])\n    for di in d:\n        ncur = Counter({k: di * v for (k, v) in pprev.items()}) + Counter({k: (di + 1) * v for (k, v) in nprev.items()})\n        pcur = Counter({k + 1: (p - di) * v for (k, v) in pprev.items()}) + Counter({k + 1: (p - di - 0) * v for (k, v) in nprev.items()})\n        (pprev, nprev) = (pcur, ncur)\n    return [ncur[i] for i in range(1 + max(ncur.keys()))]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "pcur = Counter({k + 1: (p - di) * v for (k, v) in pprev.items()}) + Counter({k + 1: (p - di - 1) * v for (k, v) in nprev.items()})",
      "mutated_line": "pcur = Counter({k + 1: (p - di) * v for (k, v) in pprev.items()}) + Counter({k + 1: (p - di - -1) * v for (k, v) in nprev.items()})",
      "code": "from collections import Counter\n\ndef calculate_binomial_coefficients_counts(n, p):\n    \"\"\"\n    Calculate the counts A_0, A_1, ..., A_M for the binomial coefficients C(N, K)\n    where P^L divides C(N, K) but P^(L+1) does not, for 0 ≤ K ≤ N.\n\n    Parameters:\n    n (int): The integer N in the binomial coefficient C(N, K).\n    p (int): The prime number P.\n\n    Returns:\n    list: A list of integers representing the counts [A_0, A_1, ..., A_M].\n    \"\"\"\n    d = []\n    nn = n\n    while nn != 0:\n        d.append(nn % p)\n        nn //= p\n    pprev = Counter()\n    nprev = Counter([0])\n    for di in d:\n        ncur = Counter({k: di * v for (k, v) in pprev.items()}) + Counter({k: (di + 1) * v for (k, v) in nprev.items()})\n        pcur = Counter({k + 1: (p - di) * v for (k, v) in pprev.items()}) + Counter({k + 1: (p - di - -1) * v for (k, v) in nprev.items()})\n        (pprev, nprev) = (pcur, ncur)\n    return [ncur[i] for i in range(1 + max(ncur.keys()))]"
    }
  ]
}