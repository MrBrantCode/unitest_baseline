{
  "task_id": "taco_7077",
  "entry_point": "reconstruct_alphabet",
  "mutant_count": 33,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if min(ingraph.values(), default=0) != 0:",
      "mutated_line": "return 'IMPOSSIBLE'",
      "code": "from collections import defaultdict, deque\n\ndef reconstruct_alphabet(n, k, pages):\n    graph = defaultdict(set)\n    ingraph = defaultdict(int)\n    allwords = set()\n    for page in pages:\n        (p, words) = page\n        allwords.update(words)\n        for word in words:\n            for other_word in words:\n                if word != other_word:\n                    match(word, other_word, graph, ingraph)\n    if min(ingraph.values(), default=0) == 0:\n        return 'IMPOSSIBLE'\n    ans = ''\n    d = deque()\n    for j in graph:\n        if ingraph[j] == 0:\n            d.append(j)\n    while d:\n        node = d.popleft()\n        ans += node\n        for j in graph[node]:\n            ingraph[j] -= 1\n            if not ingraph[j]:\n                d.append(j)\n    if len(ans) != len(allwords):\n        return 'IMPOSSIBLE'\n    return ans\n\ndef match(a, b, graph, ingraph):\n    for j in range(min(len(a), len(b))):\n        if a[j] == b[j]:\n            continue\n        elif b[j] in graph[a[j]]:\n            return\n        else:\n            graph[a[j]].add(b[j])\n            ingraph[b[j]] += 1\n            return\n    if len(a) > len(b):\n        print('IMPOSSIBLE')\n        return"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "ans = ''",
      "mutated_line": "ans = 'MUTATED'",
      "code": "from collections import defaultdict, deque\n\ndef reconstruct_alphabet(n, k, pages):\n    graph = defaultdict(set)\n    ingraph = defaultdict(int)\n    allwords = set()\n    for page in pages:\n        (p, words) = page\n        allwords.update(words)\n        for word in words:\n            for other_word in words:\n                if word != other_word:\n                    match(word, other_word, graph, ingraph)\n    if min(ingraph.values(), default=0) != 0:\n        return 'IMPOSSIBLE'\n    ans = 'MUTATED'\n    d = deque()\n    for j in graph:\n        if ingraph[j] == 0:\n            d.append(j)\n    while d:\n        node = d.popleft()\n        ans += node\n        for j in graph[node]:\n            ingraph[j] -= 1\n            if not ingraph[j]:\n                d.append(j)\n    if len(ans) != len(allwords):\n        return 'IMPOSSIBLE'\n    return ans\n\ndef match(a, b, graph, ingraph):\n    for j in range(min(len(a), len(b))):\n        if a[j] == b[j]:\n            continue\n        elif b[j] in graph[a[j]]:\n            return\n        else:\n            graph[a[j]].add(b[j])\n            ingraph[b[j]] += 1\n            return\n    if len(a) > len(b):\n        print('IMPOSSIBLE')\n        return"
    },
    {
      "operator": "ASR",
      "lineno": 30,
      "original_line": "ans += node",
      "mutated_line": "ans -= node",
      "code": "from collections import defaultdict, deque\n\ndef reconstruct_alphabet(n, k, pages):\n    graph = defaultdict(set)\n    ingraph = defaultdict(int)\n    allwords = set()\n    for page in pages:\n        (p, words) = page\n        allwords.update(words)\n        for word in words:\n            for other_word in words:\n                if word != other_word:\n                    match(word, other_word, graph, ingraph)\n    if min(ingraph.values(), default=0) != 0:\n        return 'IMPOSSIBLE'\n    ans = ''\n    d = deque()\n    for j in graph:\n        if ingraph[j] == 0:\n            d.append(j)\n    while d:\n        node = d.popleft()\n        ans -= node\n        for j in graph[node]:\n            ingraph[j] -= 1\n            if not ingraph[j]:\n                d.append(j)\n    if len(ans) != len(allwords):\n        return 'IMPOSSIBLE'\n    return ans\n\ndef match(a, b, graph, ingraph):\n    for j in range(min(len(a), len(b))):\n        if a[j] == b[j]:\n            continue\n        elif b[j] in graph[a[j]]:\n            return\n        else:\n            graph[a[j]].add(b[j])\n            ingraph[b[j]] += 1\n            return\n    if len(a) > len(b):\n        print('IMPOSSIBLE')\n        return"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if len(ans) != len(allwords):",
      "mutated_line": "return 'IMPOSSIBLE'",
      "code": "from collections import defaultdict, deque\n\ndef reconstruct_alphabet(n, k, pages):\n    graph = defaultdict(set)\n    ingraph = defaultdict(int)\n    allwords = set()\n    for page in pages:\n        (p, words) = page\n        allwords.update(words)\n        for word in words:\n            for other_word in words:\n                if word != other_word:\n                    match(word, other_word, graph, ingraph)\n    if min(ingraph.values(), default=0) != 0:\n        return 'IMPOSSIBLE'\n    ans = ''\n    d = deque()\n    for j in graph:\n        if ingraph[j] == 0:\n            d.append(j)\n    while d:\n        node = d.popleft()\n        ans += node\n        for j in graph[node]:\n            ingraph[j] -= 1\n            if not ingraph[j]:\n                d.append(j)\n    if len(ans) == len(allwords):\n        return 'IMPOSSIBLE'\n    return ans\n\ndef match(a, b, graph, ingraph):\n    for j in range(min(len(a), len(b))):\n        if a[j] == b[j]:\n            continue\n        elif b[j] in graph[a[j]]:\n            return\n        else:\n            graph[a[j]].add(b[j])\n            ingraph[b[j]] += 1\n            return\n    if len(a) > len(b):\n        print('IMPOSSIBLE')\n        return"
    },
    {
      "operator": "ROR",
      "lineno": 51,
      "original_line": "if len(a) > len(b):",
      "mutated_line": "if len(a) >= len(b):",
      "code": "from collections import defaultdict, deque\n\ndef reconstruct_alphabet(n, k, pages):\n    graph = defaultdict(set)\n    ingraph = defaultdict(int)\n    allwords = set()\n    for page in pages:\n        (p, words) = page\n        allwords.update(words)\n        for word in words:\n            for other_word in words:\n                if word != other_word:\n                    match(word, other_word, graph, ingraph)\n    if min(ingraph.values(), default=0) != 0:\n        return 'IMPOSSIBLE'\n    ans = ''\n    d = deque()\n    for j in graph:\n        if ingraph[j] == 0:\n            d.append(j)\n    while d:\n        node = d.popleft()\n        ans += node\n        for j in graph[node]:\n            ingraph[j] -= 1\n            if not ingraph[j]:\n                d.append(j)\n    if len(ans) != len(allwords):\n        return 'IMPOSSIBLE'\n    return ans\n\ndef match(a, b, graph, ingraph):\n    for j in range(min(len(a), len(b))):\n        if a[j] == b[j]:\n            continue\n        elif b[j] in graph[a[j]]:\n            return\n        else:\n            graph[a[j]].add(b[j])\n            ingraph[b[j]] += 1\n            return\n    if len(a) >= len(b):\n        print('IMPOSSIBLE')\n        return"
    },
    {
      "operator": "ROR",
      "lineno": 51,
      "original_line": "if len(a) > len(b):",
      "mutated_line": "if len(a) <= len(b):",
      "code": "from collections import defaultdict, deque\n\ndef reconstruct_alphabet(n, k, pages):\n    graph = defaultdict(set)\n    ingraph = defaultdict(int)\n    allwords = set()\n    for page in pages:\n        (p, words) = page\n        allwords.update(words)\n        for word in words:\n            for other_word in words:\n                if word != other_word:\n                    match(word, other_word, graph, ingraph)\n    if min(ingraph.values(), default=0) != 0:\n        return 'IMPOSSIBLE'\n    ans = ''\n    d = deque()\n    for j in graph:\n        if ingraph[j] == 0:\n            d.append(j)\n    while d:\n        node = d.popleft()\n        ans += node\n        for j in graph[node]:\n            ingraph[j] -= 1\n            if not ingraph[j]:\n                d.append(j)\n    if len(ans) != len(allwords):\n        return 'IMPOSSIBLE'\n    return ans\n\ndef match(a, b, graph, ingraph):\n    for j in range(min(len(a), len(b))):\n        if a[j] == b[j]:\n            continue\n        elif b[j] in graph[a[j]]:\n            return\n        else:\n            graph[a[j]].add(b[j])\n            ingraph[b[j]] += 1\n            return\n    if len(a) <= len(b):\n        print('IMPOSSIBLE')\n        return"
    },
    {
      "operator": "ROR",
      "lineno": 51,
      "original_line": "if len(a) > len(b):",
      "mutated_line": "if len(a) != len(b):",
      "code": "from collections import defaultdict, deque\n\ndef reconstruct_alphabet(n, k, pages):\n    graph = defaultdict(set)\n    ingraph = defaultdict(int)\n    allwords = set()\n    for page in pages:\n        (p, words) = page\n        allwords.update(words)\n        for word in words:\n            for other_word in words:\n                if word != other_word:\n                    match(word, other_word, graph, ingraph)\n    if min(ingraph.values(), default=0) != 0:\n        return 'IMPOSSIBLE'\n    ans = ''\n    d = deque()\n    for j in graph:\n        if ingraph[j] == 0:\n            d.append(j)\n    while d:\n        node = d.popleft()\n        ans += node\n        for j in graph[node]:\n            ingraph[j] -= 1\n            if not ingraph[j]:\n                d.append(j)\n    if len(ans) != len(allwords):\n        return 'IMPOSSIBLE'\n    return ans\n\ndef match(a, b, graph, ingraph):\n    for j in range(min(len(a), len(b))):\n        if a[j] == b[j]:\n            continue\n        elif b[j] in graph[a[j]]:\n            return\n        else:\n            graph[a[j]].add(b[j])\n            ingraph[b[j]] += 1\n            return\n    if len(a) != len(b):\n        print('IMPOSSIBLE')\n        return"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if min(ingraph.values(), default=0) != 0:",
      "mutated_line": "return 'IMPOSSIBLE'",
      "code": "from collections import defaultdict, deque\n\ndef reconstruct_alphabet(n, k, pages):\n    graph = defaultdict(set)\n    ingraph = defaultdict(int)\n    allwords = set()\n    for page in pages:\n        (p, words) = page\n        allwords.update(words)\n        for word in words:\n            for other_word in words:\n                if word != other_word:\n                    match(word, other_word, graph, ingraph)\n    if min(ingraph.values(), default=0) != 1:\n        return 'IMPOSSIBLE'\n    ans = ''\n    d = deque()\n    for j in graph:\n        if ingraph[j] == 0:\n            d.append(j)\n    while d:\n        node = d.popleft()\n        ans += node\n        for j in graph[node]:\n            ingraph[j] -= 1\n            if not ingraph[j]:\n                d.append(j)\n    if len(ans) != len(allwords):\n        return 'IMPOSSIBLE'\n    return ans\n\ndef match(a, b, graph, ingraph):\n    for j in range(min(len(a), len(b))):\n        if a[j] == b[j]:\n            continue\n        elif b[j] in graph[a[j]]:\n            return\n        else:\n            graph[a[j]].add(b[j])\n            ingraph[b[j]] += 1\n            return\n    if len(a) > len(b):\n        print('IMPOSSIBLE')\n        return"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if min(ingraph.values(), default=0) != 0:",
      "mutated_line": "return 'IMPOSSIBLE'",
      "code": "from collections import defaultdict, deque\n\ndef reconstruct_alphabet(n, k, pages):\n    graph = defaultdict(set)\n    ingraph = defaultdict(int)\n    allwords = set()\n    for page in pages:\n        (p, words) = page\n        allwords.update(words)\n        for word in words:\n            for other_word in words:\n                if word != other_word:\n                    match(word, other_word, graph, ingraph)\n    if min(ingraph.values(), default=0) != -1:\n        return 'IMPOSSIBLE'\n    ans = ''\n    d = deque()\n    for j in graph:\n        if ingraph[j] == 0:\n            d.append(j)\n    while d:\n        node = d.popleft()\n        ans += node\n        for j in graph[node]:\n            ingraph[j] -= 1\n            if not ingraph[j]:\n                d.append(j)\n    if len(ans) != len(allwords):\n        return 'IMPOSSIBLE'\n    return ans\n\ndef match(a, b, graph, ingraph):\n    for j in range(min(len(a), len(b))):\n        if a[j] == b[j]:\n            continue\n        elif b[j] in graph[a[j]]:\n            return\n        else:\n            graph[a[j]].add(b[j])\n            ingraph[b[j]] += 1\n            return\n    if len(a) > len(b):\n        print('IMPOSSIBLE')\n        return"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if min(ingraph.values(), default=0) != 0:",
      "mutated_line": "return 'IMPOSSIBLE'",
      "code": "from collections import defaultdict, deque\n\ndef reconstruct_alphabet(n, k, pages):\n    graph = defaultdict(set)\n    ingraph = defaultdict(int)\n    allwords = set()\n    for page in pages:\n        (p, words) = page\n        allwords.update(words)\n        for word in words:\n            for other_word in words:\n                if word != other_word:\n                    match(word, other_word, graph, ingraph)\n    if min(ingraph.values(), default=0) != 1:\n        return 'IMPOSSIBLE'\n    ans = ''\n    d = deque()\n    for j in graph:\n        if ingraph[j] == 0:\n            d.append(j)\n    while d:\n        node = d.popleft()\n        ans += node\n        for j in graph[node]:\n            ingraph[j] -= 1\n            if not ingraph[j]:\n                d.append(j)\n    if len(ans) != len(allwords):\n        return 'IMPOSSIBLE'\n    return ans\n\ndef match(a, b, graph, ingraph):\n    for j in range(min(len(a), len(b))):\n        if a[j] == b[j]:\n            continue\n        elif b[j] in graph[a[j]]:\n            return\n        else:\n            graph[a[j]].add(b[j])\n            ingraph[b[j]] += 1\n            return\n    if len(a) > len(b):\n        print('IMPOSSIBLE')\n        return"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return \"IMPOSSIBLE\"",
      "mutated_line": "return ''",
      "code": "from collections import defaultdict, deque\n\ndef reconstruct_alphabet(n, k, pages):\n    graph = defaultdict(set)\n    ingraph = defaultdict(int)\n    allwords = set()\n    for page in pages:\n        (p, words) = page\n        allwords.update(words)\n        for word in words:\n            for other_word in words:\n                if word != other_word:\n                    match(word, other_word, graph, ingraph)\n    if min(ingraph.values(), default=0) != 0:\n        return ''\n    ans = ''\n    d = deque()\n    for j in graph:\n        if ingraph[j] == 0:\n            d.append(j)\n    while d:\n        node = d.popleft()\n        ans += node\n        for j in graph[node]:\n            ingraph[j] -= 1\n            if not ingraph[j]:\n                d.append(j)\n    if len(ans) != len(allwords):\n        return 'IMPOSSIBLE'\n    return ans\n\ndef match(a, b, graph, ingraph):\n    for j in range(min(len(a), len(b))):\n        if a[j] == b[j]:\n            continue\n        elif b[j] in graph[a[j]]:\n            return\n        else:\n            graph[a[j]].add(b[j])\n            ingraph[b[j]] += 1\n            return\n    if len(a) > len(b):\n        print('IMPOSSIBLE')\n        return"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if ingraph[j] == 0:",
      "mutated_line": "if ingraph[j] != 0:",
      "code": "from collections import defaultdict, deque\n\ndef reconstruct_alphabet(n, k, pages):\n    graph = defaultdict(set)\n    ingraph = defaultdict(int)\n    allwords = set()\n    for page in pages:\n        (p, words) = page\n        allwords.update(words)\n        for word in words:\n            for other_word in words:\n                if word != other_word:\n                    match(word, other_word, graph, ingraph)\n    if min(ingraph.values(), default=0) != 0:\n        return 'IMPOSSIBLE'\n    ans = ''\n    d = deque()\n    for j in graph:\n        if ingraph[j] != 0:\n            d.append(j)\n    while d:\n        node = d.popleft()\n        ans += node\n        for j in graph[node]:\n            ingraph[j] -= 1\n            if not ingraph[j]:\n                d.append(j)\n    if len(ans) != len(allwords):\n        return 'IMPOSSIBLE'\n    return ans\n\ndef match(a, b, graph, ingraph):\n    for j in range(min(len(a), len(b))):\n        if a[j] == b[j]:\n            continue\n        elif b[j] in graph[a[j]]:\n            return\n        else:\n            graph[a[j]].add(b[j])\n            ingraph[b[j]] += 1\n            return\n    if len(a) > len(b):\n        print('IMPOSSIBLE')\n        return"
    },
    {
      "operator": "ASR",
      "lineno": 32,
      "original_line": "ingraph[j] -= 1",
      "mutated_line": "ingraph[j] += 1",
      "code": "from collections import defaultdict, deque\n\ndef reconstruct_alphabet(n, k, pages):\n    graph = defaultdict(set)\n    ingraph = defaultdict(int)\n    allwords = set()\n    for page in pages:\n        (p, words) = page\n        allwords.update(words)\n        for word in words:\n            for other_word in words:\n                if word != other_word:\n                    match(word, other_word, graph, ingraph)\n    if min(ingraph.values(), default=0) != 0:\n        return 'IMPOSSIBLE'\n    ans = ''\n    d = deque()\n    for j in graph:\n        if ingraph[j] == 0:\n            d.append(j)\n    while d:\n        node = d.popleft()\n        ans += node\n        for j in graph[node]:\n            ingraph[j] += 1\n            if not ingraph[j]:\n                d.append(j)\n    if len(ans) != len(allwords):\n        return 'IMPOSSIBLE'\n    return ans\n\ndef match(a, b, graph, ingraph):\n    for j in range(min(len(a), len(b))):\n        if a[j] == b[j]:\n            continue\n        elif b[j] in graph[a[j]]:\n            return\n        else:\n            graph[a[j]].add(b[j])\n            ingraph[b[j]] += 1\n            return\n    if len(a) > len(b):\n        print('IMPOSSIBLE')\n        return"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "return \"IMPOSSIBLE\"",
      "mutated_line": "return ''",
      "code": "from collections import defaultdict, deque\n\ndef reconstruct_alphabet(n, k, pages):\n    graph = defaultdict(set)\n    ingraph = defaultdict(int)\n    allwords = set()\n    for page in pages:\n        (p, words) = page\n        allwords.update(words)\n        for word in words:\n            for other_word in words:\n                if word != other_word:\n                    match(word, other_word, graph, ingraph)\n    if min(ingraph.values(), default=0) != 0:\n        return 'IMPOSSIBLE'\n    ans = ''\n    d = deque()\n    for j in graph:\n        if ingraph[j] == 0:\n            d.append(j)\n    while d:\n        node = d.popleft()\n        ans += node\n        for j in graph[node]:\n            ingraph[j] -= 1\n            if not ingraph[j]:\n                d.append(j)\n    if len(ans) != len(allwords):\n        return ''\n    return ans\n\ndef match(a, b, graph, ingraph):\n    for j in range(min(len(a), len(b))):\n        if a[j] == b[j]:\n            continue\n        elif b[j] in graph[a[j]]:\n            return\n        else:\n            graph[a[j]].add(b[j])\n            ingraph[b[j]] += 1\n            return\n    if len(a) > len(b):\n        print('IMPOSSIBLE')\n        return"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "if a[j] == b[j]:",
      "mutated_line": "if a[j] != b[j]:",
      "code": "from collections import defaultdict, deque\n\ndef reconstruct_alphabet(n, k, pages):\n    graph = defaultdict(set)\n    ingraph = defaultdict(int)\n    allwords = set()\n    for page in pages:\n        (p, words) = page\n        allwords.update(words)\n        for word in words:\n            for other_word in words:\n                if word != other_word:\n                    match(word, other_word, graph, ingraph)\n    if min(ingraph.values(), default=0) != 0:\n        return 'IMPOSSIBLE'\n    ans = ''\n    d = deque()\n    for j in graph:\n        if ingraph[j] == 0:\n            d.append(j)\n    while d:\n        node = d.popleft()\n        ans += node\n        for j in graph[node]:\n            ingraph[j] -= 1\n            if not ingraph[j]:\n                d.append(j)\n    if len(ans) != len(allwords):\n        return 'IMPOSSIBLE'\n    return ans\n\ndef match(a, b, graph, ingraph):\n    for j in range(min(len(a), len(b))):\n        if a[j] != b[j]:\n            continue\n        elif b[j] in graph[a[j]]:\n            return\n        else:\n            graph[a[j]].add(b[j])\n            ingraph[b[j]] += 1\n            return\n    if len(a) > len(b):\n        print('IMPOSSIBLE')\n        return"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if ingraph[j] == 0:",
      "mutated_line": "if ingraph[j] == 1:",
      "code": "from collections import defaultdict, deque\n\ndef reconstruct_alphabet(n, k, pages):\n    graph = defaultdict(set)\n    ingraph = defaultdict(int)\n    allwords = set()\n    for page in pages:\n        (p, words) = page\n        allwords.update(words)\n        for word in words:\n            for other_word in words:\n                if word != other_word:\n                    match(word, other_word, graph, ingraph)\n    if min(ingraph.values(), default=0) != 0:\n        return 'IMPOSSIBLE'\n    ans = ''\n    d = deque()\n    for j in graph:\n        if ingraph[j] == 1:\n            d.append(j)\n    while d:\n        node = d.popleft()\n        ans += node\n        for j in graph[node]:\n            ingraph[j] -= 1\n            if not ingraph[j]:\n                d.append(j)\n    if len(ans) != len(allwords):\n        return 'IMPOSSIBLE'\n    return ans\n\ndef match(a, b, graph, ingraph):\n    for j in range(min(len(a), len(b))):\n        if a[j] == b[j]:\n            continue\n        elif b[j] in graph[a[j]]:\n            return\n        else:\n            graph[a[j]].add(b[j])\n            ingraph[b[j]] += 1\n            return\n    if len(a) > len(b):\n        print('IMPOSSIBLE')\n        return"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if ingraph[j] == 0:",
      "mutated_line": "if ingraph[j] == -1:",
      "code": "from collections import defaultdict, deque\n\ndef reconstruct_alphabet(n, k, pages):\n    graph = defaultdict(set)\n    ingraph = defaultdict(int)\n    allwords = set()\n    for page in pages:\n        (p, words) = page\n        allwords.update(words)\n        for word in words:\n            for other_word in words:\n                if word != other_word:\n                    match(word, other_word, graph, ingraph)\n    if min(ingraph.values(), default=0) != 0:\n        return 'IMPOSSIBLE'\n    ans = ''\n    d = deque()\n    for j in graph:\n        if ingraph[j] == -1:\n            d.append(j)\n    while d:\n        node = d.popleft()\n        ans += node\n        for j in graph[node]:\n            ingraph[j] -= 1\n            if not ingraph[j]:\n                d.append(j)\n    if len(ans) != len(allwords):\n        return 'IMPOSSIBLE'\n    return ans\n\ndef match(a, b, graph, ingraph):\n    for j in range(min(len(a), len(b))):\n        if a[j] == b[j]:\n            continue\n        elif b[j] in graph[a[j]]:\n            return\n        else:\n            graph[a[j]].add(b[j])\n            ingraph[b[j]] += 1\n            return\n    if len(a) > len(b):\n        print('IMPOSSIBLE')\n        return"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if ingraph[j] == 0:",
      "mutated_line": "if ingraph[j] == 1:",
      "code": "from collections import defaultdict, deque\n\ndef reconstruct_alphabet(n, k, pages):\n    graph = defaultdict(set)\n    ingraph = defaultdict(int)\n    allwords = set()\n    for page in pages:\n        (p, words) = page\n        allwords.update(words)\n        for word in words:\n            for other_word in words:\n                if word != other_word:\n                    match(word, other_word, graph, ingraph)\n    if min(ingraph.values(), default=0) != 0:\n        return 'IMPOSSIBLE'\n    ans = ''\n    d = deque()\n    for j in graph:\n        if ingraph[j] == 1:\n            d.append(j)\n    while d:\n        node = d.popleft()\n        ans += node\n        for j in graph[node]:\n            ingraph[j] -= 1\n            if not ingraph[j]:\n                d.append(j)\n    if len(ans) != len(allwords):\n        return 'IMPOSSIBLE'\n    return ans\n\ndef match(a, b, graph, ingraph):\n    for j in range(min(len(a), len(b))):\n        if a[j] == b[j]:\n            continue\n        elif b[j] in graph[a[j]]:\n            return\n        else:\n            graph[a[j]].add(b[j])\n            ingraph[b[j]] += 1\n            return\n    if len(a) > len(b):\n        print('IMPOSSIBLE')\n        return"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "ingraph[j] -= 1",
      "mutated_line": "ingraph[j] -= 2",
      "code": "from collections import defaultdict, deque\n\ndef reconstruct_alphabet(n, k, pages):\n    graph = defaultdict(set)\n    ingraph = defaultdict(int)\n    allwords = set()\n    for page in pages:\n        (p, words) = page\n        allwords.update(words)\n        for word in words:\n            for other_word in words:\n                if word != other_word:\n                    match(word, other_word, graph, ingraph)\n    if min(ingraph.values(), default=0) != 0:\n        return 'IMPOSSIBLE'\n    ans = ''\n    d = deque()\n    for j in graph:\n        if ingraph[j] == 0:\n            d.append(j)\n    while d:\n        node = d.popleft()\n        ans += node\n        for j in graph[node]:\n            ingraph[j] -= 2\n            if not ingraph[j]:\n                d.append(j)\n    if len(ans) != len(allwords):\n        return 'IMPOSSIBLE'\n    return ans\n\ndef match(a, b, graph, ingraph):\n    for j in range(min(len(a), len(b))):\n        if a[j] == b[j]:\n            continue\n        elif b[j] in graph[a[j]]:\n            return\n        else:\n            graph[a[j]].add(b[j])\n            ingraph[b[j]] += 1\n            return\n    if len(a) > len(b):\n        print('IMPOSSIBLE')\n        return"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "ingraph[j] -= 1",
      "mutated_line": "ingraph[j] -= 0",
      "code": "from collections import defaultdict, deque\n\ndef reconstruct_alphabet(n, k, pages):\n    graph = defaultdict(set)\n    ingraph = defaultdict(int)\n    allwords = set()\n    for page in pages:\n        (p, words) = page\n        allwords.update(words)\n        for word in words:\n            for other_word in words:\n                if word != other_word:\n                    match(word, other_word, graph, ingraph)\n    if min(ingraph.values(), default=0) != 0:\n        return 'IMPOSSIBLE'\n    ans = ''\n    d = deque()\n    for j in graph:\n        if ingraph[j] == 0:\n            d.append(j)\n    while d:\n        node = d.popleft()\n        ans += node\n        for j in graph[node]:\n            ingraph[j] -= 0\n            if not ingraph[j]:\n                d.append(j)\n    if len(ans) != len(allwords):\n        return 'IMPOSSIBLE'\n    return ans\n\ndef match(a, b, graph, ingraph):\n    for j in range(min(len(a), len(b))):\n        if a[j] == b[j]:\n            continue\n        elif b[j] in graph[a[j]]:\n            return\n        else:\n            graph[a[j]].add(b[j])\n            ingraph[b[j]] += 1\n            return\n    if len(a) > len(b):\n        print('IMPOSSIBLE')\n        return"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "ingraph[j] -= 1",
      "mutated_line": "ingraph[j] -= 0",
      "code": "from collections import defaultdict, deque\n\ndef reconstruct_alphabet(n, k, pages):\n    graph = defaultdict(set)\n    ingraph = defaultdict(int)\n    allwords = set()\n    for page in pages:\n        (p, words) = page\n        allwords.update(words)\n        for word in words:\n            for other_word in words:\n                if word != other_word:\n                    match(word, other_word, graph, ingraph)\n    if min(ingraph.values(), default=0) != 0:\n        return 'IMPOSSIBLE'\n    ans = ''\n    d = deque()\n    for j in graph:\n        if ingraph[j] == 0:\n            d.append(j)\n    while d:\n        node = d.popleft()\n        ans += node\n        for j in graph[node]:\n            ingraph[j] -= 0\n            if not ingraph[j]:\n                d.append(j)\n    if len(ans) != len(allwords):\n        return 'IMPOSSIBLE'\n    return ans\n\ndef match(a, b, graph, ingraph):\n    for j in range(min(len(a), len(b))):\n        if a[j] == b[j]:\n            continue\n        elif b[j] in graph[a[j]]:\n            return\n        else:\n            graph[a[j]].add(b[j])\n            ingraph[b[j]] += 1\n            return\n    if len(a) > len(b):\n        print('IMPOSSIBLE')\n        return"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "ingraph[j] -= 1",
      "mutated_line": "ingraph[j] -= -1",
      "code": "from collections import defaultdict, deque\n\ndef reconstruct_alphabet(n, k, pages):\n    graph = defaultdict(set)\n    ingraph = defaultdict(int)\n    allwords = set()\n    for page in pages:\n        (p, words) = page\n        allwords.update(words)\n        for word in words:\n            for other_word in words:\n                if word != other_word:\n                    match(word, other_word, graph, ingraph)\n    if min(ingraph.values(), default=0) != 0:\n        return 'IMPOSSIBLE'\n    ans = ''\n    d = deque()\n    for j in graph:\n        if ingraph[j] == 0:\n            d.append(j)\n    while d:\n        node = d.popleft()\n        ans += node\n        for j in graph[node]:\n            ingraph[j] -= -1\n            if not ingraph[j]:\n                d.append(j)\n    if len(ans) != len(allwords):\n        return 'IMPOSSIBLE'\n    return ans\n\ndef match(a, b, graph, ingraph):\n    for j in range(min(len(a), len(b))):\n        if a[j] == b[j]:\n            continue\n        elif b[j] in graph[a[j]]:\n            return\n        else:\n            graph[a[j]].add(b[j])\n            ingraph[b[j]] += 1\n            return\n    if len(a) > len(b):\n        print('IMPOSSIBLE')\n        return"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "elif b[j] in graph[a[j]]:",
      "mutated_line": "elif b[j] not in graph[a[j]]:",
      "code": "from collections import defaultdict, deque\n\ndef reconstruct_alphabet(n, k, pages):\n    graph = defaultdict(set)\n    ingraph = defaultdict(int)\n    allwords = set()\n    for page in pages:\n        (p, words) = page\n        allwords.update(words)\n        for word in words:\n            for other_word in words:\n                if word != other_word:\n                    match(word, other_word, graph, ingraph)\n    if min(ingraph.values(), default=0) != 0:\n        return 'IMPOSSIBLE'\n    ans = ''\n    d = deque()\n    for j in graph:\n        if ingraph[j] == 0:\n            d.append(j)\n    while d:\n        node = d.popleft()\n        ans += node\n        for j in graph[node]:\n            ingraph[j] -= 1\n            if not ingraph[j]:\n                d.append(j)\n    if len(ans) != len(allwords):\n        return 'IMPOSSIBLE'\n    return ans\n\ndef match(a, b, graph, ingraph):\n    for j in range(min(len(a), len(b))):\n        if a[j] == b[j]:\n            continue\n        elif b[j] not in graph[a[j]]:\n            return\n        else:\n            graph[a[j]].add(b[j])\n            ingraph[b[j]] += 1\n            return\n    if len(a) > len(b):\n        print('IMPOSSIBLE')\n        return"
    },
    {
      "operator": "ASR",
      "lineno": 49,
      "original_line": "ingraph[b[j]] += 1",
      "mutated_line": "ingraph[b[j]] -= 1",
      "code": "from collections import defaultdict, deque\n\ndef reconstruct_alphabet(n, k, pages):\n    graph = defaultdict(set)\n    ingraph = defaultdict(int)\n    allwords = set()\n    for page in pages:\n        (p, words) = page\n        allwords.update(words)\n        for word in words:\n            for other_word in words:\n                if word != other_word:\n                    match(word, other_word, graph, ingraph)\n    if min(ingraph.values(), default=0) != 0:\n        return 'IMPOSSIBLE'\n    ans = ''\n    d = deque()\n    for j in graph:\n        if ingraph[j] == 0:\n            d.append(j)\n    while d:\n        node = d.popleft()\n        ans += node\n        for j in graph[node]:\n            ingraph[j] -= 1\n            if not ingraph[j]:\n                d.append(j)\n    if len(ans) != len(allwords):\n        return 'IMPOSSIBLE'\n    return ans\n\ndef match(a, b, graph, ingraph):\n    for j in range(min(len(a), len(b))):\n        if a[j] == b[j]:\n            continue\n        elif b[j] in graph[a[j]]:\n            return\n        else:\n            graph[a[j]].add(b[j])\n            ingraph[b[j]] -= 1\n            return\n    if len(a) > len(b):\n        print('IMPOSSIBLE')\n        return"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "print('IMPOSSIBLE')",
      "mutated_line": "print('')",
      "code": "from collections import defaultdict, deque\n\ndef reconstruct_alphabet(n, k, pages):\n    graph = defaultdict(set)\n    ingraph = defaultdict(int)\n    allwords = set()\n    for page in pages:\n        (p, words) = page\n        allwords.update(words)\n        for word in words:\n            for other_word in words:\n                if word != other_word:\n                    match(word, other_word, graph, ingraph)\n    if min(ingraph.values(), default=0) != 0:\n        return 'IMPOSSIBLE'\n    ans = ''\n    d = deque()\n    for j in graph:\n        if ingraph[j] == 0:\n            d.append(j)\n    while d:\n        node = d.popleft()\n        ans += node\n        for j in graph[node]:\n            ingraph[j] -= 1\n            if not ingraph[j]:\n                d.append(j)\n    if len(ans) != len(allwords):\n        return 'IMPOSSIBLE'\n    return ans\n\ndef match(a, b, graph, ingraph):\n    for j in range(min(len(a), len(b))):\n        if a[j] == b[j]:\n            continue\n        elif b[j] in graph[a[j]]:\n            return\n        else:\n            graph[a[j]].add(b[j])\n            ingraph[b[j]] += 1\n            return\n    if len(a) > len(b):\n        print('')\n        return"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if word != other_word:",
      "mutated_line": "if word == other_word:",
      "code": "from collections import defaultdict, deque\n\ndef reconstruct_alphabet(n, k, pages):\n    graph = defaultdict(set)\n    ingraph = defaultdict(int)\n    allwords = set()\n    for page in pages:\n        (p, words) = page\n        allwords.update(words)\n        for word in words:\n            for other_word in words:\n                if word == other_word:\n                    match(word, other_word, graph, ingraph)\n    if min(ingraph.values(), default=0) != 0:\n        return 'IMPOSSIBLE'\n    ans = ''\n    d = deque()\n    for j in graph:\n        if ingraph[j] == 0:\n            d.append(j)\n    while d:\n        node = d.popleft()\n        ans += node\n        for j in graph[node]:\n            ingraph[j] -= 1\n            if not ingraph[j]:\n                d.append(j)\n    if len(ans) != len(allwords):\n        return 'IMPOSSIBLE'\n    return ans\n\ndef match(a, b, graph, ingraph):\n    for j in range(min(len(a), len(b))):\n        if a[j] == b[j]:\n            continue\n        elif b[j] in graph[a[j]]:\n            return\n        else:\n            graph[a[j]].add(b[j])\n            ingraph[b[j]] += 1\n            return\n    if len(a) > len(b):\n        print('IMPOSSIBLE')\n        return"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if min(ingraph.values(), default=0) != 0:",
      "mutated_line": "return 'IMPOSSIBLE'",
      "code": "from collections import defaultdict, deque\n\ndef reconstruct_alphabet(n, k, pages):\n    graph = defaultdict(set)\n    ingraph = defaultdict(int)\n    allwords = set()\n    for page in pages:\n        (p, words) = page\n        allwords.update(words)\n        for word in words:\n            for other_word in words:\n                if word != other_word:\n                    match(word, other_word, graph, ingraph)\n    if min(ingraph.values(), default=1) != 0:\n        return 'IMPOSSIBLE'\n    ans = ''\n    d = deque()\n    for j in graph:\n        if ingraph[j] == 0:\n            d.append(j)\n    while d:\n        node = d.popleft()\n        ans += node\n        for j in graph[node]:\n            ingraph[j] -= 1\n            if not ingraph[j]:\n                d.append(j)\n    if len(ans) != len(allwords):\n        return 'IMPOSSIBLE'\n    return ans\n\ndef match(a, b, graph, ingraph):\n    for j in range(min(len(a), len(b))):\n        if a[j] == b[j]:\n            continue\n        elif b[j] in graph[a[j]]:\n            return\n        else:\n            graph[a[j]].add(b[j])\n            ingraph[b[j]] += 1\n            return\n    if len(a) > len(b):\n        print('IMPOSSIBLE')\n        return"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if min(ingraph.values(), default=0) != 0:",
      "mutated_line": "return 'IMPOSSIBLE'",
      "code": "from collections import defaultdict, deque\n\ndef reconstruct_alphabet(n, k, pages):\n    graph = defaultdict(set)\n    ingraph = defaultdict(int)\n    allwords = set()\n    for page in pages:\n        (p, words) = page\n        allwords.update(words)\n        for word in words:\n            for other_word in words:\n                if word != other_word:\n                    match(word, other_word, graph, ingraph)\n    if min(ingraph.values(), default=-1) != 0:\n        return 'IMPOSSIBLE'\n    ans = ''\n    d = deque()\n    for j in graph:\n        if ingraph[j] == 0:\n            d.append(j)\n    while d:\n        node = d.popleft()\n        ans += node\n        for j in graph[node]:\n            ingraph[j] -= 1\n            if not ingraph[j]:\n                d.append(j)\n    if len(ans) != len(allwords):\n        return 'IMPOSSIBLE'\n    return ans\n\ndef match(a, b, graph, ingraph):\n    for j in range(min(len(a), len(b))):\n        if a[j] == b[j]:\n            continue\n        elif b[j] in graph[a[j]]:\n            return\n        else:\n            graph[a[j]].add(b[j])\n            ingraph[b[j]] += 1\n            return\n    if len(a) > len(b):\n        print('IMPOSSIBLE')\n        return"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if min(ingraph.values(), default=0) != 0:",
      "mutated_line": "return 'IMPOSSIBLE'",
      "code": "from collections import defaultdict, deque\n\ndef reconstruct_alphabet(n, k, pages):\n    graph = defaultdict(set)\n    ingraph = defaultdict(int)\n    allwords = set()\n    for page in pages:\n        (p, words) = page\n        allwords.update(words)\n        for word in words:\n            for other_word in words:\n                if word != other_word:\n                    match(word, other_word, graph, ingraph)\n    if min(ingraph.values(), default=1) != 0:\n        return 'IMPOSSIBLE'\n    ans = ''\n    d = deque()\n    for j in graph:\n        if ingraph[j] == 0:\n            d.append(j)\n    while d:\n        node = d.popleft()\n        ans += node\n        for j in graph[node]:\n            ingraph[j] -= 1\n            if not ingraph[j]:\n                d.append(j)\n    if len(ans) != len(allwords):\n        return 'IMPOSSIBLE'\n    return ans\n\ndef match(a, b, graph, ingraph):\n    for j in range(min(len(a), len(b))):\n        if a[j] == b[j]:\n            continue\n        elif b[j] in graph[a[j]]:\n            return\n        else:\n            graph[a[j]].add(b[j])\n            ingraph[b[j]] += 1\n            return\n    if len(a) > len(b):\n        print('IMPOSSIBLE')\n        return"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "ingraph[b[j]] += 1",
      "mutated_line": "ingraph[b[j]] += 2",
      "code": "from collections import defaultdict, deque\n\ndef reconstruct_alphabet(n, k, pages):\n    graph = defaultdict(set)\n    ingraph = defaultdict(int)\n    allwords = set()\n    for page in pages:\n        (p, words) = page\n        allwords.update(words)\n        for word in words:\n            for other_word in words:\n                if word != other_word:\n                    match(word, other_word, graph, ingraph)\n    if min(ingraph.values(), default=0) != 0:\n        return 'IMPOSSIBLE'\n    ans = ''\n    d = deque()\n    for j in graph:\n        if ingraph[j] == 0:\n            d.append(j)\n    while d:\n        node = d.popleft()\n        ans += node\n        for j in graph[node]:\n            ingraph[j] -= 1\n            if not ingraph[j]:\n                d.append(j)\n    if len(ans) != len(allwords):\n        return 'IMPOSSIBLE'\n    return ans\n\ndef match(a, b, graph, ingraph):\n    for j in range(min(len(a), len(b))):\n        if a[j] == b[j]:\n            continue\n        elif b[j] in graph[a[j]]:\n            return\n        else:\n            graph[a[j]].add(b[j])\n            ingraph[b[j]] += 2\n            return\n    if len(a) > len(b):\n        print('IMPOSSIBLE')\n        return"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "ingraph[b[j]] += 1",
      "mutated_line": "ingraph[b[j]] += 0",
      "code": "from collections import defaultdict, deque\n\ndef reconstruct_alphabet(n, k, pages):\n    graph = defaultdict(set)\n    ingraph = defaultdict(int)\n    allwords = set()\n    for page in pages:\n        (p, words) = page\n        allwords.update(words)\n        for word in words:\n            for other_word in words:\n                if word != other_word:\n                    match(word, other_word, graph, ingraph)\n    if min(ingraph.values(), default=0) != 0:\n        return 'IMPOSSIBLE'\n    ans = ''\n    d = deque()\n    for j in graph:\n        if ingraph[j] == 0:\n            d.append(j)\n    while d:\n        node = d.popleft()\n        ans += node\n        for j in graph[node]:\n            ingraph[j] -= 1\n            if not ingraph[j]:\n                d.append(j)\n    if len(ans) != len(allwords):\n        return 'IMPOSSIBLE'\n    return ans\n\ndef match(a, b, graph, ingraph):\n    for j in range(min(len(a), len(b))):\n        if a[j] == b[j]:\n            continue\n        elif b[j] in graph[a[j]]:\n            return\n        else:\n            graph[a[j]].add(b[j])\n            ingraph[b[j]] += 0\n            return\n    if len(a) > len(b):\n        print('IMPOSSIBLE')\n        return"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "ingraph[b[j]] += 1",
      "mutated_line": "ingraph[b[j]] += 0",
      "code": "from collections import defaultdict, deque\n\ndef reconstruct_alphabet(n, k, pages):\n    graph = defaultdict(set)\n    ingraph = defaultdict(int)\n    allwords = set()\n    for page in pages:\n        (p, words) = page\n        allwords.update(words)\n        for word in words:\n            for other_word in words:\n                if word != other_word:\n                    match(word, other_word, graph, ingraph)\n    if min(ingraph.values(), default=0) != 0:\n        return 'IMPOSSIBLE'\n    ans = ''\n    d = deque()\n    for j in graph:\n        if ingraph[j] == 0:\n            d.append(j)\n    while d:\n        node = d.popleft()\n        ans += node\n        for j in graph[node]:\n            ingraph[j] -= 1\n            if not ingraph[j]:\n                d.append(j)\n    if len(ans) != len(allwords):\n        return 'IMPOSSIBLE'\n    return ans\n\ndef match(a, b, graph, ingraph):\n    for j in range(min(len(a), len(b))):\n        if a[j] == b[j]:\n            continue\n        elif b[j] in graph[a[j]]:\n            return\n        else:\n            graph[a[j]].add(b[j])\n            ingraph[b[j]] += 0\n            return\n    if len(a) > len(b):\n        print('IMPOSSIBLE')\n        return"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "ingraph[b[j]] += 1",
      "mutated_line": "ingraph[b[j]] += -1",
      "code": "from collections import defaultdict, deque\n\ndef reconstruct_alphabet(n, k, pages):\n    graph = defaultdict(set)\n    ingraph = defaultdict(int)\n    allwords = set()\n    for page in pages:\n        (p, words) = page\n        allwords.update(words)\n        for word in words:\n            for other_word in words:\n                if word != other_word:\n                    match(word, other_word, graph, ingraph)\n    if min(ingraph.values(), default=0) != 0:\n        return 'IMPOSSIBLE'\n    ans = ''\n    d = deque()\n    for j in graph:\n        if ingraph[j] == 0:\n            d.append(j)\n    while d:\n        node = d.popleft()\n        ans += node\n        for j in graph[node]:\n            ingraph[j] -= 1\n            if not ingraph[j]:\n                d.append(j)\n    if len(ans) != len(allwords):\n        return 'IMPOSSIBLE'\n    return ans\n\ndef match(a, b, graph, ingraph):\n    for j in range(min(len(a), len(b))):\n        if a[j] == b[j]:\n            continue\n        elif b[j] in graph[a[j]]:\n            return\n        else:\n            graph[a[j]].add(b[j])\n            ingraph[b[j]] += -1\n            return\n    if len(a) > len(b):\n        print('IMPOSSIBLE')\n        return"
    }
  ]
}