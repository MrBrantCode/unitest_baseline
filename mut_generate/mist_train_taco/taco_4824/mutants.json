{
  "task_id": "taco_4824",
  "entry_point": "calculate_path_weights",
  "mutant_count": 100,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "max_log = 35",
      "mutated_line": "max_log = 36",
      "code": "def calculate_path_weights(n, k, f, w):\n    max_log = 36\n    next_n = [[-1] * n for _ in range(max_log)]\n    next_m = [[float('inf')] * n for _ in range(max_log)]\n    next_s = [[0] * n for _ in range(max_log)]\n    for u in range(n):\n        v = f[u]\n        next_n[0][u] = v\n        next_m[0][u] = w[u]\n        next_s[0][u] = w[u]\n    for k_log in range(1, max_log):\n        for u in range(n):\n            v = next_n[k_log - 1][u]\n            m = next_m[k_log - 1][u]\n            s = next_s[k_log - 1][u]\n            next_n[k_log][u] = next_n[k_log - 1][v]\n            next_m[k_log][u] = min(next_m[k_log - 1][v], m)\n            next_s[k_log][u] = next_s[k_log - 1][v] + s\n    result = []\n    for u in range(n):\n        (s, m) = (0, float('inf'))\n        v = u\n        cur = 1 << max_log\n        i = max_log\n        while cur > 0:\n            if cur & k:\n                m = min(m, next_m[i][v])\n                s = s + next_s[i][v]\n                v = next_n[i][v]\n            cur >>= 1\n            i -= 1\n        result.append((s, m))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "max_log = 35",
      "mutated_line": "max_log = 34",
      "code": "def calculate_path_weights(n, k, f, w):\n    max_log = 34\n    next_n = [[-1] * n for _ in range(max_log)]\n    next_m = [[float('inf')] * n for _ in range(max_log)]\n    next_s = [[0] * n for _ in range(max_log)]\n    for u in range(n):\n        v = f[u]\n        next_n[0][u] = v\n        next_m[0][u] = w[u]\n        next_s[0][u] = w[u]\n    for k_log in range(1, max_log):\n        for u in range(n):\n            v = next_n[k_log - 1][u]\n            m = next_m[k_log - 1][u]\n            s = next_s[k_log - 1][u]\n            next_n[k_log][u] = next_n[k_log - 1][v]\n            next_m[k_log][u] = min(next_m[k_log - 1][v], m)\n            next_s[k_log][u] = next_s[k_log - 1][v] + s\n    result = []\n    for u in range(n):\n        (s, m) = (0, float('inf'))\n        v = u\n        cur = 1 << max_log\n        i = max_log\n        while cur > 0:\n            if cur & k:\n                m = min(m, next_m[i][v])\n                s = s + next_s[i][v]\n                v = next_n[i][v]\n            cur >>= 1\n            i -= 1\n        result.append((s, m))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "max_log = 35",
      "mutated_line": "max_log = 0",
      "code": "def calculate_path_weights(n, k, f, w):\n    max_log = 0\n    next_n = [[-1] * n for _ in range(max_log)]\n    next_m = [[float('inf')] * n for _ in range(max_log)]\n    next_s = [[0] * n for _ in range(max_log)]\n    for u in range(n):\n        v = f[u]\n        next_n[0][u] = v\n        next_m[0][u] = w[u]\n        next_s[0][u] = w[u]\n    for k_log in range(1, max_log):\n        for u in range(n):\n            v = next_n[k_log - 1][u]\n            m = next_m[k_log - 1][u]\n            s = next_s[k_log - 1][u]\n            next_n[k_log][u] = next_n[k_log - 1][v]\n            next_m[k_log][u] = min(next_m[k_log - 1][v], m)\n            next_s[k_log][u] = next_s[k_log - 1][v] + s\n    result = []\n    for u in range(n):\n        (s, m) = (0, float('inf'))\n        v = u\n        cur = 1 << max_log\n        i = max_log\n        while cur > 0:\n            if cur & k:\n                m = min(m, next_m[i][v])\n                s = s + next_s[i][v]\n                v = next_n[i][v]\n            cur >>= 1\n            i -= 1\n        result.append((s, m))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "max_log = 35",
      "mutated_line": "max_log = 1",
      "code": "def calculate_path_weights(n, k, f, w):\n    max_log = 1\n    next_n = [[-1] * n for _ in range(max_log)]\n    next_m = [[float('inf')] * n for _ in range(max_log)]\n    next_s = [[0] * n for _ in range(max_log)]\n    for u in range(n):\n        v = f[u]\n        next_n[0][u] = v\n        next_m[0][u] = w[u]\n        next_s[0][u] = w[u]\n    for k_log in range(1, max_log):\n        for u in range(n):\n            v = next_n[k_log - 1][u]\n            m = next_m[k_log - 1][u]\n            s = next_s[k_log - 1][u]\n            next_n[k_log][u] = next_n[k_log - 1][v]\n            next_m[k_log][u] = min(next_m[k_log - 1][v], m)\n            next_s[k_log][u] = next_s[k_log - 1][v] + s\n    result = []\n    for u in range(n):\n        (s, m) = (0, float('inf'))\n        v = u\n        cur = 1 << max_log\n        i = max_log\n        while cur > 0:\n            if cur & k:\n                m = min(m, next_m[i][v])\n                s = s + next_s[i][v]\n                v = next_n[i][v]\n            cur >>= 1\n            i -= 1\n        result.append((s, m))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "max_log = 35",
      "mutated_line": "max_log = -35",
      "code": "def calculate_path_weights(n, k, f, w):\n    max_log = -35\n    next_n = [[-1] * n for _ in range(max_log)]\n    next_m = [[float('inf')] * n for _ in range(max_log)]\n    next_s = [[0] * n for _ in range(max_log)]\n    for u in range(n):\n        v = f[u]\n        next_n[0][u] = v\n        next_m[0][u] = w[u]\n        next_s[0][u] = w[u]\n    for k_log in range(1, max_log):\n        for u in range(n):\n            v = next_n[k_log - 1][u]\n            m = next_m[k_log - 1][u]\n            s = next_s[k_log - 1][u]\n            next_n[k_log][u] = next_n[k_log - 1][v]\n            next_m[k_log][u] = min(next_m[k_log - 1][v], m)\n            next_s[k_log][u] = next_s[k_log - 1][v] + s\n    result = []\n    for u in range(n):\n        (s, m) = (0, float('inf'))\n        v = u\n        cur = 1 << max_log\n        i = max_log\n        while cur > 0:\n            if cur & k:\n                m = min(m, next_m[i][v])\n                s = s + next_s[i][v]\n                v = next_n[i][v]\n            cur >>= 1\n            i -= 1\n        result.append((s, m))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "next_n = [[-1] * n for _ in range(max_log)]",
      "mutated_line": "next_n = [[-1] / n for _ in range(max_log)]",
      "code": "def calculate_path_weights(n, k, f, w):\n    max_log = 35\n    next_n = [[-1] / n for _ in range(max_log)]\n    next_m = [[float('inf')] * n for _ in range(max_log)]\n    next_s = [[0] * n for _ in range(max_log)]\n    for u in range(n):\n        v = f[u]\n        next_n[0][u] = v\n        next_m[0][u] = w[u]\n        next_s[0][u] = w[u]\n    for k_log in range(1, max_log):\n        for u in range(n):\n            v = next_n[k_log - 1][u]\n            m = next_m[k_log - 1][u]\n            s = next_s[k_log - 1][u]\n            next_n[k_log][u] = next_n[k_log - 1][v]\n            next_m[k_log][u] = min(next_m[k_log - 1][v], m)\n            next_s[k_log][u] = next_s[k_log - 1][v] + s\n    result = []\n    for u in range(n):\n        (s, m) = (0, float('inf'))\n        v = u\n        cur = 1 << max_log\n        i = max_log\n        while cur > 0:\n            if cur & k:\n                m = min(m, next_m[i][v])\n                s = s + next_s[i][v]\n                v = next_n[i][v]\n            cur >>= 1\n            i -= 1\n        result.append((s, m))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "next_n = [[-1] * n for _ in range(max_log)]",
      "mutated_line": "next_n = [[-1] + n for _ in range(max_log)]",
      "code": "def calculate_path_weights(n, k, f, w):\n    max_log = 35\n    next_n = [[-1] + n for _ in range(max_log)]\n    next_m = [[float('inf')] * n for _ in range(max_log)]\n    next_s = [[0] * n for _ in range(max_log)]\n    for u in range(n):\n        v = f[u]\n        next_n[0][u] = v\n        next_m[0][u] = w[u]\n        next_s[0][u] = w[u]\n    for k_log in range(1, max_log):\n        for u in range(n):\n            v = next_n[k_log - 1][u]\n            m = next_m[k_log - 1][u]\n            s = next_s[k_log - 1][u]\n            next_n[k_log][u] = next_n[k_log - 1][v]\n            next_m[k_log][u] = min(next_m[k_log - 1][v], m)\n            next_s[k_log][u] = next_s[k_log - 1][v] + s\n    result = []\n    for u in range(n):\n        (s, m) = (0, float('inf'))\n        v = u\n        cur = 1 << max_log\n        i = max_log\n        while cur > 0:\n            if cur & k:\n                m = min(m, next_m[i][v])\n                s = s + next_s[i][v]\n                v = next_n[i][v]\n            cur >>= 1\n            i -= 1\n        result.append((s, m))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "next_n = [[-1] * n for _ in range(max_log)]",
      "mutated_line": "next_n = [[-1] ** n for _ in range(max_log)]",
      "code": "def calculate_path_weights(n, k, f, w):\n    max_log = 35\n    next_n = [[-1] ** n for _ in range(max_log)]\n    next_m = [[float('inf')] * n for _ in range(max_log)]\n    next_s = [[0] * n for _ in range(max_log)]\n    for u in range(n):\n        v = f[u]\n        next_n[0][u] = v\n        next_m[0][u] = w[u]\n        next_s[0][u] = w[u]\n    for k_log in range(1, max_log):\n        for u in range(n):\n            v = next_n[k_log - 1][u]\n            m = next_m[k_log - 1][u]\n            s = next_s[k_log - 1][u]\n            next_n[k_log][u] = next_n[k_log - 1][v]\n            next_m[k_log][u] = min(next_m[k_log - 1][v], m)\n            next_s[k_log][u] = next_s[k_log - 1][v] + s\n    result = []\n    for u in range(n):\n        (s, m) = (0, float('inf'))\n        v = u\n        cur = 1 << max_log\n        i = max_log\n        while cur > 0:\n            if cur & k:\n                m = min(m, next_m[i][v])\n                s = s + next_s[i][v]\n                v = next_n[i][v]\n            cur >>= 1\n            i -= 1\n        result.append((s, m))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "next_m = [[float('inf')] * n for _ in range(max_log)]",
      "mutated_line": "next_m = [[float('inf')] / n for _ in range(max_log)]",
      "code": "def calculate_path_weights(n, k, f, w):\n    max_log = 35\n    next_n = [[-1] * n for _ in range(max_log)]\n    next_m = [[float('inf')] / n for _ in range(max_log)]\n    next_s = [[0] * n for _ in range(max_log)]\n    for u in range(n):\n        v = f[u]\n        next_n[0][u] = v\n        next_m[0][u] = w[u]\n        next_s[0][u] = w[u]\n    for k_log in range(1, max_log):\n        for u in range(n):\n            v = next_n[k_log - 1][u]\n            m = next_m[k_log - 1][u]\n            s = next_s[k_log - 1][u]\n            next_n[k_log][u] = next_n[k_log - 1][v]\n            next_m[k_log][u] = min(next_m[k_log - 1][v], m)\n            next_s[k_log][u] = next_s[k_log - 1][v] + s\n    result = []\n    for u in range(n):\n        (s, m) = (0, float('inf'))\n        v = u\n        cur = 1 << max_log\n        i = max_log\n        while cur > 0:\n            if cur & k:\n                m = min(m, next_m[i][v])\n                s = s + next_s[i][v]\n                v = next_n[i][v]\n            cur >>= 1\n            i -= 1\n        result.append((s, m))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "next_m = [[float('inf')] * n for _ in range(max_log)]",
      "mutated_line": "next_m = [[float('inf')] + n for _ in range(max_log)]",
      "code": "def calculate_path_weights(n, k, f, w):\n    max_log = 35\n    next_n = [[-1] * n for _ in range(max_log)]\n    next_m = [[float('inf')] + n for _ in range(max_log)]\n    next_s = [[0] * n for _ in range(max_log)]\n    for u in range(n):\n        v = f[u]\n        next_n[0][u] = v\n        next_m[0][u] = w[u]\n        next_s[0][u] = w[u]\n    for k_log in range(1, max_log):\n        for u in range(n):\n            v = next_n[k_log - 1][u]\n            m = next_m[k_log - 1][u]\n            s = next_s[k_log - 1][u]\n            next_n[k_log][u] = next_n[k_log - 1][v]\n            next_m[k_log][u] = min(next_m[k_log - 1][v], m)\n            next_s[k_log][u] = next_s[k_log - 1][v] + s\n    result = []\n    for u in range(n):\n        (s, m) = (0, float('inf'))\n        v = u\n        cur = 1 << max_log\n        i = max_log\n        while cur > 0:\n            if cur & k:\n                m = min(m, next_m[i][v])\n                s = s + next_s[i][v]\n                v = next_n[i][v]\n            cur >>= 1\n            i -= 1\n        result.append((s, m))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "next_m = [[float('inf')] * n for _ in range(max_log)]",
      "mutated_line": "next_m = [[float('inf')] ** n for _ in range(max_log)]",
      "code": "def calculate_path_weights(n, k, f, w):\n    max_log = 35\n    next_n = [[-1] * n for _ in range(max_log)]\n    next_m = [[float('inf')] ** n for _ in range(max_log)]\n    next_s = [[0] * n for _ in range(max_log)]\n    for u in range(n):\n        v = f[u]\n        next_n[0][u] = v\n        next_m[0][u] = w[u]\n        next_s[0][u] = w[u]\n    for k_log in range(1, max_log):\n        for u in range(n):\n            v = next_n[k_log - 1][u]\n            m = next_m[k_log - 1][u]\n            s = next_s[k_log - 1][u]\n            next_n[k_log][u] = next_n[k_log - 1][v]\n            next_m[k_log][u] = min(next_m[k_log - 1][v], m)\n            next_s[k_log][u] = next_s[k_log - 1][v] + s\n    result = []\n    for u in range(n):\n        (s, m) = (0, float('inf'))\n        v = u\n        cur = 1 << max_log\n        i = max_log\n        while cur > 0:\n            if cur & k:\n                m = min(m, next_m[i][v])\n                s = s + next_s[i][v]\n                v = next_n[i][v]\n            cur >>= 1\n            i -= 1\n        result.append((s, m))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "next_s = [[0] * n for _ in range(max_log)]",
      "mutated_line": "next_s = [[0] / n for _ in range(max_log)]",
      "code": "def calculate_path_weights(n, k, f, w):\n    max_log = 35\n    next_n = [[-1] * n for _ in range(max_log)]\n    next_m = [[float('inf')] * n for _ in range(max_log)]\n    next_s = [[0] / n for _ in range(max_log)]\n    for u in range(n):\n        v = f[u]\n        next_n[0][u] = v\n        next_m[0][u] = w[u]\n        next_s[0][u] = w[u]\n    for k_log in range(1, max_log):\n        for u in range(n):\n            v = next_n[k_log - 1][u]\n            m = next_m[k_log - 1][u]\n            s = next_s[k_log - 1][u]\n            next_n[k_log][u] = next_n[k_log - 1][v]\n            next_m[k_log][u] = min(next_m[k_log - 1][v], m)\n            next_s[k_log][u] = next_s[k_log - 1][v] + s\n    result = []\n    for u in range(n):\n        (s, m) = (0, float('inf'))\n        v = u\n        cur = 1 << max_log\n        i = max_log\n        while cur > 0:\n            if cur & k:\n                m = min(m, next_m[i][v])\n                s = s + next_s[i][v]\n                v = next_n[i][v]\n            cur >>= 1\n            i -= 1\n        result.append((s, m))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "next_s = [[0] * n for _ in range(max_log)]",
      "mutated_line": "next_s = [[0] + n for _ in range(max_log)]",
      "code": "def calculate_path_weights(n, k, f, w):\n    max_log = 35\n    next_n = [[-1] * n for _ in range(max_log)]\n    next_m = [[float('inf')] * n for _ in range(max_log)]\n    next_s = [[0] + n for _ in range(max_log)]\n    for u in range(n):\n        v = f[u]\n        next_n[0][u] = v\n        next_m[0][u] = w[u]\n        next_s[0][u] = w[u]\n    for k_log in range(1, max_log):\n        for u in range(n):\n            v = next_n[k_log - 1][u]\n            m = next_m[k_log - 1][u]\n            s = next_s[k_log - 1][u]\n            next_n[k_log][u] = next_n[k_log - 1][v]\n            next_m[k_log][u] = min(next_m[k_log - 1][v], m)\n            next_s[k_log][u] = next_s[k_log - 1][v] + s\n    result = []\n    for u in range(n):\n        (s, m) = (0, float('inf'))\n        v = u\n        cur = 1 << max_log\n        i = max_log\n        while cur > 0:\n            if cur & k:\n                m = min(m, next_m[i][v])\n                s = s + next_s[i][v]\n                v = next_n[i][v]\n            cur >>= 1\n            i -= 1\n        result.append((s, m))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "next_s = [[0] * n for _ in range(max_log)]",
      "mutated_line": "next_s = [[0] ** n for _ in range(max_log)]",
      "code": "def calculate_path_weights(n, k, f, w):\n    max_log = 35\n    next_n = [[-1] * n for _ in range(max_log)]\n    next_m = [[float('inf')] * n for _ in range(max_log)]\n    next_s = [[0] ** n for _ in range(max_log)]\n    for u in range(n):\n        v = f[u]\n        next_n[0][u] = v\n        next_m[0][u] = w[u]\n        next_s[0][u] = w[u]\n    for k_log in range(1, max_log):\n        for u in range(n):\n            v = next_n[k_log - 1][u]\n            m = next_m[k_log - 1][u]\n            s = next_s[k_log - 1][u]\n            next_n[k_log][u] = next_n[k_log - 1][v]\n            next_m[k_log][u] = min(next_m[k_log - 1][v], m)\n            next_s[k_log][u] = next_s[k_log - 1][v] + s\n    result = []\n    for u in range(n):\n        (s, m) = (0, float('inf'))\n        v = u\n        cur = 1 << max_log\n        i = max_log\n        while cur > 0:\n            if cur & k:\n                m = min(m, next_m[i][v])\n                s = s + next_s[i][v]\n                v = next_n[i][v]\n            cur >>= 1\n            i -= 1\n        result.append((s, m))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for k_log in range(1, max_log):",
      "mutated_line": "for k_log in range(2, max_log):",
      "code": "def calculate_path_weights(n, k, f, w):\n    max_log = 35\n    next_n = [[-1] * n for _ in range(max_log)]\n    next_m = [[float('inf')] * n for _ in range(max_log)]\n    next_s = [[0] * n for _ in range(max_log)]\n    for u in range(n):\n        v = f[u]\n        next_n[0][u] = v\n        next_m[0][u] = w[u]\n        next_s[0][u] = w[u]\n    for k_log in range(2, max_log):\n        for u in range(n):\n            v = next_n[k_log - 1][u]\n            m = next_m[k_log - 1][u]\n            s = next_s[k_log - 1][u]\n            next_n[k_log][u] = next_n[k_log - 1][v]\n            next_m[k_log][u] = min(next_m[k_log - 1][v], m)\n            next_s[k_log][u] = next_s[k_log - 1][v] + s\n    result = []\n    for u in range(n):\n        (s, m) = (0, float('inf'))\n        v = u\n        cur = 1 << max_log\n        i = max_log\n        while cur > 0:\n            if cur & k:\n                m = min(m, next_m[i][v])\n                s = s + next_s[i][v]\n                v = next_n[i][v]\n            cur >>= 1\n            i -= 1\n        result.append((s, m))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for k_log in range(1, max_log):",
      "mutated_line": "for k_log in range(0, max_log):",
      "code": "def calculate_path_weights(n, k, f, w):\n    max_log = 35\n    next_n = [[-1] * n for _ in range(max_log)]\n    next_m = [[float('inf')] * n for _ in range(max_log)]\n    next_s = [[0] * n for _ in range(max_log)]\n    for u in range(n):\n        v = f[u]\n        next_n[0][u] = v\n        next_m[0][u] = w[u]\n        next_s[0][u] = w[u]\n    for k_log in range(0, max_log):\n        for u in range(n):\n            v = next_n[k_log - 1][u]\n            m = next_m[k_log - 1][u]\n            s = next_s[k_log - 1][u]\n            next_n[k_log][u] = next_n[k_log - 1][v]\n            next_m[k_log][u] = min(next_m[k_log - 1][v], m)\n            next_s[k_log][u] = next_s[k_log - 1][v] + s\n    result = []\n    for u in range(n):\n        (s, m) = (0, float('inf'))\n        v = u\n        cur = 1 << max_log\n        i = max_log\n        while cur > 0:\n            if cur & k:\n                m = min(m, next_m[i][v])\n                s = s + next_s[i][v]\n                v = next_n[i][v]\n            cur >>= 1\n            i -= 1\n        result.append((s, m))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for k_log in range(1, max_log):",
      "mutated_line": "for k_log in range(0, max_log):",
      "code": "def calculate_path_weights(n, k, f, w):\n    max_log = 35\n    next_n = [[-1] * n for _ in range(max_log)]\n    next_m = [[float('inf')] * n for _ in range(max_log)]\n    next_s = [[0] * n for _ in range(max_log)]\n    for u in range(n):\n        v = f[u]\n        next_n[0][u] = v\n        next_m[0][u] = w[u]\n        next_s[0][u] = w[u]\n    for k_log in range(0, max_log):\n        for u in range(n):\n            v = next_n[k_log - 1][u]\n            m = next_m[k_log - 1][u]\n            s = next_s[k_log - 1][u]\n            next_n[k_log][u] = next_n[k_log - 1][v]\n            next_m[k_log][u] = min(next_m[k_log - 1][v], m)\n            next_s[k_log][u] = next_s[k_log - 1][v] + s\n    result = []\n    for u in range(n):\n        (s, m) = (0, float('inf'))\n        v = u\n        cur = 1 << max_log\n        i = max_log\n        while cur > 0:\n            if cur & k:\n                m = min(m, next_m[i][v])\n                s = s + next_s[i][v]\n                v = next_n[i][v]\n            cur >>= 1\n            i -= 1\n        result.append((s, m))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for k_log in range(1, max_log):",
      "mutated_line": "for k_log in range(-1, max_log):",
      "code": "def calculate_path_weights(n, k, f, w):\n    max_log = 35\n    next_n = [[-1] * n for _ in range(max_log)]\n    next_m = [[float('inf')] * n for _ in range(max_log)]\n    next_s = [[0] * n for _ in range(max_log)]\n    for u in range(n):\n        v = f[u]\n        next_n[0][u] = v\n        next_m[0][u] = w[u]\n        next_s[0][u] = w[u]\n    for k_log in range(-1, max_log):\n        for u in range(n):\n            v = next_n[k_log - 1][u]\n            m = next_m[k_log - 1][u]\n            s = next_s[k_log - 1][u]\n            next_n[k_log][u] = next_n[k_log - 1][v]\n            next_m[k_log][u] = min(next_m[k_log - 1][v], m)\n            next_s[k_log][u] = next_s[k_log - 1][v] + s\n    result = []\n    for u in range(n):\n        (s, m) = (0, float('inf'))\n        v = u\n        cur = 1 << max_log\n        i = max_log\n        while cur > 0:\n            if cur & k:\n                m = min(m, next_m[i][v])\n                s = s + next_s[i][v]\n                v = next_n[i][v]\n            cur >>= 1\n            i -= 1\n        result.append((s, m))\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "while cur > 0:",
      "mutated_line": "while cur >= 0:",
      "code": "def calculate_path_weights(n, k, f, w):\n    max_log = 35\n    next_n = [[-1] * n for _ in range(max_log)]\n    next_m = [[float('inf')] * n for _ in range(max_log)]\n    next_s = [[0] * n for _ in range(max_log)]\n    for u in range(n):\n        v = f[u]\n        next_n[0][u] = v\n        next_m[0][u] = w[u]\n        next_s[0][u] = w[u]\n    for k_log in range(1, max_log):\n        for u in range(n):\n            v = next_n[k_log - 1][u]\n            m = next_m[k_log - 1][u]\n            s = next_s[k_log - 1][u]\n            next_n[k_log][u] = next_n[k_log - 1][v]\n            next_m[k_log][u] = min(next_m[k_log - 1][v], m)\n            next_s[k_log][u] = next_s[k_log - 1][v] + s\n    result = []\n    for u in range(n):\n        (s, m) = (0, float('inf'))\n        v = u\n        cur = 1 << max_log\n        i = max_log\n        while cur >= 0:\n            if cur & k:\n                m = min(m, next_m[i][v])\n                s = s + next_s[i][v]\n                v = next_n[i][v]\n            cur >>= 1\n            i -= 1\n        result.append((s, m))\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "while cur > 0:",
      "mutated_line": "while cur <= 0:",
      "code": "def calculate_path_weights(n, k, f, w):\n    max_log = 35\n    next_n = [[-1] * n for _ in range(max_log)]\n    next_m = [[float('inf')] * n for _ in range(max_log)]\n    next_s = [[0] * n for _ in range(max_log)]\n    for u in range(n):\n        v = f[u]\n        next_n[0][u] = v\n        next_m[0][u] = w[u]\n        next_s[0][u] = w[u]\n    for k_log in range(1, max_log):\n        for u in range(n):\n            v = next_n[k_log - 1][u]\n            m = next_m[k_log - 1][u]\n            s = next_s[k_log - 1][u]\n            next_n[k_log][u] = next_n[k_log - 1][v]\n            next_m[k_log][u] = min(next_m[k_log - 1][v], m)\n            next_s[k_log][u] = next_s[k_log - 1][v] + s\n    result = []\n    for u in range(n):\n        (s, m) = (0, float('inf'))\n        v = u\n        cur = 1 << max_log\n        i = max_log\n        while cur <= 0:\n            if cur & k:\n                m = min(m, next_m[i][v])\n                s = s + next_s[i][v]\n                v = next_n[i][v]\n            cur >>= 1\n            i -= 1\n        result.append((s, m))\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "while cur > 0:",
      "mutated_line": "while cur != 0:",
      "code": "def calculate_path_weights(n, k, f, w):\n    max_log = 35\n    next_n = [[-1] * n for _ in range(max_log)]\n    next_m = [[float('inf')] * n for _ in range(max_log)]\n    next_s = [[0] * n for _ in range(max_log)]\n    for u in range(n):\n        v = f[u]\n        next_n[0][u] = v\n        next_m[0][u] = w[u]\n        next_s[0][u] = w[u]\n    for k_log in range(1, max_log):\n        for u in range(n):\n            v = next_n[k_log - 1][u]\n            m = next_m[k_log - 1][u]\n            s = next_s[k_log - 1][u]\n            next_n[k_log][u] = next_n[k_log - 1][v]\n            next_m[k_log][u] = min(next_m[k_log - 1][v], m)\n            next_s[k_log][u] = next_s[k_log - 1][v] + s\n    result = []\n    for u in range(n):\n        (s, m) = (0, float('inf'))\n        v = u\n        cur = 1 << max_log\n        i = max_log\n        while cur != 0:\n            if cur & k:\n                m = min(m, next_m[i][v])\n                s = s + next_s[i][v]\n                v = next_n[i][v]\n            cur >>= 1\n            i -= 1\n        result.append((s, m))\n    return result"
    },
    {
      "operator": "ASR",
      "lineno": 34,
      "original_line": "i -= 1",
      "mutated_line": "i += 1",
      "code": "def calculate_path_weights(n, k, f, w):\n    max_log = 35\n    next_n = [[-1] * n for _ in range(max_log)]\n    next_m = [[float('inf')] * n for _ in range(max_log)]\n    next_s = [[0] * n for _ in range(max_log)]\n    for u in range(n):\n        v = f[u]\n        next_n[0][u] = v\n        next_m[0][u] = w[u]\n        next_s[0][u] = w[u]\n    for k_log in range(1, max_log):\n        for u in range(n):\n            v = next_n[k_log - 1][u]\n            m = next_m[k_log - 1][u]\n            s = next_s[k_log - 1][u]\n            next_n[k_log][u] = next_n[k_log - 1][v]\n            next_m[k_log][u] = min(next_m[k_log - 1][v], m)\n            next_s[k_log][u] = next_s[k_log - 1][v] + s\n    result = []\n    for u in range(n):\n        (s, m) = (0, float('inf'))\n        v = u\n        cur = 1 << max_log\n        i = max_log\n        while cur > 0:\n            if cur & k:\n                m = min(m, next_m[i][v])\n                s = s + next_s[i][v]\n                v = next_n[i][v]\n            cur >>= 1\n            i += 1\n        result.append((s, m))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "next_s[k_log][u] = next_s[k_log - 1][v] + s",
      "mutated_line": "next_s[k_log][u] = next_s[k_log - 1][v] - s",
      "code": "def calculate_path_weights(n, k, f, w):\n    max_log = 35\n    next_n = [[-1] * n for _ in range(max_log)]\n    next_m = [[float('inf')] * n for _ in range(max_log)]\n    next_s = [[0] * n for _ in range(max_log)]\n    for u in range(n):\n        v = f[u]\n        next_n[0][u] = v\n        next_m[0][u] = w[u]\n        next_s[0][u] = w[u]\n    for k_log in range(1, max_log):\n        for u in range(n):\n            v = next_n[k_log - 1][u]\n            m = next_m[k_log - 1][u]\n            s = next_s[k_log - 1][u]\n            next_n[k_log][u] = next_n[k_log - 1][v]\n            next_m[k_log][u] = min(next_m[k_log - 1][v], m)\n            next_s[k_log][u] = next_s[k_log - 1][v] - s\n    result = []\n    for u in range(n):\n        (s, m) = (0, float('inf'))\n        v = u\n        cur = 1 << max_log\n        i = max_log\n        while cur > 0:\n            if cur & k:\n                m = min(m, next_m[i][v])\n                s = s + next_s[i][v]\n                v = next_n[i][v]\n            cur >>= 1\n            i -= 1\n        result.append((s, m))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "next_s[k_log][u] = next_s[k_log - 1][v] + s",
      "mutated_line": "next_s[k_log][u] = next_s[k_log - 1][v] * s",
      "code": "def calculate_path_weights(n, k, f, w):\n    max_log = 35\n    next_n = [[-1] * n for _ in range(max_log)]\n    next_m = [[float('inf')] * n for _ in range(max_log)]\n    next_s = [[0] * n for _ in range(max_log)]\n    for u in range(n):\n        v = f[u]\n        next_n[0][u] = v\n        next_m[0][u] = w[u]\n        next_s[0][u] = w[u]\n    for k_log in range(1, max_log):\n        for u in range(n):\n            v = next_n[k_log - 1][u]\n            m = next_m[k_log - 1][u]\n            s = next_s[k_log - 1][u]\n            next_n[k_log][u] = next_n[k_log - 1][v]\n            next_m[k_log][u] = min(next_m[k_log - 1][v], m)\n            next_s[k_log][u] = next_s[k_log - 1][v] * s\n    result = []\n    for u in range(n):\n        (s, m) = (0, float('inf'))\n        v = u\n        cur = 1 << max_log\n        i = max_log\n        while cur > 0:\n            if cur & k:\n                m = min(m, next_m[i][v])\n                s = s + next_s[i][v]\n                v = next_n[i][v]\n            cur >>= 1\n            i -= 1\n        result.append((s, m))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "s, m = 0, float('inf')",
      "mutated_line": "(s, m) = (1, float('inf'))",
      "code": "def calculate_path_weights(n, k, f, w):\n    max_log = 35\n    next_n = [[-1] * n for _ in range(max_log)]\n    next_m = [[float('inf')] * n for _ in range(max_log)]\n    next_s = [[0] * n for _ in range(max_log)]\n    for u in range(n):\n        v = f[u]\n        next_n[0][u] = v\n        next_m[0][u] = w[u]\n        next_s[0][u] = w[u]\n    for k_log in range(1, max_log):\n        for u in range(n):\n            v = next_n[k_log - 1][u]\n            m = next_m[k_log - 1][u]\n            s = next_s[k_log - 1][u]\n            next_n[k_log][u] = next_n[k_log - 1][v]\n            next_m[k_log][u] = min(next_m[k_log - 1][v], m)\n            next_s[k_log][u] = next_s[k_log - 1][v] + s\n    result = []\n    for u in range(n):\n        (s, m) = (1, float('inf'))\n        v = u\n        cur = 1 << max_log\n        i = max_log\n        while cur > 0:\n            if cur & k:\n                m = min(m, next_m[i][v])\n                s = s + next_s[i][v]\n                v = next_n[i][v]\n            cur >>= 1\n            i -= 1\n        result.append((s, m))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "s, m = 0, float('inf')",
      "mutated_line": "(s, m) = (-1, float('inf'))",
      "code": "def calculate_path_weights(n, k, f, w):\n    max_log = 35\n    next_n = [[-1] * n for _ in range(max_log)]\n    next_m = [[float('inf')] * n for _ in range(max_log)]\n    next_s = [[0] * n for _ in range(max_log)]\n    for u in range(n):\n        v = f[u]\n        next_n[0][u] = v\n        next_m[0][u] = w[u]\n        next_s[0][u] = w[u]\n    for k_log in range(1, max_log):\n        for u in range(n):\n            v = next_n[k_log - 1][u]\n            m = next_m[k_log - 1][u]\n            s = next_s[k_log - 1][u]\n            next_n[k_log][u] = next_n[k_log - 1][v]\n            next_m[k_log][u] = min(next_m[k_log - 1][v], m)\n            next_s[k_log][u] = next_s[k_log - 1][v] + s\n    result = []\n    for u in range(n):\n        (s, m) = (-1, float('inf'))\n        v = u\n        cur = 1 << max_log\n        i = max_log\n        while cur > 0:\n            if cur & k:\n                m = min(m, next_m[i][v])\n                s = s + next_s[i][v]\n                v = next_n[i][v]\n            cur >>= 1\n            i -= 1\n        result.append((s, m))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "s, m = 0, float('inf')",
      "mutated_line": "(s, m) = (1, float('inf'))",
      "code": "def calculate_path_weights(n, k, f, w):\n    max_log = 35\n    next_n = [[-1] * n for _ in range(max_log)]\n    next_m = [[float('inf')] * n for _ in range(max_log)]\n    next_s = [[0] * n for _ in range(max_log)]\n    for u in range(n):\n        v = f[u]\n        next_n[0][u] = v\n        next_m[0][u] = w[u]\n        next_s[0][u] = w[u]\n    for k_log in range(1, max_log):\n        for u in range(n):\n            v = next_n[k_log - 1][u]\n            m = next_m[k_log - 1][u]\n            s = next_s[k_log - 1][u]\n            next_n[k_log][u] = next_n[k_log - 1][v]\n            next_m[k_log][u] = min(next_m[k_log - 1][v], m)\n            next_s[k_log][u] = next_s[k_log - 1][v] + s\n    result = []\n    for u in range(n):\n        (s, m) = (1, float('inf'))\n        v = u\n        cur = 1 << max_log\n        i = max_log\n        while cur > 0:\n            if cur & k:\n                m = min(m, next_m[i][v])\n                s = s + next_s[i][v]\n                v = next_n[i][v]\n            cur >>= 1\n            i -= 1\n        result.append((s, m))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "cur = 1 << max_log",
      "mutated_line": "cur = 2 << max_log",
      "code": "def calculate_path_weights(n, k, f, w):\n    max_log = 35\n    next_n = [[-1] * n for _ in range(max_log)]\n    next_m = [[float('inf')] * n for _ in range(max_log)]\n    next_s = [[0] * n for _ in range(max_log)]\n    for u in range(n):\n        v = f[u]\n        next_n[0][u] = v\n        next_m[0][u] = w[u]\n        next_s[0][u] = w[u]\n    for k_log in range(1, max_log):\n        for u in range(n):\n            v = next_n[k_log - 1][u]\n            m = next_m[k_log - 1][u]\n            s = next_s[k_log - 1][u]\n            next_n[k_log][u] = next_n[k_log - 1][v]\n            next_m[k_log][u] = min(next_m[k_log - 1][v], m)\n            next_s[k_log][u] = next_s[k_log - 1][v] + s\n    result = []\n    for u in range(n):\n        (s, m) = (0, float('inf'))\n        v = u\n        cur = 2 << max_log\n        i = max_log\n        while cur > 0:\n            if cur & k:\n                m = min(m, next_m[i][v])\n                s = s + next_s[i][v]\n                v = next_n[i][v]\n            cur >>= 1\n            i -= 1\n        result.append((s, m))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "cur = 1 << max_log",
      "mutated_line": "cur = 0 << max_log",
      "code": "def calculate_path_weights(n, k, f, w):\n    max_log = 35\n    next_n = [[-1] * n for _ in range(max_log)]\n    next_m = [[float('inf')] * n for _ in range(max_log)]\n    next_s = [[0] * n for _ in range(max_log)]\n    for u in range(n):\n        v = f[u]\n        next_n[0][u] = v\n        next_m[0][u] = w[u]\n        next_s[0][u] = w[u]\n    for k_log in range(1, max_log):\n        for u in range(n):\n            v = next_n[k_log - 1][u]\n            m = next_m[k_log - 1][u]\n            s = next_s[k_log - 1][u]\n            next_n[k_log][u] = next_n[k_log - 1][v]\n            next_m[k_log][u] = min(next_m[k_log - 1][v], m)\n            next_s[k_log][u] = next_s[k_log - 1][v] + s\n    result = []\n    for u in range(n):\n        (s, m) = (0, float('inf'))\n        v = u\n        cur = 0 << max_log\n        i = max_log\n        while cur > 0:\n            if cur & k:\n                m = min(m, next_m[i][v])\n                s = s + next_s[i][v]\n                v = next_n[i][v]\n            cur >>= 1\n            i -= 1\n        result.append((s, m))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "cur = 1 << max_log",
      "mutated_line": "cur = 0 << max_log",
      "code": "def calculate_path_weights(n, k, f, w):\n    max_log = 35\n    next_n = [[-1] * n for _ in range(max_log)]\n    next_m = [[float('inf')] * n for _ in range(max_log)]\n    next_s = [[0] * n for _ in range(max_log)]\n    for u in range(n):\n        v = f[u]\n        next_n[0][u] = v\n        next_m[0][u] = w[u]\n        next_s[0][u] = w[u]\n    for k_log in range(1, max_log):\n        for u in range(n):\n            v = next_n[k_log - 1][u]\n            m = next_m[k_log - 1][u]\n            s = next_s[k_log - 1][u]\n            next_n[k_log][u] = next_n[k_log - 1][v]\n            next_m[k_log][u] = min(next_m[k_log - 1][v], m)\n            next_s[k_log][u] = next_s[k_log - 1][v] + s\n    result = []\n    for u in range(n):\n        (s, m) = (0, float('inf'))\n        v = u\n        cur = 0 << max_log\n        i = max_log\n        while cur > 0:\n            if cur & k:\n                m = min(m, next_m[i][v])\n                s = s + next_s[i][v]\n                v = next_n[i][v]\n            cur >>= 1\n            i -= 1\n        result.append((s, m))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "cur = 1 << max_log",
      "mutated_line": "cur = -1 << max_log",
      "code": "def calculate_path_weights(n, k, f, w):\n    max_log = 35\n    next_n = [[-1] * n for _ in range(max_log)]\n    next_m = [[float('inf')] * n for _ in range(max_log)]\n    next_s = [[0] * n for _ in range(max_log)]\n    for u in range(n):\n        v = f[u]\n        next_n[0][u] = v\n        next_m[0][u] = w[u]\n        next_s[0][u] = w[u]\n    for k_log in range(1, max_log):\n        for u in range(n):\n            v = next_n[k_log - 1][u]\n            m = next_m[k_log - 1][u]\n            s = next_s[k_log - 1][u]\n            next_n[k_log][u] = next_n[k_log - 1][v]\n            next_m[k_log][u] = min(next_m[k_log - 1][v], m)\n            next_s[k_log][u] = next_s[k_log - 1][v] + s\n    result = []\n    for u in range(n):\n        (s, m) = (0, float('inf'))\n        v = u\n        cur = -1 << max_log\n        i = max_log\n        while cur > 0:\n            if cur & k:\n                m = min(m, next_m[i][v])\n                s = s + next_s[i][v]\n                v = next_n[i][v]\n            cur >>= 1\n            i -= 1\n        result.append((s, m))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "while cur > 0:",
      "mutated_line": "while cur > 1:",
      "code": "def calculate_path_weights(n, k, f, w):\n    max_log = 35\n    next_n = [[-1] * n for _ in range(max_log)]\n    next_m = [[float('inf')] * n for _ in range(max_log)]\n    next_s = [[0] * n for _ in range(max_log)]\n    for u in range(n):\n        v = f[u]\n        next_n[0][u] = v\n        next_m[0][u] = w[u]\n        next_s[0][u] = w[u]\n    for k_log in range(1, max_log):\n        for u in range(n):\n            v = next_n[k_log - 1][u]\n            m = next_m[k_log - 1][u]\n            s = next_s[k_log - 1][u]\n            next_n[k_log][u] = next_n[k_log - 1][v]\n            next_m[k_log][u] = min(next_m[k_log - 1][v], m)\n            next_s[k_log][u] = next_s[k_log - 1][v] + s\n    result = []\n    for u in range(n):\n        (s, m) = (0, float('inf'))\n        v = u\n        cur = 1 << max_log\n        i = max_log\n        while cur > 1:\n            if cur & k:\n                m = min(m, next_m[i][v])\n                s = s + next_s[i][v]\n                v = next_n[i][v]\n            cur >>= 1\n            i -= 1\n        result.append((s, m))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "while cur > 0:",
      "mutated_line": "while cur > -1:",
      "code": "def calculate_path_weights(n, k, f, w):\n    max_log = 35\n    next_n = [[-1] * n for _ in range(max_log)]\n    next_m = [[float('inf')] * n for _ in range(max_log)]\n    next_s = [[0] * n for _ in range(max_log)]\n    for u in range(n):\n        v = f[u]\n        next_n[0][u] = v\n        next_m[0][u] = w[u]\n        next_s[0][u] = w[u]\n    for k_log in range(1, max_log):\n        for u in range(n):\n            v = next_n[k_log - 1][u]\n            m = next_m[k_log - 1][u]\n            s = next_s[k_log - 1][u]\n            next_n[k_log][u] = next_n[k_log - 1][v]\n            next_m[k_log][u] = min(next_m[k_log - 1][v], m)\n            next_s[k_log][u] = next_s[k_log - 1][v] + s\n    result = []\n    for u in range(n):\n        (s, m) = (0, float('inf'))\n        v = u\n        cur = 1 << max_log\n        i = max_log\n        while cur > -1:\n            if cur & k:\n                m = min(m, next_m[i][v])\n                s = s + next_s[i][v]\n                v = next_n[i][v]\n            cur >>= 1\n            i -= 1\n        result.append((s, m))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "while cur > 0:",
      "mutated_line": "while cur > 1:",
      "code": "def calculate_path_weights(n, k, f, w):\n    max_log = 35\n    next_n = [[-1] * n for _ in range(max_log)]\n    next_m = [[float('inf')] * n for _ in range(max_log)]\n    next_s = [[0] * n for _ in range(max_log)]\n    for u in range(n):\n        v = f[u]\n        next_n[0][u] = v\n        next_m[0][u] = w[u]\n        next_s[0][u] = w[u]\n    for k_log in range(1, max_log):\n        for u in range(n):\n            v = next_n[k_log - 1][u]\n            m = next_m[k_log - 1][u]\n            s = next_s[k_log - 1][u]\n            next_n[k_log][u] = next_n[k_log - 1][v]\n            next_m[k_log][u] = min(next_m[k_log - 1][v], m)\n            next_s[k_log][u] = next_s[k_log - 1][v] + s\n    result = []\n    for u in range(n):\n        (s, m) = (0, float('inf'))\n        v = u\n        cur = 1 << max_log\n        i = max_log\n        while cur > 1:\n            if cur & k:\n                m = min(m, next_m[i][v])\n                s = s + next_s[i][v]\n                v = next_n[i][v]\n            cur >>= 1\n            i -= 1\n        result.append((s, m))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "if cur & k:",
      "mutated_line": "if cur | k:",
      "code": "def calculate_path_weights(n, k, f, w):\n    max_log = 35\n    next_n = [[-1] * n for _ in range(max_log)]\n    next_m = [[float('inf')] * n for _ in range(max_log)]\n    next_s = [[0] * n for _ in range(max_log)]\n    for u in range(n):\n        v = f[u]\n        next_n[0][u] = v\n        next_m[0][u] = w[u]\n        next_s[0][u] = w[u]\n    for k_log in range(1, max_log):\n        for u in range(n):\n            v = next_n[k_log - 1][u]\n            m = next_m[k_log - 1][u]\n            s = next_s[k_log - 1][u]\n            next_n[k_log][u] = next_n[k_log - 1][v]\n            next_m[k_log][u] = min(next_m[k_log - 1][v], m)\n            next_s[k_log][u] = next_s[k_log - 1][v] + s\n    result = []\n    for u in range(n):\n        (s, m) = (0, float('inf'))\n        v = u\n        cur = 1 << max_log\n        i = max_log\n        while cur > 0:\n            if cur | k:\n                m = min(m, next_m[i][v])\n                s = s + next_s[i][v]\n                v = next_n[i][v]\n            cur >>= 1\n            i -= 1\n        result.append((s, m))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "cur >>= 1",
      "mutated_line": "cur >>= 2",
      "code": "def calculate_path_weights(n, k, f, w):\n    max_log = 35\n    next_n = [[-1] * n for _ in range(max_log)]\n    next_m = [[float('inf')] * n for _ in range(max_log)]\n    next_s = [[0] * n for _ in range(max_log)]\n    for u in range(n):\n        v = f[u]\n        next_n[0][u] = v\n        next_m[0][u] = w[u]\n        next_s[0][u] = w[u]\n    for k_log in range(1, max_log):\n        for u in range(n):\n            v = next_n[k_log - 1][u]\n            m = next_m[k_log - 1][u]\n            s = next_s[k_log - 1][u]\n            next_n[k_log][u] = next_n[k_log - 1][v]\n            next_m[k_log][u] = min(next_m[k_log - 1][v], m)\n            next_s[k_log][u] = next_s[k_log - 1][v] + s\n    result = []\n    for u in range(n):\n        (s, m) = (0, float('inf'))\n        v = u\n        cur = 1 << max_log\n        i = max_log\n        while cur > 0:\n            if cur & k:\n                m = min(m, next_m[i][v])\n                s = s + next_s[i][v]\n                v = next_n[i][v]\n            cur >>= 2\n            i -= 1\n        result.append((s, m))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "cur >>= 1",
      "mutated_line": "cur >>= 0",
      "code": "def calculate_path_weights(n, k, f, w):\n    max_log = 35\n    next_n = [[-1] * n for _ in range(max_log)]\n    next_m = [[float('inf')] * n for _ in range(max_log)]\n    next_s = [[0] * n for _ in range(max_log)]\n    for u in range(n):\n        v = f[u]\n        next_n[0][u] = v\n        next_m[0][u] = w[u]\n        next_s[0][u] = w[u]\n    for k_log in range(1, max_log):\n        for u in range(n):\n            v = next_n[k_log - 1][u]\n            m = next_m[k_log - 1][u]\n            s = next_s[k_log - 1][u]\n            next_n[k_log][u] = next_n[k_log - 1][v]\n            next_m[k_log][u] = min(next_m[k_log - 1][v], m)\n            next_s[k_log][u] = next_s[k_log - 1][v] + s\n    result = []\n    for u in range(n):\n        (s, m) = (0, float('inf'))\n        v = u\n        cur = 1 << max_log\n        i = max_log\n        while cur > 0:\n            if cur & k:\n                m = min(m, next_m[i][v])\n                s = s + next_s[i][v]\n                v = next_n[i][v]\n            cur >>= 0\n            i -= 1\n        result.append((s, m))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "cur >>= 1",
      "mutated_line": "cur >>= 0",
      "code": "def calculate_path_weights(n, k, f, w):\n    max_log = 35\n    next_n = [[-1] * n for _ in range(max_log)]\n    next_m = [[float('inf')] * n for _ in range(max_log)]\n    next_s = [[0] * n for _ in range(max_log)]\n    for u in range(n):\n        v = f[u]\n        next_n[0][u] = v\n        next_m[0][u] = w[u]\n        next_s[0][u] = w[u]\n    for k_log in range(1, max_log):\n        for u in range(n):\n            v = next_n[k_log - 1][u]\n            m = next_m[k_log - 1][u]\n            s = next_s[k_log - 1][u]\n            next_n[k_log][u] = next_n[k_log - 1][v]\n            next_m[k_log][u] = min(next_m[k_log - 1][v], m)\n            next_s[k_log][u] = next_s[k_log - 1][v] + s\n    result = []\n    for u in range(n):\n        (s, m) = (0, float('inf'))\n        v = u\n        cur = 1 << max_log\n        i = max_log\n        while cur > 0:\n            if cur & k:\n                m = min(m, next_m[i][v])\n                s = s + next_s[i][v]\n                v = next_n[i][v]\n            cur >>= 0\n            i -= 1\n        result.append((s, m))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "cur >>= 1",
      "mutated_line": "cur >>= -1",
      "code": "def calculate_path_weights(n, k, f, w):\n    max_log = 35\n    next_n = [[-1] * n for _ in range(max_log)]\n    next_m = [[float('inf')] * n for _ in range(max_log)]\n    next_s = [[0] * n for _ in range(max_log)]\n    for u in range(n):\n        v = f[u]\n        next_n[0][u] = v\n        next_m[0][u] = w[u]\n        next_s[0][u] = w[u]\n    for k_log in range(1, max_log):\n        for u in range(n):\n            v = next_n[k_log - 1][u]\n            m = next_m[k_log - 1][u]\n            s = next_s[k_log - 1][u]\n            next_n[k_log][u] = next_n[k_log - 1][v]\n            next_m[k_log][u] = min(next_m[k_log - 1][v], m)\n            next_s[k_log][u] = next_s[k_log - 1][v] + s\n    result = []\n    for u in range(n):\n        (s, m) = (0, float('inf'))\n        v = u\n        cur = 1 << max_log\n        i = max_log\n        while cur > 0:\n            if cur & k:\n                m = min(m, next_m[i][v])\n                s = s + next_s[i][v]\n                v = next_n[i][v]\n            cur >>= -1\n            i -= 1\n        result.append((s, m))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "i -= 1",
      "mutated_line": "i -= 2",
      "code": "def calculate_path_weights(n, k, f, w):\n    max_log = 35\n    next_n = [[-1] * n for _ in range(max_log)]\n    next_m = [[float('inf')] * n for _ in range(max_log)]\n    next_s = [[0] * n for _ in range(max_log)]\n    for u in range(n):\n        v = f[u]\n        next_n[0][u] = v\n        next_m[0][u] = w[u]\n        next_s[0][u] = w[u]\n    for k_log in range(1, max_log):\n        for u in range(n):\n            v = next_n[k_log - 1][u]\n            m = next_m[k_log - 1][u]\n            s = next_s[k_log - 1][u]\n            next_n[k_log][u] = next_n[k_log - 1][v]\n            next_m[k_log][u] = min(next_m[k_log - 1][v], m)\n            next_s[k_log][u] = next_s[k_log - 1][v] + s\n    result = []\n    for u in range(n):\n        (s, m) = (0, float('inf'))\n        v = u\n        cur = 1 << max_log\n        i = max_log\n        while cur > 0:\n            if cur & k:\n                m = min(m, next_m[i][v])\n                s = s + next_s[i][v]\n                v = next_n[i][v]\n            cur >>= 1\n            i -= 2\n        result.append((s, m))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "i -= 1",
      "mutated_line": "i -= 0",
      "code": "def calculate_path_weights(n, k, f, w):\n    max_log = 35\n    next_n = [[-1] * n for _ in range(max_log)]\n    next_m = [[float('inf')] * n for _ in range(max_log)]\n    next_s = [[0] * n for _ in range(max_log)]\n    for u in range(n):\n        v = f[u]\n        next_n[0][u] = v\n        next_m[0][u] = w[u]\n        next_s[0][u] = w[u]\n    for k_log in range(1, max_log):\n        for u in range(n):\n            v = next_n[k_log - 1][u]\n            m = next_m[k_log - 1][u]\n            s = next_s[k_log - 1][u]\n            next_n[k_log][u] = next_n[k_log - 1][v]\n            next_m[k_log][u] = min(next_m[k_log - 1][v], m)\n            next_s[k_log][u] = next_s[k_log - 1][v] + s\n    result = []\n    for u in range(n):\n        (s, m) = (0, float('inf'))\n        v = u\n        cur = 1 << max_log\n        i = max_log\n        while cur > 0:\n            if cur & k:\n                m = min(m, next_m[i][v])\n                s = s + next_s[i][v]\n                v = next_n[i][v]\n            cur >>= 1\n            i -= 0\n        result.append((s, m))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "i -= 1",
      "mutated_line": "i -= 0",
      "code": "def calculate_path_weights(n, k, f, w):\n    max_log = 35\n    next_n = [[-1] * n for _ in range(max_log)]\n    next_m = [[float('inf')] * n for _ in range(max_log)]\n    next_s = [[0] * n for _ in range(max_log)]\n    for u in range(n):\n        v = f[u]\n        next_n[0][u] = v\n        next_m[0][u] = w[u]\n        next_s[0][u] = w[u]\n    for k_log in range(1, max_log):\n        for u in range(n):\n            v = next_n[k_log - 1][u]\n            m = next_m[k_log - 1][u]\n            s = next_s[k_log - 1][u]\n            next_n[k_log][u] = next_n[k_log - 1][v]\n            next_m[k_log][u] = min(next_m[k_log - 1][v], m)\n            next_s[k_log][u] = next_s[k_log - 1][v] + s\n    result = []\n    for u in range(n):\n        (s, m) = (0, float('inf'))\n        v = u\n        cur = 1 << max_log\n        i = max_log\n        while cur > 0:\n            if cur & k:\n                m = min(m, next_m[i][v])\n                s = s + next_s[i][v]\n                v = next_n[i][v]\n            cur >>= 1\n            i -= 0\n        result.append((s, m))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "i -= 1",
      "mutated_line": "i -= -1",
      "code": "def calculate_path_weights(n, k, f, w):\n    max_log = 35\n    next_n = [[-1] * n for _ in range(max_log)]\n    next_m = [[float('inf')] * n for _ in range(max_log)]\n    next_s = [[0] * n for _ in range(max_log)]\n    for u in range(n):\n        v = f[u]\n        next_n[0][u] = v\n        next_m[0][u] = w[u]\n        next_s[0][u] = w[u]\n    for k_log in range(1, max_log):\n        for u in range(n):\n            v = next_n[k_log - 1][u]\n            m = next_m[k_log - 1][u]\n            s = next_s[k_log - 1][u]\n            next_n[k_log][u] = next_n[k_log - 1][v]\n            next_m[k_log][u] = min(next_m[k_log - 1][v], m)\n            next_s[k_log][u] = next_s[k_log - 1][v] + s\n    result = []\n    for u in range(n):\n        (s, m) = (0, float('inf'))\n        v = u\n        cur = 1 << max_log\n        i = max_log\n        while cur > 0:\n            if cur & k:\n                m = min(m, next_m[i][v])\n                s = s + next_s[i][v]\n                v = next_n[i][v]\n            cur >>= 1\n            i -= -1\n        result.append((s, m))\n    return result"
    },
    {
      "operator": "UOI",
      "lineno": 3,
      "original_line": "next_n = [[-1] * n for _ in range(max_log)]",
      "mutated_line": "next_n = [[+1] * n for _ in range(max_log)]",
      "code": "def calculate_path_weights(n, k, f, w):\n    max_log = 35\n    next_n = [[+1] * n for _ in range(max_log)]\n    next_m = [[float('inf')] * n for _ in range(max_log)]\n    next_s = [[0] * n for _ in range(max_log)]\n    for u in range(n):\n        v = f[u]\n        next_n[0][u] = v\n        next_m[0][u] = w[u]\n        next_s[0][u] = w[u]\n    for k_log in range(1, max_log):\n        for u in range(n):\n            v = next_n[k_log - 1][u]\n            m = next_m[k_log - 1][u]\n            s = next_s[k_log - 1][u]\n            next_n[k_log][u] = next_n[k_log - 1][v]\n            next_m[k_log][u] = min(next_m[k_log - 1][v], m)\n            next_s[k_log][u] = next_s[k_log - 1][v] + s\n    result = []\n    for u in range(n):\n        (s, m) = (0, float('inf'))\n        v = u\n        cur = 1 << max_log\n        i = max_log\n        while cur > 0:\n            if cur & k:\n                m = min(m, next_m[i][v])\n                s = s + next_s[i][v]\n                v = next_n[i][v]\n            cur >>= 1\n            i -= 1\n        result.append((s, m))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "next_s = [[0] * n for _ in range(max_log)]",
      "mutated_line": "next_s = [[1] * n for _ in range(max_log)]",
      "code": "def calculate_path_weights(n, k, f, w):\n    max_log = 35\n    next_n = [[-1] * n for _ in range(max_log)]\n    next_m = [[float('inf')] * n for _ in range(max_log)]\n    next_s = [[1] * n for _ in range(max_log)]\n    for u in range(n):\n        v = f[u]\n        next_n[0][u] = v\n        next_m[0][u] = w[u]\n        next_s[0][u] = w[u]\n    for k_log in range(1, max_log):\n        for u in range(n):\n            v = next_n[k_log - 1][u]\n            m = next_m[k_log - 1][u]\n            s = next_s[k_log - 1][u]\n            next_n[k_log][u] = next_n[k_log - 1][v]\n            next_m[k_log][u] = min(next_m[k_log - 1][v], m)\n            next_s[k_log][u] = next_s[k_log - 1][v] + s\n    result = []\n    for u in range(n):\n        (s, m) = (0, float('inf'))\n        v = u\n        cur = 1 << max_log\n        i = max_log\n        while cur > 0:\n            if cur & k:\n                m = min(m, next_m[i][v])\n                s = s + next_s[i][v]\n                v = next_n[i][v]\n            cur >>= 1\n            i -= 1\n        result.append((s, m))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "next_s = [[0] * n for _ in range(max_log)]",
      "mutated_line": "next_s = [[-1] * n for _ in range(max_log)]",
      "code": "def calculate_path_weights(n, k, f, w):\n    max_log = 35\n    next_n = [[-1] * n for _ in range(max_log)]\n    next_m = [[float('inf')] * n for _ in range(max_log)]\n    next_s = [[-1] * n for _ in range(max_log)]\n    for u in range(n):\n        v = f[u]\n        next_n[0][u] = v\n        next_m[0][u] = w[u]\n        next_s[0][u] = w[u]\n    for k_log in range(1, max_log):\n        for u in range(n):\n            v = next_n[k_log - 1][u]\n            m = next_m[k_log - 1][u]\n            s = next_s[k_log - 1][u]\n            next_n[k_log][u] = next_n[k_log - 1][v]\n            next_m[k_log][u] = min(next_m[k_log - 1][v], m)\n            next_s[k_log][u] = next_s[k_log - 1][v] + s\n    result = []\n    for u in range(n):\n        (s, m) = (0, float('inf'))\n        v = u\n        cur = 1 << max_log\n        i = max_log\n        while cur > 0:\n            if cur & k:\n                m = min(m, next_m[i][v])\n                s = s + next_s[i][v]\n                v = next_n[i][v]\n            cur >>= 1\n            i -= 1\n        result.append((s, m))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "next_s = [[0] * n for _ in range(max_log)]",
      "mutated_line": "next_s = [[1] * n for _ in range(max_log)]",
      "code": "def calculate_path_weights(n, k, f, w):\n    max_log = 35\n    next_n = [[-1] * n for _ in range(max_log)]\n    next_m = [[float('inf')] * n for _ in range(max_log)]\n    next_s = [[1] * n for _ in range(max_log)]\n    for u in range(n):\n        v = f[u]\n        next_n[0][u] = v\n        next_m[0][u] = w[u]\n        next_s[0][u] = w[u]\n    for k_log in range(1, max_log):\n        for u in range(n):\n            v = next_n[k_log - 1][u]\n            m = next_m[k_log - 1][u]\n            s = next_s[k_log - 1][u]\n            next_n[k_log][u] = next_n[k_log - 1][v]\n            next_m[k_log][u] = min(next_m[k_log - 1][v], m)\n            next_s[k_log][u] = next_s[k_log - 1][v] + s\n    result = []\n    for u in range(n):\n        (s, m) = (0, float('inf'))\n        v = u\n        cur = 1 << max_log\n        i = max_log\n        while cur > 0:\n            if cur & k:\n                m = min(m, next_m[i][v])\n                s = s + next_s[i][v]\n                v = next_n[i][v]\n            cur >>= 1\n            i -= 1\n        result.append((s, m))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "next_n[0][u] = v",
      "mutated_line": "next_n[1][u] = v",
      "code": "def calculate_path_weights(n, k, f, w):\n    max_log = 35\n    next_n = [[-1] * n for _ in range(max_log)]\n    next_m = [[float('inf')] * n for _ in range(max_log)]\n    next_s = [[0] * n for _ in range(max_log)]\n    for u in range(n):\n        v = f[u]\n        next_n[1][u] = v\n        next_m[0][u] = w[u]\n        next_s[0][u] = w[u]\n    for k_log in range(1, max_log):\n        for u in range(n):\n            v = next_n[k_log - 1][u]\n            m = next_m[k_log - 1][u]\n            s = next_s[k_log - 1][u]\n            next_n[k_log][u] = next_n[k_log - 1][v]\n            next_m[k_log][u] = min(next_m[k_log - 1][v], m)\n            next_s[k_log][u] = next_s[k_log - 1][v] + s\n    result = []\n    for u in range(n):\n        (s, m) = (0, float('inf'))\n        v = u\n        cur = 1 << max_log\n        i = max_log\n        while cur > 0:\n            if cur & k:\n                m = min(m, next_m[i][v])\n                s = s + next_s[i][v]\n                v = next_n[i][v]\n            cur >>= 1\n            i -= 1\n        result.append((s, m))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "next_n[0][u] = v",
      "mutated_line": "next_n[-1][u] = v",
      "code": "def calculate_path_weights(n, k, f, w):\n    max_log = 35\n    next_n = [[-1] * n for _ in range(max_log)]\n    next_m = [[float('inf')] * n for _ in range(max_log)]\n    next_s = [[0] * n for _ in range(max_log)]\n    for u in range(n):\n        v = f[u]\n        next_n[-1][u] = v\n        next_m[0][u] = w[u]\n        next_s[0][u] = w[u]\n    for k_log in range(1, max_log):\n        for u in range(n):\n            v = next_n[k_log - 1][u]\n            m = next_m[k_log - 1][u]\n            s = next_s[k_log - 1][u]\n            next_n[k_log][u] = next_n[k_log - 1][v]\n            next_m[k_log][u] = min(next_m[k_log - 1][v], m)\n            next_s[k_log][u] = next_s[k_log - 1][v] + s\n    result = []\n    for u in range(n):\n        (s, m) = (0, float('inf'))\n        v = u\n        cur = 1 << max_log\n        i = max_log\n        while cur > 0:\n            if cur & k:\n                m = min(m, next_m[i][v])\n                s = s + next_s[i][v]\n                v = next_n[i][v]\n            cur >>= 1\n            i -= 1\n        result.append((s, m))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "next_n[0][u] = v",
      "mutated_line": "next_n[1][u] = v",
      "code": "def calculate_path_weights(n, k, f, w):\n    max_log = 35\n    next_n = [[-1] * n for _ in range(max_log)]\n    next_m = [[float('inf')] * n for _ in range(max_log)]\n    next_s = [[0] * n for _ in range(max_log)]\n    for u in range(n):\n        v = f[u]\n        next_n[1][u] = v\n        next_m[0][u] = w[u]\n        next_s[0][u] = w[u]\n    for k_log in range(1, max_log):\n        for u in range(n):\n            v = next_n[k_log - 1][u]\n            m = next_m[k_log - 1][u]\n            s = next_s[k_log - 1][u]\n            next_n[k_log][u] = next_n[k_log - 1][v]\n            next_m[k_log][u] = min(next_m[k_log - 1][v], m)\n            next_s[k_log][u] = next_s[k_log - 1][v] + s\n    result = []\n    for u in range(n):\n        (s, m) = (0, float('inf'))\n        v = u\n        cur = 1 << max_log\n        i = max_log\n        while cur > 0:\n            if cur & k:\n                m = min(m, next_m[i][v])\n                s = s + next_s[i][v]\n                v = next_n[i][v]\n            cur >>= 1\n            i -= 1\n        result.append((s, m))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "next_m[0][u] = w[u]",
      "mutated_line": "next_m[1][u] = w[u]",
      "code": "def calculate_path_weights(n, k, f, w):\n    max_log = 35\n    next_n = [[-1] * n for _ in range(max_log)]\n    next_m = [[float('inf')] * n for _ in range(max_log)]\n    next_s = [[0] * n for _ in range(max_log)]\n    for u in range(n):\n        v = f[u]\n        next_n[0][u] = v\n        next_m[1][u] = w[u]\n        next_s[0][u] = w[u]\n    for k_log in range(1, max_log):\n        for u in range(n):\n            v = next_n[k_log - 1][u]\n            m = next_m[k_log - 1][u]\n            s = next_s[k_log - 1][u]\n            next_n[k_log][u] = next_n[k_log - 1][v]\n            next_m[k_log][u] = min(next_m[k_log - 1][v], m)\n            next_s[k_log][u] = next_s[k_log - 1][v] + s\n    result = []\n    for u in range(n):\n        (s, m) = (0, float('inf'))\n        v = u\n        cur = 1 << max_log\n        i = max_log\n        while cur > 0:\n            if cur & k:\n                m = min(m, next_m[i][v])\n                s = s + next_s[i][v]\n                v = next_n[i][v]\n            cur >>= 1\n            i -= 1\n        result.append((s, m))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "next_m[0][u] = w[u]",
      "mutated_line": "next_m[-1][u] = w[u]",
      "code": "def calculate_path_weights(n, k, f, w):\n    max_log = 35\n    next_n = [[-1] * n for _ in range(max_log)]\n    next_m = [[float('inf')] * n for _ in range(max_log)]\n    next_s = [[0] * n for _ in range(max_log)]\n    for u in range(n):\n        v = f[u]\n        next_n[0][u] = v\n        next_m[-1][u] = w[u]\n        next_s[0][u] = w[u]\n    for k_log in range(1, max_log):\n        for u in range(n):\n            v = next_n[k_log - 1][u]\n            m = next_m[k_log - 1][u]\n            s = next_s[k_log - 1][u]\n            next_n[k_log][u] = next_n[k_log - 1][v]\n            next_m[k_log][u] = min(next_m[k_log - 1][v], m)\n            next_s[k_log][u] = next_s[k_log - 1][v] + s\n    result = []\n    for u in range(n):\n        (s, m) = (0, float('inf'))\n        v = u\n        cur = 1 << max_log\n        i = max_log\n        while cur > 0:\n            if cur & k:\n                m = min(m, next_m[i][v])\n                s = s + next_s[i][v]\n                v = next_n[i][v]\n            cur >>= 1\n            i -= 1\n        result.append((s, m))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "next_m[0][u] = w[u]",
      "mutated_line": "next_m[1][u] = w[u]",
      "code": "def calculate_path_weights(n, k, f, w):\n    max_log = 35\n    next_n = [[-1] * n for _ in range(max_log)]\n    next_m = [[float('inf')] * n for _ in range(max_log)]\n    next_s = [[0] * n for _ in range(max_log)]\n    for u in range(n):\n        v = f[u]\n        next_n[0][u] = v\n        next_m[1][u] = w[u]\n        next_s[0][u] = w[u]\n    for k_log in range(1, max_log):\n        for u in range(n):\n            v = next_n[k_log - 1][u]\n            m = next_m[k_log - 1][u]\n            s = next_s[k_log - 1][u]\n            next_n[k_log][u] = next_n[k_log - 1][v]\n            next_m[k_log][u] = min(next_m[k_log - 1][v], m)\n            next_s[k_log][u] = next_s[k_log - 1][v] + s\n    result = []\n    for u in range(n):\n        (s, m) = (0, float('inf'))\n        v = u\n        cur = 1 << max_log\n        i = max_log\n        while cur > 0:\n            if cur & k:\n                m = min(m, next_m[i][v])\n                s = s + next_s[i][v]\n                v = next_n[i][v]\n            cur >>= 1\n            i -= 1\n        result.append((s, m))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "next_s[0][u] = w[u]",
      "mutated_line": "next_s[1][u] = w[u]",
      "code": "def calculate_path_weights(n, k, f, w):\n    max_log = 35\n    next_n = [[-1] * n for _ in range(max_log)]\n    next_m = [[float('inf')] * n for _ in range(max_log)]\n    next_s = [[0] * n for _ in range(max_log)]\n    for u in range(n):\n        v = f[u]\n        next_n[0][u] = v\n        next_m[0][u] = w[u]\n        next_s[1][u] = w[u]\n    for k_log in range(1, max_log):\n        for u in range(n):\n            v = next_n[k_log - 1][u]\n            m = next_m[k_log - 1][u]\n            s = next_s[k_log - 1][u]\n            next_n[k_log][u] = next_n[k_log - 1][v]\n            next_m[k_log][u] = min(next_m[k_log - 1][v], m)\n            next_s[k_log][u] = next_s[k_log - 1][v] + s\n    result = []\n    for u in range(n):\n        (s, m) = (0, float('inf'))\n        v = u\n        cur = 1 << max_log\n        i = max_log\n        while cur > 0:\n            if cur & k:\n                m = min(m, next_m[i][v])\n                s = s + next_s[i][v]\n                v = next_n[i][v]\n            cur >>= 1\n            i -= 1\n        result.append((s, m))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "next_s[0][u] = w[u]",
      "mutated_line": "next_s[-1][u] = w[u]",
      "code": "def calculate_path_weights(n, k, f, w):\n    max_log = 35\n    next_n = [[-1] * n for _ in range(max_log)]\n    next_m = [[float('inf')] * n for _ in range(max_log)]\n    next_s = [[0] * n for _ in range(max_log)]\n    for u in range(n):\n        v = f[u]\n        next_n[0][u] = v\n        next_m[0][u] = w[u]\n        next_s[-1][u] = w[u]\n    for k_log in range(1, max_log):\n        for u in range(n):\n            v = next_n[k_log - 1][u]\n            m = next_m[k_log - 1][u]\n            s = next_s[k_log - 1][u]\n            next_n[k_log][u] = next_n[k_log - 1][v]\n            next_m[k_log][u] = min(next_m[k_log - 1][v], m)\n            next_s[k_log][u] = next_s[k_log - 1][v] + s\n    result = []\n    for u in range(n):\n        (s, m) = (0, float('inf'))\n        v = u\n        cur = 1 << max_log\n        i = max_log\n        while cur > 0:\n            if cur & k:\n                m = min(m, next_m[i][v])\n                s = s + next_s[i][v]\n                v = next_n[i][v]\n            cur >>= 1\n            i -= 1\n        result.append((s, m))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "next_s[0][u] = w[u]",
      "mutated_line": "next_s[1][u] = w[u]",
      "code": "def calculate_path_weights(n, k, f, w):\n    max_log = 35\n    next_n = [[-1] * n for _ in range(max_log)]\n    next_m = [[float('inf')] * n for _ in range(max_log)]\n    next_s = [[0] * n for _ in range(max_log)]\n    for u in range(n):\n        v = f[u]\n        next_n[0][u] = v\n        next_m[0][u] = w[u]\n        next_s[1][u] = w[u]\n    for k_log in range(1, max_log):\n        for u in range(n):\n            v = next_n[k_log - 1][u]\n            m = next_m[k_log - 1][u]\n            s = next_s[k_log - 1][u]\n            next_n[k_log][u] = next_n[k_log - 1][v]\n            next_m[k_log][u] = min(next_m[k_log - 1][v], m)\n            next_s[k_log][u] = next_s[k_log - 1][v] + s\n    result = []\n    for u in range(n):\n        (s, m) = (0, float('inf'))\n        v = u\n        cur = 1 << max_log\n        i = max_log\n        while cur > 0:\n            if cur & k:\n                m = min(m, next_m[i][v])\n                s = s + next_s[i][v]\n                v = next_n[i][v]\n            cur >>= 1\n            i -= 1\n        result.append((s, m))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "s, m = 0, float('inf')",
      "mutated_line": "(s, m) = (0, float(''))",
      "code": "def calculate_path_weights(n, k, f, w):\n    max_log = 35\n    next_n = [[-1] * n for _ in range(max_log)]\n    next_m = [[float('inf')] * n for _ in range(max_log)]\n    next_s = [[0] * n for _ in range(max_log)]\n    for u in range(n):\n        v = f[u]\n        next_n[0][u] = v\n        next_m[0][u] = w[u]\n        next_s[0][u] = w[u]\n    for k_log in range(1, max_log):\n        for u in range(n):\n            v = next_n[k_log - 1][u]\n            m = next_m[k_log - 1][u]\n            s = next_s[k_log - 1][u]\n            next_n[k_log][u] = next_n[k_log - 1][v]\n            next_m[k_log][u] = min(next_m[k_log - 1][v], m)\n            next_s[k_log][u] = next_s[k_log - 1][v] + s\n    result = []\n    for u in range(n):\n        (s, m) = (0, float(''))\n        v = u\n        cur = 1 << max_log\n        i = max_log\n        while cur > 0:\n            if cur & k:\n                m = min(m, next_m[i][v])\n                s = s + next_s[i][v]\n                v = next_n[i][v]\n            cur >>= 1\n            i -= 1\n        result.append((s, m))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "s = s + next_s[i][v]",
      "mutated_line": "s = s - next_s[i][v]",
      "code": "def calculate_path_weights(n, k, f, w):\n    max_log = 35\n    next_n = [[-1] * n for _ in range(max_log)]\n    next_m = [[float('inf')] * n for _ in range(max_log)]\n    next_s = [[0] * n for _ in range(max_log)]\n    for u in range(n):\n        v = f[u]\n        next_n[0][u] = v\n        next_m[0][u] = w[u]\n        next_s[0][u] = w[u]\n    for k_log in range(1, max_log):\n        for u in range(n):\n            v = next_n[k_log - 1][u]\n            m = next_m[k_log - 1][u]\n            s = next_s[k_log - 1][u]\n            next_n[k_log][u] = next_n[k_log - 1][v]\n            next_m[k_log][u] = min(next_m[k_log - 1][v], m)\n            next_s[k_log][u] = next_s[k_log - 1][v] + s\n    result = []\n    for u in range(n):\n        (s, m) = (0, float('inf'))\n        v = u\n        cur = 1 << max_log\n        i = max_log\n        while cur > 0:\n            if cur & k:\n                m = min(m, next_m[i][v])\n                s = s - next_s[i][v]\n                v = next_n[i][v]\n            cur >>= 1\n            i -= 1\n        result.append((s, m))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "s = s + next_s[i][v]",
      "mutated_line": "s = s * next_s[i][v]",
      "code": "def calculate_path_weights(n, k, f, w):\n    max_log = 35\n    next_n = [[-1] * n for _ in range(max_log)]\n    next_m = [[float('inf')] * n for _ in range(max_log)]\n    next_s = [[0] * n for _ in range(max_log)]\n    for u in range(n):\n        v = f[u]\n        next_n[0][u] = v\n        next_m[0][u] = w[u]\n        next_s[0][u] = w[u]\n    for k_log in range(1, max_log):\n        for u in range(n):\n            v = next_n[k_log - 1][u]\n            m = next_m[k_log - 1][u]\n            s = next_s[k_log - 1][u]\n            next_n[k_log][u] = next_n[k_log - 1][v]\n            next_m[k_log][u] = min(next_m[k_log - 1][v], m)\n            next_s[k_log][u] = next_s[k_log - 1][v] + s\n    result = []\n    for u in range(n):\n        (s, m) = (0, float('inf'))\n        v = u\n        cur = 1 << max_log\n        i = max_log\n        while cur > 0:\n            if cur & k:\n                m = min(m, next_m[i][v])\n                s = s * next_s[i][v]\n                v = next_n[i][v]\n            cur >>= 1\n            i -= 1\n        result.append((s, m))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "next_n = [[-1] * n for _ in range(max_log)]",
      "mutated_line": "next_n = [[-2] * n for _ in range(max_log)]",
      "code": "def calculate_path_weights(n, k, f, w):\n    max_log = 35\n    next_n = [[-2] * n for _ in range(max_log)]\n    next_m = [[float('inf')] * n for _ in range(max_log)]\n    next_s = [[0] * n for _ in range(max_log)]\n    for u in range(n):\n        v = f[u]\n        next_n[0][u] = v\n        next_m[0][u] = w[u]\n        next_s[0][u] = w[u]\n    for k_log in range(1, max_log):\n        for u in range(n):\n            v = next_n[k_log - 1][u]\n            m = next_m[k_log - 1][u]\n            s = next_s[k_log - 1][u]\n            next_n[k_log][u] = next_n[k_log - 1][v]\n            next_m[k_log][u] = min(next_m[k_log - 1][v], m)\n            next_s[k_log][u] = next_s[k_log - 1][v] + s\n    result = []\n    for u in range(n):\n        (s, m) = (0, float('inf'))\n        v = u\n        cur = 1 << max_log\n        i = max_log\n        while cur > 0:\n            if cur & k:\n                m = min(m, next_m[i][v])\n                s = s + next_s[i][v]\n                v = next_n[i][v]\n            cur >>= 1\n            i -= 1\n        result.append((s, m))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "next_n = [[-1] * n for _ in range(max_log)]",
      "mutated_line": "next_n = [[-0] * n for _ in range(max_log)]",
      "code": "def calculate_path_weights(n, k, f, w):\n    max_log = 35\n    next_n = [[-0] * n for _ in range(max_log)]\n    next_m = [[float('inf')] * n for _ in range(max_log)]\n    next_s = [[0] * n for _ in range(max_log)]\n    for u in range(n):\n        v = f[u]\n        next_n[0][u] = v\n        next_m[0][u] = w[u]\n        next_s[0][u] = w[u]\n    for k_log in range(1, max_log):\n        for u in range(n):\n            v = next_n[k_log - 1][u]\n            m = next_m[k_log - 1][u]\n            s = next_s[k_log - 1][u]\n            next_n[k_log][u] = next_n[k_log - 1][v]\n            next_m[k_log][u] = min(next_m[k_log - 1][v], m)\n            next_s[k_log][u] = next_s[k_log - 1][v] + s\n    result = []\n    for u in range(n):\n        (s, m) = (0, float('inf'))\n        v = u\n        cur = 1 << max_log\n        i = max_log\n        while cur > 0:\n            if cur & k:\n                m = min(m, next_m[i][v])\n                s = s + next_s[i][v]\n                v = next_n[i][v]\n            cur >>= 1\n            i -= 1\n        result.append((s, m))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "next_n = [[-1] * n for _ in range(max_log)]",
      "mutated_line": "next_n = [[-0] * n for _ in range(max_log)]",
      "code": "def calculate_path_weights(n, k, f, w):\n    max_log = 35\n    next_n = [[-0] * n for _ in range(max_log)]\n    next_m = [[float('inf')] * n for _ in range(max_log)]\n    next_s = [[0] * n for _ in range(max_log)]\n    for u in range(n):\n        v = f[u]\n        next_n[0][u] = v\n        next_m[0][u] = w[u]\n        next_s[0][u] = w[u]\n    for k_log in range(1, max_log):\n        for u in range(n):\n            v = next_n[k_log - 1][u]\n            m = next_m[k_log - 1][u]\n            s = next_s[k_log - 1][u]\n            next_n[k_log][u] = next_n[k_log - 1][v]\n            next_m[k_log][u] = min(next_m[k_log - 1][v], m)\n            next_s[k_log][u] = next_s[k_log - 1][v] + s\n    result = []\n    for u in range(n):\n        (s, m) = (0, float('inf'))\n        v = u\n        cur = 1 << max_log\n        i = max_log\n        while cur > 0:\n            if cur & k:\n                m = min(m, next_m[i][v])\n                s = s + next_s[i][v]\n                v = next_n[i][v]\n            cur >>= 1\n            i -= 1\n        result.append((s, m))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "next_n = [[-1] * n for _ in range(max_log)]",
      "mutated_line": "next_n = [[--1] * n for _ in range(max_log)]",
      "code": "def calculate_path_weights(n, k, f, w):\n    max_log = 35\n    next_n = [[--1] * n for _ in range(max_log)]\n    next_m = [[float('inf')] * n for _ in range(max_log)]\n    next_s = [[0] * n for _ in range(max_log)]\n    for u in range(n):\n        v = f[u]\n        next_n[0][u] = v\n        next_m[0][u] = w[u]\n        next_s[0][u] = w[u]\n    for k_log in range(1, max_log):\n        for u in range(n):\n            v = next_n[k_log - 1][u]\n            m = next_m[k_log - 1][u]\n            s = next_s[k_log - 1][u]\n            next_n[k_log][u] = next_n[k_log - 1][v]\n            next_m[k_log][u] = min(next_m[k_log - 1][v], m)\n            next_s[k_log][u] = next_s[k_log - 1][v] + s\n    result = []\n    for u in range(n):\n        (s, m) = (0, float('inf'))\n        v = u\n        cur = 1 << max_log\n        i = max_log\n        while cur > 0:\n            if cur & k:\n                m = min(m, next_m[i][v])\n                s = s + next_s[i][v]\n                v = next_n[i][v]\n            cur >>= 1\n            i -= 1\n        result.append((s, m))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "next_m = [[float('inf')] * n for _ in range(max_log)]",
      "mutated_line": "next_m = [[float('')] * n for _ in range(max_log)]",
      "code": "def calculate_path_weights(n, k, f, w):\n    max_log = 35\n    next_n = [[-1] * n for _ in range(max_log)]\n    next_m = [[float('')] * n for _ in range(max_log)]\n    next_s = [[0] * n for _ in range(max_log)]\n    for u in range(n):\n        v = f[u]\n        next_n[0][u] = v\n        next_m[0][u] = w[u]\n        next_s[0][u] = w[u]\n    for k_log in range(1, max_log):\n        for u in range(n):\n            v = next_n[k_log - 1][u]\n            m = next_m[k_log - 1][u]\n            s = next_s[k_log - 1][u]\n            next_n[k_log][u] = next_n[k_log - 1][v]\n            next_m[k_log][u] = min(next_m[k_log - 1][v], m)\n            next_s[k_log][u] = next_s[k_log - 1][v] + s\n    result = []\n    for u in range(n):\n        (s, m) = (0, float('inf'))\n        v = u\n        cur = 1 << max_log\n        i = max_log\n        while cur > 0:\n            if cur & k:\n                m = min(m, next_m[i][v])\n                s = s + next_s[i][v]\n                v = next_n[i][v]\n            cur >>= 1\n            i -= 1\n        result.append((s, m))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "v = next_n[k_log - 1][u]",
      "mutated_line": "v = next_n[k_log + 1][u]",
      "code": "def calculate_path_weights(n, k, f, w):\n    max_log = 35\n    next_n = [[-1] * n for _ in range(max_log)]\n    next_m = [[float('inf')] * n for _ in range(max_log)]\n    next_s = [[0] * n for _ in range(max_log)]\n    for u in range(n):\n        v = f[u]\n        next_n[0][u] = v\n        next_m[0][u] = w[u]\n        next_s[0][u] = w[u]\n    for k_log in range(1, max_log):\n        for u in range(n):\n            v = next_n[k_log + 1][u]\n            m = next_m[k_log - 1][u]\n            s = next_s[k_log - 1][u]\n            next_n[k_log][u] = next_n[k_log - 1][v]\n            next_m[k_log][u] = min(next_m[k_log - 1][v], m)\n            next_s[k_log][u] = next_s[k_log - 1][v] + s\n    result = []\n    for u in range(n):\n        (s, m) = (0, float('inf'))\n        v = u\n        cur = 1 << max_log\n        i = max_log\n        while cur > 0:\n            if cur & k:\n                m = min(m, next_m[i][v])\n                s = s + next_s[i][v]\n                v = next_n[i][v]\n            cur >>= 1\n            i -= 1\n        result.append((s, m))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "v = next_n[k_log - 1][u]",
      "mutated_line": "v = next_n[k_log * 1][u]",
      "code": "def calculate_path_weights(n, k, f, w):\n    max_log = 35\n    next_n = [[-1] * n for _ in range(max_log)]\n    next_m = [[float('inf')] * n for _ in range(max_log)]\n    next_s = [[0] * n for _ in range(max_log)]\n    for u in range(n):\n        v = f[u]\n        next_n[0][u] = v\n        next_m[0][u] = w[u]\n        next_s[0][u] = w[u]\n    for k_log in range(1, max_log):\n        for u in range(n):\n            v = next_n[k_log * 1][u]\n            m = next_m[k_log - 1][u]\n            s = next_s[k_log - 1][u]\n            next_n[k_log][u] = next_n[k_log - 1][v]\n            next_m[k_log][u] = min(next_m[k_log - 1][v], m)\n            next_s[k_log][u] = next_s[k_log - 1][v] + s\n    result = []\n    for u in range(n):\n        (s, m) = (0, float('inf'))\n        v = u\n        cur = 1 << max_log\n        i = max_log\n        while cur > 0:\n            if cur & k:\n                m = min(m, next_m[i][v])\n                s = s + next_s[i][v]\n                v = next_n[i][v]\n            cur >>= 1\n            i -= 1\n        result.append((s, m))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "m = next_m[k_log - 1][u]",
      "mutated_line": "m = next_m[k_log + 1][u]",
      "code": "def calculate_path_weights(n, k, f, w):\n    max_log = 35\n    next_n = [[-1] * n for _ in range(max_log)]\n    next_m = [[float('inf')] * n for _ in range(max_log)]\n    next_s = [[0] * n for _ in range(max_log)]\n    for u in range(n):\n        v = f[u]\n        next_n[0][u] = v\n        next_m[0][u] = w[u]\n        next_s[0][u] = w[u]\n    for k_log in range(1, max_log):\n        for u in range(n):\n            v = next_n[k_log - 1][u]\n            m = next_m[k_log + 1][u]\n            s = next_s[k_log - 1][u]\n            next_n[k_log][u] = next_n[k_log - 1][v]\n            next_m[k_log][u] = min(next_m[k_log - 1][v], m)\n            next_s[k_log][u] = next_s[k_log - 1][v] + s\n    result = []\n    for u in range(n):\n        (s, m) = (0, float('inf'))\n        v = u\n        cur = 1 << max_log\n        i = max_log\n        while cur > 0:\n            if cur & k:\n                m = min(m, next_m[i][v])\n                s = s + next_s[i][v]\n                v = next_n[i][v]\n            cur >>= 1\n            i -= 1\n        result.append((s, m))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "m = next_m[k_log - 1][u]",
      "mutated_line": "m = next_m[k_log * 1][u]",
      "code": "def calculate_path_weights(n, k, f, w):\n    max_log = 35\n    next_n = [[-1] * n for _ in range(max_log)]\n    next_m = [[float('inf')] * n for _ in range(max_log)]\n    next_s = [[0] * n for _ in range(max_log)]\n    for u in range(n):\n        v = f[u]\n        next_n[0][u] = v\n        next_m[0][u] = w[u]\n        next_s[0][u] = w[u]\n    for k_log in range(1, max_log):\n        for u in range(n):\n            v = next_n[k_log - 1][u]\n            m = next_m[k_log * 1][u]\n            s = next_s[k_log - 1][u]\n            next_n[k_log][u] = next_n[k_log - 1][v]\n            next_m[k_log][u] = min(next_m[k_log - 1][v], m)\n            next_s[k_log][u] = next_s[k_log - 1][v] + s\n    result = []\n    for u in range(n):\n        (s, m) = (0, float('inf'))\n        v = u\n        cur = 1 << max_log\n        i = max_log\n        while cur > 0:\n            if cur & k:\n                m = min(m, next_m[i][v])\n                s = s + next_s[i][v]\n                v = next_n[i][v]\n            cur >>= 1\n            i -= 1\n        result.append((s, m))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "s = next_s[k_log - 1][u]",
      "mutated_line": "s = next_s[k_log + 1][u]",
      "code": "def calculate_path_weights(n, k, f, w):\n    max_log = 35\n    next_n = [[-1] * n for _ in range(max_log)]\n    next_m = [[float('inf')] * n for _ in range(max_log)]\n    next_s = [[0] * n for _ in range(max_log)]\n    for u in range(n):\n        v = f[u]\n        next_n[0][u] = v\n        next_m[0][u] = w[u]\n        next_s[0][u] = w[u]\n    for k_log in range(1, max_log):\n        for u in range(n):\n            v = next_n[k_log - 1][u]\n            m = next_m[k_log - 1][u]\n            s = next_s[k_log + 1][u]\n            next_n[k_log][u] = next_n[k_log - 1][v]\n            next_m[k_log][u] = min(next_m[k_log - 1][v], m)\n            next_s[k_log][u] = next_s[k_log - 1][v] + s\n    result = []\n    for u in range(n):\n        (s, m) = (0, float('inf'))\n        v = u\n        cur = 1 << max_log\n        i = max_log\n        while cur > 0:\n            if cur & k:\n                m = min(m, next_m[i][v])\n                s = s + next_s[i][v]\n                v = next_n[i][v]\n            cur >>= 1\n            i -= 1\n        result.append((s, m))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "s = next_s[k_log - 1][u]",
      "mutated_line": "s = next_s[k_log * 1][u]",
      "code": "def calculate_path_weights(n, k, f, w):\n    max_log = 35\n    next_n = [[-1] * n for _ in range(max_log)]\n    next_m = [[float('inf')] * n for _ in range(max_log)]\n    next_s = [[0] * n for _ in range(max_log)]\n    for u in range(n):\n        v = f[u]\n        next_n[0][u] = v\n        next_m[0][u] = w[u]\n        next_s[0][u] = w[u]\n    for k_log in range(1, max_log):\n        for u in range(n):\n            v = next_n[k_log - 1][u]\n            m = next_m[k_log - 1][u]\n            s = next_s[k_log * 1][u]\n            next_n[k_log][u] = next_n[k_log - 1][v]\n            next_m[k_log][u] = min(next_m[k_log - 1][v], m)\n            next_s[k_log][u] = next_s[k_log - 1][v] + s\n    result = []\n    for u in range(n):\n        (s, m) = (0, float('inf'))\n        v = u\n        cur = 1 << max_log\n        i = max_log\n        while cur > 0:\n            if cur & k:\n                m = min(m, next_m[i][v])\n                s = s + next_s[i][v]\n                v = next_n[i][v]\n            cur >>= 1\n            i -= 1\n        result.append((s, m))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "next_n[k_log][u] = next_n[k_log - 1][v]",
      "mutated_line": "next_n[k_log][u] = next_n[k_log + 1][v]",
      "code": "def calculate_path_weights(n, k, f, w):\n    max_log = 35\n    next_n = [[-1] * n for _ in range(max_log)]\n    next_m = [[float('inf')] * n for _ in range(max_log)]\n    next_s = [[0] * n for _ in range(max_log)]\n    for u in range(n):\n        v = f[u]\n        next_n[0][u] = v\n        next_m[0][u] = w[u]\n        next_s[0][u] = w[u]\n    for k_log in range(1, max_log):\n        for u in range(n):\n            v = next_n[k_log - 1][u]\n            m = next_m[k_log - 1][u]\n            s = next_s[k_log - 1][u]\n            next_n[k_log][u] = next_n[k_log + 1][v]\n            next_m[k_log][u] = min(next_m[k_log - 1][v], m)\n            next_s[k_log][u] = next_s[k_log - 1][v] + s\n    result = []\n    for u in range(n):\n        (s, m) = (0, float('inf'))\n        v = u\n        cur = 1 << max_log\n        i = max_log\n        while cur > 0:\n            if cur & k:\n                m = min(m, next_m[i][v])\n                s = s + next_s[i][v]\n                v = next_n[i][v]\n            cur >>= 1\n            i -= 1\n        result.append((s, m))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "next_n[k_log][u] = next_n[k_log - 1][v]",
      "mutated_line": "next_n[k_log][u] = next_n[k_log * 1][v]",
      "code": "def calculate_path_weights(n, k, f, w):\n    max_log = 35\n    next_n = [[-1] * n for _ in range(max_log)]\n    next_m = [[float('inf')] * n for _ in range(max_log)]\n    next_s = [[0] * n for _ in range(max_log)]\n    for u in range(n):\n        v = f[u]\n        next_n[0][u] = v\n        next_m[0][u] = w[u]\n        next_s[0][u] = w[u]\n    for k_log in range(1, max_log):\n        for u in range(n):\n            v = next_n[k_log - 1][u]\n            m = next_m[k_log - 1][u]\n            s = next_s[k_log - 1][u]\n            next_n[k_log][u] = next_n[k_log * 1][v]\n            next_m[k_log][u] = min(next_m[k_log - 1][v], m)\n            next_s[k_log][u] = next_s[k_log - 1][v] + s\n    result = []\n    for u in range(n):\n        (s, m) = (0, float('inf'))\n        v = u\n        cur = 1 << max_log\n        i = max_log\n        while cur > 0:\n            if cur & k:\n                m = min(m, next_m[i][v])\n                s = s + next_s[i][v]\n                v = next_n[i][v]\n            cur >>= 1\n            i -= 1\n        result.append((s, m))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "v = next_n[k_log - 1][u]",
      "mutated_line": "v = next_n[k_log - 2][u]",
      "code": "def calculate_path_weights(n, k, f, w):\n    max_log = 35\n    next_n = [[-1] * n for _ in range(max_log)]\n    next_m = [[float('inf')] * n for _ in range(max_log)]\n    next_s = [[0] * n for _ in range(max_log)]\n    for u in range(n):\n        v = f[u]\n        next_n[0][u] = v\n        next_m[0][u] = w[u]\n        next_s[0][u] = w[u]\n    for k_log in range(1, max_log):\n        for u in range(n):\n            v = next_n[k_log - 2][u]\n            m = next_m[k_log - 1][u]\n            s = next_s[k_log - 1][u]\n            next_n[k_log][u] = next_n[k_log - 1][v]\n            next_m[k_log][u] = min(next_m[k_log - 1][v], m)\n            next_s[k_log][u] = next_s[k_log - 1][v] + s\n    result = []\n    for u in range(n):\n        (s, m) = (0, float('inf'))\n        v = u\n        cur = 1 << max_log\n        i = max_log\n        while cur > 0:\n            if cur & k:\n                m = min(m, next_m[i][v])\n                s = s + next_s[i][v]\n                v = next_n[i][v]\n            cur >>= 1\n            i -= 1\n        result.append((s, m))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "v = next_n[k_log - 1][u]",
      "mutated_line": "v = next_n[k_log - 0][u]",
      "code": "def calculate_path_weights(n, k, f, w):\n    max_log = 35\n    next_n = [[-1] * n for _ in range(max_log)]\n    next_m = [[float('inf')] * n for _ in range(max_log)]\n    next_s = [[0] * n for _ in range(max_log)]\n    for u in range(n):\n        v = f[u]\n        next_n[0][u] = v\n        next_m[0][u] = w[u]\n        next_s[0][u] = w[u]\n    for k_log in range(1, max_log):\n        for u in range(n):\n            v = next_n[k_log - 0][u]\n            m = next_m[k_log - 1][u]\n            s = next_s[k_log - 1][u]\n            next_n[k_log][u] = next_n[k_log - 1][v]\n            next_m[k_log][u] = min(next_m[k_log - 1][v], m)\n            next_s[k_log][u] = next_s[k_log - 1][v] + s\n    result = []\n    for u in range(n):\n        (s, m) = (0, float('inf'))\n        v = u\n        cur = 1 << max_log\n        i = max_log\n        while cur > 0:\n            if cur & k:\n                m = min(m, next_m[i][v])\n                s = s + next_s[i][v]\n                v = next_n[i][v]\n            cur >>= 1\n            i -= 1\n        result.append((s, m))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "v = next_n[k_log - 1][u]",
      "mutated_line": "v = next_n[k_log - 0][u]",
      "code": "def calculate_path_weights(n, k, f, w):\n    max_log = 35\n    next_n = [[-1] * n for _ in range(max_log)]\n    next_m = [[float('inf')] * n for _ in range(max_log)]\n    next_s = [[0] * n for _ in range(max_log)]\n    for u in range(n):\n        v = f[u]\n        next_n[0][u] = v\n        next_m[0][u] = w[u]\n        next_s[0][u] = w[u]\n    for k_log in range(1, max_log):\n        for u in range(n):\n            v = next_n[k_log - 0][u]\n            m = next_m[k_log - 1][u]\n            s = next_s[k_log - 1][u]\n            next_n[k_log][u] = next_n[k_log - 1][v]\n            next_m[k_log][u] = min(next_m[k_log - 1][v], m)\n            next_s[k_log][u] = next_s[k_log - 1][v] + s\n    result = []\n    for u in range(n):\n        (s, m) = (0, float('inf'))\n        v = u\n        cur = 1 << max_log\n        i = max_log\n        while cur > 0:\n            if cur & k:\n                m = min(m, next_m[i][v])\n                s = s + next_s[i][v]\n                v = next_n[i][v]\n            cur >>= 1\n            i -= 1\n        result.append((s, m))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "v = next_n[k_log - 1][u]",
      "mutated_line": "v = next_n[k_log - -1][u]",
      "code": "def calculate_path_weights(n, k, f, w):\n    max_log = 35\n    next_n = [[-1] * n for _ in range(max_log)]\n    next_m = [[float('inf')] * n for _ in range(max_log)]\n    next_s = [[0] * n for _ in range(max_log)]\n    for u in range(n):\n        v = f[u]\n        next_n[0][u] = v\n        next_m[0][u] = w[u]\n        next_s[0][u] = w[u]\n    for k_log in range(1, max_log):\n        for u in range(n):\n            v = next_n[k_log - -1][u]\n            m = next_m[k_log - 1][u]\n            s = next_s[k_log - 1][u]\n            next_n[k_log][u] = next_n[k_log - 1][v]\n            next_m[k_log][u] = min(next_m[k_log - 1][v], m)\n            next_s[k_log][u] = next_s[k_log - 1][v] + s\n    result = []\n    for u in range(n):\n        (s, m) = (0, float('inf'))\n        v = u\n        cur = 1 << max_log\n        i = max_log\n        while cur > 0:\n            if cur & k:\n                m = min(m, next_m[i][v])\n                s = s + next_s[i][v]\n                v = next_n[i][v]\n            cur >>= 1\n            i -= 1\n        result.append((s, m))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "m = next_m[k_log - 1][u]",
      "mutated_line": "m = next_m[k_log - 2][u]",
      "code": "def calculate_path_weights(n, k, f, w):\n    max_log = 35\n    next_n = [[-1] * n for _ in range(max_log)]\n    next_m = [[float('inf')] * n for _ in range(max_log)]\n    next_s = [[0] * n for _ in range(max_log)]\n    for u in range(n):\n        v = f[u]\n        next_n[0][u] = v\n        next_m[0][u] = w[u]\n        next_s[0][u] = w[u]\n    for k_log in range(1, max_log):\n        for u in range(n):\n            v = next_n[k_log - 1][u]\n            m = next_m[k_log - 2][u]\n            s = next_s[k_log - 1][u]\n            next_n[k_log][u] = next_n[k_log - 1][v]\n            next_m[k_log][u] = min(next_m[k_log - 1][v], m)\n            next_s[k_log][u] = next_s[k_log - 1][v] + s\n    result = []\n    for u in range(n):\n        (s, m) = (0, float('inf'))\n        v = u\n        cur = 1 << max_log\n        i = max_log\n        while cur > 0:\n            if cur & k:\n                m = min(m, next_m[i][v])\n                s = s + next_s[i][v]\n                v = next_n[i][v]\n            cur >>= 1\n            i -= 1\n        result.append((s, m))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "m = next_m[k_log - 1][u]",
      "mutated_line": "m = next_m[k_log - 0][u]",
      "code": "def calculate_path_weights(n, k, f, w):\n    max_log = 35\n    next_n = [[-1] * n for _ in range(max_log)]\n    next_m = [[float('inf')] * n for _ in range(max_log)]\n    next_s = [[0] * n for _ in range(max_log)]\n    for u in range(n):\n        v = f[u]\n        next_n[0][u] = v\n        next_m[0][u] = w[u]\n        next_s[0][u] = w[u]\n    for k_log in range(1, max_log):\n        for u in range(n):\n            v = next_n[k_log - 1][u]\n            m = next_m[k_log - 0][u]\n            s = next_s[k_log - 1][u]\n            next_n[k_log][u] = next_n[k_log - 1][v]\n            next_m[k_log][u] = min(next_m[k_log - 1][v], m)\n            next_s[k_log][u] = next_s[k_log - 1][v] + s\n    result = []\n    for u in range(n):\n        (s, m) = (0, float('inf'))\n        v = u\n        cur = 1 << max_log\n        i = max_log\n        while cur > 0:\n            if cur & k:\n                m = min(m, next_m[i][v])\n                s = s + next_s[i][v]\n                v = next_n[i][v]\n            cur >>= 1\n            i -= 1\n        result.append((s, m))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "m = next_m[k_log - 1][u]",
      "mutated_line": "m = next_m[k_log - 0][u]",
      "code": "def calculate_path_weights(n, k, f, w):\n    max_log = 35\n    next_n = [[-1] * n for _ in range(max_log)]\n    next_m = [[float('inf')] * n for _ in range(max_log)]\n    next_s = [[0] * n for _ in range(max_log)]\n    for u in range(n):\n        v = f[u]\n        next_n[0][u] = v\n        next_m[0][u] = w[u]\n        next_s[0][u] = w[u]\n    for k_log in range(1, max_log):\n        for u in range(n):\n            v = next_n[k_log - 1][u]\n            m = next_m[k_log - 0][u]\n            s = next_s[k_log - 1][u]\n            next_n[k_log][u] = next_n[k_log - 1][v]\n            next_m[k_log][u] = min(next_m[k_log - 1][v], m)\n            next_s[k_log][u] = next_s[k_log - 1][v] + s\n    result = []\n    for u in range(n):\n        (s, m) = (0, float('inf'))\n        v = u\n        cur = 1 << max_log\n        i = max_log\n        while cur > 0:\n            if cur & k:\n                m = min(m, next_m[i][v])\n                s = s + next_s[i][v]\n                v = next_n[i][v]\n            cur >>= 1\n            i -= 1\n        result.append((s, m))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "m = next_m[k_log - 1][u]",
      "mutated_line": "m = next_m[k_log - -1][u]",
      "code": "def calculate_path_weights(n, k, f, w):\n    max_log = 35\n    next_n = [[-1] * n for _ in range(max_log)]\n    next_m = [[float('inf')] * n for _ in range(max_log)]\n    next_s = [[0] * n for _ in range(max_log)]\n    for u in range(n):\n        v = f[u]\n        next_n[0][u] = v\n        next_m[0][u] = w[u]\n        next_s[0][u] = w[u]\n    for k_log in range(1, max_log):\n        for u in range(n):\n            v = next_n[k_log - 1][u]\n            m = next_m[k_log - -1][u]\n            s = next_s[k_log - 1][u]\n            next_n[k_log][u] = next_n[k_log - 1][v]\n            next_m[k_log][u] = min(next_m[k_log - 1][v], m)\n            next_s[k_log][u] = next_s[k_log - 1][v] + s\n    result = []\n    for u in range(n):\n        (s, m) = (0, float('inf'))\n        v = u\n        cur = 1 << max_log\n        i = max_log\n        while cur > 0:\n            if cur & k:\n                m = min(m, next_m[i][v])\n                s = s + next_s[i][v]\n                v = next_n[i][v]\n            cur >>= 1\n            i -= 1\n        result.append((s, m))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "s = next_s[k_log - 1][u]",
      "mutated_line": "s = next_s[k_log - 2][u]",
      "code": "def calculate_path_weights(n, k, f, w):\n    max_log = 35\n    next_n = [[-1] * n for _ in range(max_log)]\n    next_m = [[float('inf')] * n for _ in range(max_log)]\n    next_s = [[0] * n for _ in range(max_log)]\n    for u in range(n):\n        v = f[u]\n        next_n[0][u] = v\n        next_m[0][u] = w[u]\n        next_s[0][u] = w[u]\n    for k_log in range(1, max_log):\n        for u in range(n):\n            v = next_n[k_log - 1][u]\n            m = next_m[k_log - 1][u]\n            s = next_s[k_log - 2][u]\n            next_n[k_log][u] = next_n[k_log - 1][v]\n            next_m[k_log][u] = min(next_m[k_log - 1][v], m)\n            next_s[k_log][u] = next_s[k_log - 1][v] + s\n    result = []\n    for u in range(n):\n        (s, m) = (0, float('inf'))\n        v = u\n        cur = 1 << max_log\n        i = max_log\n        while cur > 0:\n            if cur & k:\n                m = min(m, next_m[i][v])\n                s = s + next_s[i][v]\n                v = next_n[i][v]\n            cur >>= 1\n            i -= 1\n        result.append((s, m))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "s = next_s[k_log - 1][u]",
      "mutated_line": "s = next_s[k_log - 0][u]",
      "code": "def calculate_path_weights(n, k, f, w):\n    max_log = 35\n    next_n = [[-1] * n for _ in range(max_log)]\n    next_m = [[float('inf')] * n for _ in range(max_log)]\n    next_s = [[0] * n for _ in range(max_log)]\n    for u in range(n):\n        v = f[u]\n        next_n[0][u] = v\n        next_m[0][u] = w[u]\n        next_s[0][u] = w[u]\n    for k_log in range(1, max_log):\n        for u in range(n):\n            v = next_n[k_log - 1][u]\n            m = next_m[k_log - 1][u]\n            s = next_s[k_log - 0][u]\n            next_n[k_log][u] = next_n[k_log - 1][v]\n            next_m[k_log][u] = min(next_m[k_log - 1][v], m)\n            next_s[k_log][u] = next_s[k_log - 1][v] + s\n    result = []\n    for u in range(n):\n        (s, m) = (0, float('inf'))\n        v = u\n        cur = 1 << max_log\n        i = max_log\n        while cur > 0:\n            if cur & k:\n                m = min(m, next_m[i][v])\n                s = s + next_s[i][v]\n                v = next_n[i][v]\n            cur >>= 1\n            i -= 1\n        result.append((s, m))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "s = next_s[k_log - 1][u]",
      "mutated_line": "s = next_s[k_log - 0][u]",
      "code": "def calculate_path_weights(n, k, f, w):\n    max_log = 35\n    next_n = [[-1] * n for _ in range(max_log)]\n    next_m = [[float('inf')] * n for _ in range(max_log)]\n    next_s = [[0] * n for _ in range(max_log)]\n    for u in range(n):\n        v = f[u]\n        next_n[0][u] = v\n        next_m[0][u] = w[u]\n        next_s[0][u] = w[u]\n    for k_log in range(1, max_log):\n        for u in range(n):\n            v = next_n[k_log - 1][u]\n            m = next_m[k_log - 1][u]\n            s = next_s[k_log - 0][u]\n            next_n[k_log][u] = next_n[k_log - 1][v]\n            next_m[k_log][u] = min(next_m[k_log - 1][v], m)\n            next_s[k_log][u] = next_s[k_log - 1][v] + s\n    result = []\n    for u in range(n):\n        (s, m) = (0, float('inf'))\n        v = u\n        cur = 1 << max_log\n        i = max_log\n        while cur > 0:\n            if cur & k:\n                m = min(m, next_m[i][v])\n                s = s + next_s[i][v]\n                v = next_n[i][v]\n            cur >>= 1\n            i -= 1\n        result.append((s, m))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "s = next_s[k_log - 1][u]",
      "mutated_line": "s = next_s[k_log - -1][u]",
      "code": "def calculate_path_weights(n, k, f, w):\n    max_log = 35\n    next_n = [[-1] * n for _ in range(max_log)]\n    next_m = [[float('inf')] * n for _ in range(max_log)]\n    next_s = [[0] * n for _ in range(max_log)]\n    for u in range(n):\n        v = f[u]\n        next_n[0][u] = v\n        next_m[0][u] = w[u]\n        next_s[0][u] = w[u]\n    for k_log in range(1, max_log):\n        for u in range(n):\n            v = next_n[k_log - 1][u]\n            m = next_m[k_log - 1][u]\n            s = next_s[k_log - -1][u]\n            next_n[k_log][u] = next_n[k_log - 1][v]\n            next_m[k_log][u] = min(next_m[k_log - 1][v], m)\n            next_s[k_log][u] = next_s[k_log - 1][v] + s\n    result = []\n    for u in range(n):\n        (s, m) = (0, float('inf'))\n        v = u\n        cur = 1 << max_log\n        i = max_log\n        while cur > 0:\n            if cur & k:\n                m = min(m, next_m[i][v])\n                s = s + next_s[i][v]\n                v = next_n[i][v]\n            cur >>= 1\n            i -= 1\n        result.append((s, m))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "next_n[k_log][u] = next_n[k_log - 1][v]",
      "mutated_line": "next_n[k_log][u] = next_n[k_log - 2][v]",
      "code": "def calculate_path_weights(n, k, f, w):\n    max_log = 35\n    next_n = [[-1] * n for _ in range(max_log)]\n    next_m = [[float('inf')] * n for _ in range(max_log)]\n    next_s = [[0] * n for _ in range(max_log)]\n    for u in range(n):\n        v = f[u]\n        next_n[0][u] = v\n        next_m[0][u] = w[u]\n        next_s[0][u] = w[u]\n    for k_log in range(1, max_log):\n        for u in range(n):\n            v = next_n[k_log - 1][u]\n            m = next_m[k_log - 1][u]\n            s = next_s[k_log - 1][u]\n            next_n[k_log][u] = next_n[k_log - 2][v]\n            next_m[k_log][u] = min(next_m[k_log - 1][v], m)\n            next_s[k_log][u] = next_s[k_log - 1][v] + s\n    result = []\n    for u in range(n):\n        (s, m) = (0, float('inf'))\n        v = u\n        cur = 1 << max_log\n        i = max_log\n        while cur > 0:\n            if cur & k:\n                m = min(m, next_m[i][v])\n                s = s + next_s[i][v]\n                v = next_n[i][v]\n            cur >>= 1\n            i -= 1\n        result.append((s, m))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "next_n[k_log][u] = next_n[k_log - 1][v]",
      "mutated_line": "next_n[k_log][u] = next_n[k_log - 0][v]",
      "code": "def calculate_path_weights(n, k, f, w):\n    max_log = 35\n    next_n = [[-1] * n for _ in range(max_log)]\n    next_m = [[float('inf')] * n for _ in range(max_log)]\n    next_s = [[0] * n for _ in range(max_log)]\n    for u in range(n):\n        v = f[u]\n        next_n[0][u] = v\n        next_m[0][u] = w[u]\n        next_s[0][u] = w[u]\n    for k_log in range(1, max_log):\n        for u in range(n):\n            v = next_n[k_log - 1][u]\n            m = next_m[k_log - 1][u]\n            s = next_s[k_log - 1][u]\n            next_n[k_log][u] = next_n[k_log - 0][v]\n            next_m[k_log][u] = min(next_m[k_log - 1][v], m)\n            next_s[k_log][u] = next_s[k_log - 1][v] + s\n    result = []\n    for u in range(n):\n        (s, m) = (0, float('inf'))\n        v = u\n        cur = 1 << max_log\n        i = max_log\n        while cur > 0:\n            if cur & k:\n                m = min(m, next_m[i][v])\n                s = s + next_s[i][v]\n                v = next_n[i][v]\n            cur >>= 1\n            i -= 1\n        result.append((s, m))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "next_n[k_log][u] = next_n[k_log - 1][v]",
      "mutated_line": "next_n[k_log][u] = next_n[k_log - 0][v]",
      "code": "def calculate_path_weights(n, k, f, w):\n    max_log = 35\n    next_n = [[-1] * n for _ in range(max_log)]\n    next_m = [[float('inf')] * n for _ in range(max_log)]\n    next_s = [[0] * n for _ in range(max_log)]\n    for u in range(n):\n        v = f[u]\n        next_n[0][u] = v\n        next_m[0][u] = w[u]\n        next_s[0][u] = w[u]\n    for k_log in range(1, max_log):\n        for u in range(n):\n            v = next_n[k_log - 1][u]\n            m = next_m[k_log - 1][u]\n            s = next_s[k_log - 1][u]\n            next_n[k_log][u] = next_n[k_log - 0][v]\n            next_m[k_log][u] = min(next_m[k_log - 1][v], m)\n            next_s[k_log][u] = next_s[k_log - 1][v] + s\n    result = []\n    for u in range(n):\n        (s, m) = (0, float('inf'))\n        v = u\n        cur = 1 << max_log\n        i = max_log\n        while cur > 0:\n            if cur & k:\n                m = min(m, next_m[i][v])\n                s = s + next_s[i][v]\n                v = next_n[i][v]\n            cur >>= 1\n            i -= 1\n        result.append((s, m))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "next_n[k_log][u] = next_n[k_log - 1][v]",
      "mutated_line": "next_n[k_log][u] = next_n[k_log - -1][v]",
      "code": "def calculate_path_weights(n, k, f, w):\n    max_log = 35\n    next_n = [[-1] * n for _ in range(max_log)]\n    next_m = [[float('inf')] * n for _ in range(max_log)]\n    next_s = [[0] * n for _ in range(max_log)]\n    for u in range(n):\n        v = f[u]\n        next_n[0][u] = v\n        next_m[0][u] = w[u]\n        next_s[0][u] = w[u]\n    for k_log in range(1, max_log):\n        for u in range(n):\n            v = next_n[k_log - 1][u]\n            m = next_m[k_log - 1][u]\n            s = next_s[k_log - 1][u]\n            next_n[k_log][u] = next_n[k_log - -1][v]\n            next_m[k_log][u] = min(next_m[k_log - 1][v], m)\n            next_s[k_log][u] = next_s[k_log - 1][v] + s\n    result = []\n    for u in range(n):\n        (s, m) = (0, float('inf'))\n        v = u\n        cur = 1 << max_log\n        i = max_log\n        while cur > 0:\n            if cur & k:\n                m = min(m, next_m[i][v])\n                s = s + next_s[i][v]\n                v = next_n[i][v]\n            cur >>= 1\n            i -= 1\n        result.append((s, m))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "next_m[k_log][u] = min(next_m[k_log - 1][v], m)",
      "mutated_line": "next_m[k_log][u] = min(next_m[k_log + 1][v], m)",
      "code": "def calculate_path_weights(n, k, f, w):\n    max_log = 35\n    next_n = [[-1] * n for _ in range(max_log)]\n    next_m = [[float('inf')] * n for _ in range(max_log)]\n    next_s = [[0] * n for _ in range(max_log)]\n    for u in range(n):\n        v = f[u]\n        next_n[0][u] = v\n        next_m[0][u] = w[u]\n        next_s[0][u] = w[u]\n    for k_log in range(1, max_log):\n        for u in range(n):\n            v = next_n[k_log - 1][u]\n            m = next_m[k_log - 1][u]\n            s = next_s[k_log - 1][u]\n            next_n[k_log][u] = next_n[k_log - 1][v]\n            next_m[k_log][u] = min(next_m[k_log + 1][v], m)\n            next_s[k_log][u] = next_s[k_log - 1][v] + s\n    result = []\n    for u in range(n):\n        (s, m) = (0, float('inf'))\n        v = u\n        cur = 1 << max_log\n        i = max_log\n        while cur > 0:\n            if cur & k:\n                m = min(m, next_m[i][v])\n                s = s + next_s[i][v]\n                v = next_n[i][v]\n            cur >>= 1\n            i -= 1\n        result.append((s, m))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "next_m[k_log][u] = min(next_m[k_log - 1][v], m)",
      "mutated_line": "next_m[k_log][u] = min(next_m[k_log * 1][v], m)",
      "code": "def calculate_path_weights(n, k, f, w):\n    max_log = 35\n    next_n = [[-1] * n for _ in range(max_log)]\n    next_m = [[float('inf')] * n for _ in range(max_log)]\n    next_s = [[0] * n for _ in range(max_log)]\n    for u in range(n):\n        v = f[u]\n        next_n[0][u] = v\n        next_m[0][u] = w[u]\n        next_s[0][u] = w[u]\n    for k_log in range(1, max_log):\n        for u in range(n):\n            v = next_n[k_log - 1][u]\n            m = next_m[k_log - 1][u]\n            s = next_s[k_log - 1][u]\n            next_n[k_log][u] = next_n[k_log - 1][v]\n            next_m[k_log][u] = min(next_m[k_log * 1][v], m)\n            next_s[k_log][u] = next_s[k_log - 1][v] + s\n    result = []\n    for u in range(n):\n        (s, m) = (0, float('inf'))\n        v = u\n        cur = 1 << max_log\n        i = max_log\n        while cur > 0:\n            if cur & k:\n                m = min(m, next_m[i][v])\n                s = s + next_s[i][v]\n                v = next_n[i][v]\n            cur >>= 1\n            i -= 1\n        result.append((s, m))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "next_s[k_log][u] = next_s[k_log - 1][v] + s",
      "mutated_line": "next_s[k_log][u] = next_s[k_log + 1][v] + s",
      "code": "def calculate_path_weights(n, k, f, w):\n    max_log = 35\n    next_n = [[-1] * n for _ in range(max_log)]\n    next_m = [[float('inf')] * n for _ in range(max_log)]\n    next_s = [[0] * n for _ in range(max_log)]\n    for u in range(n):\n        v = f[u]\n        next_n[0][u] = v\n        next_m[0][u] = w[u]\n        next_s[0][u] = w[u]\n    for k_log in range(1, max_log):\n        for u in range(n):\n            v = next_n[k_log - 1][u]\n            m = next_m[k_log - 1][u]\n            s = next_s[k_log - 1][u]\n            next_n[k_log][u] = next_n[k_log - 1][v]\n            next_m[k_log][u] = min(next_m[k_log - 1][v], m)\n            next_s[k_log][u] = next_s[k_log + 1][v] + s\n    result = []\n    for u in range(n):\n        (s, m) = (0, float('inf'))\n        v = u\n        cur = 1 << max_log\n        i = max_log\n        while cur > 0:\n            if cur & k:\n                m = min(m, next_m[i][v])\n                s = s + next_s[i][v]\n                v = next_n[i][v]\n            cur >>= 1\n            i -= 1\n        result.append((s, m))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "next_s[k_log][u] = next_s[k_log - 1][v] + s",
      "mutated_line": "next_s[k_log][u] = next_s[k_log * 1][v] + s",
      "code": "def calculate_path_weights(n, k, f, w):\n    max_log = 35\n    next_n = [[-1] * n for _ in range(max_log)]\n    next_m = [[float('inf')] * n for _ in range(max_log)]\n    next_s = [[0] * n for _ in range(max_log)]\n    for u in range(n):\n        v = f[u]\n        next_n[0][u] = v\n        next_m[0][u] = w[u]\n        next_s[0][u] = w[u]\n    for k_log in range(1, max_log):\n        for u in range(n):\n            v = next_n[k_log - 1][u]\n            m = next_m[k_log - 1][u]\n            s = next_s[k_log - 1][u]\n            next_n[k_log][u] = next_n[k_log - 1][v]\n            next_m[k_log][u] = min(next_m[k_log - 1][v], m)\n            next_s[k_log][u] = next_s[k_log * 1][v] + s\n    result = []\n    for u in range(n):\n        (s, m) = (0, float('inf'))\n        v = u\n        cur = 1 << max_log\n        i = max_log\n        while cur > 0:\n            if cur & k:\n                m = min(m, next_m[i][v])\n                s = s + next_s[i][v]\n                v = next_n[i][v]\n            cur >>= 1\n            i -= 1\n        result.append((s, m))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "next_m[k_log][u] = min(next_m[k_log - 1][v], m)",
      "mutated_line": "next_m[k_log][u] = min(next_m[k_log - 2][v], m)",
      "code": "def calculate_path_weights(n, k, f, w):\n    max_log = 35\n    next_n = [[-1] * n for _ in range(max_log)]\n    next_m = [[float('inf')] * n for _ in range(max_log)]\n    next_s = [[0] * n for _ in range(max_log)]\n    for u in range(n):\n        v = f[u]\n        next_n[0][u] = v\n        next_m[0][u] = w[u]\n        next_s[0][u] = w[u]\n    for k_log in range(1, max_log):\n        for u in range(n):\n            v = next_n[k_log - 1][u]\n            m = next_m[k_log - 1][u]\n            s = next_s[k_log - 1][u]\n            next_n[k_log][u] = next_n[k_log - 1][v]\n            next_m[k_log][u] = min(next_m[k_log - 2][v], m)\n            next_s[k_log][u] = next_s[k_log - 1][v] + s\n    result = []\n    for u in range(n):\n        (s, m) = (0, float('inf'))\n        v = u\n        cur = 1 << max_log\n        i = max_log\n        while cur > 0:\n            if cur & k:\n                m = min(m, next_m[i][v])\n                s = s + next_s[i][v]\n                v = next_n[i][v]\n            cur >>= 1\n            i -= 1\n        result.append((s, m))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "next_m[k_log][u] = min(next_m[k_log - 1][v], m)",
      "mutated_line": "next_m[k_log][u] = min(next_m[k_log - 0][v], m)",
      "code": "def calculate_path_weights(n, k, f, w):\n    max_log = 35\n    next_n = [[-1] * n for _ in range(max_log)]\n    next_m = [[float('inf')] * n for _ in range(max_log)]\n    next_s = [[0] * n for _ in range(max_log)]\n    for u in range(n):\n        v = f[u]\n        next_n[0][u] = v\n        next_m[0][u] = w[u]\n        next_s[0][u] = w[u]\n    for k_log in range(1, max_log):\n        for u in range(n):\n            v = next_n[k_log - 1][u]\n            m = next_m[k_log - 1][u]\n            s = next_s[k_log - 1][u]\n            next_n[k_log][u] = next_n[k_log - 1][v]\n            next_m[k_log][u] = min(next_m[k_log - 0][v], m)\n            next_s[k_log][u] = next_s[k_log - 1][v] + s\n    result = []\n    for u in range(n):\n        (s, m) = (0, float('inf'))\n        v = u\n        cur = 1 << max_log\n        i = max_log\n        while cur > 0:\n            if cur & k:\n                m = min(m, next_m[i][v])\n                s = s + next_s[i][v]\n                v = next_n[i][v]\n            cur >>= 1\n            i -= 1\n        result.append((s, m))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "next_m[k_log][u] = min(next_m[k_log - 1][v], m)",
      "mutated_line": "next_m[k_log][u] = min(next_m[k_log - 0][v], m)",
      "code": "def calculate_path_weights(n, k, f, w):\n    max_log = 35\n    next_n = [[-1] * n for _ in range(max_log)]\n    next_m = [[float('inf')] * n for _ in range(max_log)]\n    next_s = [[0] * n for _ in range(max_log)]\n    for u in range(n):\n        v = f[u]\n        next_n[0][u] = v\n        next_m[0][u] = w[u]\n        next_s[0][u] = w[u]\n    for k_log in range(1, max_log):\n        for u in range(n):\n            v = next_n[k_log - 1][u]\n            m = next_m[k_log - 1][u]\n            s = next_s[k_log - 1][u]\n            next_n[k_log][u] = next_n[k_log - 1][v]\n            next_m[k_log][u] = min(next_m[k_log - 0][v], m)\n            next_s[k_log][u] = next_s[k_log - 1][v] + s\n    result = []\n    for u in range(n):\n        (s, m) = (0, float('inf'))\n        v = u\n        cur = 1 << max_log\n        i = max_log\n        while cur > 0:\n            if cur & k:\n                m = min(m, next_m[i][v])\n                s = s + next_s[i][v]\n                v = next_n[i][v]\n            cur >>= 1\n            i -= 1\n        result.append((s, m))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "next_m[k_log][u] = min(next_m[k_log - 1][v], m)",
      "mutated_line": "next_m[k_log][u] = min(next_m[k_log - -1][v], m)",
      "code": "def calculate_path_weights(n, k, f, w):\n    max_log = 35\n    next_n = [[-1] * n for _ in range(max_log)]\n    next_m = [[float('inf')] * n for _ in range(max_log)]\n    next_s = [[0] * n for _ in range(max_log)]\n    for u in range(n):\n        v = f[u]\n        next_n[0][u] = v\n        next_m[0][u] = w[u]\n        next_s[0][u] = w[u]\n    for k_log in range(1, max_log):\n        for u in range(n):\n            v = next_n[k_log - 1][u]\n            m = next_m[k_log - 1][u]\n            s = next_s[k_log - 1][u]\n            next_n[k_log][u] = next_n[k_log - 1][v]\n            next_m[k_log][u] = min(next_m[k_log - -1][v], m)\n            next_s[k_log][u] = next_s[k_log - 1][v] + s\n    result = []\n    for u in range(n):\n        (s, m) = (0, float('inf'))\n        v = u\n        cur = 1 << max_log\n        i = max_log\n        while cur > 0:\n            if cur & k:\n                m = min(m, next_m[i][v])\n                s = s + next_s[i][v]\n                v = next_n[i][v]\n            cur >>= 1\n            i -= 1\n        result.append((s, m))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "next_s[k_log][u] = next_s[k_log - 1][v] + s",
      "mutated_line": "next_s[k_log][u] = next_s[k_log - 2][v] + s",
      "code": "def calculate_path_weights(n, k, f, w):\n    max_log = 35\n    next_n = [[-1] * n for _ in range(max_log)]\n    next_m = [[float('inf')] * n for _ in range(max_log)]\n    next_s = [[0] * n for _ in range(max_log)]\n    for u in range(n):\n        v = f[u]\n        next_n[0][u] = v\n        next_m[0][u] = w[u]\n        next_s[0][u] = w[u]\n    for k_log in range(1, max_log):\n        for u in range(n):\n            v = next_n[k_log - 1][u]\n            m = next_m[k_log - 1][u]\n            s = next_s[k_log - 1][u]\n            next_n[k_log][u] = next_n[k_log - 1][v]\n            next_m[k_log][u] = min(next_m[k_log - 1][v], m)\n            next_s[k_log][u] = next_s[k_log - 2][v] + s\n    result = []\n    for u in range(n):\n        (s, m) = (0, float('inf'))\n        v = u\n        cur = 1 << max_log\n        i = max_log\n        while cur > 0:\n            if cur & k:\n                m = min(m, next_m[i][v])\n                s = s + next_s[i][v]\n                v = next_n[i][v]\n            cur >>= 1\n            i -= 1\n        result.append((s, m))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "next_s[k_log][u] = next_s[k_log - 1][v] + s",
      "mutated_line": "next_s[k_log][u] = next_s[k_log - 0][v] + s",
      "code": "def calculate_path_weights(n, k, f, w):\n    max_log = 35\n    next_n = [[-1] * n for _ in range(max_log)]\n    next_m = [[float('inf')] * n for _ in range(max_log)]\n    next_s = [[0] * n for _ in range(max_log)]\n    for u in range(n):\n        v = f[u]\n        next_n[0][u] = v\n        next_m[0][u] = w[u]\n        next_s[0][u] = w[u]\n    for k_log in range(1, max_log):\n        for u in range(n):\n            v = next_n[k_log - 1][u]\n            m = next_m[k_log - 1][u]\n            s = next_s[k_log - 1][u]\n            next_n[k_log][u] = next_n[k_log - 1][v]\n            next_m[k_log][u] = min(next_m[k_log - 1][v], m)\n            next_s[k_log][u] = next_s[k_log - 0][v] + s\n    result = []\n    for u in range(n):\n        (s, m) = (0, float('inf'))\n        v = u\n        cur = 1 << max_log\n        i = max_log\n        while cur > 0:\n            if cur & k:\n                m = min(m, next_m[i][v])\n                s = s + next_s[i][v]\n                v = next_n[i][v]\n            cur >>= 1\n            i -= 1\n        result.append((s, m))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "next_s[k_log][u] = next_s[k_log - 1][v] + s",
      "mutated_line": "next_s[k_log][u] = next_s[k_log - 0][v] + s",
      "code": "def calculate_path_weights(n, k, f, w):\n    max_log = 35\n    next_n = [[-1] * n for _ in range(max_log)]\n    next_m = [[float('inf')] * n for _ in range(max_log)]\n    next_s = [[0] * n for _ in range(max_log)]\n    for u in range(n):\n        v = f[u]\n        next_n[0][u] = v\n        next_m[0][u] = w[u]\n        next_s[0][u] = w[u]\n    for k_log in range(1, max_log):\n        for u in range(n):\n            v = next_n[k_log - 1][u]\n            m = next_m[k_log - 1][u]\n            s = next_s[k_log - 1][u]\n            next_n[k_log][u] = next_n[k_log - 1][v]\n            next_m[k_log][u] = min(next_m[k_log - 1][v], m)\n            next_s[k_log][u] = next_s[k_log - 0][v] + s\n    result = []\n    for u in range(n):\n        (s, m) = (0, float('inf'))\n        v = u\n        cur = 1 << max_log\n        i = max_log\n        while cur > 0:\n            if cur & k:\n                m = min(m, next_m[i][v])\n                s = s + next_s[i][v]\n                v = next_n[i][v]\n            cur >>= 1\n            i -= 1\n        result.append((s, m))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "next_s[k_log][u] = next_s[k_log - 1][v] + s",
      "mutated_line": "next_s[k_log][u] = next_s[k_log - -1][v] + s",
      "code": "def calculate_path_weights(n, k, f, w):\n    max_log = 35\n    next_n = [[-1] * n for _ in range(max_log)]\n    next_m = [[float('inf')] * n for _ in range(max_log)]\n    next_s = [[0] * n for _ in range(max_log)]\n    for u in range(n):\n        v = f[u]\n        next_n[0][u] = v\n        next_m[0][u] = w[u]\n        next_s[0][u] = w[u]\n    for k_log in range(1, max_log):\n        for u in range(n):\n            v = next_n[k_log - 1][u]\n            m = next_m[k_log - 1][u]\n            s = next_s[k_log - 1][u]\n            next_n[k_log][u] = next_n[k_log - 1][v]\n            next_m[k_log][u] = min(next_m[k_log - 1][v], m)\n            next_s[k_log][u] = next_s[k_log - -1][v] + s\n    result = []\n    for u in range(n):\n        (s, m) = (0, float('inf'))\n        v = u\n        cur = 1 << max_log\n        i = max_log\n        while cur > 0:\n            if cur & k:\n                m = min(m, next_m[i][v])\n                s = s + next_s[i][v]\n                v = next_n[i][v]\n            cur >>= 1\n            i -= 1\n        result.append((s, m))\n    return result"
    }
  ]
}