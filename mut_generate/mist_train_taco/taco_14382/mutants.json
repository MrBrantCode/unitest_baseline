{
  "task_id": "taco_14382",
  "entry_point": "find_max_degree_spanning_tree",
  "mutant_count": 51,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "mx = [0] * (n + 1)",
      "mutated_line": "mx = [0] / (n + 1)",
      "code": "def find_max_degree_spanning_tree(n, m, edges):\n    ar = [[] for _ in range(n + 1)]\n    mx = [0] / (n + 1)\n    for (x, y) in edges:\n        mx[x] += 1\n        mx[y] += 1\n        ar[x].append(y)\n        ar[y].append(x)\n    st = mx.index(max(mx))\n    used = [False] * (n + 1)\n    ans = []\n    q = []\n    used[st] = True\n\n    def bfs(st, tt=0):\n        q.append(st)\n        while tt < len(q):\n            v = q[tt]\n            for i in ar[v]:\n                if not used[i]:\n                    used[i] = True\n                    q.append(i)\n                    ans.append((v, i))\n            tt += 1\n    bfs(st)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "mx = [0] * (n + 1)",
      "mutated_line": "mx = [0] + (n + 1)",
      "code": "def find_max_degree_spanning_tree(n, m, edges):\n    ar = [[] for _ in range(n + 1)]\n    mx = [0] + (n + 1)\n    for (x, y) in edges:\n        mx[x] += 1\n        mx[y] += 1\n        ar[x].append(y)\n        ar[y].append(x)\n    st = mx.index(max(mx))\n    used = [False] * (n + 1)\n    ans = []\n    q = []\n    used[st] = True\n\n    def bfs(st, tt=0):\n        q.append(st)\n        while tt < len(q):\n            v = q[tt]\n            for i in ar[v]:\n                if not used[i]:\n                    used[i] = True\n                    q.append(i)\n                    ans.append((v, i))\n            tt += 1\n    bfs(st)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "mx = [0] * (n + 1)",
      "mutated_line": "mx = [0] ** (n + 1)",
      "code": "def find_max_degree_spanning_tree(n, m, edges):\n    ar = [[] for _ in range(n + 1)]\n    mx = [0] ** (n + 1)\n    for (x, y) in edges:\n        mx[x] += 1\n        mx[y] += 1\n        ar[x].append(y)\n        ar[y].append(x)\n    st = mx.index(max(mx))\n    used = [False] * (n + 1)\n    ans = []\n    q = []\n    used[st] = True\n\n    def bfs(st, tt=0):\n        q.append(st)\n        while tt < len(q):\n            v = q[tt]\n            for i in ar[v]:\n                if not used[i]:\n                    used[i] = True\n                    q.append(i)\n                    ans.append((v, i))\n            tt += 1\n    bfs(st)\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 8,
      "original_line": "mx[x] += 1",
      "mutated_line": "mx[x] -= 1",
      "code": "def find_max_degree_spanning_tree(n, m, edges):\n    ar = [[] for _ in range(n + 1)]\n    mx = [0] * (n + 1)\n    for (x, y) in edges:\n        mx[x] -= 1\n        mx[y] += 1\n        ar[x].append(y)\n        ar[y].append(x)\n    st = mx.index(max(mx))\n    used = [False] * (n + 1)\n    ans = []\n    q = []\n    used[st] = True\n\n    def bfs(st, tt=0):\n        q.append(st)\n        while tt < len(q):\n            v = q[tt]\n            for i in ar[v]:\n                if not used[i]:\n                    used[i] = True\n                    q.append(i)\n                    ans.append((v, i))\n            tt += 1\n    bfs(st)\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 9,
      "original_line": "mx[y] += 1",
      "mutated_line": "mx[y] -= 1",
      "code": "def find_max_degree_spanning_tree(n, m, edges):\n    ar = [[] for _ in range(n + 1)]\n    mx = [0] * (n + 1)\n    for (x, y) in edges:\n        mx[x] += 1\n        mx[y] -= 1\n        ar[x].append(y)\n        ar[y].append(x)\n    st = mx.index(max(mx))\n    used = [False] * (n + 1)\n    ans = []\n    q = []\n    used[st] = True\n\n    def bfs(st, tt=0):\n        q.append(st)\n        while tt < len(q):\n            v = q[tt]\n            for i in ar[v]:\n                if not used[i]:\n                    used[i] = True\n                    q.append(i)\n                    ans.append((v, i))\n            tt += 1\n    bfs(st)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "used = [False] * (n + 1)",
      "mutated_line": "used = [False] / (n + 1)",
      "code": "def find_max_degree_spanning_tree(n, m, edges):\n    ar = [[] for _ in range(n + 1)]\n    mx = [0] * (n + 1)\n    for (x, y) in edges:\n        mx[x] += 1\n        mx[y] += 1\n        ar[x].append(y)\n        ar[y].append(x)\n    st = mx.index(max(mx))\n    used = [False] / (n + 1)\n    ans = []\n    q = []\n    used[st] = True\n\n    def bfs(st, tt=0):\n        q.append(st)\n        while tt < len(q):\n            v = q[tt]\n            for i in ar[v]:\n                if not used[i]:\n                    used[i] = True\n                    q.append(i)\n                    ans.append((v, i))\n            tt += 1\n    bfs(st)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "used = [False] * (n + 1)",
      "mutated_line": "used = [False] + (n + 1)",
      "code": "def find_max_degree_spanning_tree(n, m, edges):\n    ar = [[] for _ in range(n + 1)]\n    mx = [0] * (n + 1)\n    for (x, y) in edges:\n        mx[x] += 1\n        mx[y] += 1\n        ar[x].append(y)\n        ar[y].append(x)\n    st = mx.index(max(mx))\n    used = [False] + (n + 1)\n    ans = []\n    q = []\n    used[st] = True\n\n    def bfs(st, tt=0):\n        q.append(st)\n        while tt < len(q):\n            v = q[tt]\n            for i in ar[v]:\n                if not used[i]:\n                    used[i] = True\n                    q.append(i)\n                    ans.append((v, i))\n            tt += 1\n    bfs(st)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "used = [False] * (n + 1)",
      "mutated_line": "used = [False] ** (n + 1)",
      "code": "def find_max_degree_spanning_tree(n, m, edges):\n    ar = [[] for _ in range(n + 1)]\n    mx = [0] * (n + 1)\n    for (x, y) in edges:\n        mx[x] += 1\n        mx[y] += 1\n        ar[x].append(y)\n        ar[y].append(x)\n    st = mx.index(max(mx))\n    used = [False] ** (n + 1)\n    ans = []\n    q = []\n    used[st] = True\n\n    def bfs(st, tt=0):\n        q.append(st)\n        while tt < len(q):\n            v = q[tt]\n            for i in ar[v]:\n                if not used[i]:\n                    used[i] = True\n                    q.append(i)\n                    ans.append((v, i))\n            tt += 1\n    bfs(st)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "used[st] = True",
      "mutated_line": "used[st] = False",
      "code": "def find_max_degree_spanning_tree(n, m, edges):\n    ar = [[] for _ in range(n + 1)]\n    mx = [0] * (n + 1)\n    for (x, y) in edges:\n        mx[x] += 1\n        mx[y] += 1\n        ar[x].append(y)\n        ar[y].append(x)\n    st = mx.index(max(mx))\n    used = [False] * (n + 1)\n    ans = []\n    q = []\n    used[st] = False\n\n    def bfs(st, tt=0):\n        q.append(st)\n        while tt < len(q):\n            v = q[tt]\n            for i in ar[v]:\n                if not used[i]:\n                    used[i] = True\n                    q.append(i)\n                    ans.append((v, i))\n            tt += 1\n    bfs(st)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "mx = [0] * (n + 1)",
      "mutated_line": "mx = [0] * (n - 1)",
      "code": "def find_max_degree_spanning_tree(n, m, edges):\n    ar = [[] for _ in range(n + 1)]\n    mx = [0] * (n - 1)\n    for (x, y) in edges:\n        mx[x] += 1\n        mx[y] += 1\n        ar[x].append(y)\n        ar[y].append(x)\n    st = mx.index(max(mx))\n    used = [False] * (n + 1)\n    ans = []\n    q = []\n    used[st] = True\n\n    def bfs(st, tt=0):\n        q.append(st)\n        while tt < len(q):\n            v = q[tt]\n            for i in ar[v]:\n                if not used[i]:\n                    used[i] = True\n                    q.append(i)\n                    ans.append((v, i))\n            tt += 1\n    bfs(st)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "mx = [0] * (n + 1)",
      "mutated_line": "mx = [0] * (n * 1)",
      "code": "def find_max_degree_spanning_tree(n, m, edges):\n    ar = [[] for _ in range(n + 1)]\n    mx = [0] * (n * 1)\n    for (x, y) in edges:\n        mx[x] += 1\n        mx[y] += 1\n        ar[x].append(y)\n        ar[y].append(x)\n    st = mx.index(max(mx))\n    used = [False] * (n + 1)\n    ans = []\n    q = []\n    used[st] = True\n\n    def bfs(st, tt=0):\n        q.append(st)\n        while tt < len(q):\n            v = q[tt]\n            for i in ar[v]:\n                if not used[i]:\n                    used[i] = True\n                    q.append(i)\n                    ans.append((v, i))\n            tt += 1\n    bfs(st)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "mx[x] += 1",
      "mutated_line": "mx[x] += 2",
      "code": "def find_max_degree_spanning_tree(n, m, edges):\n    ar = [[] for _ in range(n + 1)]\n    mx = [0] * (n + 1)\n    for (x, y) in edges:\n        mx[x] += 2\n        mx[y] += 1\n        ar[x].append(y)\n        ar[y].append(x)\n    st = mx.index(max(mx))\n    used = [False] * (n + 1)\n    ans = []\n    q = []\n    used[st] = True\n\n    def bfs(st, tt=0):\n        q.append(st)\n        while tt < len(q):\n            v = q[tt]\n            for i in ar[v]:\n                if not used[i]:\n                    used[i] = True\n                    q.append(i)\n                    ans.append((v, i))\n            tt += 1\n    bfs(st)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "mx[x] += 1",
      "mutated_line": "mx[x] += 0",
      "code": "def find_max_degree_spanning_tree(n, m, edges):\n    ar = [[] for _ in range(n + 1)]\n    mx = [0] * (n + 1)\n    for (x, y) in edges:\n        mx[x] += 0\n        mx[y] += 1\n        ar[x].append(y)\n        ar[y].append(x)\n    st = mx.index(max(mx))\n    used = [False] * (n + 1)\n    ans = []\n    q = []\n    used[st] = True\n\n    def bfs(st, tt=0):\n        q.append(st)\n        while tt < len(q):\n            v = q[tt]\n            for i in ar[v]:\n                if not used[i]:\n                    used[i] = True\n                    q.append(i)\n                    ans.append((v, i))\n            tt += 1\n    bfs(st)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "mx[x] += 1",
      "mutated_line": "mx[x] += 0",
      "code": "def find_max_degree_spanning_tree(n, m, edges):\n    ar = [[] for _ in range(n + 1)]\n    mx = [0] * (n + 1)\n    for (x, y) in edges:\n        mx[x] += 0\n        mx[y] += 1\n        ar[x].append(y)\n        ar[y].append(x)\n    st = mx.index(max(mx))\n    used = [False] * (n + 1)\n    ans = []\n    q = []\n    used[st] = True\n\n    def bfs(st, tt=0):\n        q.append(st)\n        while tt < len(q):\n            v = q[tt]\n            for i in ar[v]:\n                if not used[i]:\n                    used[i] = True\n                    q.append(i)\n                    ans.append((v, i))\n            tt += 1\n    bfs(st)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "mx[x] += 1",
      "mutated_line": "mx[x] += -1",
      "code": "def find_max_degree_spanning_tree(n, m, edges):\n    ar = [[] for _ in range(n + 1)]\n    mx = [0] * (n + 1)\n    for (x, y) in edges:\n        mx[x] += -1\n        mx[y] += 1\n        ar[x].append(y)\n        ar[y].append(x)\n    st = mx.index(max(mx))\n    used = [False] * (n + 1)\n    ans = []\n    q = []\n    used[st] = True\n\n    def bfs(st, tt=0):\n        q.append(st)\n        while tt < len(q):\n            v = q[tt]\n            for i in ar[v]:\n                if not used[i]:\n                    used[i] = True\n                    q.append(i)\n                    ans.append((v, i))\n            tt += 1\n    bfs(st)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "mx[y] += 1",
      "mutated_line": "mx[y] += 2",
      "code": "def find_max_degree_spanning_tree(n, m, edges):\n    ar = [[] for _ in range(n + 1)]\n    mx = [0] * (n + 1)\n    for (x, y) in edges:\n        mx[x] += 1\n        mx[y] += 2\n        ar[x].append(y)\n        ar[y].append(x)\n    st = mx.index(max(mx))\n    used = [False] * (n + 1)\n    ans = []\n    q = []\n    used[st] = True\n\n    def bfs(st, tt=0):\n        q.append(st)\n        while tt < len(q):\n            v = q[tt]\n            for i in ar[v]:\n                if not used[i]:\n                    used[i] = True\n                    q.append(i)\n                    ans.append((v, i))\n            tt += 1\n    bfs(st)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "mx[y] += 1",
      "mutated_line": "mx[y] += 0",
      "code": "def find_max_degree_spanning_tree(n, m, edges):\n    ar = [[] for _ in range(n + 1)]\n    mx = [0] * (n + 1)\n    for (x, y) in edges:\n        mx[x] += 1\n        mx[y] += 0\n        ar[x].append(y)\n        ar[y].append(x)\n    st = mx.index(max(mx))\n    used = [False] * (n + 1)\n    ans = []\n    q = []\n    used[st] = True\n\n    def bfs(st, tt=0):\n        q.append(st)\n        while tt < len(q):\n            v = q[tt]\n            for i in ar[v]:\n                if not used[i]:\n                    used[i] = True\n                    q.append(i)\n                    ans.append((v, i))\n            tt += 1\n    bfs(st)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "mx[y] += 1",
      "mutated_line": "mx[y] += 0",
      "code": "def find_max_degree_spanning_tree(n, m, edges):\n    ar = [[] for _ in range(n + 1)]\n    mx = [0] * (n + 1)\n    for (x, y) in edges:\n        mx[x] += 1\n        mx[y] += 0\n        ar[x].append(y)\n        ar[y].append(x)\n    st = mx.index(max(mx))\n    used = [False] * (n + 1)\n    ans = []\n    q = []\n    used[st] = True\n\n    def bfs(st, tt=0):\n        q.append(st)\n        while tt < len(q):\n            v = q[tt]\n            for i in ar[v]:\n                if not used[i]:\n                    used[i] = True\n                    q.append(i)\n                    ans.append((v, i))\n            tt += 1\n    bfs(st)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "mx[y] += 1",
      "mutated_line": "mx[y] += -1",
      "code": "def find_max_degree_spanning_tree(n, m, edges):\n    ar = [[] for _ in range(n + 1)]\n    mx = [0] * (n + 1)\n    for (x, y) in edges:\n        mx[x] += 1\n        mx[y] += -1\n        ar[x].append(y)\n        ar[y].append(x)\n    st = mx.index(max(mx))\n    used = [False] * (n + 1)\n    ans = []\n    q = []\n    used[st] = True\n\n    def bfs(st, tt=0):\n        q.append(st)\n        while tt < len(q):\n            v = q[tt]\n            for i in ar[v]:\n                if not used[i]:\n                    used[i] = True\n                    q.append(i)\n                    ans.append((v, i))\n            tt += 1\n    bfs(st)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "used = [False] * (n + 1)",
      "mutated_line": "used = [False] * (n - 1)",
      "code": "def find_max_degree_spanning_tree(n, m, edges):\n    ar = [[] for _ in range(n + 1)]\n    mx = [0] * (n + 1)\n    for (x, y) in edges:\n        mx[x] += 1\n        mx[y] += 1\n        ar[x].append(y)\n        ar[y].append(x)\n    st = mx.index(max(mx))\n    used = [False] * (n - 1)\n    ans = []\n    q = []\n    used[st] = True\n\n    def bfs(st, tt=0):\n        q.append(st)\n        while tt < len(q):\n            v = q[tt]\n            for i in ar[v]:\n                if not used[i]:\n                    used[i] = True\n                    q.append(i)\n                    ans.append((v, i))\n            tt += 1\n    bfs(st)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "used = [False] * (n + 1)",
      "mutated_line": "used = [False] * (n * 1)",
      "code": "def find_max_degree_spanning_tree(n, m, edges):\n    ar = [[] for _ in range(n + 1)]\n    mx = [0] * (n + 1)\n    for (x, y) in edges:\n        mx[x] += 1\n        mx[y] += 1\n        ar[x].append(y)\n        ar[y].append(x)\n    st = mx.index(max(mx))\n    used = [False] * (n * 1)\n    ans = []\n    q = []\n    used[st] = True\n\n    def bfs(st, tt=0):\n        q.append(st)\n        while tt < len(q):\n            v = q[tt]\n            for i in ar[v]:\n                if not used[i]:\n                    used[i] = True\n                    q.append(i)\n                    ans.append((v, i))\n            tt += 1\n    bfs(st)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "def bfs(st, tt=0):",
      "mutated_line": "def bfs(st, tt=1):",
      "code": "def find_max_degree_spanning_tree(n, m, edges):\n    ar = [[] for _ in range(n + 1)]\n    mx = [0] * (n + 1)\n    for (x, y) in edges:\n        mx[x] += 1\n        mx[y] += 1\n        ar[x].append(y)\n        ar[y].append(x)\n    st = mx.index(max(mx))\n    used = [False] * (n + 1)\n    ans = []\n    q = []\n    used[st] = True\n\n    def bfs(st, tt=1):\n        q.append(st)\n        while tt < len(q):\n            v = q[tt]\n            for i in ar[v]:\n                if not used[i]:\n                    used[i] = True\n                    q.append(i)\n                    ans.append((v, i))\n            tt += 1\n    bfs(st)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "def bfs(st, tt=0):",
      "mutated_line": "def bfs(st, tt=-1):",
      "code": "def find_max_degree_spanning_tree(n, m, edges):\n    ar = [[] for _ in range(n + 1)]\n    mx = [0] * (n + 1)\n    for (x, y) in edges:\n        mx[x] += 1\n        mx[y] += 1\n        ar[x].append(y)\n        ar[y].append(x)\n    st = mx.index(max(mx))\n    used = [False] * (n + 1)\n    ans = []\n    q = []\n    used[st] = True\n\n    def bfs(st, tt=-1):\n        q.append(st)\n        while tt < len(q):\n            v = q[tt]\n            for i in ar[v]:\n                if not used[i]:\n                    used[i] = True\n                    q.append(i)\n                    ans.append((v, i))\n            tt += 1\n    bfs(st)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "def bfs(st, tt=0):",
      "mutated_line": "def bfs(st, tt=1):",
      "code": "def find_max_degree_spanning_tree(n, m, edges):\n    ar = [[] for _ in range(n + 1)]\n    mx = [0] * (n + 1)\n    for (x, y) in edges:\n        mx[x] += 1\n        mx[y] += 1\n        ar[x].append(y)\n        ar[y].append(x)\n    st = mx.index(max(mx))\n    used = [False] * (n + 1)\n    ans = []\n    q = []\n    used[st] = True\n\n    def bfs(st, tt=1):\n        q.append(st)\n        while tt < len(q):\n            v = q[tt]\n            for i in ar[v]:\n                if not used[i]:\n                    used[i] = True\n                    q.append(i)\n                    ans.append((v, i))\n            tt += 1\n    bfs(st)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "while tt < len(q):",
      "mutated_line": "while tt <= len(q):",
      "code": "def find_max_degree_spanning_tree(n, m, edges):\n    ar = [[] for _ in range(n + 1)]\n    mx = [0] * (n + 1)\n    for (x, y) in edges:\n        mx[x] += 1\n        mx[y] += 1\n        ar[x].append(y)\n        ar[y].append(x)\n    st = mx.index(max(mx))\n    used = [False] * (n + 1)\n    ans = []\n    q = []\n    used[st] = True\n\n    def bfs(st, tt=0):\n        q.append(st)\n        while tt <= len(q):\n            v = q[tt]\n            for i in ar[v]:\n                if not used[i]:\n                    used[i] = True\n                    q.append(i)\n                    ans.append((v, i))\n            tt += 1\n    bfs(st)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "while tt < len(q):",
      "mutated_line": "while tt >= len(q):",
      "code": "def find_max_degree_spanning_tree(n, m, edges):\n    ar = [[] for _ in range(n + 1)]\n    mx = [0] * (n + 1)\n    for (x, y) in edges:\n        mx[x] += 1\n        mx[y] += 1\n        ar[x].append(y)\n        ar[y].append(x)\n    st = mx.index(max(mx))\n    used = [False] * (n + 1)\n    ans = []\n    q = []\n    used[st] = True\n\n    def bfs(st, tt=0):\n        q.append(st)\n        while tt >= len(q):\n            v = q[tt]\n            for i in ar[v]:\n                if not used[i]:\n                    used[i] = True\n                    q.append(i)\n                    ans.append((v, i))\n            tt += 1\n    bfs(st)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "while tt < len(q):",
      "mutated_line": "while tt != len(q):",
      "code": "def find_max_degree_spanning_tree(n, m, edges):\n    ar = [[] for _ in range(n + 1)]\n    mx = [0] * (n + 1)\n    for (x, y) in edges:\n        mx[x] += 1\n        mx[y] += 1\n        ar[x].append(y)\n        ar[y].append(x)\n    st = mx.index(max(mx))\n    used = [False] * (n + 1)\n    ans = []\n    q = []\n    used[st] = True\n\n    def bfs(st, tt=0):\n        q.append(st)\n        while tt != len(q):\n            v = q[tt]\n            for i in ar[v]:\n                if not used[i]:\n                    used[i] = True\n                    q.append(i)\n                    ans.append((v, i))\n            tt += 1\n    bfs(st)\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 32,
      "original_line": "tt += 1",
      "mutated_line": "tt -= 1",
      "code": "def find_max_degree_spanning_tree(n, m, edges):\n    ar = [[] for _ in range(n + 1)]\n    mx = [0] * (n + 1)\n    for (x, y) in edges:\n        mx[x] += 1\n        mx[y] += 1\n        ar[x].append(y)\n        ar[y].append(x)\n    st = mx.index(max(mx))\n    used = [False] * (n + 1)\n    ans = []\n    q = []\n    used[st] = True\n\n    def bfs(st, tt=0):\n        q.append(st)\n        while tt < len(q):\n            v = q[tt]\n            for i in ar[v]:\n                if not used[i]:\n                    used[i] = True\n                    q.append(i)\n                    ans.append((v, i))\n            tt -= 1\n    bfs(st)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "mx = [0] * (n + 1)",
      "mutated_line": "mx = [1] * (n + 1)",
      "code": "def find_max_degree_spanning_tree(n, m, edges):\n    ar = [[] for _ in range(n + 1)]\n    mx = [1] * (n + 1)\n    for (x, y) in edges:\n        mx[x] += 1\n        mx[y] += 1\n        ar[x].append(y)\n        ar[y].append(x)\n    st = mx.index(max(mx))\n    used = [False] * (n + 1)\n    ans = []\n    q = []\n    used[st] = True\n\n    def bfs(st, tt=0):\n        q.append(st)\n        while tt < len(q):\n            v = q[tt]\n            for i in ar[v]:\n                if not used[i]:\n                    used[i] = True\n                    q.append(i)\n                    ans.append((v, i))\n            tt += 1\n    bfs(st)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "mx = [0] * (n + 1)",
      "mutated_line": "mx = [-1] * (n + 1)",
      "code": "def find_max_degree_spanning_tree(n, m, edges):\n    ar = [[] for _ in range(n + 1)]\n    mx = [-1] * (n + 1)\n    for (x, y) in edges:\n        mx[x] += 1\n        mx[y] += 1\n        ar[x].append(y)\n        ar[y].append(x)\n    st = mx.index(max(mx))\n    used = [False] * (n + 1)\n    ans = []\n    q = []\n    used[st] = True\n\n    def bfs(st, tt=0):\n        q.append(st)\n        while tt < len(q):\n            v = q[tt]\n            for i in ar[v]:\n                if not used[i]:\n                    used[i] = True\n                    q.append(i)\n                    ans.append((v, i))\n            tt += 1\n    bfs(st)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "mx = [0] * (n + 1)",
      "mutated_line": "mx = [1] * (n + 1)",
      "code": "def find_max_degree_spanning_tree(n, m, edges):\n    ar = [[] for _ in range(n + 1)]\n    mx = [1] * (n + 1)\n    for (x, y) in edges:\n        mx[x] += 1\n        mx[y] += 1\n        ar[x].append(y)\n        ar[y].append(x)\n    st = mx.index(max(mx))\n    used = [False] * (n + 1)\n    ans = []\n    q = []\n    used[st] = True\n\n    def bfs(st, tt=0):\n        q.append(st)\n        while tt < len(q):\n            v = q[tt]\n            for i in ar[v]:\n                if not used[i]:\n                    used[i] = True\n                    q.append(i)\n                    ans.append((v, i))\n            tt += 1\n    bfs(st)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "mx = [0] * (n + 1)",
      "mutated_line": "mx = [0] * (n + 2)",
      "code": "def find_max_degree_spanning_tree(n, m, edges):\n    ar = [[] for _ in range(n + 1)]\n    mx = [0] * (n + 2)\n    for (x, y) in edges:\n        mx[x] += 1\n        mx[y] += 1\n        ar[x].append(y)\n        ar[y].append(x)\n    st = mx.index(max(mx))\n    used = [False] * (n + 1)\n    ans = []\n    q = []\n    used[st] = True\n\n    def bfs(st, tt=0):\n        q.append(st)\n        while tt < len(q):\n            v = q[tt]\n            for i in ar[v]:\n                if not used[i]:\n                    used[i] = True\n                    q.append(i)\n                    ans.append((v, i))\n            tt += 1\n    bfs(st)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "mx = [0] * (n + 1)",
      "mutated_line": "mx = [0] * (n + 0)",
      "code": "def find_max_degree_spanning_tree(n, m, edges):\n    ar = [[] for _ in range(n + 1)]\n    mx = [0] * (n + 0)\n    for (x, y) in edges:\n        mx[x] += 1\n        mx[y] += 1\n        ar[x].append(y)\n        ar[y].append(x)\n    st = mx.index(max(mx))\n    used = [False] * (n + 1)\n    ans = []\n    q = []\n    used[st] = True\n\n    def bfs(st, tt=0):\n        q.append(st)\n        while tt < len(q):\n            v = q[tt]\n            for i in ar[v]:\n                if not used[i]:\n                    used[i] = True\n                    q.append(i)\n                    ans.append((v, i))\n            tt += 1\n    bfs(st)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "mx = [0] * (n + 1)",
      "mutated_line": "mx = [0] * (n + 0)",
      "code": "def find_max_degree_spanning_tree(n, m, edges):\n    ar = [[] for _ in range(n + 1)]\n    mx = [0] * (n + 0)\n    for (x, y) in edges:\n        mx[x] += 1\n        mx[y] += 1\n        ar[x].append(y)\n        ar[y].append(x)\n    st = mx.index(max(mx))\n    used = [False] * (n + 1)\n    ans = []\n    q = []\n    used[st] = True\n\n    def bfs(st, tt=0):\n        q.append(st)\n        while tt < len(q):\n            v = q[tt]\n            for i in ar[v]:\n                if not used[i]:\n                    used[i] = True\n                    q.append(i)\n                    ans.append((v, i))\n            tt += 1\n    bfs(st)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "mx = [0] * (n + 1)",
      "mutated_line": "mx = [0] * (n + -1)",
      "code": "def find_max_degree_spanning_tree(n, m, edges):\n    ar = [[] for _ in range(n + 1)]\n    mx = [0] * (n + -1)\n    for (x, y) in edges:\n        mx[x] += 1\n        mx[y] += 1\n        ar[x].append(y)\n        ar[y].append(x)\n    st = mx.index(max(mx))\n    used = [False] * (n + 1)\n    ans = []\n    q = []\n    used[st] = True\n\n    def bfs(st, tt=0):\n        q.append(st)\n        while tt < len(q):\n            v = q[tt]\n            for i in ar[v]:\n                if not used[i]:\n                    used[i] = True\n                    q.append(i)\n                    ans.append((v, i))\n            tt += 1\n    bfs(st)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "used = [False] * (n + 1)",
      "mutated_line": "used = [True] * (n + 1)",
      "code": "def find_max_degree_spanning_tree(n, m, edges):\n    ar = [[] for _ in range(n + 1)]\n    mx = [0] * (n + 1)\n    for (x, y) in edges:\n        mx[x] += 1\n        mx[y] += 1\n        ar[x].append(y)\n        ar[y].append(x)\n    st = mx.index(max(mx))\n    used = [True] * (n + 1)\n    ans = []\n    q = []\n    used[st] = True\n\n    def bfs(st, tt=0):\n        q.append(st)\n        while tt < len(q):\n            v = q[tt]\n            for i in ar[v]:\n                if not used[i]:\n                    used[i] = True\n                    q.append(i)\n                    ans.append((v, i))\n            tt += 1\n    bfs(st)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "used = [False] * (n + 1)",
      "mutated_line": "used = [False] * (n + 2)",
      "code": "def find_max_degree_spanning_tree(n, m, edges):\n    ar = [[] for _ in range(n + 1)]\n    mx = [0] * (n + 1)\n    for (x, y) in edges:\n        mx[x] += 1\n        mx[y] += 1\n        ar[x].append(y)\n        ar[y].append(x)\n    st = mx.index(max(mx))\n    used = [False] * (n + 2)\n    ans = []\n    q = []\n    used[st] = True\n\n    def bfs(st, tt=0):\n        q.append(st)\n        while tt < len(q):\n            v = q[tt]\n            for i in ar[v]:\n                if not used[i]:\n                    used[i] = True\n                    q.append(i)\n                    ans.append((v, i))\n            tt += 1\n    bfs(st)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "used = [False] * (n + 1)",
      "mutated_line": "used = [False] * (n + 0)",
      "code": "def find_max_degree_spanning_tree(n, m, edges):\n    ar = [[] for _ in range(n + 1)]\n    mx = [0] * (n + 1)\n    for (x, y) in edges:\n        mx[x] += 1\n        mx[y] += 1\n        ar[x].append(y)\n        ar[y].append(x)\n    st = mx.index(max(mx))\n    used = [False] * (n + 0)\n    ans = []\n    q = []\n    used[st] = True\n\n    def bfs(st, tt=0):\n        q.append(st)\n        while tt < len(q):\n            v = q[tt]\n            for i in ar[v]:\n                if not used[i]:\n                    used[i] = True\n                    q.append(i)\n                    ans.append((v, i))\n            tt += 1\n    bfs(st)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "used = [False] * (n + 1)",
      "mutated_line": "used = [False] * (n + 0)",
      "code": "def find_max_degree_spanning_tree(n, m, edges):\n    ar = [[] for _ in range(n + 1)]\n    mx = [0] * (n + 1)\n    for (x, y) in edges:\n        mx[x] += 1\n        mx[y] += 1\n        ar[x].append(y)\n        ar[y].append(x)\n    st = mx.index(max(mx))\n    used = [False] * (n + 0)\n    ans = []\n    q = []\n    used[st] = True\n\n    def bfs(st, tt=0):\n        q.append(st)\n        while tt < len(q):\n            v = q[tt]\n            for i in ar[v]:\n                if not used[i]:\n                    used[i] = True\n                    q.append(i)\n                    ans.append((v, i))\n            tt += 1\n    bfs(st)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "used = [False] * (n + 1)",
      "mutated_line": "used = [False] * (n + -1)",
      "code": "def find_max_degree_spanning_tree(n, m, edges):\n    ar = [[] for _ in range(n + 1)]\n    mx = [0] * (n + 1)\n    for (x, y) in edges:\n        mx[x] += 1\n        mx[y] += 1\n        ar[x].append(y)\n        ar[y].append(x)\n    st = mx.index(max(mx))\n    used = [False] * (n + -1)\n    ans = []\n    q = []\n    used[st] = True\n\n    def bfs(st, tt=0):\n        q.append(st)\n        while tt < len(q):\n            v = q[tt]\n            for i in ar[v]:\n                if not used[i]:\n                    used[i] = True\n                    q.append(i)\n                    ans.append((v, i))\n            tt += 1\n    bfs(st)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "tt += 1",
      "mutated_line": "tt += 2",
      "code": "def find_max_degree_spanning_tree(n, m, edges):\n    ar = [[] for _ in range(n + 1)]\n    mx = [0] * (n + 1)\n    for (x, y) in edges:\n        mx[x] += 1\n        mx[y] += 1\n        ar[x].append(y)\n        ar[y].append(x)\n    st = mx.index(max(mx))\n    used = [False] * (n + 1)\n    ans = []\n    q = []\n    used[st] = True\n\n    def bfs(st, tt=0):\n        q.append(st)\n        while tt < len(q):\n            v = q[tt]\n            for i in ar[v]:\n                if not used[i]:\n                    used[i] = True\n                    q.append(i)\n                    ans.append((v, i))\n            tt += 2\n    bfs(st)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "tt += 1",
      "mutated_line": "tt += 0",
      "code": "def find_max_degree_spanning_tree(n, m, edges):\n    ar = [[] for _ in range(n + 1)]\n    mx = [0] * (n + 1)\n    for (x, y) in edges:\n        mx[x] += 1\n        mx[y] += 1\n        ar[x].append(y)\n        ar[y].append(x)\n    st = mx.index(max(mx))\n    used = [False] * (n + 1)\n    ans = []\n    q = []\n    used[st] = True\n\n    def bfs(st, tt=0):\n        q.append(st)\n        while tt < len(q):\n            v = q[tt]\n            for i in ar[v]:\n                if not used[i]:\n                    used[i] = True\n                    q.append(i)\n                    ans.append((v, i))\n            tt += 0\n    bfs(st)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "tt += 1",
      "mutated_line": "tt += 0",
      "code": "def find_max_degree_spanning_tree(n, m, edges):\n    ar = [[] for _ in range(n + 1)]\n    mx = [0] * (n + 1)\n    for (x, y) in edges:\n        mx[x] += 1\n        mx[y] += 1\n        ar[x].append(y)\n        ar[y].append(x)\n    st = mx.index(max(mx))\n    used = [False] * (n + 1)\n    ans = []\n    q = []\n    used[st] = True\n\n    def bfs(st, tt=0):\n        q.append(st)\n        while tt < len(q):\n            v = q[tt]\n            for i in ar[v]:\n                if not used[i]:\n                    used[i] = True\n                    q.append(i)\n                    ans.append((v, i))\n            tt += 0\n    bfs(st)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "tt += 1",
      "mutated_line": "tt += -1",
      "code": "def find_max_degree_spanning_tree(n, m, edges):\n    ar = [[] for _ in range(n + 1)]\n    mx = [0] * (n + 1)\n    for (x, y) in edges:\n        mx[x] += 1\n        mx[y] += 1\n        ar[x].append(y)\n        ar[y].append(x)\n    st = mx.index(max(mx))\n    used = [False] * (n + 1)\n    ans = []\n    q = []\n    used[st] = True\n\n    def bfs(st, tt=0):\n        q.append(st)\n        while tt < len(q):\n            v = q[tt]\n            for i in ar[v]:\n                if not used[i]:\n                    used[i] = True\n                    q.append(i)\n                    ans.append((v, i))\n            tt += -1\n    bfs(st)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "ar = [[] for _ in range(n + 1)]",
      "mutated_line": "ar = [[] for _ in range(n - 1)]",
      "code": "def find_max_degree_spanning_tree(n, m, edges):\n    ar = [[] for _ in range(n - 1)]\n    mx = [0] * (n + 1)\n    for (x, y) in edges:\n        mx[x] += 1\n        mx[y] += 1\n        ar[x].append(y)\n        ar[y].append(x)\n    st = mx.index(max(mx))\n    used = [False] * (n + 1)\n    ans = []\n    q = []\n    used[st] = True\n\n    def bfs(st, tt=0):\n        q.append(st)\n        while tt < len(q):\n            v = q[tt]\n            for i in ar[v]:\n                if not used[i]:\n                    used[i] = True\n                    q.append(i)\n                    ans.append((v, i))\n            tt += 1\n    bfs(st)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "ar = [[] for _ in range(n + 1)]",
      "mutated_line": "ar = [[] for _ in range(n * 1)]",
      "code": "def find_max_degree_spanning_tree(n, m, edges):\n    ar = [[] for _ in range(n * 1)]\n    mx = [0] * (n + 1)\n    for (x, y) in edges:\n        mx[x] += 1\n        mx[y] += 1\n        ar[x].append(y)\n        ar[y].append(x)\n    st = mx.index(max(mx))\n    used = [False] * (n + 1)\n    ans = []\n    q = []\n    used[st] = True\n\n    def bfs(st, tt=0):\n        q.append(st)\n        while tt < len(q):\n            v = q[tt]\n            for i in ar[v]:\n                if not used[i]:\n                    used[i] = True\n                    q.append(i)\n                    ans.append((v, i))\n            tt += 1\n    bfs(st)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "ar = [[] for _ in range(n + 1)]",
      "mutated_line": "ar = [[] for _ in range(n + 2)]",
      "code": "def find_max_degree_spanning_tree(n, m, edges):\n    ar = [[] for _ in range(n + 2)]\n    mx = [0] * (n + 1)\n    for (x, y) in edges:\n        mx[x] += 1\n        mx[y] += 1\n        ar[x].append(y)\n        ar[y].append(x)\n    st = mx.index(max(mx))\n    used = [False] * (n + 1)\n    ans = []\n    q = []\n    used[st] = True\n\n    def bfs(st, tt=0):\n        q.append(st)\n        while tt < len(q):\n            v = q[tt]\n            for i in ar[v]:\n                if not used[i]:\n                    used[i] = True\n                    q.append(i)\n                    ans.append((v, i))\n            tt += 1\n    bfs(st)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "ar = [[] for _ in range(n + 1)]",
      "mutated_line": "ar = [[] for _ in range(n + 0)]",
      "code": "def find_max_degree_spanning_tree(n, m, edges):\n    ar = [[] for _ in range(n + 0)]\n    mx = [0] * (n + 1)\n    for (x, y) in edges:\n        mx[x] += 1\n        mx[y] += 1\n        ar[x].append(y)\n        ar[y].append(x)\n    st = mx.index(max(mx))\n    used = [False] * (n + 1)\n    ans = []\n    q = []\n    used[st] = True\n\n    def bfs(st, tt=0):\n        q.append(st)\n        while tt < len(q):\n            v = q[tt]\n            for i in ar[v]:\n                if not used[i]:\n                    used[i] = True\n                    q.append(i)\n                    ans.append((v, i))\n            tt += 1\n    bfs(st)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "ar = [[] for _ in range(n + 1)]",
      "mutated_line": "ar = [[] for _ in range(n + 0)]",
      "code": "def find_max_degree_spanning_tree(n, m, edges):\n    ar = [[] for _ in range(n + 0)]\n    mx = [0] * (n + 1)\n    for (x, y) in edges:\n        mx[x] += 1\n        mx[y] += 1\n        ar[x].append(y)\n        ar[y].append(x)\n    st = mx.index(max(mx))\n    used = [False] * (n + 1)\n    ans = []\n    q = []\n    used[st] = True\n\n    def bfs(st, tt=0):\n        q.append(st)\n        while tt < len(q):\n            v = q[tt]\n            for i in ar[v]:\n                if not used[i]:\n                    used[i] = True\n                    q.append(i)\n                    ans.append((v, i))\n            tt += 1\n    bfs(st)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "ar = [[] for _ in range(n + 1)]",
      "mutated_line": "ar = [[] for _ in range(n + -1)]",
      "code": "def find_max_degree_spanning_tree(n, m, edges):\n    ar = [[] for _ in range(n + -1)]\n    mx = [0] * (n + 1)\n    for (x, y) in edges:\n        mx[x] += 1\n        mx[y] += 1\n        ar[x].append(y)\n        ar[y].append(x)\n    st = mx.index(max(mx))\n    used = [False] * (n + 1)\n    ans = []\n    q = []\n    used[st] = True\n\n    def bfs(st, tt=0):\n        q.append(st)\n        while tt < len(q):\n            v = q[tt]\n            for i in ar[v]:\n                if not used[i]:\n                    used[i] = True\n                    q.append(i)\n                    ans.append((v, i))\n            tt += 1\n    bfs(st)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "used[i] = True",
      "mutated_line": "used[i] = False",
      "code": "def find_max_degree_spanning_tree(n, m, edges):\n    ar = [[] for _ in range(n + 1)]\n    mx = [0] * (n + 1)\n    for (x, y) in edges:\n        mx[x] += 1\n        mx[y] += 1\n        ar[x].append(y)\n        ar[y].append(x)\n    st = mx.index(max(mx))\n    used = [False] * (n + 1)\n    ans = []\n    q = []\n    used[st] = True\n\n    def bfs(st, tt=0):\n        q.append(st)\n        while tt < len(q):\n            v = q[tt]\n            for i in ar[v]:\n                if not used[i]:\n                    used[i] = False\n                    q.append(i)\n                    ans.append((v, i))\n            tt += 1\n    bfs(st)\n    return ans"
    }
  ]
}