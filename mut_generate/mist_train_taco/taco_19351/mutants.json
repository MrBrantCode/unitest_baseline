{
  "task_id": "taco_19351",
  "entry_point": "max_roads_to_destroy",
  "mutant_count": 129,
  "mutants": [
    {
      "operator": "ASR",
      "lineno": 5,
      "original_line": "s1 -= 1",
      "mutated_line": "s1 += 1",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 += 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "ASR",
      "lineno": 6,
      "original_line": "t1 -= 1",
      "mutated_line": "t1 += 1",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 += 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "ASR",
      "lineno": 7,
      "original_line": "s2 -= 1",
      "mutated_line": "s2 += 1",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 += 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "ASR",
      "lineno": 8,
      "original_line": "t2 -= 1",
      "mutated_line": "t2 += 1",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 += 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "s1 -= 1",
      "mutated_line": "s1 -= 2",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 2\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "s1 -= 1",
      "mutated_line": "s1 -= 0",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 0\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "s1 -= 1",
      "mutated_line": "s1 -= 0",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 0\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "s1 -= 1",
      "mutated_line": "s1 -= -1",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= -1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "t1 -= 1",
      "mutated_line": "t1 -= 2",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 2\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "t1 -= 1",
      "mutated_line": "t1 -= 0",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 0\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "t1 -= 1",
      "mutated_line": "t1 -= 0",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 0\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "t1 -= 1",
      "mutated_line": "t1 -= -1",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= -1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "s2 -= 1",
      "mutated_line": "s2 -= 2",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 2\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "s2 -= 1",
      "mutated_line": "s2 -= 0",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 0\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "s2 -= 1",
      "mutated_line": "s2 -= 0",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 0\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "s2 -= 1",
      "mutated_line": "s2 -= -1",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= -1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "t2 -= 1",
      "mutated_line": "t2 -= 2",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 2\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "t2 -= 1",
      "mutated_line": "t2 -= 0",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 0\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "t2 -= 1",
      "mutated_line": "t2 -= 0",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 0\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "t2 -= 1",
      "mutated_line": "t2 -= -1",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= -1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "LCR",
      "lineno": 33,
      "original_line": "if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:",
      "mutated_line": "if Dist[s1][t1] > l1 and Dist[s2][t2] > l2:",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 and Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "rest = Dist[s1][t1] + Dist[s2][t2]",
      "mutated_line": "rest = Dist[s1][t1] - Dist[s2][t2]",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] - Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "rest = Dist[s1][t1] + Dist[s2][t2]",
      "mutated_line": "rest = Dist[s1][t1] * Dist[s2][t2]",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] * Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "return m - rest",
      "mutated_line": "return m + rest",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m + rest"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "return m - rest",
      "mutated_line": "return m * rest",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m * rest"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "dist = [-1] * n",
      "mutated_line": "dist = [-1] / n",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] / n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "dist = [-1] * n",
      "mutated_line": "dist = [-1] + n",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] + n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "dist = [-1] * n",
      "mutated_line": "dist = [-1] ** n",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] ** n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dist[s] = 0",
      "mutated_line": "dist[s] = 1",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 1\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dist[s] = 0",
      "mutated_line": "dist[s] = -1",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = -1\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dist[s] = 0",
      "mutated_line": "dist[s] = 1",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 1\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:",
      "mutated_line": "if Dist[s1][t1] >= l1 or Dist[s2][t2] > l2:",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] >= l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:",
      "mutated_line": "if Dist[s1][t1] <= l1 or Dist[s2][t2] > l2:",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] <= l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:",
      "mutated_line": "if Dist[s1][t1] != l1 or Dist[s2][t2] > l2:",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] != l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:",
      "mutated_line": "if Dist[s1][t1] > l1 or Dist[s2][t2] >= l2:",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] >= l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:",
      "mutated_line": "if Dist[s1][t1] > l1 or Dist[s2][t2] <= l2:",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] <= l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:",
      "mutated_line": "if Dist[s1][t1] > l1 or Dist[s2][t2] != l2:",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] != l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "UOI",
      "lineno": 34,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return +1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "G[x - 1].append(y - 1)",
      "mutated_line": "G[x - 1].append(y + 1)",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y + 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "G[x - 1].append(y - 1)",
      "mutated_line": "G[x - 1].append(y * 1)",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y * 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "G[y - 1].append(x - 1)",
      "mutated_line": "G[y - 1].append(x + 1)",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x + 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "G[y - 1].append(x - 1)",
      "mutated_line": "G[y - 1].append(x * 1)",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x * 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -2\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -0\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -0\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return --1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "LCR",
      "lineno": 42,
      "original_line": "if (Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and",
      "mutated_line": "if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 or Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 or Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "LCR",
      "lineno": 45,
      "original_line": "if (Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and",
      "mutated_line": "if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 or Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 or Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "G[x - 1].append(y - 1)",
      "mutated_line": "G[x - 1].append(y - 2)",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 2)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "G[x - 1].append(y - 1)",
      "mutated_line": "G[x - 1].append(y - 0)",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 0)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "G[x - 1].append(y - 1)",
      "mutated_line": "G[x - 1].append(y - 0)",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 0)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "G[x - 1].append(y - 1)",
      "mutated_line": "G[x - 1].append(y - -1)",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - -1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "G[y - 1].append(x - 1)",
      "mutated_line": "G[y - 1].append(x - 2)",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 2)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "G[y - 1].append(x - 1)",
      "mutated_line": "G[y - 1].append(x - 0)",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 0)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "G[y - 1].append(x - 1)",
      "mutated_line": "G[y - 1].append(x - 0)",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 0)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "G[y - 1].append(x - 1)",
      "mutated_line": "G[y - 1].append(x - -1)",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - -1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "UOI",
      "lineno": 18,
      "original_line": "dist = [-1] * n",
      "mutated_line": "dist = [+1] * n",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [+1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if dist[to] == -1:",
      "mutated_line": "if dist[to] != -1:",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] != -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if (Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and",
      "mutated_line": "if Dist[i][s1] + Dist[i][j] + Dist[j][t1] < l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] < l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if (Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and",
      "mutated_line": "if Dist[i][s1] + Dist[i][j] + Dist[j][t1] > l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] > l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if (Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and",
      "mutated_line": "if Dist[i][s1] + Dist[i][j] + Dist[j][t1] == l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] == l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2):",
      "mutated_line": "if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] < l2:",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] < l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2):",
      "mutated_line": "if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] > l2:",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] > l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2):",
      "mutated_line": "if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] == l2:",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] == l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "if (Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and",
      "mutated_line": "if Dist[i][s1] + Dist[i][j] + Dist[j][t1] < l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] < l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "if (Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and",
      "mutated_line": "if Dist[i][s1] + Dist[i][j] + Dist[j][t1] > l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] > l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "if (Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and",
      "mutated_line": "if Dist[i][s1] + Dist[i][j] + Dist[j][t1] == l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] == l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "ROR",
      "lineno": 46,
      "original_line": "Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2):",
      "mutated_line": "if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] < l2:",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] < l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "ROR",
      "lineno": 46,
      "original_line": "Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2):",
      "mutated_line": "if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] > l2:",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] > l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "ROR",
      "lineno": 46,
      "original_line": "Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2):",
      "mutated_line": "if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] == l2:",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] == l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "G[x - 1].append(y - 1)",
      "mutated_line": "G[x + 1].append(y - 1)",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x + 1].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "G[x - 1].append(y - 1)",
      "mutated_line": "G[x * 1].append(y - 1)",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x * 1].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "G[y - 1].append(x - 1)",
      "mutated_line": "G[y + 1].append(x - 1)",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y + 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "G[y - 1].append(x - 1)",
      "mutated_line": "G[y * 1].append(x - 1)",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y * 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dist = [-1] * n",
      "mutated_line": "dist = [-2] * n",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-2] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dist = [-1] * n",
      "mutated_line": "dist = [-0] * n",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-0] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dist = [-1] * n",
      "mutated_line": "dist = [-0] * n",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-0] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dist = [-1] * n",
      "mutated_line": "dist = [--1] * n",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [--1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "UOI",
      "lineno": 24,
      "original_line": "if dist[to] == -1:",
      "mutated_line": "if dist[to] == +1:",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == +1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "dist[to] = dist[v] + 1",
      "mutated_line": "dist[to] = dist[v] - 1",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] - 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "dist[to] = dist[v] + 1",
      "mutated_line": "dist[to] = dist[v] * 1",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] * 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "if (Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and",
      "mutated_line": "if Dist[i][s1] + Dist[i][j] - Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] - Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "if (Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and",
      "mutated_line": "if (Dist[i][s1] + Dist[i][j]) * Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if (Dist[i][s1] + Dist[i][j]) * Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2):",
      "mutated_line": "if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] - Dist[j][t2] <= l2:",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] - Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2):",
      "mutated_line": "if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and (Dist[i][s2] + Dist[i][j]) * Dist[j][t2] <= l2:",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and (Dist[i][s2] + Dist[i][j]) * Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])",
      "mutated_line": "if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] - Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])",
      "mutated_line": "if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, (Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1]) * Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "if (Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and",
      "mutated_line": "if Dist[i][s1] + Dist[i][j] - Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] - Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "if (Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and",
      "mutated_line": "if (Dist[i][s1] + Dist[i][j]) * Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if (Dist[i][s1] + Dist[i][j]) * Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2):",
      "mutated_line": "if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] - Dist[i][t2] <= l2:",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] - Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2):",
      "mutated_line": "if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and (Dist[j][s2] + Dist[i][j]) * Dist[i][t2] <= l2:",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and (Dist[j][s2] + Dist[i][j]) * Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])",
      "mutated_line": "rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] - Dist[i][t2])",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] - Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])",
      "mutated_line": "rest = min(rest, (Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1]) * Dist[i][t2])",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, (Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1]) * Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "G[x - 1].append(y - 1)",
      "mutated_line": "G[x - 2].append(y - 1)",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 2].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "G[x - 1].append(y - 1)",
      "mutated_line": "G[x - 0].append(y - 1)",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 0].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "G[x - 1].append(y - 1)",
      "mutated_line": "G[x - 0].append(y - 1)",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 0].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "G[x - 1].append(y - 1)",
      "mutated_line": "G[x - -1].append(y - 1)",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - -1].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "G[y - 1].append(x - 1)",
      "mutated_line": "G[y - 2].append(x - 1)",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 2].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "G[y - 1].append(x - 1)",
      "mutated_line": "G[y - 0].append(x - 1)",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 0].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "G[y - 1].append(x - 1)",
      "mutated_line": "G[y - 0].append(x - 1)",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 0].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "G[y - 1].append(x - 1)",
      "mutated_line": "G[y - -1].append(x - 1)",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - -1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if dist[to] == -1:",
      "mutated_line": "if dist[to] == -2:",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -2:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if dist[to] == -1:",
      "mutated_line": "if dist[to] == -0:",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -0:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if dist[to] == -1:",
      "mutated_line": "if dist[to] == -0:",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -0:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if dist[to] == -1:",
      "mutated_line": "if dist[to] == --1:",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == --1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dist[to] = dist[v] + 1",
      "mutated_line": "dist[to] = dist[v] + 2",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 2\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dist[to] = dist[v] + 1",
      "mutated_line": "dist[to] = dist[v] + 0",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 0\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dist[to] = dist[v] + 1",
      "mutated_line": "dist[to] = dist[v] + 0",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 0\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dist[to] = dist[v] + 1",
      "mutated_line": "dist[to] = dist[v] + -1",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + -1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "if (Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and",
      "mutated_line": "if Dist[i][s1] - Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] - Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "if (Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and",
      "mutated_line": "if Dist[i][s1] * Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] * Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2):",
      "mutated_line": "if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] - Dist[i][j] + Dist[j][t2] <= l2:",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] - Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2):",
      "mutated_line": "if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] * Dist[i][j] + Dist[j][t2] <= l2:",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] * Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])",
      "mutated_line": "if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] - Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])",
      "mutated_line": "if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, (Dist[i][j] + Dist[i][s1] + Dist[i][s2]) * Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "if (Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and",
      "mutated_line": "if Dist[i][s1] - Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] - Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "if (Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and",
      "mutated_line": "if Dist[i][s1] * Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] * Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2):",
      "mutated_line": "if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] - Dist[i][j] + Dist[i][t2] <= l2:",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] - Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2):",
      "mutated_line": "if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] * Dist[i][j] + Dist[i][t2] <= l2:",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] * Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])",
      "mutated_line": "rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] - Dist[i][s1] + Dist[i][t2])",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] - Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])",
      "mutated_line": "rest = min(rest, (Dist[i][j] + Dist[j][t1] + Dist[j][s2]) * Dist[i][s1] + Dist[i][t2])",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, (Dist[i][j] + Dist[j][t1] + Dist[j][s2]) * Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])",
      "mutated_line": "if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] - Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])",
      "mutated_line": "if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, (Dist[i][j] + Dist[i][s1]) * Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])",
      "mutated_line": "rest = min(rest, Dist[i][j] + Dist[j][t1] - Dist[j][s2] + Dist[i][s1] + Dist[i][t2])",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] - Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])",
      "mutated_line": "rest = min(rest, (Dist[i][j] + Dist[j][t1]) * Dist[j][s2] + Dist[i][s1] + Dist[i][t2])",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, (Dist[i][j] + Dist[j][t1]) * Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])",
      "mutated_line": "if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] - Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])",
      "mutated_line": "if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] * Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])",
      "mutated_line": "rest = min(rest, Dist[i][j] - Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] - Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "rest = min(rest, Dist[i][j] + Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])",
      "mutated_line": "rest = min(rest, Dist[i][j] * Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])",
      "code": "from collections import deque\n\ndef max_roads_to_destroy(n, m, roads, s1, t1, l1, s2, t2, l2):\n    s1 -= 1\n    t1 -= 1\n    s2 -= 1\n    t2 -= 1\n    G = [[] for _ in range(n)]\n    for (x, y) in roads:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n\n    def BFS(s):\n        dist = [-1] * n\n        dist[s] = 0\n        Q = deque([s])\n        while Q:\n            v = Q.popleft()\n            for to in G[v]:\n                if dist[to] == -1:\n                    dist[to] = dist[v] + 1\n                    Q.append(to)\n        return dist\n    Dist = [BFS(i) for i in range(n)]\n    if Dist[s1][t1] > l1 or Dist[s2][t2] > l2:\n        return -1\n    rest = Dist[s1][t1] + Dist[s2][t2]\n    for i in range(n):\n        for j in range(n):\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[i][s2] + Dist[i][j] + Dist[j][t2] <= l2:\n                rest = min(rest, Dist[i][j] + Dist[i][s1] + Dist[i][s2] + Dist[j][t1] + Dist[j][t2])\n            if Dist[i][s1] + Dist[i][j] + Dist[j][t1] <= l1 and Dist[j][s2] + Dist[i][j] + Dist[i][t2] <= l2:\n                rest = min(rest, Dist[i][j] * Dist[j][t1] + Dist[j][s2] + Dist[i][s1] + Dist[i][t2])\n    return m - rest"
    }
  ]
}