{
  "task_id": "taco_16695",
  "entry_point": "find_median_of_stream",
  "mutant_count": 44,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if len(max_heap) > len(min_heap) + 1:",
      "mutated_line": "if len(max_heap) >= len(min_heap) + 1:",
      "code": "import heapq\n\ndef find_median_of_stream(nums):\n\n    def balance_heaps():\n        if len(max_heap) >= len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n        elif len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n\n    def get_median():\n        if len(max_heap) == len(min_heap):\n            return (-max_heap[0] + min_heap[0]) / 2\n        else:\n            return -max_heap[0]\n\n    def insert_heaps(num):\n        if not max_heap or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n        balance_heaps()\n    max_heap = []\n    min_heap = []\n    medians = []\n    for num in nums:\n        insert_heaps(num)\n        medians.append(get_median())\n    return medians"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if len(max_heap) > len(min_heap) + 1:",
      "mutated_line": "if len(max_heap) <= len(min_heap) + 1:",
      "code": "import heapq\n\ndef find_median_of_stream(nums):\n\n    def balance_heaps():\n        if len(max_heap) <= len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n        elif len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n\n    def get_median():\n        if len(max_heap) == len(min_heap):\n            return (-max_heap[0] + min_heap[0]) / 2\n        else:\n            return -max_heap[0]\n\n    def insert_heaps(num):\n        if not max_heap or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n        balance_heaps()\n    max_heap = []\n    min_heap = []\n    medians = []\n    for num in nums:\n        insert_heaps(num)\n        medians.append(get_median())\n    return medians"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if len(max_heap) > len(min_heap) + 1:",
      "mutated_line": "if len(max_heap) != len(min_heap) + 1:",
      "code": "import heapq\n\ndef find_median_of_stream(nums):\n\n    def balance_heaps():\n        if len(max_heap) != len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n        elif len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n\n    def get_median():\n        if len(max_heap) == len(min_heap):\n            return (-max_heap[0] + min_heap[0]) / 2\n        else:\n            return -max_heap[0]\n\n    def insert_heaps(num):\n        if not max_heap or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n        balance_heaps()\n    max_heap = []\n    min_heap = []\n    medians = []\n    for num in nums:\n        insert_heaps(num)\n        medians.append(get_median())\n    return medians"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if len(max_heap) == len(min_heap):",
      "mutated_line": "if len(max_heap) != len(min_heap):",
      "code": "import heapq\n\ndef find_median_of_stream(nums):\n\n    def balance_heaps():\n        if len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n        elif len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n\n    def get_median():\n        if len(max_heap) != len(min_heap):\n            return (-max_heap[0] + min_heap[0]) / 2\n        else:\n            return -max_heap[0]\n\n    def insert_heaps(num):\n        if not max_heap or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n        balance_heaps()\n    max_heap = []\n    min_heap = []\n    medians = []\n    for num in nums:\n        insert_heaps(num)\n        medians.append(get_median())\n    return medians"
    },
    {
      "operator": "LCR",
      "lineno": 17,
      "original_line": "if not max_heap or num < -max_heap[0]:",
      "mutated_line": "if not max_heap and num < -max_heap[0]:",
      "code": "import heapq\n\ndef find_median_of_stream(nums):\n\n    def balance_heaps():\n        if len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n        elif len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n\n    def get_median():\n        if len(max_heap) == len(min_heap):\n            return (-max_heap[0] + min_heap[0]) / 2\n        else:\n            return -max_heap[0]\n\n    def insert_heaps(num):\n        if not max_heap and num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n        balance_heaps()\n    max_heap = []\n    min_heap = []\n    medians = []\n    for num in nums:\n        insert_heaps(num)\n        medians.append(get_median())\n    return medians"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "if len(max_heap) > len(min_heap) + 1:",
      "mutated_line": "if len(max_heap) > len(min_heap) - 1:",
      "code": "import heapq\n\ndef find_median_of_stream(nums):\n\n    def balance_heaps():\n        if len(max_heap) > len(min_heap) - 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n        elif len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n\n    def get_median():\n        if len(max_heap) == len(min_heap):\n            return (-max_heap[0] + min_heap[0]) / 2\n        else:\n            return -max_heap[0]\n\n    def insert_heaps(num):\n        if not max_heap or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n        balance_heaps()\n    max_heap = []\n    min_heap = []\n    medians = []\n    for num in nums:\n        insert_heaps(num)\n        medians.append(get_median())\n    return medians"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "if len(max_heap) > len(min_heap) + 1:",
      "mutated_line": "if len(max_heap) > len(min_heap) * 1:",
      "code": "import heapq\n\ndef find_median_of_stream(nums):\n\n    def balance_heaps():\n        if len(max_heap) > len(min_heap) * 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n        elif len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n\n    def get_median():\n        if len(max_heap) == len(min_heap):\n            return (-max_heap[0] + min_heap[0]) / 2\n        else:\n            return -max_heap[0]\n\n    def insert_heaps(num):\n        if not max_heap or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n        balance_heaps()\n    max_heap = []\n    min_heap = []\n    medians = []\n    for num in nums:\n        insert_heaps(num)\n        medians.append(get_median())\n    return medians"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "elif len(min_heap) > len(max_heap):",
      "mutated_line": "elif len(min_heap) >= len(max_heap):",
      "code": "import heapq\n\ndef find_median_of_stream(nums):\n\n    def balance_heaps():\n        if len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n        elif len(min_heap) >= len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n\n    def get_median():\n        if len(max_heap) == len(min_heap):\n            return (-max_heap[0] + min_heap[0]) / 2\n        else:\n            return -max_heap[0]\n\n    def insert_heaps(num):\n        if not max_heap or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n        balance_heaps()\n    max_heap = []\n    min_heap = []\n    medians = []\n    for num in nums:\n        insert_heaps(num)\n        medians.append(get_median())\n    return medians"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "elif len(min_heap) > len(max_heap):",
      "mutated_line": "elif len(min_heap) <= len(max_heap):",
      "code": "import heapq\n\ndef find_median_of_stream(nums):\n\n    def balance_heaps():\n        if len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n        elif len(min_heap) <= len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n\n    def get_median():\n        if len(max_heap) == len(min_heap):\n            return (-max_heap[0] + min_heap[0]) / 2\n        else:\n            return -max_heap[0]\n\n    def insert_heaps(num):\n        if not max_heap or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n        balance_heaps()\n    max_heap = []\n    min_heap = []\n    medians = []\n    for num in nums:\n        insert_heaps(num)\n        medians.append(get_median())\n    return medians"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "elif len(min_heap) > len(max_heap):",
      "mutated_line": "elif len(min_heap) != len(max_heap):",
      "code": "import heapq\n\ndef find_median_of_stream(nums):\n\n    def balance_heaps():\n        if len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n        elif len(min_heap) != len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n\n    def get_median():\n        if len(max_heap) == len(min_heap):\n            return (-max_heap[0] + min_heap[0]) / 2\n        else:\n            return -max_heap[0]\n\n    def insert_heaps(num):\n        if not max_heap or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n        balance_heaps()\n    max_heap = []\n    min_heap = []\n    medians = []\n    for num in nums:\n        insert_heaps(num)\n        medians.append(get_median())\n    return medians"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "return (-max_heap[0] + min_heap[0]) / 2",
      "mutated_line": "return (-max_heap[0] + min_heap[0]) * 2",
      "code": "import heapq\n\ndef find_median_of_stream(nums):\n\n    def balance_heaps():\n        if len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n        elif len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n\n    def get_median():\n        if len(max_heap) == len(min_heap):\n            return (-max_heap[0] + min_heap[0]) * 2\n        else:\n            return -max_heap[0]\n\n    def insert_heaps(num):\n        if not max_heap or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n        balance_heaps()\n    max_heap = []\n    min_heap = []\n    medians = []\n    for num in nums:\n        insert_heaps(num)\n        medians.append(get_median())\n    return medians"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "return (-max_heap[0] + min_heap[0]) / 2",
      "mutated_line": "return (-max_heap[0] + min_heap[0]) // 2",
      "code": "import heapq\n\ndef find_median_of_stream(nums):\n\n    def balance_heaps():\n        if len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n        elif len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n\n    def get_median():\n        if len(max_heap) == len(min_heap):\n            return (-max_heap[0] + min_heap[0]) // 2\n        else:\n            return -max_heap[0]\n\n    def insert_heaps(num):\n        if not max_heap or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n        balance_heaps()\n    max_heap = []\n    min_heap = []\n    medians = []\n    for num in nums:\n        insert_heaps(num)\n        medians.append(get_median())\n    return medians"
    },
    {
      "operator": "UOI",
      "lineno": 14,
      "original_line": "return -max_heap[0]",
      "mutated_line": "return +max_heap[0]",
      "code": "import heapq\n\ndef find_median_of_stream(nums):\n\n    def balance_heaps():\n        if len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n        elif len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n\n    def get_median():\n        if len(max_heap) == len(min_heap):\n            return (-max_heap[0] + min_heap[0]) / 2\n        else:\n            return +max_heap[0]\n\n    def insert_heaps(num):\n        if not max_heap or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n        balance_heaps()\n    max_heap = []\n    min_heap = []\n    medians = []\n    for num in nums:\n        insert_heaps(num)\n        medians.append(get_median())\n    return medians"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if not max_heap or num < -max_heap[0]:",
      "mutated_line": "if not max_heap or num <= -max_heap[0]:",
      "code": "import heapq\n\ndef find_median_of_stream(nums):\n\n    def balance_heaps():\n        if len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n        elif len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n\n    def get_median():\n        if len(max_heap) == len(min_heap):\n            return (-max_heap[0] + min_heap[0]) / 2\n        else:\n            return -max_heap[0]\n\n    def insert_heaps(num):\n        if not max_heap or num <= -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n        balance_heaps()\n    max_heap = []\n    min_heap = []\n    medians = []\n    for num in nums:\n        insert_heaps(num)\n        medians.append(get_median())\n    return medians"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if not max_heap or num < -max_heap[0]:",
      "mutated_line": "if not max_heap or num >= -max_heap[0]:",
      "code": "import heapq\n\ndef find_median_of_stream(nums):\n\n    def balance_heaps():\n        if len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n        elif len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n\n    def get_median():\n        if len(max_heap) == len(min_heap):\n            return (-max_heap[0] + min_heap[0]) / 2\n        else:\n            return -max_heap[0]\n\n    def insert_heaps(num):\n        if not max_heap or num >= -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n        balance_heaps()\n    max_heap = []\n    min_heap = []\n    medians = []\n    for num in nums:\n        insert_heaps(num)\n        medians.append(get_median())\n    return medians"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if not max_heap or num < -max_heap[0]:",
      "mutated_line": "if not max_heap or num != -max_heap[0]:",
      "code": "import heapq\n\ndef find_median_of_stream(nums):\n\n    def balance_heaps():\n        if len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n        elif len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n\n    def get_median():\n        if len(max_heap) == len(min_heap):\n            return (-max_heap[0] + min_heap[0]) / 2\n        else:\n            return -max_heap[0]\n\n    def insert_heaps(num):\n        if not max_heap or num != -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n        balance_heaps()\n    max_heap = []\n    min_heap = []\n    medians = []\n    for num in nums:\n        insert_heaps(num)\n        medians.append(get_median())\n    return medians"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if len(max_heap) > len(min_heap) + 1:",
      "mutated_line": "if len(max_heap) > len(min_heap) + 2:",
      "code": "import heapq\n\ndef find_median_of_stream(nums):\n\n    def balance_heaps():\n        if len(max_heap) > len(min_heap) + 2:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n        elif len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n\n    def get_median():\n        if len(max_heap) == len(min_heap):\n            return (-max_heap[0] + min_heap[0]) / 2\n        else:\n            return -max_heap[0]\n\n    def insert_heaps(num):\n        if not max_heap or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n        balance_heaps()\n    max_heap = []\n    min_heap = []\n    medians = []\n    for num in nums:\n        insert_heaps(num)\n        medians.append(get_median())\n    return medians"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if len(max_heap) > len(min_heap) + 1:",
      "mutated_line": "if len(max_heap) > len(min_heap) + 0:",
      "code": "import heapq\n\ndef find_median_of_stream(nums):\n\n    def balance_heaps():\n        if len(max_heap) > len(min_heap) + 0:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n        elif len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n\n    def get_median():\n        if len(max_heap) == len(min_heap):\n            return (-max_heap[0] + min_heap[0]) / 2\n        else:\n            return -max_heap[0]\n\n    def insert_heaps(num):\n        if not max_heap or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n        balance_heaps()\n    max_heap = []\n    min_heap = []\n    medians = []\n    for num in nums:\n        insert_heaps(num)\n        medians.append(get_median())\n    return medians"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if len(max_heap) > len(min_heap) + 1:",
      "mutated_line": "if len(max_heap) > len(min_heap) + 0:",
      "code": "import heapq\n\ndef find_median_of_stream(nums):\n\n    def balance_heaps():\n        if len(max_heap) > len(min_heap) + 0:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n        elif len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n\n    def get_median():\n        if len(max_heap) == len(min_heap):\n            return (-max_heap[0] + min_heap[0]) / 2\n        else:\n            return -max_heap[0]\n\n    def insert_heaps(num):\n        if not max_heap or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n        balance_heaps()\n    max_heap = []\n    min_heap = []\n    medians = []\n    for num in nums:\n        insert_heaps(num)\n        medians.append(get_median())\n    return medians"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if len(max_heap) > len(min_heap) + 1:",
      "mutated_line": "if len(max_heap) > len(min_heap) + -1:",
      "code": "import heapq\n\ndef find_median_of_stream(nums):\n\n    def balance_heaps():\n        if len(max_heap) > len(min_heap) + -1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n        elif len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n\n    def get_median():\n        if len(max_heap) == len(min_heap):\n            return (-max_heap[0] + min_heap[0]) / 2\n        else:\n            return -max_heap[0]\n\n    def insert_heaps(num):\n        if not max_heap or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n        balance_heaps()\n    max_heap = []\n    min_heap = []\n    medians = []\n    for num in nums:\n        insert_heaps(num)\n        medians.append(get_median())\n    return medians"
    },
    {
      "operator": "UOI",
      "lineno": 6,
      "original_line": "heapq.heappush(min_heap, -heapq.heappop(max_heap))",
      "mutated_line": "heapq.heappush(min_heap, +heapq.heappop(max_heap))",
      "code": "import heapq\n\ndef find_median_of_stream(nums):\n\n    def balance_heaps():\n        if len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, +heapq.heappop(max_heap))\n        elif len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n\n    def get_median():\n        if len(max_heap) == len(min_heap):\n            return (-max_heap[0] + min_heap[0]) / 2\n        else:\n            return -max_heap[0]\n\n    def insert_heaps(num):\n        if not max_heap or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n        balance_heaps()\n    max_heap = []\n    min_heap = []\n    medians = []\n    for num in nums:\n        insert_heaps(num)\n        medians.append(get_median())\n    return medians"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "return (-max_heap[0] + min_heap[0]) / 2",
      "mutated_line": "return (-max_heap[0] - min_heap[0]) / 2",
      "code": "import heapq\n\ndef find_median_of_stream(nums):\n\n    def balance_heaps():\n        if len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n        elif len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n\n    def get_median():\n        if len(max_heap) == len(min_heap):\n            return (-max_heap[0] - min_heap[0]) / 2\n        else:\n            return -max_heap[0]\n\n    def insert_heaps(num):\n        if not max_heap or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n        balance_heaps()\n    max_heap = []\n    min_heap = []\n    medians = []\n    for num in nums:\n        insert_heaps(num)\n        medians.append(get_median())\n    return medians"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "return (-max_heap[0] + min_heap[0]) / 2",
      "mutated_line": "return -max_heap[0] * min_heap[0] / 2",
      "code": "import heapq\n\ndef find_median_of_stream(nums):\n\n    def balance_heaps():\n        if len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n        elif len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n\n    def get_median():\n        if len(max_heap) == len(min_heap):\n            return -max_heap[0] * min_heap[0] / 2\n        else:\n            return -max_heap[0]\n\n    def insert_heaps(num):\n        if not max_heap or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n        balance_heaps()\n    max_heap = []\n    min_heap = []\n    medians = []\n    for num in nums:\n        insert_heaps(num)\n        medians.append(get_median())\n    return medians"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return (-max_heap[0] + min_heap[0]) / 2",
      "mutated_line": "return (-max_heap[0] + min_heap[0]) / 3",
      "code": "import heapq\n\ndef find_median_of_stream(nums):\n\n    def balance_heaps():\n        if len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n        elif len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n\n    def get_median():\n        if len(max_heap) == len(min_heap):\n            return (-max_heap[0] + min_heap[0]) / 3\n        else:\n            return -max_heap[0]\n\n    def insert_heaps(num):\n        if not max_heap or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n        balance_heaps()\n    max_heap = []\n    min_heap = []\n    medians = []\n    for num in nums:\n        insert_heaps(num)\n        medians.append(get_median())\n    return medians"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return (-max_heap[0] + min_heap[0]) / 2",
      "mutated_line": "return (-max_heap[0] + min_heap[0]) / 1",
      "code": "import heapq\n\ndef find_median_of_stream(nums):\n\n    def balance_heaps():\n        if len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n        elif len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n\n    def get_median():\n        if len(max_heap) == len(min_heap):\n            return (-max_heap[0] + min_heap[0]) / 1\n        else:\n            return -max_heap[0]\n\n    def insert_heaps(num):\n        if not max_heap or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n        balance_heaps()\n    max_heap = []\n    min_heap = []\n    medians = []\n    for num in nums:\n        insert_heaps(num)\n        medians.append(get_median())\n    return medians"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return (-max_heap[0] + min_heap[0]) / 2",
      "mutated_line": "return (-max_heap[0] + min_heap[0]) / 0",
      "code": "import heapq\n\ndef find_median_of_stream(nums):\n\n    def balance_heaps():\n        if len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n        elif len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n\n    def get_median():\n        if len(max_heap) == len(min_heap):\n            return (-max_heap[0] + min_heap[0]) / 0\n        else:\n            return -max_heap[0]\n\n    def insert_heaps(num):\n        if not max_heap or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n        balance_heaps()\n    max_heap = []\n    min_heap = []\n    medians = []\n    for num in nums:\n        insert_heaps(num)\n        medians.append(get_median())\n    return medians"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return (-max_heap[0] + min_heap[0]) / 2",
      "mutated_line": "return (-max_heap[0] + min_heap[0]) / 1",
      "code": "import heapq\n\ndef find_median_of_stream(nums):\n\n    def balance_heaps():\n        if len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n        elif len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n\n    def get_median():\n        if len(max_heap) == len(min_heap):\n            return (-max_heap[0] + min_heap[0]) / 1\n        else:\n            return -max_heap[0]\n\n    def insert_heaps(num):\n        if not max_heap or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n        balance_heaps()\n    max_heap = []\n    min_heap = []\n    medians = []\n    for num in nums:\n        insert_heaps(num)\n        medians.append(get_median())\n    return medians"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return (-max_heap[0] + min_heap[0]) / 2",
      "mutated_line": "return (-max_heap[0] + min_heap[0]) / -2",
      "code": "import heapq\n\ndef find_median_of_stream(nums):\n\n    def balance_heaps():\n        if len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n        elif len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n\n    def get_median():\n        if len(max_heap) == len(min_heap):\n            return (-max_heap[0] + min_heap[0]) / -2\n        else:\n            return -max_heap[0]\n\n    def insert_heaps(num):\n        if not max_heap or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n        balance_heaps()\n    max_heap = []\n    min_heap = []\n    medians = []\n    for num in nums:\n        insert_heaps(num)\n        medians.append(get_median())\n    return medians"
    },
    {
      "operator": "UOI",
      "lineno": 17,
      "original_line": "if not max_heap or num < -max_heap[0]:",
      "mutated_line": "if not max_heap or num < +max_heap[0]:",
      "code": "import heapq\n\ndef find_median_of_stream(nums):\n\n    def balance_heaps():\n        if len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n        elif len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n\n    def get_median():\n        if len(max_heap) == len(min_heap):\n            return (-max_heap[0] + min_heap[0]) / 2\n        else:\n            return -max_heap[0]\n\n    def insert_heaps(num):\n        if not max_heap or num < +max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n        balance_heaps()\n    max_heap = []\n    min_heap = []\n    medians = []\n    for num in nums:\n        insert_heaps(num)\n        medians.append(get_median())\n    return medians"
    },
    {
      "operator": "UOI",
      "lineno": 18,
      "original_line": "heapq.heappush(max_heap, -num)",
      "mutated_line": "heapq.heappush(max_heap, +num)",
      "code": "import heapq\n\ndef find_median_of_stream(nums):\n\n    def balance_heaps():\n        if len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n        elif len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n\n    def get_median():\n        if len(max_heap) == len(min_heap):\n            return (-max_heap[0] + min_heap[0]) / 2\n        else:\n            return -max_heap[0]\n\n    def insert_heaps(num):\n        if not max_heap or num < -max_heap[0]:\n            heapq.heappush(max_heap, +num)\n        else:\n            heapq.heappush(min_heap, num)\n        balance_heaps()\n    max_heap = []\n    min_heap = []\n    medians = []\n    for num in nums:\n        insert_heaps(num)\n        medians.append(get_median())\n    return medians"
    },
    {
      "operator": "UOI",
      "lineno": 8,
      "original_line": "heapq.heappush(max_heap, -heapq.heappop(min_heap))",
      "mutated_line": "heapq.heappush(max_heap, +heapq.heappop(min_heap))",
      "code": "import heapq\n\ndef find_median_of_stream(nums):\n\n    def balance_heaps():\n        if len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n        elif len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, +heapq.heappop(min_heap))\n\n    def get_median():\n        if len(max_heap) == len(min_heap):\n            return (-max_heap[0] + min_heap[0]) / 2\n        else:\n            return -max_heap[0]\n\n    def insert_heaps(num):\n        if not max_heap or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n        balance_heaps()\n    max_heap = []\n    min_heap = []\n    medians = []\n    for num in nums:\n        insert_heaps(num)\n        medians.append(get_median())\n    return medians"
    },
    {
      "operator": "UOI",
      "lineno": 12,
      "original_line": "return (-max_heap[0] + min_heap[0]) / 2",
      "mutated_line": "return (+max_heap[0] + min_heap[0]) / 2",
      "code": "import heapq\n\ndef find_median_of_stream(nums):\n\n    def balance_heaps():\n        if len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n        elif len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n\n    def get_median():\n        if len(max_heap) == len(min_heap):\n            return (+max_heap[0] + min_heap[0]) / 2\n        else:\n            return -max_heap[0]\n\n    def insert_heaps(num):\n        if not max_heap or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n        balance_heaps()\n    max_heap = []\n    min_heap = []\n    medians = []\n    for num in nums:\n        insert_heaps(num)\n        medians.append(get_median())\n    return medians"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return -max_heap[0]",
      "mutated_line": "return -max_heap[1]",
      "code": "import heapq\n\ndef find_median_of_stream(nums):\n\n    def balance_heaps():\n        if len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n        elif len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n\n    def get_median():\n        if len(max_heap) == len(min_heap):\n            return (-max_heap[0] + min_heap[0]) / 2\n        else:\n            return -max_heap[1]\n\n    def insert_heaps(num):\n        if not max_heap or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n        balance_heaps()\n    max_heap = []\n    min_heap = []\n    medians = []\n    for num in nums:\n        insert_heaps(num)\n        medians.append(get_median())\n    return medians"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return -max_heap[0]",
      "mutated_line": "return -max_heap[-1]",
      "code": "import heapq\n\ndef find_median_of_stream(nums):\n\n    def balance_heaps():\n        if len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n        elif len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n\n    def get_median():\n        if len(max_heap) == len(min_heap):\n            return (-max_heap[0] + min_heap[0]) / 2\n        else:\n            return -max_heap[-1]\n\n    def insert_heaps(num):\n        if not max_heap or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n        balance_heaps()\n    max_heap = []\n    min_heap = []\n    medians = []\n    for num in nums:\n        insert_heaps(num)\n        medians.append(get_median())\n    return medians"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return -max_heap[0]",
      "mutated_line": "return -max_heap[1]",
      "code": "import heapq\n\ndef find_median_of_stream(nums):\n\n    def balance_heaps():\n        if len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n        elif len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n\n    def get_median():\n        if len(max_heap) == len(min_heap):\n            return (-max_heap[0] + min_heap[0]) / 2\n        else:\n            return -max_heap[1]\n\n    def insert_heaps(num):\n        if not max_heap or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n        balance_heaps()\n    max_heap = []\n    min_heap = []\n    medians = []\n    for num in nums:\n        insert_heaps(num)\n        medians.append(get_median())\n    return medians"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return (-max_heap[0] + min_heap[0]) / 2",
      "mutated_line": "return (-max_heap[0] + min_heap[1]) / 2",
      "code": "import heapq\n\ndef find_median_of_stream(nums):\n\n    def balance_heaps():\n        if len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n        elif len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n\n    def get_median():\n        if len(max_heap) == len(min_heap):\n            return (-max_heap[0] + min_heap[1]) / 2\n        else:\n            return -max_heap[0]\n\n    def insert_heaps(num):\n        if not max_heap or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n        balance_heaps()\n    max_heap = []\n    min_heap = []\n    medians = []\n    for num in nums:\n        insert_heaps(num)\n        medians.append(get_median())\n    return medians"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return (-max_heap[0] + min_heap[0]) / 2",
      "mutated_line": "return (-max_heap[0] + min_heap[-1]) / 2",
      "code": "import heapq\n\ndef find_median_of_stream(nums):\n\n    def balance_heaps():\n        if len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n        elif len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n\n    def get_median():\n        if len(max_heap) == len(min_heap):\n            return (-max_heap[0] + min_heap[-1]) / 2\n        else:\n            return -max_heap[0]\n\n    def insert_heaps(num):\n        if not max_heap or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n        balance_heaps()\n    max_heap = []\n    min_heap = []\n    medians = []\n    for num in nums:\n        insert_heaps(num)\n        medians.append(get_median())\n    return medians"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return (-max_heap[0] + min_heap[0]) / 2",
      "mutated_line": "return (-max_heap[0] + min_heap[1]) / 2",
      "code": "import heapq\n\ndef find_median_of_stream(nums):\n\n    def balance_heaps():\n        if len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n        elif len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n\n    def get_median():\n        if len(max_heap) == len(min_heap):\n            return (-max_heap[0] + min_heap[1]) / 2\n        else:\n            return -max_heap[0]\n\n    def insert_heaps(num):\n        if not max_heap or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n        balance_heaps()\n    max_heap = []\n    min_heap = []\n    medians = []\n    for num in nums:\n        insert_heaps(num)\n        medians.append(get_median())\n    return medians"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if not max_heap or num < -max_heap[0]:",
      "mutated_line": "if not max_heap or num < -max_heap[1]:",
      "code": "import heapq\n\ndef find_median_of_stream(nums):\n\n    def balance_heaps():\n        if len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n        elif len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n\n    def get_median():\n        if len(max_heap) == len(min_heap):\n            return (-max_heap[0] + min_heap[0]) / 2\n        else:\n            return -max_heap[0]\n\n    def insert_heaps(num):\n        if not max_heap or num < -max_heap[1]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n        balance_heaps()\n    max_heap = []\n    min_heap = []\n    medians = []\n    for num in nums:\n        insert_heaps(num)\n        medians.append(get_median())\n    return medians"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if not max_heap or num < -max_heap[0]:",
      "mutated_line": "if not max_heap or num < -max_heap[-1]:",
      "code": "import heapq\n\ndef find_median_of_stream(nums):\n\n    def balance_heaps():\n        if len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n        elif len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n\n    def get_median():\n        if len(max_heap) == len(min_heap):\n            return (-max_heap[0] + min_heap[0]) / 2\n        else:\n            return -max_heap[0]\n\n    def insert_heaps(num):\n        if not max_heap or num < -max_heap[-1]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n        balance_heaps()\n    max_heap = []\n    min_heap = []\n    medians = []\n    for num in nums:\n        insert_heaps(num)\n        medians.append(get_median())\n    return medians"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if not max_heap or num < -max_heap[0]:",
      "mutated_line": "if not max_heap or num < -max_heap[1]:",
      "code": "import heapq\n\ndef find_median_of_stream(nums):\n\n    def balance_heaps():\n        if len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n        elif len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n\n    def get_median():\n        if len(max_heap) == len(min_heap):\n            return (-max_heap[0] + min_heap[0]) / 2\n        else:\n            return -max_heap[0]\n\n    def insert_heaps(num):\n        if not max_heap or num < -max_heap[1]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n        balance_heaps()\n    max_heap = []\n    min_heap = []\n    medians = []\n    for num in nums:\n        insert_heaps(num)\n        medians.append(get_median())\n    return medians"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return (-max_heap[0] + min_heap[0]) / 2",
      "mutated_line": "return (-max_heap[1] + min_heap[0]) / 2",
      "code": "import heapq\n\ndef find_median_of_stream(nums):\n\n    def balance_heaps():\n        if len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n        elif len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n\n    def get_median():\n        if len(max_heap) == len(min_heap):\n            return (-max_heap[1] + min_heap[0]) / 2\n        else:\n            return -max_heap[0]\n\n    def insert_heaps(num):\n        if not max_heap or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n        balance_heaps()\n    max_heap = []\n    min_heap = []\n    medians = []\n    for num in nums:\n        insert_heaps(num)\n        medians.append(get_median())\n    return medians"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return (-max_heap[0] + min_heap[0]) / 2",
      "mutated_line": "return (-max_heap[-1] + min_heap[0]) / 2",
      "code": "import heapq\n\ndef find_median_of_stream(nums):\n\n    def balance_heaps():\n        if len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n        elif len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n\n    def get_median():\n        if len(max_heap) == len(min_heap):\n            return (-max_heap[-1] + min_heap[0]) / 2\n        else:\n            return -max_heap[0]\n\n    def insert_heaps(num):\n        if not max_heap or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n        balance_heaps()\n    max_heap = []\n    min_heap = []\n    medians = []\n    for num in nums:\n        insert_heaps(num)\n        medians.append(get_median())\n    return medians"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return (-max_heap[0] + min_heap[0]) / 2",
      "mutated_line": "return (-max_heap[1] + min_heap[0]) / 2",
      "code": "import heapq\n\ndef find_median_of_stream(nums):\n\n    def balance_heaps():\n        if len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n        elif len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n\n    def get_median():\n        if len(max_heap) == len(min_heap):\n            return (-max_heap[1] + min_heap[0]) / 2\n        else:\n            return -max_heap[0]\n\n    def insert_heaps(num):\n        if not max_heap or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n        balance_heaps()\n    max_heap = []\n    min_heap = []\n    medians = []\n    for num in nums:\n        insert_heaps(num)\n        medians.append(get_median())\n    return medians"
    }
  ]
}