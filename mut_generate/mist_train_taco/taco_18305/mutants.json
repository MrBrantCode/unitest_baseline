{
  "task_id": "taco_18305",
  "entry_point": "find_suitable_talk_show_moment",
  "mutant_count": 176,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "sb = [0] * (n + 1)",
      "mutated_line": "sb = [0] / (n + 1)",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] / (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "sb = [0] * (n + 1)",
      "mutated_line": "sb = [0] + (n + 1)",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] + (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "sb = [0] * (n + 1)",
      "mutated_line": "sb = [0] ** (n + 1)",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] ** (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "pp = 0",
      "mutated_line": "pp = 1",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 1\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "pp = 0",
      "mutated_line": "pp = -1",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = -1\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "pp = 0",
      "mutated_line": "pp = 1",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 1\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "ASR",
      "lineno": 50,
      "original_line": "sa += -sb[j] + mq[0][0] if mq else 0",
      "mutated_line": "sa -= -sb[j] + mq[0][0] if mq else 0",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa -= -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 57,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return +1"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "sb = [0] * (n + 1)",
      "mutated_line": "sb = [0] * (n - 1)",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n - 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "sb = [0] * (n + 1)",
      "mutated_line": "sb = [0] * (n * 1)",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n * 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "LCR",
      "lineno": 17,
      "original_line": "while q and q[0][0] + len <= t:",
      "mutated_line": "(p, j, ma, sa) = po()",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q or q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "ASR",
      "lineno": 23,
      "original_line": "sa += -sb[j] + mq[0][0] if mq else 0",
      "mutated_line": "sa -= -sb[j] + mq[0][0] if mq else 0",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa -= -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if qi == 1:",
      "mutated_line": "if qi != 1:",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi != 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "ASR",
      "lineno": 31,
      "original_line": "start += a",
      "mutated_line": "start -= a",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start -= a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "ASR",
      "lineno": 34,
      "original_line": "start -= b",
      "mutated_line": "start += b",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start += b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if mst > start:",
      "mutated_line": "if mst >= start:",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst >= start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if mst > start:",
      "mutated_line": "if mst <= start:",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst <= start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if mst > start:",
      "mutated_line": "if mst != start:",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst != start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "LCR",
      "lineno": 38,
      "original_line": "while mq and mq[-1][0] > x:",
      "mutated_line": "while mq or mq[-1][0] > x:",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq or mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 46,
      "original_line": "if ma < 0:",
      "mutated_line": "if ma <= 0:",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma <= 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 46,
      "original_line": "if ma < 0:",
      "mutated_line": "if ma >= 0:",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma >= 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 46,
      "original_line": "if ma < 0:",
      "mutated_line": "if ma != 0:",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma != 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "LCR",
      "lineno": 48,
      "original_line": "while mq and mq[0][1] < p:",
      "mutated_line": "while mq or mq[0][1] < p:",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq or mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 51,
      "original_line": "if ma > sa:",
      "mutated_line": "if ma >= sa:",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma >= sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 51,
      "original_line": "if ma > sa:",
      "mutated_line": "if ma <= sa:",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma <= sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 51,
      "original_line": "if ma > sa:",
      "mutated_line": "if ma != sa:",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma != sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 53,
      "original_line": "if ma >= 0:",
      "mutated_line": "if ma > 0:",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma > 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 53,
      "original_line": "if ma >= 0:",
      "mutated_line": "if ma < 0:",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma < 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 53,
      "original_line": "if ma >= 0:",
      "mutated_line": "if ma == 0:",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma == 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 55,
      "original_line": "pp = p + 1",
      "mutated_line": "pp = p - 1",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p - 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 55,
      "original_line": "pp = p + 1",
      "mutated_line": "pp = p * 1",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p * 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 57,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -2"
    },
    {
      "operator": "CRP",
      "lineno": 57,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 57,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 57,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return --1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "sb = [0] * (n + 1)",
      "mutated_line": "sb = [1] * (n + 1)",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [1] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "sb = [0] * (n + 1)",
      "mutated_line": "sb = [-1] * (n + 1)",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [-1] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "sb = [0] * (n + 1)",
      "mutated_line": "sb = [1] * (n + 1)",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [1] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "sb = [0] * (n + 1)",
      "mutated_line": "sb = [0] * (n + 2)",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 2)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "sb = [0] * (n + 1)",
      "mutated_line": "sb = [0] * (n + 0)",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 0)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "sb = [0] * (n + 1)",
      "mutated_line": "sb = [0] * (n + 0)",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 0)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "sb = [0] * (n + 1)",
      "mutated_line": "sb = [0] * (n + -1)",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + -1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "pu((0, 0, mst, start))",
      "mutated_line": "pu((1, 0, mst, start))",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((1, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "pu((0, 0, mst, start))",
      "mutated_line": "pu((-1, 0, mst, start))",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((-1, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "pu((0, 0, mst, start))",
      "mutated_line": "pu((1, 0, mst, start))",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((1, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "pu((0, 0, mst, start))",
      "mutated_line": "pu((0, 1, mst, start))",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 1, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "pu((0, 0, mst, start))",
      "mutated_line": "pu((0, -1, mst, start))",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, -1, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "pu((0, 0, mst, start))",
      "mutated_line": "pu((0, 1, mst, start))",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 1, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "while q and q[0][0] + len <= t:",
      "mutated_line": "(p, j, ma, sa) = po()",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len < t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "while q and q[0][0] + len <= t:",
      "mutated_line": "(p, j, ma, sa) = po()",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len > t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "while q and q[0][0] + len <= t:",
      "mutated_line": "(p, j, ma, sa) = po()",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len == t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if ma < 0:",
      "mutated_line": "if ma <= 0:",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma <= 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if ma < 0:",
      "mutated_line": "if ma >= 0:",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma >= 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if ma < 0:",
      "mutated_line": "if ma != 0:",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma != 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "LCR",
      "lineno": 21,
      "original_line": "while mq and mq[0][1] < p:",
      "mutated_line": "while mq or mq[0][1] < p:",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq or mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if ma > sa:",
      "mutated_line": "if ma >= sa:",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma >= sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if ma > sa:",
      "mutated_line": "if ma <= sa:",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma <= sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if ma > sa:",
      "mutated_line": "if ma != sa:",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma != sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if ma >= 0:",
      "mutated_line": "if ma > 0:",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma > 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if ma >= 0:",
      "mutated_line": "if ma < 0:",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma < 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if ma >= 0:",
      "mutated_line": "if ma == 0:",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma == 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "pp = p + 1",
      "mutated_line": "pp = p - 1",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p - 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "pp = p + 1",
      "mutated_line": "pp = p * 1",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p * 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if qi == 1:",
      "mutated_line": "if qi == 2:",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 2:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if qi == 1:",
      "mutated_line": "if qi == 0:",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 0:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if qi == 1:",
      "mutated_line": "if qi == 0:",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 0:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if qi == 1:",
      "mutated_line": "if qi == -1:",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == -1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "x = sb[i] + c",
      "mutated_line": "x = sb[i] - c",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] - c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "x = sb[i] + c",
      "mutated_line": "x = sb[i] * c",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] * c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "x = sb[i] - d",
      "mutated_line": "x = sb[i] + d",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] + d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "x = sb[i] - d",
      "mutated_line": "x = sb[i] * d",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] * d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "while mq and mq[-1][0] > x:",
      "mutated_line": "while mq and mq[-1][0] >= x:",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] >= x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "while mq and mq[-1][0] > x:",
      "mutated_line": "while mq and mq[-1][0] <= x:",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] <= x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "while mq and mq[-1][0] > x:",
      "mutated_line": "while mq and mq[-1][0] != x:",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] != x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "sb[i + 1] = x",
      "mutated_line": "sb[i - 1] = x",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i - 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "sb[i + 1] = x",
      "mutated_line": "sb[i * 1] = x",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i * 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "pu((t + 1, n, mst, start))",
      "mutated_line": "pu((t - 1, n, mst, start))",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t - 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "pu((t + 1, n, mst, start))",
      "mutated_line": "pu((t * 1, n, mst, start))",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t * 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if ma < 0:",
      "mutated_line": "if ma < 1:",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 1:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if ma < 0:",
      "mutated_line": "if ma < -1:",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < -1:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if ma < 0:",
      "mutated_line": "if ma < 1:",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 1:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 47,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return +1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 48,
      "original_line": "while mq and mq[0][1] < p:",
      "mutated_line": "while mq and mq[0][1] <= p:",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] <= p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 48,
      "original_line": "while mq and mq[0][1] < p:",
      "mutated_line": "while mq and mq[0][1] >= p:",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] >= p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 48,
      "original_line": "while mq and mq[0][1] < p:",
      "mutated_line": "while mq and mq[0][1] != p:",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] != p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "sa += -sb[j] + mq[0][0] if mq else 0",
      "mutated_line": "sa += -sb[j] - mq[0][0] if mq else 0",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] - mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "sa += -sb[j] + mq[0][0] if mq else 0",
      "mutated_line": "sa += -sb[j] * mq[0][0] if mq else 0",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] * mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "sa += -sb[j] + mq[0][0] if mq else 0",
      "mutated_line": "sa += -sb[j] + mq[0][0] if mq else 1",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 1\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "sa += -sb[j] + mq[0][0] if mq else 0",
      "mutated_line": "sa += -sb[j] + mq[0][0] if mq else -1",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else -1\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "sa += -sb[j] + mq[0][0] if mq else 0",
      "mutated_line": "sa += -sb[j] + mq[0][0] if mq else 1",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 1\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "if ma >= 0:",
      "mutated_line": "if ma >= 1:",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 1:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "if ma >= 0:",
      "mutated_line": "if ma >= -1:",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= -1:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "if ma >= 0:",
      "mutated_line": "if ma >= 1:",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 1:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "pp = p + 1",
      "mutated_line": "pp = p + 2",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 2\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "pp = p + 1",
      "mutated_line": "pp = p + 0",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 0\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "pp = p + 1",
      "mutated_line": "pp = p + 0",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 0\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "pp = p + 1",
      "mutated_line": "pp = p + -1",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + -1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "while q and q[0][0] + len <= t:",
      "mutated_line": "(p, j, ma, sa) = po()",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] - len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "while q and q[0][0] + len <= t:",
      "mutated_line": "(p, j, ma, sa) = po()",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] * len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if ma < 0:",
      "mutated_line": "if ma < 1:",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 1:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if ma < 0:",
      "mutated_line": "if ma < -1:",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < -1:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if ma < 0:",
      "mutated_line": "if ma < 1:",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 1:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 20,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return +1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "while mq and mq[0][1] < p:",
      "mutated_line": "while mq and mq[0][1] <= p:",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] <= p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "while mq and mq[0][1] < p:",
      "mutated_line": "while mq and mq[0][1] >= p:",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] >= p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "while mq and mq[0][1] < p:",
      "mutated_line": "while mq and mq[0][1] != p:",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] != p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "sa += -sb[j] + mq[0][0] if mq else 0",
      "mutated_line": "sa += -sb[j] - mq[0][0] if mq else 0",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] - mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "sa += -sb[j] + mq[0][0] if mq else 0",
      "mutated_line": "sa += -sb[j] * mq[0][0] if mq else 0",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] * mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "sa += -sb[j] + mq[0][0] if mq else 0",
      "mutated_line": "sa += -sb[j] + mq[0][0] if mq else 1",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 1\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "sa += -sb[j] + mq[0][0] if mq else 0",
      "mutated_line": "sa += -sb[j] + mq[0][0] if mq else -1",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else -1\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "sa += -sb[j] + mq[0][0] if mq else 0",
      "mutated_line": "sa += -sb[j] + mq[0][0] if mq else 1",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 1\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if ma >= 0:",
      "mutated_line": "if ma >= 1:",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 1:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if ma >= 0:",
      "mutated_line": "if ma >= -1:",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= -1:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if ma >= 0:",
      "mutated_line": "if ma >= 1:",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 1:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "pp = p + 1",
      "mutated_line": "pp = p + 2",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 2\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "pp = p + 1",
      "mutated_line": "pp = p + 0",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 0\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "pp = p + 1",
      "mutated_line": "pp = p + 0",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 0\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "pp = p + 1",
      "mutated_line": "pp = p + -1",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + -1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "sb[i + 1] = x",
      "mutated_line": "sb[i + 2] = x",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 2] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "sb[i + 1] = x",
      "mutated_line": "sb[i + 0] = x",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 0] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "sb[i + 1] = x",
      "mutated_line": "sb[i + 0] = x",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 0] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "sb[i + 1] = x",
      "mutated_line": "sb[i + -1] = x",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + -1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "pu((t + 1, n, mst, start))",
      "mutated_line": "pu((t + 2, n, mst, start))",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 2, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "pu((t + 1, n, mst, start))",
      "mutated_line": "pu((t + 0, n, mst, start))",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 0, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "pu((t + 1, n, mst, start))",
      "mutated_line": "pu((t + 0, n, mst, start))",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 0, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "pu((t + 1, n, mst, start))",
      "mutated_line": "pu((t + -1, n, mst, start))",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + -1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -2\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -0\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -0\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return --1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 50,
      "original_line": "sa += -sb[j] + mq[0][0] if mq else 0",
      "mutated_line": "sa += +sb[j] + mq[0][0] if mq else 0",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += +sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -2\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -0\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -0\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return --1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 23,
      "original_line": "sa += -sb[j] + mq[0][0] if mq else 0",
      "mutated_line": "sa += +sb[j] + mq[0][0] if mq else 0",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += +sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "while mq and mq[-1][0] > x:",
      "mutated_line": "while mq and mq[-1][1] > x:",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][1] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "while mq and mq[-1][0] > x:",
      "mutated_line": "while mq and mq[-1][-1] > x:",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][-1] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "while mq and mq[-1][0] > x:",
      "mutated_line": "while mq and mq[-1][1] > x:",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][1] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "while mq and mq[0][1] < p:",
      "mutated_line": "while mq and mq[0][2] < p:",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][2] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "while mq and mq[0][1] < p:",
      "mutated_line": "while mq and mq[0][0] < p:",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][0] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "while mq and mq[0][1] < p:",
      "mutated_line": "while mq and mq[0][0] < p:",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][0] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "while mq and mq[0][1] < p:",
      "mutated_line": "while mq and mq[0][-1] < p:",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][-1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "sa += -sb[j] + mq[0][0] if mq else 0",
      "mutated_line": "sa += -sb[j] + mq[0][1] if mq else 0",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][1] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "sa += -sb[j] + mq[0][0] if mq else 0",
      "mutated_line": "sa += -sb[j] + mq[0][-1] if mq else 0",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][-1] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "sa += -sb[j] + mq[0][0] if mq else 0",
      "mutated_line": "sa += -sb[j] + mq[0][1] if mq else 0",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][1] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "while q and q[0][0] + len <= t:",
      "mutated_line": "(p, j, ma, sa) = po()",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][1] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "while q and q[0][0] + len <= t:",
      "mutated_line": "(p, j, ma, sa) = po()",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][-1] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "while q and q[0][0] + len <= t:",
      "mutated_line": "(p, j, ma, sa) = po()",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][1] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "while mq and mq[0][1] < p:",
      "mutated_line": "while mq and mq[0][2] < p:",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][2] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "while mq and mq[0][1] < p:",
      "mutated_line": "while mq and mq[0][0] < p:",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][0] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "while mq and mq[0][1] < p:",
      "mutated_line": "while mq and mq[0][0] < p:",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][0] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "while mq and mq[0][1] < p:",
      "mutated_line": "while mq and mq[0][-1] < p:",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][-1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "sa += -sb[j] + mq[0][0] if mq else 0",
      "mutated_line": "sa += -sb[j] + mq[0][1] if mq else 0",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][1] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "sa += -sb[j] + mq[0][0] if mq else 0",
      "mutated_line": "sa += -sb[j] + mq[0][-1] if mq else 0",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][-1] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "sa += -sb[j] + mq[0][0] if mq else 0",
      "mutated_line": "sa += -sb[j] + mq[0][1] if mq else 0",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][1] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 38,
      "original_line": "while mq and mq[-1][0] > x:",
      "mutated_line": "while mq and mq[+1][0] > x:",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[+1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "while mq and mq[0][1] < p:",
      "mutated_line": "while mq and mq[1][1] < p:",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[1][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "while mq and mq[0][1] < p:",
      "mutated_line": "while mq and mq[-1][1] < p:",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[-1][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "while mq and mq[0][1] < p:",
      "mutated_line": "while mq and mq[1][1] < p:",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[1][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "sa += -sb[j] + mq[0][0] if mq else 0",
      "mutated_line": "sa += -sb[j] + mq[1][0] if mq else 0",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[1][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "sa += -sb[j] + mq[0][0] if mq else 0",
      "mutated_line": "sa += -sb[j] + mq[-1][0] if mq else 0",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[-1][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "sa += -sb[j] + mq[0][0] if mq else 0",
      "mutated_line": "sa += -sb[j] + mq[1][0] if mq else 0",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[1][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "while q and q[0][0] + len <= t:",
      "mutated_line": "(p, j, ma, sa) = po()",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[1][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "while q and q[0][0] + len <= t:",
      "mutated_line": "(p, j, ma, sa) = po()",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[-1][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "while q and q[0][0] + len <= t:",
      "mutated_line": "(p, j, ma, sa) = po()",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[1][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "while mq and mq[0][1] < p:",
      "mutated_line": "while mq and mq[1][1] < p:",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[1][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "while mq and mq[0][1] < p:",
      "mutated_line": "while mq and mq[-1][1] < p:",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[-1][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "while mq and mq[0][1] < p:",
      "mutated_line": "while mq and mq[1][1] < p:",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[1][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "sa += -sb[j] + mq[0][0] if mq else 0",
      "mutated_line": "sa += -sb[j] + mq[1][0] if mq else 0",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[1][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "sa += -sb[j] + mq[0][0] if mq else 0",
      "mutated_line": "sa += -sb[j] + mq[-1][0] if mq else 0",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[-1][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "sa += -sb[j] + mq[0][0] if mq else 0",
      "mutated_line": "sa += -sb[j] + mq[1][0] if mq else 0",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[1][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "while mq and mq[-1][0] > x:",
      "mutated_line": "while mq and mq[-2][0] > x:",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-2][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "while mq and mq[-1][0] > x:",
      "mutated_line": "while mq and mq[-0][0] > x:",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-0][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "while mq and mq[-1][0] > x:",
      "mutated_line": "while mq and mq[-0][0] > x:",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[-0][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "while mq and mq[-1][0] > x:",
      "mutated_line": "while mq and mq[--1][0] > x:",
      "code": "from collections import deque\n\ndef find_suitable_talk_show_moment(n, a, b, c, d, start, len, events):\n    q = deque()\n    po = q.popleft\n    pu = q.append\n    mq = deque()\n    mpop = mq.pop\n    mpo = mq.popleft\n    mpu = mq.append\n    sb = [0] * (n + 1)\n    mst = start\n    pu((0, 0, mst, start))\n    pp = 0\n    for (i, (t, qi)) in enumerate(events):\n        while q and q[0][0] + len <= t:\n            (p, j, ma, sa) = po()\n            if ma < 0:\n                return -1\n            while mq and mq[0][1] < p:\n                mpo()\n            sa += -sb[j] + mq[0][0] if mq else 0\n            if ma > sa:\n                ma = sa\n            if ma >= 0:\n                return min(pp, p)\n            pp = p + 1\n        pu((t, i, mst, start))\n        if qi == 1:\n            start += a\n            x = sb[i] + c\n        else:\n            start -= b\n            x = sb[i] - d\n        if mst > start:\n            mst = start\n        while mq and mq[--1][0] > x:\n            mpop()\n        mpu((x, t))\n        sb[i + 1] = x\n    pu((t + 1, n, mst, start))\n    while q:\n        (p, j, ma, sa) = po()\n        if ma < 0:\n            return -1\n        while mq and mq[0][1] < p:\n            mpo()\n        sa += -sb[j] + mq[0][0] if mq else 0\n        if ma > sa:\n            ma = sa\n        if ma >= 0:\n            return min(pp, p)\n        pp = p + 1\n    return -1"
    }
  ]
}