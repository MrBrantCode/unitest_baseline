{
  "task_id": "taco_9971",
  "entry_point": "max_knapsack_value",
  "mutant_count": 103,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "half = N // 2",
      "mutated_line": "half = N / 2",
      "code": "from bisect import bisect_right\n\ndef max_knapsack_value(N, W, items):\n    d1 = [[0, 0]]\n    d2 = [[0, 0]]\n    half = N / 2\n    for i in range(half):\n        (w, v) = items[i]\n        size = len(d1)\n        for j in range(size):\n            d1.append([d1[j][0] + w, d1[j][1] + v])\n    for i in range(N - half):\n        (w, v) = items[half + i]\n        size = len(d2)\n        for j in range(size):\n            d2.append([d2[j][0] + w, d2[j][1] + v])\n    d1.sort()\n    d2.sort()\n    for i in range(len(d2) - 1):\n        if d2[i + 1][1] < d2[i][1]:\n            d2[i + 1][1] = d2[i][1]\n    ans = 0\n    INF = float('inf')\n    for (w, v) in d1:\n        if w > W:\n            continue\n        rest = W - w\n        idx = bisect_right(d2, [rest, INF])\n        ans = max(ans, d2[idx - 1][1] + v)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "half = N // 2",
      "mutated_line": "half = N * 2",
      "code": "from bisect import bisect_right\n\ndef max_knapsack_value(N, W, items):\n    d1 = [[0, 0]]\n    d2 = [[0, 0]]\n    half = N * 2\n    for i in range(half):\n        (w, v) = items[i]\n        size = len(d1)\n        for j in range(size):\n            d1.append([d1[j][0] + w, d1[j][1] + v])\n    for i in range(N - half):\n        (w, v) = items[half + i]\n        size = len(d2)\n        for j in range(size):\n            d2.append([d2[j][0] + w, d2[j][1] + v])\n    d1.sort()\n    d2.sort()\n    for i in range(len(d2) - 1):\n        if d2[i + 1][1] < d2[i][1]:\n            d2[i + 1][1] = d2[i][1]\n    ans = 0\n    INF = float('inf')\n    for (w, v) in d1:\n        if w > W:\n            continue\n        rest = W - w\n        idx = bisect_right(d2, [rest, INF])\n        ans = max(ans, d2[idx - 1][1] + v)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "from bisect import bisect_right\n\ndef max_knapsack_value(N, W, items):\n    d1 = [[0, 0]]\n    d2 = [[0, 0]]\n    half = N // 2\n    for i in range(half):\n        (w, v) = items[i]\n        size = len(d1)\n        for j in range(size):\n            d1.append([d1[j][0] + w, d1[j][1] + v])\n    for i in range(N - half):\n        (w, v) = items[half + i]\n        size = len(d2)\n        for j in range(size):\n            d2.append([d2[j][0] + w, d2[j][1] + v])\n    d1.sort()\n    d2.sort()\n    for i in range(len(d2) - 1):\n        if d2[i + 1][1] < d2[i][1]:\n            d2[i + 1][1] = d2[i][1]\n    ans = 1\n    INF = float('inf')\n    for (w, v) in d1:\n        if w > W:\n            continue\n        rest = W - w\n        idx = bisect_right(d2, [rest, INF])\n        ans = max(ans, d2[idx - 1][1] + v)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "ans = 0",
      "mutated_line": "ans = -1",
      "code": "from bisect import bisect_right\n\ndef max_knapsack_value(N, W, items):\n    d1 = [[0, 0]]\n    d2 = [[0, 0]]\n    half = N // 2\n    for i in range(half):\n        (w, v) = items[i]\n        size = len(d1)\n        for j in range(size):\n            d1.append([d1[j][0] + w, d1[j][1] + v])\n    for i in range(N - half):\n        (w, v) = items[half + i]\n        size = len(d2)\n        for j in range(size):\n            d2.append([d2[j][0] + w, d2[j][1] + v])\n    d1.sort()\n    d2.sort()\n    for i in range(len(d2) - 1):\n        if d2[i + 1][1] < d2[i][1]:\n            d2[i + 1][1] = d2[i][1]\n    ans = -1\n    INF = float('inf')\n    for (w, v) in d1:\n        if w > W:\n            continue\n        rest = W - w\n        idx = bisect_right(d2, [rest, INF])\n        ans = max(ans, d2[idx - 1][1] + v)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "from bisect import bisect_right\n\ndef max_knapsack_value(N, W, items):\n    d1 = [[0, 0]]\n    d2 = [[0, 0]]\n    half = N // 2\n    for i in range(half):\n        (w, v) = items[i]\n        size = len(d1)\n        for j in range(size):\n            d1.append([d1[j][0] + w, d1[j][1] + v])\n    for i in range(N - half):\n        (w, v) = items[half + i]\n        size = len(d2)\n        for j in range(size):\n            d2.append([d2[j][0] + w, d2[j][1] + v])\n    d1.sort()\n    d2.sort()\n    for i in range(len(d2) - 1):\n        if d2[i + 1][1] < d2[i][1]:\n            d2[i + 1][1] = d2[i][1]\n    ans = 1\n    INF = float('inf')\n    for (w, v) in d1:\n        if w > W:\n            continue\n        rest = W - w\n        idx = bisect_right(d2, [rest, INF])\n        ans = max(ans, d2[idx - 1][1] + v)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "half = N // 2",
      "mutated_line": "half = N // 3",
      "code": "from bisect import bisect_right\n\ndef max_knapsack_value(N, W, items):\n    d1 = [[0, 0]]\n    d2 = [[0, 0]]\n    half = N // 3\n    for i in range(half):\n        (w, v) = items[i]\n        size = len(d1)\n        for j in range(size):\n            d1.append([d1[j][0] + w, d1[j][1] + v])\n    for i in range(N - half):\n        (w, v) = items[half + i]\n        size = len(d2)\n        for j in range(size):\n            d2.append([d2[j][0] + w, d2[j][1] + v])\n    d1.sort()\n    d2.sort()\n    for i in range(len(d2) - 1):\n        if d2[i + 1][1] < d2[i][1]:\n            d2[i + 1][1] = d2[i][1]\n    ans = 0\n    INF = float('inf')\n    for (w, v) in d1:\n        if w > W:\n            continue\n        rest = W - w\n        idx = bisect_right(d2, [rest, INF])\n        ans = max(ans, d2[idx - 1][1] + v)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "half = N // 2",
      "mutated_line": "half = N // 1",
      "code": "from bisect import bisect_right\n\ndef max_knapsack_value(N, W, items):\n    d1 = [[0, 0]]\n    d2 = [[0, 0]]\n    half = N // 1\n    for i in range(half):\n        (w, v) = items[i]\n        size = len(d1)\n        for j in range(size):\n            d1.append([d1[j][0] + w, d1[j][1] + v])\n    for i in range(N - half):\n        (w, v) = items[half + i]\n        size = len(d2)\n        for j in range(size):\n            d2.append([d2[j][0] + w, d2[j][1] + v])\n    d1.sort()\n    d2.sort()\n    for i in range(len(d2) - 1):\n        if d2[i + 1][1] < d2[i][1]:\n            d2[i + 1][1] = d2[i][1]\n    ans = 0\n    INF = float('inf')\n    for (w, v) in d1:\n        if w > W:\n            continue\n        rest = W - w\n        idx = bisect_right(d2, [rest, INF])\n        ans = max(ans, d2[idx - 1][1] + v)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "half = N // 2",
      "mutated_line": "half = N // 0",
      "code": "from bisect import bisect_right\n\ndef max_knapsack_value(N, W, items):\n    d1 = [[0, 0]]\n    d2 = [[0, 0]]\n    half = N // 0\n    for i in range(half):\n        (w, v) = items[i]\n        size = len(d1)\n        for j in range(size):\n            d1.append([d1[j][0] + w, d1[j][1] + v])\n    for i in range(N - half):\n        (w, v) = items[half + i]\n        size = len(d2)\n        for j in range(size):\n            d2.append([d2[j][0] + w, d2[j][1] + v])\n    d1.sort()\n    d2.sort()\n    for i in range(len(d2) - 1):\n        if d2[i + 1][1] < d2[i][1]:\n            d2[i + 1][1] = d2[i][1]\n    ans = 0\n    INF = float('inf')\n    for (w, v) in d1:\n        if w > W:\n            continue\n        rest = W - w\n        idx = bisect_right(d2, [rest, INF])\n        ans = max(ans, d2[idx - 1][1] + v)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "half = N // 2",
      "mutated_line": "half = N // 1",
      "code": "from bisect import bisect_right\n\ndef max_knapsack_value(N, W, items):\n    d1 = [[0, 0]]\n    d2 = [[0, 0]]\n    half = N // 1\n    for i in range(half):\n        (w, v) = items[i]\n        size = len(d1)\n        for j in range(size):\n            d1.append([d1[j][0] + w, d1[j][1] + v])\n    for i in range(N - half):\n        (w, v) = items[half + i]\n        size = len(d2)\n        for j in range(size):\n            d2.append([d2[j][0] + w, d2[j][1] + v])\n    d1.sort()\n    d2.sort()\n    for i in range(len(d2) - 1):\n        if d2[i + 1][1] < d2[i][1]:\n            d2[i + 1][1] = d2[i][1]\n    ans = 0\n    INF = float('inf')\n    for (w, v) in d1:\n        if w > W:\n            continue\n        rest = W - w\n        idx = bisect_right(d2, [rest, INF])\n        ans = max(ans, d2[idx - 1][1] + v)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "half = N // 2",
      "mutated_line": "half = N // -2",
      "code": "from bisect import bisect_right\n\ndef max_knapsack_value(N, W, items):\n    d1 = [[0, 0]]\n    d2 = [[0, 0]]\n    half = N // -2\n    for i in range(half):\n        (w, v) = items[i]\n        size = len(d1)\n        for j in range(size):\n            d1.append([d1[j][0] + w, d1[j][1] + v])\n    for i in range(N - half):\n        (w, v) = items[half + i]\n        size = len(d2)\n        for j in range(size):\n            d2.append([d2[j][0] + w, d2[j][1] + v])\n    d1.sort()\n    d2.sort()\n    for i in range(len(d2) - 1):\n        if d2[i + 1][1] < d2[i][1]:\n            d2[i + 1][1] = d2[i][1]\n    ans = 0\n    INF = float('inf')\n    for (w, v) in d1:\n        if w > W:\n            continue\n        rest = W - w\n        idx = bisect_right(d2, [rest, INF])\n        ans = max(ans, d2[idx - 1][1] + v)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "for i in range(N - half):",
      "mutated_line": "for i in range(N + half):",
      "code": "from bisect import bisect_right\n\ndef max_knapsack_value(N, W, items):\n    d1 = [[0, 0]]\n    d2 = [[0, 0]]\n    half = N // 2\n    for i in range(half):\n        (w, v) = items[i]\n        size = len(d1)\n        for j in range(size):\n            d1.append([d1[j][0] + w, d1[j][1] + v])\n    for i in range(N + half):\n        (w, v) = items[half + i]\n        size = len(d2)\n        for j in range(size):\n            d2.append([d2[j][0] + w, d2[j][1] + v])\n    d1.sort()\n    d2.sort()\n    for i in range(len(d2) - 1):\n        if d2[i + 1][1] < d2[i][1]:\n            d2[i + 1][1] = d2[i][1]\n    ans = 0\n    INF = float('inf')\n    for (w, v) in d1:\n        if w > W:\n            continue\n        rest = W - w\n        idx = bisect_right(d2, [rest, INF])\n        ans = max(ans, d2[idx - 1][1] + v)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "for i in range(N - half):",
      "mutated_line": "for i in range(N * half):",
      "code": "from bisect import bisect_right\n\ndef max_knapsack_value(N, W, items):\n    d1 = [[0, 0]]\n    d2 = [[0, 0]]\n    half = N // 2\n    for i in range(half):\n        (w, v) = items[i]\n        size = len(d1)\n        for j in range(size):\n            d1.append([d1[j][0] + w, d1[j][1] + v])\n    for i in range(N * half):\n        (w, v) = items[half + i]\n        size = len(d2)\n        for j in range(size):\n            d2.append([d2[j][0] + w, d2[j][1] + v])\n    d1.sort()\n    d2.sort()\n    for i in range(len(d2) - 1):\n        if d2[i + 1][1] < d2[i][1]:\n            d2[i + 1][1] = d2[i][1]\n    ans = 0\n    INF = float('inf')\n    for (w, v) in d1:\n        if w > W:\n            continue\n        rest = W - w\n        idx = bisect_right(d2, [rest, INF])\n        ans = max(ans, d2[idx - 1][1] + v)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "for i in range(len(d2) - 1):",
      "mutated_line": "for i in range(len(d2) + 1):",
      "code": "from bisect import bisect_right\n\ndef max_knapsack_value(N, W, items):\n    d1 = [[0, 0]]\n    d2 = [[0, 0]]\n    half = N // 2\n    for i in range(half):\n        (w, v) = items[i]\n        size = len(d1)\n        for j in range(size):\n            d1.append([d1[j][0] + w, d1[j][1] + v])\n    for i in range(N - half):\n        (w, v) = items[half + i]\n        size = len(d2)\n        for j in range(size):\n            d2.append([d2[j][0] + w, d2[j][1] + v])\n    d1.sort()\n    d2.sort()\n    for i in range(len(d2) + 1):\n        if d2[i + 1][1] < d2[i][1]:\n            d2[i + 1][1] = d2[i][1]\n    ans = 0\n    INF = float('inf')\n    for (w, v) in d1:\n        if w > W:\n            continue\n        rest = W - w\n        idx = bisect_right(d2, [rest, INF])\n        ans = max(ans, d2[idx - 1][1] + v)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "for i in range(len(d2) - 1):",
      "mutated_line": "for i in range(len(d2) * 1):",
      "code": "from bisect import bisect_right\n\ndef max_knapsack_value(N, W, items):\n    d1 = [[0, 0]]\n    d2 = [[0, 0]]\n    half = N // 2\n    for i in range(half):\n        (w, v) = items[i]\n        size = len(d1)\n        for j in range(size):\n            d1.append([d1[j][0] + w, d1[j][1] + v])\n    for i in range(N - half):\n        (w, v) = items[half + i]\n        size = len(d2)\n        for j in range(size):\n            d2.append([d2[j][0] + w, d2[j][1] + v])\n    d1.sort()\n    d2.sort()\n    for i in range(len(d2) * 1):\n        if d2[i + 1][1] < d2[i][1]:\n            d2[i + 1][1] = d2[i][1]\n    ans = 0\n    INF = float('inf')\n    for (w, v) in d1:\n        if w > W:\n            continue\n        rest = W - w\n        idx = bisect_right(d2, [rest, INF])\n        ans = max(ans, d2[idx - 1][1] + v)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if d2[i + 1][1] < d2[i][1]:",
      "mutated_line": "if d2[i + 1][1] <= d2[i][1]:",
      "code": "from bisect import bisect_right\n\ndef max_knapsack_value(N, W, items):\n    d1 = [[0, 0]]\n    d2 = [[0, 0]]\n    half = N // 2\n    for i in range(half):\n        (w, v) = items[i]\n        size = len(d1)\n        for j in range(size):\n            d1.append([d1[j][0] + w, d1[j][1] + v])\n    for i in range(N - half):\n        (w, v) = items[half + i]\n        size = len(d2)\n        for j in range(size):\n            d2.append([d2[j][0] + w, d2[j][1] + v])\n    d1.sort()\n    d2.sort()\n    for i in range(len(d2) - 1):\n        if d2[i + 1][1] <= d2[i][1]:\n            d2[i + 1][1] = d2[i][1]\n    ans = 0\n    INF = float('inf')\n    for (w, v) in d1:\n        if w > W:\n            continue\n        rest = W - w\n        idx = bisect_right(d2, [rest, INF])\n        ans = max(ans, d2[idx - 1][1] + v)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if d2[i + 1][1] < d2[i][1]:",
      "mutated_line": "if d2[i + 1][1] >= d2[i][1]:",
      "code": "from bisect import bisect_right\n\ndef max_knapsack_value(N, W, items):\n    d1 = [[0, 0]]\n    d2 = [[0, 0]]\n    half = N // 2\n    for i in range(half):\n        (w, v) = items[i]\n        size = len(d1)\n        for j in range(size):\n            d1.append([d1[j][0] + w, d1[j][1] + v])\n    for i in range(N - half):\n        (w, v) = items[half + i]\n        size = len(d2)\n        for j in range(size):\n            d2.append([d2[j][0] + w, d2[j][1] + v])\n    d1.sort()\n    d2.sort()\n    for i in range(len(d2) - 1):\n        if d2[i + 1][1] >= d2[i][1]:\n            d2[i + 1][1] = d2[i][1]\n    ans = 0\n    INF = float('inf')\n    for (w, v) in d1:\n        if w > W:\n            continue\n        rest = W - w\n        idx = bisect_right(d2, [rest, INF])\n        ans = max(ans, d2[idx - 1][1] + v)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if d2[i + 1][1] < d2[i][1]:",
      "mutated_line": "if d2[i + 1][1] != d2[i][1]:",
      "code": "from bisect import bisect_right\n\ndef max_knapsack_value(N, W, items):\n    d1 = [[0, 0]]\n    d2 = [[0, 0]]\n    half = N // 2\n    for i in range(half):\n        (w, v) = items[i]\n        size = len(d1)\n        for j in range(size):\n            d1.append([d1[j][0] + w, d1[j][1] + v])\n    for i in range(N - half):\n        (w, v) = items[half + i]\n        size = len(d2)\n        for j in range(size):\n            d2.append([d2[j][0] + w, d2[j][1] + v])\n    d1.sort()\n    d2.sort()\n    for i in range(len(d2) - 1):\n        if d2[i + 1][1] != d2[i][1]:\n            d2[i + 1][1] = d2[i][1]\n    ans = 0\n    INF = float('inf')\n    for (w, v) in d1:\n        if w > W:\n            continue\n        rest = W - w\n        idx = bisect_right(d2, [rest, INF])\n        ans = max(ans, d2[idx - 1][1] + v)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "INF = float('inf')",
      "mutated_line": "INF = float('')",
      "code": "from bisect import bisect_right\n\ndef max_knapsack_value(N, W, items):\n    d1 = [[0, 0]]\n    d2 = [[0, 0]]\n    half = N // 2\n    for i in range(half):\n        (w, v) = items[i]\n        size = len(d1)\n        for j in range(size):\n            d1.append([d1[j][0] + w, d1[j][1] + v])\n    for i in range(N - half):\n        (w, v) = items[half + i]\n        size = len(d2)\n        for j in range(size):\n            d2.append([d2[j][0] + w, d2[j][1] + v])\n    d1.sort()\n    d2.sort()\n    for i in range(len(d2) - 1):\n        if d2[i + 1][1] < d2[i][1]:\n            d2[i + 1][1] = d2[i][1]\n    ans = 0\n    INF = float('')\n    for (w, v) in d1:\n        if w > W:\n            continue\n        rest = W - w\n        idx = bisect_right(d2, [rest, INF])\n        ans = max(ans, d2[idx - 1][1] + v)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if w > W:",
      "mutated_line": "if w >= W:",
      "code": "from bisect import bisect_right\n\ndef max_knapsack_value(N, W, items):\n    d1 = [[0, 0]]\n    d2 = [[0, 0]]\n    half = N // 2\n    for i in range(half):\n        (w, v) = items[i]\n        size = len(d1)\n        for j in range(size):\n            d1.append([d1[j][0] + w, d1[j][1] + v])\n    for i in range(N - half):\n        (w, v) = items[half + i]\n        size = len(d2)\n        for j in range(size):\n            d2.append([d2[j][0] + w, d2[j][1] + v])\n    d1.sort()\n    d2.sort()\n    for i in range(len(d2) - 1):\n        if d2[i + 1][1] < d2[i][1]:\n            d2[i + 1][1] = d2[i][1]\n    ans = 0\n    INF = float('inf')\n    for (w, v) in d1:\n        if w >= W:\n            continue\n        rest = W - w\n        idx = bisect_right(d2, [rest, INF])\n        ans = max(ans, d2[idx - 1][1] + v)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if w > W:",
      "mutated_line": "if w <= W:",
      "code": "from bisect import bisect_right\n\ndef max_knapsack_value(N, W, items):\n    d1 = [[0, 0]]\n    d2 = [[0, 0]]\n    half = N // 2\n    for i in range(half):\n        (w, v) = items[i]\n        size = len(d1)\n        for j in range(size):\n            d1.append([d1[j][0] + w, d1[j][1] + v])\n    for i in range(N - half):\n        (w, v) = items[half + i]\n        size = len(d2)\n        for j in range(size):\n            d2.append([d2[j][0] + w, d2[j][1] + v])\n    d1.sort()\n    d2.sort()\n    for i in range(len(d2) - 1):\n        if d2[i + 1][1] < d2[i][1]:\n            d2[i + 1][1] = d2[i][1]\n    ans = 0\n    INF = float('inf')\n    for (w, v) in d1:\n        if w <= W:\n            continue\n        rest = W - w\n        idx = bisect_right(d2, [rest, INF])\n        ans = max(ans, d2[idx - 1][1] + v)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if w > W:",
      "mutated_line": "if w != W:",
      "code": "from bisect import bisect_right\n\ndef max_knapsack_value(N, W, items):\n    d1 = [[0, 0]]\n    d2 = [[0, 0]]\n    half = N // 2\n    for i in range(half):\n        (w, v) = items[i]\n        size = len(d1)\n        for j in range(size):\n            d1.append([d1[j][0] + w, d1[j][1] + v])\n    for i in range(N - half):\n        (w, v) = items[half + i]\n        size = len(d2)\n        for j in range(size):\n            d2.append([d2[j][0] + w, d2[j][1] + v])\n    d1.sort()\n    d2.sort()\n    for i in range(len(d2) - 1):\n        if d2[i + 1][1] < d2[i][1]:\n            d2[i + 1][1] = d2[i][1]\n    ans = 0\n    INF = float('inf')\n    for (w, v) in d1:\n        if w != W:\n            continue\n        rest = W - w\n        idx = bisect_right(d2, [rest, INF])\n        ans = max(ans, d2[idx - 1][1] + v)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "rest = W - w",
      "mutated_line": "rest = W + w",
      "code": "from bisect import bisect_right\n\ndef max_knapsack_value(N, W, items):\n    d1 = [[0, 0]]\n    d2 = [[0, 0]]\n    half = N // 2\n    for i in range(half):\n        (w, v) = items[i]\n        size = len(d1)\n        for j in range(size):\n            d1.append([d1[j][0] + w, d1[j][1] + v])\n    for i in range(N - half):\n        (w, v) = items[half + i]\n        size = len(d2)\n        for j in range(size):\n            d2.append([d2[j][0] + w, d2[j][1] + v])\n    d1.sort()\n    d2.sort()\n    for i in range(len(d2) - 1):\n        if d2[i + 1][1] < d2[i][1]:\n            d2[i + 1][1] = d2[i][1]\n    ans = 0\n    INF = float('inf')\n    for (w, v) in d1:\n        if w > W:\n            continue\n        rest = W + w\n        idx = bisect_right(d2, [rest, INF])\n        ans = max(ans, d2[idx - 1][1] + v)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "rest = W - w",
      "mutated_line": "rest = W * w",
      "code": "from bisect import bisect_right\n\ndef max_knapsack_value(N, W, items):\n    d1 = [[0, 0]]\n    d2 = [[0, 0]]\n    half = N // 2\n    for i in range(half):\n        (w, v) = items[i]\n        size = len(d1)\n        for j in range(size):\n            d1.append([d1[j][0] + w, d1[j][1] + v])\n    for i in range(N - half):\n        (w, v) = items[half + i]\n        size = len(d2)\n        for j in range(size):\n            d2.append([d2[j][0] + w, d2[j][1] + v])\n    d1.sort()\n    d2.sort()\n    for i in range(len(d2) - 1):\n        if d2[i + 1][1] < d2[i][1]:\n            d2[i + 1][1] = d2[i][1]\n    ans = 0\n    INF = float('inf')\n    for (w, v) in d1:\n        if w > W:\n            continue\n        rest = W * w\n        idx = bisect_right(d2, [rest, INF])\n        ans = max(ans, d2[idx - 1][1] + v)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "d1 = [[0, 0]]",
      "mutated_line": "d1 = [[1, 0]]",
      "code": "from bisect import bisect_right\n\ndef max_knapsack_value(N, W, items):\n    d1 = [[1, 0]]\n    d2 = [[0, 0]]\n    half = N // 2\n    for i in range(half):\n        (w, v) = items[i]\n        size = len(d1)\n        for j in range(size):\n            d1.append([d1[j][0] + w, d1[j][1] + v])\n    for i in range(N - half):\n        (w, v) = items[half + i]\n        size = len(d2)\n        for j in range(size):\n            d2.append([d2[j][0] + w, d2[j][1] + v])\n    d1.sort()\n    d2.sort()\n    for i in range(len(d2) - 1):\n        if d2[i + 1][1] < d2[i][1]:\n            d2[i + 1][1] = d2[i][1]\n    ans = 0\n    INF = float('inf')\n    for (w, v) in d1:\n        if w > W:\n            continue\n        rest = W - w\n        idx = bisect_right(d2, [rest, INF])\n        ans = max(ans, d2[idx - 1][1] + v)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "d1 = [[0, 0]]",
      "mutated_line": "d1 = [[-1, 0]]",
      "code": "from bisect import bisect_right\n\ndef max_knapsack_value(N, W, items):\n    d1 = [[-1, 0]]\n    d2 = [[0, 0]]\n    half = N // 2\n    for i in range(half):\n        (w, v) = items[i]\n        size = len(d1)\n        for j in range(size):\n            d1.append([d1[j][0] + w, d1[j][1] + v])\n    for i in range(N - half):\n        (w, v) = items[half + i]\n        size = len(d2)\n        for j in range(size):\n            d2.append([d2[j][0] + w, d2[j][1] + v])\n    d1.sort()\n    d2.sort()\n    for i in range(len(d2) - 1):\n        if d2[i + 1][1] < d2[i][1]:\n            d2[i + 1][1] = d2[i][1]\n    ans = 0\n    INF = float('inf')\n    for (w, v) in d1:\n        if w > W:\n            continue\n        rest = W - w\n        idx = bisect_right(d2, [rest, INF])\n        ans = max(ans, d2[idx - 1][1] + v)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "d1 = [[0, 0]]",
      "mutated_line": "d1 = [[1, 0]]",
      "code": "from bisect import bisect_right\n\ndef max_knapsack_value(N, W, items):\n    d1 = [[1, 0]]\n    d2 = [[0, 0]]\n    half = N // 2\n    for i in range(half):\n        (w, v) = items[i]\n        size = len(d1)\n        for j in range(size):\n            d1.append([d1[j][0] + w, d1[j][1] + v])\n    for i in range(N - half):\n        (w, v) = items[half + i]\n        size = len(d2)\n        for j in range(size):\n            d2.append([d2[j][0] + w, d2[j][1] + v])\n    d1.sort()\n    d2.sort()\n    for i in range(len(d2) - 1):\n        if d2[i + 1][1] < d2[i][1]:\n            d2[i + 1][1] = d2[i][1]\n    ans = 0\n    INF = float('inf')\n    for (w, v) in d1:\n        if w > W:\n            continue\n        rest = W - w\n        idx = bisect_right(d2, [rest, INF])\n        ans = max(ans, d2[idx - 1][1] + v)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "d1 = [[0, 0]]",
      "mutated_line": "d1 = [[0, 1]]",
      "code": "from bisect import bisect_right\n\ndef max_knapsack_value(N, W, items):\n    d1 = [[0, 1]]\n    d2 = [[0, 0]]\n    half = N // 2\n    for i in range(half):\n        (w, v) = items[i]\n        size = len(d1)\n        for j in range(size):\n            d1.append([d1[j][0] + w, d1[j][1] + v])\n    for i in range(N - half):\n        (w, v) = items[half + i]\n        size = len(d2)\n        for j in range(size):\n            d2.append([d2[j][0] + w, d2[j][1] + v])\n    d1.sort()\n    d2.sort()\n    for i in range(len(d2) - 1):\n        if d2[i + 1][1] < d2[i][1]:\n            d2[i + 1][1] = d2[i][1]\n    ans = 0\n    INF = float('inf')\n    for (w, v) in d1:\n        if w > W:\n            continue\n        rest = W - w\n        idx = bisect_right(d2, [rest, INF])\n        ans = max(ans, d2[idx - 1][1] + v)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "d1 = [[0, 0]]",
      "mutated_line": "d1 = [[0, -1]]",
      "code": "from bisect import bisect_right\n\ndef max_knapsack_value(N, W, items):\n    d1 = [[0, -1]]\n    d2 = [[0, 0]]\n    half = N // 2\n    for i in range(half):\n        (w, v) = items[i]\n        size = len(d1)\n        for j in range(size):\n            d1.append([d1[j][0] + w, d1[j][1] + v])\n    for i in range(N - half):\n        (w, v) = items[half + i]\n        size = len(d2)\n        for j in range(size):\n            d2.append([d2[j][0] + w, d2[j][1] + v])\n    d1.sort()\n    d2.sort()\n    for i in range(len(d2) - 1):\n        if d2[i + 1][1] < d2[i][1]:\n            d2[i + 1][1] = d2[i][1]\n    ans = 0\n    INF = float('inf')\n    for (w, v) in d1:\n        if w > W:\n            continue\n        rest = W - w\n        idx = bisect_right(d2, [rest, INF])\n        ans = max(ans, d2[idx - 1][1] + v)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "d1 = [[0, 0]]",
      "mutated_line": "d1 = [[0, 1]]",
      "code": "from bisect import bisect_right\n\ndef max_knapsack_value(N, W, items):\n    d1 = [[0, 1]]\n    d2 = [[0, 0]]\n    half = N // 2\n    for i in range(half):\n        (w, v) = items[i]\n        size = len(d1)\n        for j in range(size):\n            d1.append([d1[j][0] + w, d1[j][1] + v])\n    for i in range(N - half):\n        (w, v) = items[half + i]\n        size = len(d2)\n        for j in range(size):\n            d2.append([d2[j][0] + w, d2[j][1] + v])\n    d1.sort()\n    d2.sort()\n    for i in range(len(d2) - 1):\n        if d2[i + 1][1] < d2[i][1]:\n            d2[i + 1][1] = d2[i][1]\n    ans = 0\n    INF = float('inf')\n    for (w, v) in d1:\n        if w > W:\n            continue\n        rest = W - w\n        idx = bisect_right(d2, [rest, INF])\n        ans = max(ans, d2[idx - 1][1] + v)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "d2 = [[0, 0]]",
      "mutated_line": "d2 = [[1, 0]]",
      "code": "from bisect import bisect_right\n\ndef max_knapsack_value(N, W, items):\n    d1 = [[0, 0]]\n    d2 = [[1, 0]]\n    half = N // 2\n    for i in range(half):\n        (w, v) = items[i]\n        size = len(d1)\n        for j in range(size):\n            d1.append([d1[j][0] + w, d1[j][1] + v])\n    for i in range(N - half):\n        (w, v) = items[half + i]\n        size = len(d2)\n        for j in range(size):\n            d2.append([d2[j][0] + w, d2[j][1] + v])\n    d1.sort()\n    d2.sort()\n    for i in range(len(d2) - 1):\n        if d2[i + 1][1] < d2[i][1]:\n            d2[i + 1][1] = d2[i][1]\n    ans = 0\n    INF = float('inf')\n    for (w, v) in d1:\n        if w > W:\n            continue\n        rest = W - w\n        idx = bisect_right(d2, [rest, INF])\n        ans = max(ans, d2[idx - 1][1] + v)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "d2 = [[0, 0]]",
      "mutated_line": "d2 = [[-1, 0]]",
      "code": "from bisect import bisect_right\n\ndef max_knapsack_value(N, W, items):\n    d1 = [[0, 0]]\n    d2 = [[-1, 0]]\n    half = N // 2\n    for i in range(half):\n        (w, v) = items[i]\n        size = len(d1)\n        for j in range(size):\n            d1.append([d1[j][0] + w, d1[j][1] + v])\n    for i in range(N - half):\n        (w, v) = items[half + i]\n        size = len(d2)\n        for j in range(size):\n            d2.append([d2[j][0] + w, d2[j][1] + v])\n    d1.sort()\n    d2.sort()\n    for i in range(len(d2) - 1):\n        if d2[i + 1][1] < d2[i][1]:\n            d2[i + 1][1] = d2[i][1]\n    ans = 0\n    INF = float('inf')\n    for (w, v) in d1:\n        if w > W:\n            continue\n        rest = W - w\n        idx = bisect_right(d2, [rest, INF])\n        ans = max(ans, d2[idx - 1][1] + v)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "d2 = [[0, 0]]",
      "mutated_line": "d2 = [[1, 0]]",
      "code": "from bisect import bisect_right\n\ndef max_knapsack_value(N, W, items):\n    d1 = [[0, 0]]\n    d2 = [[1, 0]]\n    half = N // 2\n    for i in range(half):\n        (w, v) = items[i]\n        size = len(d1)\n        for j in range(size):\n            d1.append([d1[j][0] + w, d1[j][1] + v])\n    for i in range(N - half):\n        (w, v) = items[half + i]\n        size = len(d2)\n        for j in range(size):\n            d2.append([d2[j][0] + w, d2[j][1] + v])\n    d1.sort()\n    d2.sort()\n    for i in range(len(d2) - 1):\n        if d2[i + 1][1] < d2[i][1]:\n            d2[i + 1][1] = d2[i][1]\n    ans = 0\n    INF = float('inf')\n    for (w, v) in d1:\n        if w > W:\n            continue\n        rest = W - w\n        idx = bisect_right(d2, [rest, INF])\n        ans = max(ans, d2[idx - 1][1] + v)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "d2 = [[0, 0]]",
      "mutated_line": "d2 = [[0, 1]]",
      "code": "from bisect import bisect_right\n\ndef max_knapsack_value(N, W, items):\n    d1 = [[0, 0]]\n    d2 = [[0, 1]]\n    half = N // 2\n    for i in range(half):\n        (w, v) = items[i]\n        size = len(d1)\n        for j in range(size):\n            d1.append([d1[j][0] + w, d1[j][1] + v])\n    for i in range(N - half):\n        (w, v) = items[half + i]\n        size = len(d2)\n        for j in range(size):\n            d2.append([d2[j][0] + w, d2[j][1] + v])\n    d1.sort()\n    d2.sort()\n    for i in range(len(d2) - 1):\n        if d2[i + 1][1] < d2[i][1]:\n            d2[i + 1][1] = d2[i][1]\n    ans = 0\n    INF = float('inf')\n    for (w, v) in d1:\n        if w > W:\n            continue\n        rest = W - w\n        idx = bisect_right(d2, [rest, INF])\n        ans = max(ans, d2[idx - 1][1] + v)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "d2 = [[0, 0]]",
      "mutated_line": "d2 = [[0, -1]]",
      "code": "from bisect import bisect_right\n\ndef max_knapsack_value(N, W, items):\n    d1 = [[0, 0]]\n    d2 = [[0, -1]]\n    half = N // 2\n    for i in range(half):\n        (w, v) = items[i]\n        size = len(d1)\n        for j in range(size):\n            d1.append([d1[j][0] + w, d1[j][1] + v])\n    for i in range(N - half):\n        (w, v) = items[half + i]\n        size = len(d2)\n        for j in range(size):\n            d2.append([d2[j][0] + w, d2[j][1] + v])\n    d1.sort()\n    d2.sort()\n    for i in range(len(d2) - 1):\n        if d2[i + 1][1] < d2[i][1]:\n            d2[i + 1][1] = d2[i][1]\n    ans = 0\n    INF = float('inf')\n    for (w, v) in d1:\n        if w > W:\n            continue\n        rest = W - w\n        idx = bisect_right(d2, [rest, INF])\n        ans = max(ans, d2[idx - 1][1] + v)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "d2 = [[0, 0]]",
      "mutated_line": "d2 = [[0, 1]]",
      "code": "from bisect import bisect_right\n\ndef max_knapsack_value(N, W, items):\n    d1 = [[0, 0]]\n    d2 = [[0, 1]]\n    half = N // 2\n    for i in range(half):\n        (w, v) = items[i]\n        size = len(d1)\n        for j in range(size):\n            d1.append([d1[j][0] + w, d1[j][1] + v])\n    for i in range(N - half):\n        (w, v) = items[half + i]\n        size = len(d2)\n        for j in range(size):\n            d2.append([d2[j][0] + w, d2[j][1] + v])\n    d1.sort()\n    d2.sort()\n    for i in range(len(d2) - 1):\n        if d2[i + 1][1] < d2[i][1]:\n            d2[i + 1][1] = d2[i][1]\n    ans = 0\n    INF = float('inf')\n    for (w, v) in d1:\n        if w > W:\n            continue\n        rest = W - w\n        idx = bisect_right(d2, [rest, INF])\n        ans = max(ans, d2[idx - 1][1] + v)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "(w, v) = items[half + i]",
      "mutated_line": "(w, v) = items[half - i]",
      "code": "from bisect import bisect_right\n\ndef max_knapsack_value(N, W, items):\n    d1 = [[0, 0]]\n    d2 = [[0, 0]]\n    half = N // 2\n    for i in range(half):\n        (w, v) = items[i]\n        size = len(d1)\n        for j in range(size):\n            d1.append([d1[j][0] + w, d1[j][1] + v])\n    for i in range(N - half):\n        (w, v) = items[half - i]\n        size = len(d2)\n        for j in range(size):\n            d2.append([d2[j][0] + w, d2[j][1] + v])\n    d1.sort()\n    d2.sort()\n    for i in range(len(d2) - 1):\n        if d2[i + 1][1] < d2[i][1]:\n            d2[i + 1][1] = d2[i][1]\n    ans = 0\n    INF = float('inf')\n    for (w, v) in d1:\n        if w > W:\n            continue\n        rest = W - w\n        idx = bisect_right(d2, [rest, INF])\n        ans = max(ans, d2[idx - 1][1] + v)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "(w, v) = items[half + i]",
      "mutated_line": "(w, v) = items[half * i]",
      "code": "from bisect import bisect_right\n\ndef max_knapsack_value(N, W, items):\n    d1 = [[0, 0]]\n    d2 = [[0, 0]]\n    half = N // 2\n    for i in range(half):\n        (w, v) = items[i]\n        size = len(d1)\n        for j in range(size):\n            d1.append([d1[j][0] + w, d1[j][1] + v])\n    for i in range(N - half):\n        (w, v) = items[half * i]\n        size = len(d2)\n        for j in range(size):\n            d2.append([d2[j][0] + w, d2[j][1] + v])\n    d1.sort()\n    d2.sort()\n    for i in range(len(d2) - 1):\n        if d2[i + 1][1] < d2[i][1]:\n            d2[i + 1][1] = d2[i][1]\n    ans = 0\n    INF = float('inf')\n    for (w, v) in d1:\n        if w > W:\n            continue\n        rest = W - w\n        idx = bisect_right(d2, [rest, INF])\n        ans = max(ans, d2[idx - 1][1] + v)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for i in range(len(d2) - 1):",
      "mutated_line": "for i in range(len(d2) - 2):",
      "code": "from bisect import bisect_right\n\ndef max_knapsack_value(N, W, items):\n    d1 = [[0, 0]]\n    d2 = [[0, 0]]\n    half = N // 2\n    for i in range(half):\n        (w, v) = items[i]\n        size = len(d1)\n        for j in range(size):\n            d1.append([d1[j][0] + w, d1[j][1] + v])\n    for i in range(N - half):\n        (w, v) = items[half + i]\n        size = len(d2)\n        for j in range(size):\n            d2.append([d2[j][0] + w, d2[j][1] + v])\n    d1.sort()\n    d2.sort()\n    for i in range(len(d2) - 2):\n        if d2[i + 1][1] < d2[i][1]:\n            d2[i + 1][1] = d2[i][1]\n    ans = 0\n    INF = float('inf')\n    for (w, v) in d1:\n        if w > W:\n            continue\n        rest = W - w\n        idx = bisect_right(d2, [rest, INF])\n        ans = max(ans, d2[idx - 1][1] + v)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for i in range(len(d2) - 1):",
      "mutated_line": "for i in range(len(d2) - 0):",
      "code": "from bisect import bisect_right\n\ndef max_knapsack_value(N, W, items):\n    d1 = [[0, 0]]\n    d2 = [[0, 0]]\n    half = N // 2\n    for i in range(half):\n        (w, v) = items[i]\n        size = len(d1)\n        for j in range(size):\n            d1.append([d1[j][0] + w, d1[j][1] + v])\n    for i in range(N - half):\n        (w, v) = items[half + i]\n        size = len(d2)\n        for j in range(size):\n            d2.append([d2[j][0] + w, d2[j][1] + v])\n    d1.sort()\n    d2.sort()\n    for i in range(len(d2) - 0):\n        if d2[i + 1][1] < d2[i][1]:\n            d2[i + 1][1] = d2[i][1]\n    ans = 0\n    INF = float('inf')\n    for (w, v) in d1:\n        if w > W:\n            continue\n        rest = W - w\n        idx = bisect_right(d2, [rest, INF])\n        ans = max(ans, d2[idx - 1][1] + v)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for i in range(len(d2) - 1):",
      "mutated_line": "for i in range(len(d2) - 0):",
      "code": "from bisect import bisect_right\n\ndef max_knapsack_value(N, W, items):\n    d1 = [[0, 0]]\n    d2 = [[0, 0]]\n    half = N // 2\n    for i in range(half):\n        (w, v) = items[i]\n        size = len(d1)\n        for j in range(size):\n            d1.append([d1[j][0] + w, d1[j][1] + v])\n    for i in range(N - half):\n        (w, v) = items[half + i]\n        size = len(d2)\n        for j in range(size):\n            d2.append([d2[j][0] + w, d2[j][1] + v])\n    d1.sort()\n    d2.sort()\n    for i in range(len(d2) - 0):\n        if d2[i + 1][1] < d2[i][1]:\n            d2[i + 1][1] = d2[i][1]\n    ans = 0\n    INF = float('inf')\n    for (w, v) in d1:\n        if w > W:\n            continue\n        rest = W - w\n        idx = bisect_right(d2, [rest, INF])\n        ans = max(ans, d2[idx - 1][1] + v)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for i in range(len(d2) - 1):",
      "mutated_line": "for i in range(len(d2) - -1):",
      "code": "from bisect import bisect_right\n\ndef max_knapsack_value(N, W, items):\n    d1 = [[0, 0]]\n    d2 = [[0, 0]]\n    half = N // 2\n    for i in range(half):\n        (w, v) = items[i]\n        size = len(d1)\n        for j in range(size):\n            d1.append([d1[j][0] + w, d1[j][1] + v])\n    for i in range(N - half):\n        (w, v) = items[half + i]\n        size = len(d2)\n        for j in range(size):\n            d2.append([d2[j][0] + w, d2[j][1] + v])\n    d1.sort()\n    d2.sort()\n    for i in range(len(d2) - -1):\n        if d2[i + 1][1] < d2[i][1]:\n            d2[i + 1][1] = d2[i][1]\n    ans = 0\n    INF = float('inf')\n    for (w, v) in d1:\n        if w > W:\n            continue\n        rest = W - w\n        idx = bisect_right(d2, [rest, INF])\n        ans = max(ans, d2[idx - 1][1] + v)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "ans = max(ans, d2[idx - 1][1] + v)",
      "mutated_line": "ans = max(ans, d2[idx - 1][1] - v)",
      "code": "from bisect import bisect_right\n\ndef max_knapsack_value(N, W, items):\n    d1 = [[0, 0]]\n    d2 = [[0, 0]]\n    half = N // 2\n    for i in range(half):\n        (w, v) = items[i]\n        size = len(d1)\n        for j in range(size):\n            d1.append([d1[j][0] + w, d1[j][1] + v])\n    for i in range(N - half):\n        (w, v) = items[half + i]\n        size = len(d2)\n        for j in range(size):\n            d2.append([d2[j][0] + w, d2[j][1] + v])\n    d1.sort()\n    d2.sort()\n    for i in range(len(d2) - 1):\n        if d2[i + 1][1] < d2[i][1]:\n            d2[i + 1][1] = d2[i][1]\n    ans = 0\n    INF = float('inf')\n    for (w, v) in d1:\n        if w > W:\n            continue\n        rest = W - w\n        idx = bisect_right(d2, [rest, INF])\n        ans = max(ans, d2[idx - 1][1] - v)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "ans = max(ans, d2[idx - 1][1] + v)",
      "mutated_line": "ans = max(ans, d2[idx - 1][1] * v)",
      "code": "from bisect import bisect_right\n\ndef max_knapsack_value(N, W, items):\n    d1 = [[0, 0]]\n    d2 = [[0, 0]]\n    half = N // 2\n    for i in range(half):\n        (w, v) = items[i]\n        size = len(d1)\n        for j in range(size):\n            d1.append([d1[j][0] + w, d1[j][1] + v])\n    for i in range(N - half):\n        (w, v) = items[half + i]\n        size = len(d2)\n        for j in range(size):\n            d2.append([d2[j][0] + w, d2[j][1] + v])\n    d1.sort()\n    d2.sort()\n    for i in range(len(d2) - 1):\n        if d2[i + 1][1] < d2[i][1]:\n            d2[i + 1][1] = d2[i][1]\n    ans = 0\n    INF = float('inf')\n    for (w, v) in d1:\n        if w > W:\n            continue\n        rest = W - w\n        idx = bisect_right(d2, [rest, INF])\n        ans = max(ans, d2[idx - 1][1] * v)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if d2[i + 1][1] < d2[i][1]:",
      "mutated_line": "if d2[i + 1][2] < d2[i][1]:",
      "code": "from bisect import bisect_right\n\ndef max_knapsack_value(N, W, items):\n    d1 = [[0, 0]]\n    d2 = [[0, 0]]\n    half = N // 2\n    for i in range(half):\n        (w, v) = items[i]\n        size = len(d1)\n        for j in range(size):\n            d1.append([d1[j][0] + w, d1[j][1] + v])\n    for i in range(N - half):\n        (w, v) = items[half + i]\n        size = len(d2)\n        for j in range(size):\n            d2.append([d2[j][0] + w, d2[j][1] + v])\n    d1.sort()\n    d2.sort()\n    for i in range(len(d2) - 1):\n        if d2[i + 1][2] < d2[i][1]:\n            d2[i + 1][1] = d2[i][1]\n    ans = 0\n    INF = float('inf')\n    for (w, v) in d1:\n        if w > W:\n            continue\n        rest = W - w\n        idx = bisect_right(d2, [rest, INF])\n        ans = max(ans, d2[idx - 1][1] + v)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if d2[i + 1][1] < d2[i][1]:",
      "mutated_line": "if d2[i + 1][0] < d2[i][1]:",
      "code": "from bisect import bisect_right\n\ndef max_knapsack_value(N, W, items):\n    d1 = [[0, 0]]\n    d2 = [[0, 0]]\n    half = N // 2\n    for i in range(half):\n        (w, v) = items[i]\n        size = len(d1)\n        for j in range(size):\n            d1.append([d1[j][0] + w, d1[j][1] + v])\n    for i in range(N - half):\n        (w, v) = items[half + i]\n        size = len(d2)\n        for j in range(size):\n            d2.append([d2[j][0] + w, d2[j][1] + v])\n    d1.sort()\n    d2.sort()\n    for i in range(len(d2) - 1):\n        if d2[i + 1][0] < d2[i][1]:\n            d2[i + 1][1] = d2[i][1]\n    ans = 0\n    INF = float('inf')\n    for (w, v) in d1:\n        if w > W:\n            continue\n        rest = W - w\n        idx = bisect_right(d2, [rest, INF])\n        ans = max(ans, d2[idx - 1][1] + v)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if d2[i + 1][1] < d2[i][1]:",
      "mutated_line": "if d2[i + 1][0] < d2[i][1]:",
      "code": "from bisect import bisect_right\n\ndef max_knapsack_value(N, W, items):\n    d1 = [[0, 0]]\n    d2 = [[0, 0]]\n    half = N // 2\n    for i in range(half):\n        (w, v) = items[i]\n        size = len(d1)\n        for j in range(size):\n            d1.append([d1[j][0] + w, d1[j][1] + v])\n    for i in range(N - half):\n        (w, v) = items[half + i]\n        size = len(d2)\n        for j in range(size):\n            d2.append([d2[j][0] + w, d2[j][1] + v])\n    d1.sort()\n    d2.sort()\n    for i in range(len(d2) - 1):\n        if d2[i + 1][0] < d2[i][1]:\n            d2[i + 1][1] = d2[i][1]\n    ans = 0\n    INF = float('inf')\n    for (w, v) in d1:\n        if w > W:\n            continue\n        rest = W - w\n        idx = bisect_right(d2, [rest, INF])\n        ans = max(ans, d2[idx - 1][1] + v)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if d2[i + 1][1] < d2[i][1]:",
      "mutated_line": "if d2[i + 1][-1] < d2[i][1]:",
      "code": "from bisect import bisect_right\n\ndef max_knapsack_value(N, W, items):\n    d1 = [[0, 0]]\n    d2 = [[0, 0]]\n    half = N // 2\n    for i in range(half):\n        (w, v) = items[i]\n        size = len(d1)\n        for j in range(size):\n            d1.append([d1[j][0] + w, d1[j][1] + v])\n    for i in range(N - half):\n        (w, v) = items[half + i]\n        size = len(d2)\n        for j in range(size):\n            d2.append([d2[j][0] + w, d2[j][1] + v])\n    d1.sort()\n    d2.sort()\n    for i in range(len(d2) - 1):\n        if d2[i + 1][-1] < d2[i][1]:\n            d2[i + 1][1] = d2[i][1]\n    ans = 0\n    INF = float('inf')\n    for (w, v) in d1:\n        if w > W:\n            continue\n        rest = W - w\n        idx = bisect_right(d2, [rest, INF])\n        ans = max(ans, d2[idx - 1][1] + v)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if d2[i + 1][1] < d2[i][1]:",
      "mutated_line": "if d2[i + 1][1] < d2[i][2]:",
      "code": "from bisect import bisect_right\n\ndef max_knapsack_value(N, W, items):\n    d1 = [[0, 0]]\n    d2 = [[0, 0]]\n    half = N // 2\n    for i in range(half):\n        (w, v) = items[i]\n        size = len(d1)\n        for j in range(size):\n            d1.append([d1[j][0] + w, d1[j][1] + v])\n    for i in range(N - half):\n        (w, v) = items[half + i]\n        size = len(d2)\n        for j in range(size):\n            d2.append([d2[j][0] + w, d2[j][1] + v])\n    d1.sort()\n    d2.sort()\n    for i in range(len(d2) - 1):\n        if d2[i + 1][1] < d2[i][2]:\n            d2[i + 1][1] = d2[i][1]\n    ans = 0\n    INF = float('inf')\n    for (w, v) in d1:\n        if w > W:\n            continue\n        rest = W - w\n        idx = bisect_right(d2, [rest, INF])\n        ans = max(ans, d2[idx - 1][1] + v)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if d2[i + 1][1] < d2[i][1]:",
      "mutated_line": "if d2[i + 1][1] < d2[i][0]:",
      "code": "from bisect import bisect_right\n\ndef max_knapsack_value(N, W, items):\n    d1 = [[0, 0]]\n    d2 = [[0, 0]]\n    half = N // 2\n    for i in range(half):\n        (w, v) = items[i]\n        size = len(d1)\n        for j in range(size):\n            d1.append([d1[j][0] + w, d1[j][1] + v])\n    for i in range(N - half):\n        (w, v) = items[half + i]\n        size = len(d2)\n        for j in range(size):\n            d2.append([d2[j][0] + w, d2[j][1] + v])\n    d1.sort()\n    d2.sort()\n    for i in range(len(d2) - 1):\n        if d2[i + 1][1] < d2[i][0]:\n            d2[i + 1][1] = d2[i][1]\n    ans = 0\n    INF = float('inf')\n    for (w, v) in d1:\n        if w > W:\n            continue\n        rest = W - w\n        idx = bisect_right(d2, [rest, INF])\n        ans = max(ans, d2[idx - 1][1] + v)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if d2[i + 1][1] < d2[i][1]:",
      "mutated_line": "if d2[i + 1][1] < d2[i][0]:",
      "code": "from bisect import bisect_right\n\ndef max_knapsack_value(N, W, items):\n    d1 = [[0, 0]]\n    d2 = [[0, 0]]\n    half = N // 2\n    for i in range(half):\n        (w, v) = items[i]\n        size = len(d1)\n        for j in range(size):\n            d1.append([d1[j][0] + w, d1[j][1] + v])\n    for i in range(N - half):\n        (w, v) = items[half + i]\n        size = len(d2)\n        for j in range(size):\n            d2.append([d2[j][0] + w, d2[j][1] + v])\n    d1.sort()\n    d2.sort()\n    for i in range(len(d2) - 1):\n        if d2[i + 1][1] < d2[i][0]:\n            d2[i + 1][1] = d2[i][1]\n    ans = 0\n    INF = float('inf')\n    for (w, v) in d1:\n        if w > W:\n            continue\n        rest = W - w\n        idx = bisect_right(d2, [rest, INF])\n        ans = max(ans, d2[idx - 1][1] + v)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if d2[i + 1][1] < d2[i][1]:",
      "mutated_line": "if d2[i + 1][1] < d2[i][-1]:",
      "code": "from bisect import bisect_right\n\ndef max_knapsack_value(N, W, items):\n    d1 = [[0, 0]]\n    d2 = [[0, 0]]\n    half = N // 2\n    for i in range(half):\n        (w, v) = items[i]\n        size = len(d1)\n        for j in range(size):\n            d1.append([d1[j][0] + w, d1[j][1] + v])\n    for i in range(N - half):\n        (w, v) = items[half + i]\n        size = len(d2)\n        for j in range(size):\n            d2.append([d2[j][0] + w, d2[j][1] + v])\n    d1.sort()\n    d2.sort()\n    for i in range(len(d2) - 1):\n        if d2[i + 1][1] < d2[i][-1]:\n            d2[i + 1][1] = d2[i][1]\n    ans = 0\n    INF = float('inf')\n    for (w, v) in d1:\n        if w > W:\n            continue\n        rest = W - w\n        idx = bisect_right(d2, [rest, INF])\n        ans = max(ans, d2[idx - 1][1] + v)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "d2[i + 1][1] = d2[i][1]",
      "mutated_line": "d2[i + 1][2] = d2[i][1]",
      "code": "from bisect import bisect_right\n\ndef max_knapsack_value(N, W, items):\n    d1 = [[0, 0]]\n    d2 = [[0, 0]]\n    half = N // 2\n    for i in range(half):\n        (w, v) = items[i]\n        size = len(d1)\n        for j in range(size):\n            d1.append([d1[j][0] + w, d1[j][1] + v])\n    for i in range(N - half):\n        (w, v) = items[half + i]\n        size = len(d2)\n        for j in range(size):\n            d2.append([d2[j][0] + w, d2[j][1] + v])\n    d1.sort()\n    d2.sort()\n    for i in range(len(d2) - 1):\n        if d2[i + 1][1] < d2[i][1]:\n            d2[i + 1][2] = d2[i][1]\n    ans = 0\n    INF = float('inf')\n    for (w, v) in d1:\n        if w > W:\n            continue\n        rest = W - w\n        idx = bisect_right(d2, [rest, INF])\n        ans = max(ans, d2[idx - 1][1] + v)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "d2[i + 1][1] = d2[i][1]",
      "mutated_line": "d2[i + 1][0] = d2[i][1]",
      "code": "from bisect import bisect_right\n\ndef max_knapsack_value(N, W, items):\n    d1 = [[0, 0]]\n    d2 = [[0, 0]]\n    half = N // 2\n    for i in range(half):\n        (w, v) = items[i]\n        size = len(d1)\n        for j in range(size):\n            d1.append([d1[j][0] + w, d1[j][1] + v])\n    for i in range(N - half):\n        (w, v) = items[half + i]\n        size = len(d2)\n        for j in range(size):\n            d2.append([d2[j][0] + w, d2[j][1] + v])\n    d1.sort()\n    d2.sort()\n    for i in range(len(d2) - 1):\n        if d2[i + 1][1] < d2[i][1]:\n            d2[i + 1][0] = d2[i][1]\n    ans = 0\n    INF = float('inf')\n    for (w, v) in d1:\n        if w > W:\n            continue\n        rest = W - w\n        idx = bisect_right(d2, [rest, INF])\n        ans = max(ans, d2[idx - 1][1] + v)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "d2[i + 1][1] = d2[i][1]",
      "mutated_line": "d2[i + 1][0] = d2[i][1]",
      "code": "from bisect import bisect_right\n\ndef max_knapsack_value(N, W, items):\n    d1 = [[0, 0]]\n    d2 = [[0, 0]]\n    half = N // 2\n    for i in range(half):\n        (w, v) = items[i]\n        size = len(d1)\n        for j in range(size):\n            d1.append([d1[j][0] + w, d1[j][1] + v])\n    for i in range(N - half):\n        (w, v) = items[half + i]\n        size = len(d2)\n        for j in range(size):\n            d2.append([d2[j][0] + w, d2[j][1] + v])\n    d1.sort()\n    d2.sort()\n    for i in range(len(d2) - 1):\n        if d2[i + 1][1] < d2[i][1]:\n            d2[i + 1][0] = d2[i][1]\n    ans = 0\n    INF = float('inf')\n    for (w, v) in d1:\n        if w > W:\n            continue\n        rest = W - w\n        idx = bisect_right(d2, [rest, INF])\n        ans = max(ans, d2[idx - 1][1] + v)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "d2[i + 1][1] = d2[i][1]",
      "mutated_line": "d2[i + 1][-1] = d2[i][1]",
      "code": "from bisect import bisect_right\n\ndef max_knapsack_value(N, W, items):\n    d1 = [[0, 0]]\n    d2 = [[0, 0]]\n    half = N // 2\n    for i in range(half):\n        (w, v) = items[i]\n        size = len(d1)\n        for j in range(size):\n            d1.append([d1[j][0] + w, d1[j][1] + v])\n    for i in range(N - half):\n        (w, v) = items[half + i]\n        size = len(d2)\n        for j in range(size):\n            d2.append([d2[j][0] + w, d2[j][1] + v])\n    d1.sort()\n    d2.sort()\n    for i in range(len(d2) - 1):\n        if d2[i + 1][1] < d2[i][1]:\n            d2[i + 1][-1] = d2[i][1]\n    ans = 0\n    INF = float('inf')\n    for (w, v) in d1:\n        if w > W:\n            continue\n        rest = W - w\n        idx = bisect_right(d2, [rest, INF])\n        ans = max(ans, d2[idx - 1][1] + v)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "d2[i + 1][1] = d2[i][1]",
      "mutated_line": "d2[i + 1][1] = d2[i][2]",
      "code": "from bisect import bisect_right\n\ndef max_knapsack_value(N, W, items):\n    d1 = [[0, 0]]\n    d2 = [[0, 0]]\n    half = N // 2\n    for i in range(half):\n        (w, v) = items[i]\n        size = len(d1)\n        for j in range(size):\n            d1.append([d1[j][0] + w, d1[j][1] + v])\n    for i in range(N - half):\n        (w, v) = items[half + i]\n        size = len(d2)\n        for j in range(size):\n            d2.append([d2[j][0] + w, d2[j][1] + v])\n    d1.sort()\n    d2.sort()\n    for i in range(len(d2) - 1):\n        if d2[i + 1][1] < d2[i][1]:\n            d2[i + 1][1] = d2[i][2]\n    ans = 0\n    INF = float('inf')\n    for (w, v) in d1:\n        if w > W:\n            continue\n        rest = W - w\n        idx = bisect_right(d2, [rest, INF])\n        ans = max(ans, d2[idx - 1][1] + v)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "d2[i + 1][1] = d2[i][1]",
      "mutated_line": "d2[i + 1][1] = d2[i][0]",
      "code": "from bisect import bisect_right\n\ndef max_knapsack_value(N, W, items):\n    d1 = [[0, 0]]\n    d2 = [[0, 0]]\n    half = N // 2\n    for i in range(half):\n        (w, v) = items[i]\n        size = len(d1)\n        for j in range(size):\n            d1.append([d1[j][0] + w, d1[j][1] + v])\n    for i in range(N - half):\n        (w, v) = items[half + i]\n        size = len(d2)\n        for j in range(size):\n            d2.append([d2[j][0] + w, d2[j][1] + v])\n    d1.sort()\n    d2.sort()\n    for i in range(len(d2) - 1):\n        if d2[i + 1][1] < d2[i][1]:\n            d2[i + 1][1] = d2[i][0]\n    ans = 0\n    INF = float('inf')\n    for (w, v) in d1:\n        if w > W:\n            continue\n        rest = W - w\n        idx = bisect_right(d2, [rest, INF])\n        ans = max(ans, d2[idx - 1][1] + v)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "d2[i + 1][1] = d2[i][1]",
      "mutated_line": "d2[i + 1][1] = d2[i][0]",
      "code": "from bisect import bisect_right\n\ndef max_knapsack_value(N, W, items):\n    d1 = [[0, 0]]\n    d2 = [[0, 0]]\n    half = N // 2\n    for i in range(half):\n        (w, v) = items[i]\n        size = len(d1)\n        for j in range(size):\n            d1.append([d1[j][0] + w, d1[j][1] + v])\n    for i in range(N - half):\n        (w, v) = items[half + i]\n        size = len(d2)\n        for j in range(size):\n            d2.append([d2[j][0] + w, d2[j][1] + v])\n    d1.sort()\n    d2.sort()\n    for i in range(len(d2) - 1):\n        if d2[i + 1][1] < d2[i][1]:\n            d2[i + 1][1] = d2[i][0]\n    ans = 0\n    INF = float('inf')\n    for (w, v) in d1:\n        if w > W:\n            continue\n        rest = W - w\n        idx = bisect_right(d2, [rest, INF])\n        ans = max(ans, d2[idx - 1][1] + v)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "d2[i + 1][1] = d2[i][1]",
      "mutated_line": "d2[i + 1][1] = d2[i][-1]",
      "code": "from bisect import bisect_right\n\ndef max_knapsack_value(N, W, items):\n    d1 = [[0, 0]]\n    d2 = [[0, 0]]\n    half = N // 2\n    for i in range(half):\n        (w, v) = items[i]\n        size = len(d1)\n        for j in range(size):\n            d1.append([d1[j][0] + w, d1[j][1] + v])\n    for i in range(N - half):\n        (w, v) = items[half + i]\n        size = len(d2)\n        for j in range(size):\n            d2.append([d2[j][0] + w, d2[j][1] + v])\n    d1.sort()\n    d2.sort()\n    for i in range(len(d2) - 1):\n        if d2[i + 1][1] < d2[i][1]:\n            d2[i + 1][1] = d2[i][-1]\n    ans = 0\n    INF = float('inf')\n    for (w, v) in d1:\n        if w > W:\n            continue\n        rest = W - w\n        idx = bisect_right(d2, [rest, INF])\n        ans = max(ans, d2[idx - 1][1] + v)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "d1.append([d1[j][0] + w, d1[j][1] + v])",
      "mutated_line": "d1.append([d1[j][0] - w, d1[j][1] + v])",
      "code": "from bisect import bisect_right\n\ndef max_knapsack_value(N, W, items):\n    d1 = [[0, 0]]\n    d2 = [[0, 0]]\n    half = N // 2\n    for i in range(half):\n        (w, v) = items[i]\n        size = len(d1)\n        for j in range(size):\n            d1.append([d1[j][0] - w, d1[j][1] + v])\n    for i in range(N - half):\n        (w, v) = items[half + i]\n        size = len(d2)\n        for j in range(size):\n            d2.append([d2[j][0] + w, d2[j][1] + v])\n    d1.sort()\n    d2.sort()\n    for i in range(len(d2) - 1):\n        if d2[i + 1][1] < d2[i][1]:\n            d2[i + 1][1] = d2[i][1]\n    ans = 0\n    INF = float('inf')\n    for (w, v) in d1:\n        if w > W:\n            continue\n        rest = W - w\n        idx = bisect_right(d2, [rest, INF])\n        ans = max(ans, d2[idx - 1][1] + v)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "d1.append([d1[j][0] + w, d1[j][1] + v])",
      "mutated_line": "d1.append([d1[j][0] * w, d1[j][1] + v])",
      "code": "from bisect import bisect_right\n\ndef max_knapsack_value(N, W, items):\n    d1 = [[0, 0]]\n    d2 = [[0, 0]]\n    half = N // 2\n    for i in range(half):\n        (w, v) = items[i]\n        size = len(d1)\n        for j in range(size):\n            d1.append([d1[j][0] * w, d1[j][1] + v])\n    for i in range(N - half):\n        (w, v) = items[half + i]\n        size = len(d2)\n        for j in range(size):\n            d2.append([d2[j][0] + w, d2[j][1] + v])\n    d1.sort()\n    d2.sort()\n    for i in range(len(d2) - 1):\n        if d2[i + 1][1] < d2[i][1]:\n            d2[i + 1][1] = d2[i][1]\n    ans = 0\n    INF = float('inf')\n    for (w, v) in d1:\n        if w > W:\n            continue\n        rest = W - w\n        idx = bisect_right(d2, [rest, INF])\n        ans = max(ans, d2[idx - 1][1] + v)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "d1.append([d1[j][0] + w, d1[j][1] + v])",
      "mutated_line": "d1.append([d1[j][0] + w, d1[j][1] - v])",
      "code": "from bisect import bisect_right\n\ndef max_knapsack_value(N, W, items):\n    d1 = [[0, 0]]\n    d2 = [[0, 0]]\n    half = N // 2\n    for i in range(half):\n        (w, v) = items[i]\n        size = len(d1)\n        for j in range(size):\n            d1.append([d1[j][0] + w, d1[j][1] - v])\n    for i in range(N - half):\n        (w, v) = items[half + i]\n        size = len(d2)\n        for j in range(size):\n            d2.append([d2[j][0] + w, d2[j][1] + v])\n    d1.sort()\n    d2.sort()\n    for i in range(len(d2) - 1):\n        if d2[i + 1][1] < d2[i][1]:\n            d2[i + 1][1] = d2[i][1]\n    ans = 0\n    INF = float('inf')\n    for (w, v) in d1:\n        if w > W:\n            continue\n        rest = W - w\n        idx = bisect_right(d2, [rest, INF])\n        ans = max(ans, d2[idx - 1][1] + v)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "d1.append([d1[j][0] + w, d1[j][1] + v])",
      "mutated_line": "d1.append([d1[j][0] + w, d1[j][1] * v])",
      "code": "from bisect import bisect_right\n\ndef max_knapsack_value(N, W, items):\n    d1 = [[0, 0]]\n    d2 = [[0, 0]]\n    half = N // 2\n    for i in range(half):\n        (w, v) = items[i]\n        size = len(d1)\n        for j in range(size):\n            d1.append([d1[j][0] + w, d1[j][1] * v])\n    for i in range(N - half):\n        (w, v) = items[half + i]\n        size = len(d2)\n        for j in range(size):\n            d2.append([d2[j][0] + w, d2[j][1] + v])\n    d1.sort()\n    d2.sort()\n    for i in range(len(d2) - 1):\n        if d2[i + 1][1] < d2[i][1]:\n            d2[i + 1][1] = d2[i][1]\n    ans = 0\n    INF = float('inf')\n    for (w, v) in d1:\n        if w > W:\n            continue\n        rest = W - w\n        idx = bisect_right(d2, [rest, INF])\n        ans = max(ans, d2[idx - 1][1] + v)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "d2.append([d2[j][0] + w, d2[j][1] + v])",
      "mutated_line": "d2.append([d2[j][0] - w, d2[j][1] + v])",
      "code": "from bisect import bisect_right\n\ndef max_knapsack_value(N, W, items):\n    d1 = [[0, 0]]\n    d2 = [[0, 0]]\n    half = N // 2\n    for i in range(half):\n        (w, v) = items[i]\n        size = len(d1)\n        for j in range(size):\n            d1.append([d1[j][0] + w, d1[j][1] + v])\n    for i in range(N - half):\n        (w, v) = items[half + i]\n        size = len(d2)\n        for j in range(size):\n            d2.append([d2[j][0] - w, d2[j][1] + v])\n    d1.sort()\n    d2.sort()\n    for i in range(len(d2) - 1):\n        if d2[i + 1][1] < d2[i][1]:\n            d2[i + 1][1] = d2[i][1]\n    ans = 0\n    INF = float('inf')\n    for (w, v) in d1:\n        if w > W:\n            continue\n        rest = W - w\n        idx = bisect_right(d2, [rest, INF])\n        ans = max(ans, d2[idx - 1][1] + v)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "d2.append([d2[j][0] + w, d2[j][1] + v])",
      "mutated_line": "d2.append([d2[j][0] * w, d2[j][1] + v])",
      "code": "from bisect import bisect_right\n\ndef max_knapsack_value(N, W, items):\n    d1 = [[0, 0]]\n    d2 = [[0, 0]]\n    half = N // 2\n    for i in range(half):\n        (w, v) = items[i]\n        size = len(d1)\n        for j in range(size):\n            d1.append([d1[j][0] + w, d1[j][1] + v])\n    for i in range(N - half):\n        (w, v) = items[half + i]\n        size = len(d2)\n        for j in range(size):\n            d2.append([d2[j][0] * w, d2[j][1] + v])\n    d1.sort()\n    d2.sort()\n    for i in range(len(d2) - 1):\n        if d2[i + 1][1] < d2[i][1]:\n            d2[i + 1][1] = d2[i][1]\n    ans = 0\n    INF = float('inf')\n    for (w, v) in d1:\n        if w > W:\n            continue\n        rest = W - w\n        idx = bisect_right(d2, [rest, INF])\n        ans = max(ans, d2[idx - 1][1] + v)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "d2.append([d2[j][0] + w, d2[j][1] + v])",
      "mutated_line": "d2.append([d2[j][0] + w, d2[j][1] - v])",
      "code": "from bisect import bisect_right\n\ndef max_knapsack_value(N, W, items):\n    d1 = [[0, 0]]\n    d2 = [[0, 0]]\n    half = N // 2\n    for i in range(half):\n        (w, v) = items[i]\n        size = len(d1)\n        for j in range(size):\n            d1.append([d1[j][0] + w, d1[j][1] + v])\n    for i in range(N - half):\n        (w, v) = items[half + i]\n        size = len(d2)\n        for j in range(size):\n            d2.append([d2[j][0] + w, d2[j][1] - v])\n    d1.sort()\n    d2.sort()\n    for i in range(len(d2) - 1):\n        if d2[i + 1][1] < d2[i][1]:\n            d2[i + 1][1] = d2[i][1]\n    ans = 0\n    INF = float('inf')\n    for (w, v) in d1:\n        if w > W:\n            continue\n        rest = W - w\n        idx = bisect_right(d2, [rest, INF])\n        ans = max(ans, d2[idx - 1][1] + v)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "d2.append([d2[j][0] + w, d2[j][1] + v])",
      "mutated_line": "d2.append([d2[j][0] + w, d2[j][1] * v])",
      "code": "from bisect import bisect_right\n\ndef max_knapsack_value(N, W, items):\n    d1 = [[0, 0]]\n    d2 = [[0, 0]]\n    half = N // 2\n    for i in range(half):\n        (w, v) = items[i]\n        size = len(d1)\n        for j in range(size):\n            d1.append([d1[j][0] + w, d1[j][1] + v])\n    for i in range(N - half):\n        (w, v) = items[half + i]\n        size = len(d2)\n        for j in range(size):\n            d2.append([d2[j][0] + w, d2[j][1] * v])\n    d1.sort()\n    d2.sort()\n    for i in range(len(d2) - 1):\n        if d2[i + 1][1] < d2[i][1]:\n            d2[i + 1][1] = d2[i][1]\n    ans = 0\n    INF = float('inf')\n    for (w, v) in d1:\n        if w > W:\n            continue\n        rest = W - w\n        idx = bisect_right(d2, [rest, INF])\n        ans = max(ans, d2[idx - 1][1] + v)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "if d2[i + 1][1] < d2[i][1]:",
      "mutated_line": "if d2[i - 1][1] < d2[i][1]:",
      "code": "from bisect import bisect_right\n\ndef max_knapsack_value(N, W, items):\n    d1 = [[0, 0]]\n    d2 = [[0, 0]]\n    half = N // 2\n    for i in range(half):\n        (w, v) = items[i]\n        size = len(d1)\n        for j in range(size):\n            d1.append([d1[j][0] + w, d1[j][1] + v])\n    for i in range(N - half):\n        (w, v) = items[half + i]\n        size = len(d2)\n        for j in range(size):\n            d2.append([d2[j][0] + w, d2[j][1] + v])\n    d1.sort()\n    d2.sort()\n    for i in range(len(d2) - 1):\n        if d2[i - 1][1] < d2[i][1]:\n            d2[i + 1][1] = d2[i][1]\n    ans = 0\n    INF = float('inf')\n    for (w, v) in d1:\n        if w > W:\n            continue\n        rest = W - w\n        idx = bisect_right(d2, [rest, INF])\n        ans = max(ans, d2[idx - 1][1] + v)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "if d2[i + 1][1] < d2[i][1]:",
      "mutated_line": "if d2[i * 1][1] < d2[i][1]:",
      "code": "from bisect import bisect_right\n\ndef max_knapsack_value(N, W, items):\n    d1 = [[0, 0]]\n    d2 = [[0, 0]]\n    half = N // 2\n    for i in range(half):\n        (w, v) = items[i]\n        size = len(d1)\n        for j in range(size):\n            d1.append([d1[j][0] + w, d1[j][1] + v])\n    for i in range(N - half):\n        (w, v) = items[half + i]\n        size = len(d2)\n        for j in range(size):\n            d2.append([d2[j][0] + w, d2[j][1] + v])\n    d1.sort()\n    d2.sort()\n    for i in range(len(d2) - 1):\n        if d2[i * 1][1] < d2[i][1]:\n            d2[i + 1][1] = d2[i][1]\n    ans = 0\n    INF = float('inf')\n    for (w, v) in d1:\n        if w > W:\n            continue\n        rest = W - w\n        idx = bisect_right(d2, [rest, INF])\n        ans = max(ans, d2[idx - 1][1] + v)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "d2[i + 1][1] = d2[i][1]",
      "mutated_line": "d2[i - 1][1] = d2[i][1]",
      "code": "from bisect import bisect_right\n\ndef max_knapsack_value(N, W, items):\n    d1 = [[0, 0]]\n    d2 = [[0, 0]]\n    half = N // 2\n    for i in range(half):\n        (w, v) = items[i]\n        size = len(d1)\n        for j in range(size):\n            d1.append([d1[j][0] + w, d1[j][1] + v])\n    for i in range(N - half):\n        (w, v) = items[half + i]\n        size = len(d2)\n        for j in range(size):\n            d2.append([d2[j][0] + w, d2[j][1] + v])\n    d1.sort()\n    d2.sort()\n    for i in range(len(d2) - 1):\n        if d2[i + 1][1] < d2[i][1]:\n            d2[i - 1][1] = d2[i][1]\n    ans = 0\n    INF = float('inf')\n    for (w, v) in d1:\n        if w > W:\n            continue\n        rest = W - w\n        idx = bisect_right(d2, [rest, INF])\n        ans = max(ans, d2[idx - 1][1] + v)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "d2[i + 1][1] = d2[i][1]",
      "mutated_line": "d2[i * 1][1] = d2[i][1]",
      "code": "from bisect import bisect_right\n\ndef max_knapsack_value(N, W, items):\n    d1 = [[0, 0]]\n    d2 = [[0, 0]]\n    half = N // 2\n    for i in range(half):\n        (w, v) = items[i]\n        size = len(d1)\n        for j in range(size):\n            d1.append([d1[j][0] + w, d1[j][1] + v])\n    for i in range(N - half):\n        (w, v) = items[half + i]\n        size = len(d2)\n        for j in range(size):\n            d2.append([d2[j][0] + w, d2[j][1] + v])\n    d1.sort()\n    d2.sort()\n    for i in range(len(d2) - 1):\n        if d2[i + 1][1] < d2[i][1]:\n            d2[i * 1][1] = d2[i][1]\n    ans = 0\n    INF = float('inf')\n    for (w, v) in d1:\n        if w > W:\n            continue\n        rest = W - w\n        idx = bisect_right(d2, [rest, INF])\n        ans = max(ans, d2[idx - 1][1] + v)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "ans = max(ans, d2[idx - 1][1] + v)",
      "mutated_line": "ans = max(ans, d2[idx - 1][2] + v)",
      "code": "from bisect import bisect_right\n\ndef max_knapsack_value(N, W, items):\n    d1 = [[0, 0]]\n    d2 = [[0, 0]]\n    half = N // 2\n    for i in range(half):\n        (w, v) = items[i]\n        size = len(d1)\n        for j in range(size):\n            d1.append([d1[j][0] + w, d1[j][1] + v])\n    for i in range(N - half):\n        (w, v) = items[half + i]\n        size = len(d2)\n        for j in range(size):\n            d2.append([d2[j][0] + w, d2[j][1] + v])\n    d1.sort()\n    d2.sort()\n    for i in range(len(d2) - 1):\n        if d2[i + 1][1] < d2[i][1]:\n            d2[i + 1][1] = d2[i][1]\n    ans = 0\n    INF = float('inf')\n    for (w, v) in d1:\n        if w > W:\n            continue\n        rest = W - w\n        idx = bisect_right(d2, [rest, INF])\n        ans = max(ans, d2[idx - 1][2] + v)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "ans = max(ans, d2[idx - 1][1] + v)",
      "mutated_line": "ans = max(ans, d2[idx - 1][0] + v)",
      "code": "from bisect import bisect_right\n\ndef max_knapsack_value(N, W, items):\n    d1 = [[0, 0]]\n    d2 = [[0, 0]]\n    half = N // 2\n    for i in range(half):\n        (w, v) = items[i]\n        size = len(d1)\n        for j in range(size):\n            d1.append([d1[j][0] + w, d1[j][1] + v])\n    for i in range(N - half):\n        (w, v) = items[half + i]\n        size = len(d2)\n        for j in range(size):\n            d2.append([d2[j][0] + w, d2[j][1] + v])\n    d1.sort()\n    d2.sort()\n    for i in range(len(d2) - 1):\n        if d2[i + 1][1] < d2[i][1]:\n            d2[i + 1][1] = d2[i][1]\n    ans = 0\n    INF = float('inf')\n    for (w, v) in d1:\n        if w > W:\n            continue\n        rest = W - w\n        idx = bisect_right(d2, [rest, INF])\n        ans = max(ans, d2[idx - 1][0] + v)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "ans = max(ans, d2[idx - 1][1] + v)",
      "mutated_line": "ans = max(ans, d2[idx - 1][0] + v)",
      "code": "from bisect import bisect_right\n\ndef max_knapsack_value(N, W, items):\n    d1 = [[0, 0]]\n    d2 = [[0, 0]]\n    half = N // 2\n    for i in range(half):\n        (w, v) = items[i]\n        size = len(d1)\n        for j in range(size):\n            d1.append([d1[j][0] + w, d1[j][1] + v])\n    for i in range(N - half):\n        (w, v) = items[half + i]\n        size = len(d2)\n        for j in range(size):\n            d2.append([d2[j][0] + w, d2[j][1] + v])\n    d1.sort()\n    d2.sort()\n    for i in range(len(d2) - 1):\n        if d2[i + 1][1] < d2[i][1]:\n            d2[i + 1][1] = d2[i][1]\n    ans = 0\n    INF = float('inf')\n    for (w, v) in d1:\n        if w > W:\n            continue\n        rest = W - w\n        idx = bisect_right(d2, [rest, INF])\n        ans = max(ans, d2[idx - 1][0] + v)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "ans = max(ans, d2[idx - 1][1] + v)",
      "mutated_line": "ans = max(ans, d2[idx - 1][-1] + v)",
      "code": "from bisect import bisect_right\n\ndef max_knapsack_value(N, W, items):\n    d1 = [[0, 0]]\n    d2 = [[0, 0]]\n    half = N // 2\n    for i in range(half):\n        (w, v) = items[i]\n        size = len(d1)\n        for j in range(size):\n            d1.append([d1[j][0] + w, d1[j][1] + v])\n    for i in range(N - half):\n        (w, v) = items[half + i]\n        size = len(d2)\n        for j in range(size):\n            d2.append([d2[j][0] + w, d2[j][1] + v])\n    d1.sort()\n    d2.sort()\n    for i in range(len(d2) - 1):\n        if d2[i + 1][1] < d2[i][1]:\n            d2[i + 1][1] = d2[i][1]\n    ans = 0\n    INF = float('inf')\n    for (w, v) in d1:\n        if w > W:\n            continue\n        rest = W - w\n        idx = bisect_right(d2, [rest, INF])\n        ans = max(ans, d2[idx - 1][-1] + v)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if d2[i + 1][1] < d2[i][1]:",
      "mutated_line": "if d2[i + 2][1] < d2[i][1]:",
      "code": "from bisect import bisect_right\n\ndef max_knapsack_value(N, W, items):\n    d1 = [[0, 0]]\n    d2 = [[0, 0]]\n    half = N // 2\n    for i in range(half):\n        (w, v) = items[i]\n        size = len(d1)\n        for j in range(size):\n            d1.append([d1[j][0] + w, d1[j][1] + v])\n    for i in range(N - half):\n        (w, v) = items[half + i]\n        size = len(d2)\n        for j in range(size):\n            d2.append([d2[j][0] + w, d2[j][1] + v])\n    d1.sort()\n    d2.sort()\n    for i in range(len(d2) - 1):\n        if d2[i + 2][1] < d2[i][1]:\n            d2[i + 1][1] = d2[i][1]\n    ans = 0\n    INF = float('inf')\n    for (w, v) in d1:\n        if w > W:\n            continue\n        rest = W - w\n        idx = bisect_right(d2, [rest, INF])\n        ans = max(ans, d2[idx - 1][1] + v)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if d2[i + 1][1] < d2[i][1]:",
      "mutated_line": "if d2[i + 0][1] < d2[i][1]:",
      "code": "from bisect import bisect_right\n\ndef max_knapsack_value(N, W, items):\n    d1 = [[0, 0]]\n    d2 = [[0, 0]]\n    half = N // 2\n    for i in range(half):\n        (w, v) = items[i]\n        size = len(d1)\n        for j in range(size):\n            d1.append([d1[j][0] + w, d1[j][1] + v])\n    for i in range(N - half):\n        (w, v) = items[half + i]\n        size = len(d2)\n        for j in range(size):\n            d2.append([d2[j][0] + w, d2[j][1] + v])\n    d1.sort()\n    d2.sort()\n    for i in range(len(d2) - 1):\n        if d2[i + 0][1] < d2[i][1]:\n            d2[i + 1][1] = d2[i][1]\n    ans = 0\n    INF = float('inf')\n    for (w, v) in d1:\n        if w > W:\n            continue\n        rest = W - w\n        idx = bisect_right(d2, [rest, INF])\n        ans = max(ans, d2[idx - 1][1] + v)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if d2[i + 1][1] < d2[i][1]:",
      "mutated_line": "if d2[i + 0][1] < d2[i][1]:",
      "code": "from bisect import bisect_right\n\ndef max_knapsack_value(N, W, items):\n    d1 = [[0, 0]]\n    d2 = [[0, 0]]\n    half = N // 2\n    for i in range(half):\n        (w, v) = items[i]\n        size = len(d1)\n        for j in range(size):\n            d1.append([d1[j][0] + w, d1[j][1] + v])\n    for i in range(N - half):\n        (w, v) = items[half + i]\n        size = len(d2)\n        for j in range(size):\n            d2.append([d2[j][0] + w, d2[j][1] + v])\n    d1.sort()\n    d2.sort()\n    for i in range(len(d2) - 1):\n        if d2[i + 0][1] < d2[i][1]:\n            d2[i + 1][1] = d2[i][1]\n    ans = 0\n    INF = float('inf')\n    for (w, v) in d1:\n        if w > W:\n            continue\n        rest = W - w\n        idx = bisect_right(d2, [rest, INF])\n        ans = max(ans, d2[idx - 1][1] + v)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if d2[i + 1][1] < d2[i][1]:",
      "mutated_line": "if d2[i + -1][1] < d2[i][1]:",
      "code": "from bisect import bisect_right\n\ndef max_knapsack_value(N, W, items):\n    d1 = [[0, 0]]\n    d2 = [[0, 0]]\n    half = N // 2\n    for i in range(half):\n        (w, v) = items[i]\n        size = len(d1)\n        for j in range(size):\n            d1.append([d1[j][0] + w, d1[j][1] + v])\n    for i in range(N - half):\n        (w, v) = items[half + i]\n        size = len(d2)\n        for j in range(size):\n            d2.append([d2[j][0] + w, d2[j][1] + v])\n    d1.sort()\n    d2.sort()\n    for i in range(len(d2) - 1):\n        if d2[i + -1][1] < d2[i][1]:\n            d2[i + 1][1] = d2[i][1]\n    ans = 0\n    INF = float('inf')\n    for (w, v) in d1:\n        if w > W:\n            continue\n        rest = W - w\n        idx = bisect_right(d2, [rest, INF])\n        ans = max(ans, d2[idx - 1][1] + v)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "d2[i + 1][1] = d2[i][1]",
      "mutated_line": "d2[i + 2][1] = d2[i][1]",
      "code": "from bisect import bisect_right\n\ndef max_knapsack_value(N, W, items):\n    d1 = [[0, 0]]\n    d2 = [[0, 0]]\n    half = N // 2\n    for i in range(half):\n        (w, v) = items[i]\n        size = len(d1)\n        for j in range(size):\n            d1.append([d1[j][0] + w, d1[j][1] + v])\n    for i in range(N - half):\n        (w, v) = items[half + i]\n        size = len(d2)\n        for j in range(size):\n            d2.append([d2[j][0] + w, d2[j][1] + v])\n    d1.sort()\n    d2.sort()\n    for i in range(len(d2) - 1):\n        if d2[i + 1][1] < d2[i][1]:\n            d2[i + 2][1] = d2[i][1]\n    ans = 0\n    INF = float('inf')\n    for (w, v) in d1:\n        if w > W:\n            continue\n        rest = W - w\n        idx = bisect_right(d2, [rest, INF])\n        ans = max(ans, d2[idx - 1][1] + v)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "d2[i + 1][1] = d2[i][1]",
      "mutated_line": "d2[i + 0][1] = d2[i][1]",
      "code": "from bisect import bisect_right\n\ndef max_knapsack_value(N, W, items):\n    d1 = [[0, 0]]\n    d2 = [[0, 0]]\n    half = N // 2\n    for i in range(half):\n        (w, v) = items[i]\n        size = len(d1)\n        for j in range(size):\n            d1.append([d1[j][0] + w, d1[j][1] + v])\n    for i in range(N - half):\n        (w, v) = items[half + i]\n        size = len(d2)\n        for j in range(size):\n            d2.append([d2[j][0] + w, d2[j][1] + v])\n    d1.sort()\n    d2.sort()\n    for i in range(len(d2) - 1):\n        if d2[i + 1][1] < d2[i][1]:\n            d2[i + 0][1] = d2[i][1]\n    ans = 0\n    INF = float('inf')\n    for (w, v) in d1:\n        if w > W:\n            continue\n        rest = W - w\n        idx = bisect_right(d2, [rest, INF])\n        ans = max(ans, d2[idx - 1][1] + v)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "d2[i + 1][1] = d2[i][1]",
      "mutated_line": "d2[i + 0][1] = d2[i][1]",
      "code": "from bisect import bisect_right\n\ndef max_knapsack_value(N, W, items):\n    d1 = [[0, 0]]\n    d2 = [[0, 0]]\n    half = N // 2\n    for i in range(half):\n        (w, v) = items[i]\n        size = len(d1)\n        for j in range(size):\n            d1.append([d1[j][0] + w, d1[j][1] + v])\n    for i in range(N - half):\n        (w, v) = items[half + i]\n        size = len(d2)\n        for j in range(size):\n            d2.append([d2[j][0] + w, d2[j][1] + v])\n    d1.sort()\n    d2.sort()\n    for i in range(len(d2) - 1):\n        if d2[i + 1][1] < d2[i][1]:\n            d2[i + 0][1] = d2[i][1]\n    ans = 0\n    INF = float('inf')\n    for (w, v) in d1:\n        if w > W:\n            continue\n        rest = W - w\n        idx = bisect_right(d2, [rest, INF])\n        ans = max(ans, d2[idx - 1][1] + v)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "d2[i + 1][1] = d2[i][1]",
      "mutated_line": "d2[i + -1][1] = d2[i][1]",
      "code": "from bisect import bisect_right\n\ndef max_knapsack_value(N, W, items):\n    d1 = [[0, 0]]\n    d2 = [[0, 0]]\n    half = N // 2\n    for i in range(half):\n        (w, v) = items[i]\n        size = len(d1)\n        for j in range(size):\n            d1.append([d1[j][0] + w, d1[j][1] + v])\n    for i in range(N - half):\n        (w, v) = items[half + i]\n        size = len(d2)\n        for j in range(size):\n            d2.append([d2[j][0] + w, d2[j][1] + v])\n    d1.sort()\n    d2.sort()\n    for i in range(len(d2) - 1):\n        if d2[i + 1][1] < d2[i][1]:\n            d2[i + -1][1] = d2[i][1]\n    ans = 0\n    INF = float('inf')\n    for (w, v) in d1:\n        if w > W:\n            continue\n        rest = W - w\n        idx = bisect_right(d2, [rest, INF])\n        ans = max(ans, d2[idx - 1][1] + v)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "ans = max(ans, d2[idx - 1][1] + v)",
      "mutated_line": "ans = max(ans, d2[idx + 1][1] + v)",
      "code": "from bisect import bisect_right\n\ndef max_knapsack_value(N, W, items):\n    d1 = [[0, 0]]\n    d2 = [[0, 0]]\n    half = N // 2\n    for i in range(half):\n        (w, v) = items[i]\n        size = len(d1)\n        for j in range(size):\n            d1.append([d1[j][0] + w, d1[j][1] + v])\n    for i in range(N - half):\n        (w, v) = items[half + i]\n        size = len(d2)\n        for j in range(size):\n            d2.append([d2[j][0] + w, d2[j][1] + v])\n    d1.sort()\n    d2.sort()\n    for i in range(len(d2) - 1):\n        if d2[i + 1][1] < d2[i][1]:\n            d2[i + 1][1] = d2[i][1]\n    ans = 0\n    INF = float('inf')\n    for (w, v) in d1:\n        if w > W:\n            continue\n        rest = W - w\n        idx = bisect_right(d2, [rest, INF])\n        ans = max(ans, d2[idx + 1][1] + v)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "ans = max(ans, d2[idx - 1][1] + v)",
      "mutated_line": "ans = max(ans, d2[idx * 1][1] + v)",
      "code": "from bisect import bisect_right\n\ndef max_knapsack_value(N, W, items):\n    d1 = [[0, 0]]\n    d2 = [[0, 0]]\n    half = N // 2\n    for i in range(half):\n        (w, v) = items[i]\n        size = len(d1)\n        for j in range(size):\n            d1.append([d1[j][0] + w, d1[j][1] + v])\n    for i in range(N - half):\n        (w, v) = items[half + i]\n        size = len(d2)\n        for j in range(size):\n            d2.append([d2[j][0] + w, d2[j][1] + v])\n    d1.sort()\n    d2.sort()\n    for i in range(len(d2) - 1):\n        if d2[i + 1][1] < d2[i][1]:\n            d2[i + 1][1] = d2[i][1]\n    ans = 0\n    INF = float('inf')\n    for (w, v) in d1:\n        if w > W:\n            continue\n        rest = W - w\n        idx = bisect_right(d2, [rest, INF])\n        ans = max(ans, d2[idx * 1][1] + v)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "d1.append([d1[j][0] + w, d1[j][1] + v])",
      "mutated_line": "d1.append([d1[j][1] + w, d1[j][1] + v])",
      "code": "from bisect import bisect_right\n\ndef max_knapsack_value(N, W, items):\n    d1 = [[0, 0]]\n    d2 = [[0, 0]]\n    half = N // 2\n    for i in range(half):\n        (w, v) = items[i]\n        size = len(d1)\n        for j in range(size):\n            d1.append([d1[j][1] + w, d1[j][1] + v])\n    for i in range(N - half):\n        (w, v) = items[half + i]\n        size = len(d2)\n        for j in range(size):\n            d2.append([d2[j][0] + w, d2[j][1] + v])\n    d1.sort()\n    d2.sort()\n    for i in range(len(d2) - 1):\n        if d2[i + 1][1] < d2[i][1]:\n            d2[i + 1][1] = d2[i][1]\n    ans = 0\n    INF = float('inf')\n    for (w, v) in d1:\n        if w > W:\n            continue\n        rest = W - w\n        idx = bisect_right(d2, [rest, INF])\n        ans = max(ans, d2[idx - 1][1] + v)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "d1.append([d1[j][0] + w, d1[j][1] + v])",
      "mutated_line": "d1.append([d1[j][-1] + w, d1[j][1] + v])",
      "code": "from bisect import bisect_right\n\ndef max_knapsack_value(N, W, items):\n    d1 = [[0, 0]]\n    d2 = [[0, 0]]\n    half = N // 2\n    for i in range(half):\n        (w, v) = items[i]\n        size = len(d1)\n        for j in range(size):\n            d1.append([d1[j][-1] + w, d1[j][1] + v])\n    for i in range(N - half):\n        (w, v) = items[half + i]\n        size = len(d2)\n        for j in range(size):\n            d2.append([d2[j][0] + w, d2[j][1] + v])\n    d1.sort()\n    d2.sort()\n    for i in range(len(d2) - 1):\n        if d2[i + 1][1] < d2[i][1]:\n            d2[i + 1][1] = d2[i][1]\n    ans = 0\n    INF = float('inf')\n    for (w, v) in d1:\n        if w > W:\n            continue\n        rest = W - w\n        idx = bisect_right(d2, [rest, INF])\n        ans = max(ans, d2[idx - 1][1] + v)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "d1.append([d1[j][0] + w, d1[j][1] + v])",
      "mutated_line": "d1.append([d1[j][1] + w, d1[j][1] + v])",
      "code": "from bisect import bisect_right\n\ndef max_knapsack_value(N, W, items):\n    d1 = [[0, 0]]\n    d2 = [[0, 0]]\n    half = N // 2\n    for i in range(half):\n        (w, v) = items[i]\n        size = len(d1)\n        for j in range(size):\n            d1.append([d1[j][1] + w, d1[j][1] + v])\n    for i in range(N - half):\n        (w, v) = items[half + i]\n        size = len(d2)\n        for j in range(size):\n            d2.append([d2[j][0] + w, d2[j][1] + v])\n    d1.sort()\n    d2.sort()\n    for i in range(len(d2) - 1):\n        if d2[i + 1][1] < d2[i][1]:\n            d2[i + 1][1] = d2[i][1]\n    ans = 0\n    INF = float('inf')\n    for (w, v) in d1:\n        if w > W:\n            continue\n        rest = W - w\n        idx = bisect_right(d2, [rest, INF])\n        ans = max(ans, d2[idx - 1][1] + v)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "d1.append([d1[j][0] + w, d1[j][1] + v])",
      "mutated_line": "d1.append([d1[j][0] + w, d1[j][2] + v])",
      "code": "from bisect import bisect_right\n\ndef max_knapsack_value(N, W, items):\n    d1 = [[0, 0]]\n    d2 = [[0, 0]]\n    half = N // 2\n    for i in range(half):\n        (w, v) = items[i]\n        size = len(d1)\n        for j in range(size):\n            d1.append([d1[j][0] + w, d1[j][2] + v])\n    for i in range(N - half):\n        (w, v) = items[half + i]\n        size = len(d2)\n        for j in range(size):\n            d2.append([d2[j][0] + w, d2[j][1] + v])\n    d1.sort()\n    d2.sort()\n    for i in range(len(d2) - 1):\n        if d2[i + 1][1] < d2[i][1]:\n            d2[i + 1][1] = d2[i][1]\n    ans = 0\n    INF = float('inf')\n    for (w, v) in d1:\n        if w > W:\n            continue\n        rest = W - w\n        idx = bisect_right(d2, [rest, INF])\n        ans = max(ans, d2[idx - 1][1] + v)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "d1.append([d1[j][0] + w, d1[j][1] + v])",
      "mutated_line": "d1.append([d1[j][0] + w, d1[j][0] + v])",
      "code": "from bisect import bisect_right\n\ndef max_knapsack_value(N, W, items):\n    d1 = [[0, 0]]\n    d2 = [[0, 0]]\n    half = N // 2\n    for i in range(half):\n        (w, v) = items[i]\n        size = len(d1)\n        for j in range(size):\n            d1.append([d1[j][0] + w, d1[j][0] + v])\n    for i in range(N - half):\n        (w, v) = items[half + i]\n        size = len(d2)\n        for j in range(size):\n            d2.append([d2[j][0] + w, d2[j][1] + v])\n    d1.sort()\n    d2.sort()\n    for i in range(len(d2) - 1):\n        if d2[i + 1][1] < d2[i][1]:\n            d2[i + 1][1] = d2[i][1]\n    ans = 0\n    INF = float('inf')\n    for (w, v) in d1:\n        if w > W:\n            continue\n        rest = W - w\n        idx = bisect_right(d2, [rest, INF])\n        ans = max(ans, d2[idx - 1][1] + v)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "d1.append([d1[j][0] + w, d1[j][1] + v])",
      "mutated_line": "d1.append([d1[j][0] + w, d1[j][0] + v])",
      "code": "from bisect import bisect_right\n\ndef max_knapsack_value(N, W, items):\n    d1 = [[0, 0]]\n    d2 = [[0, 0]]\n    half = N // 2\n    for i in range(half):\n        (w, v) = items[i]\n        size = len(d1)\n        for j in range(size):\n            d1.append([d1[j][0] + w, d1[j][0] + v])\n    for i in range(N - half):\n        (w, v) = items[half + i]\n        size = len(d2)\n        for j in range(size):\n            d2.append([d2[j][0] + w, d2[j][1] + v])\n    d1.sort()\n    d2.sort()\n    for i in range(len(d2) - 1):\n        if d2[i + 1][1] < d2[i][1]:\n            d2[i + 1][1] = d2[i][1]\n    ans = 0\n    INF = float('inf')\n    for (w, v) in d1:\n        if w > W:\n            continue\n        rest = W - w\n        idx = bisect_right(d2, [rest, INF])\n        ans = max(ans, d2[idx - 1][1] + v)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "d1.append([d1[j][0] + w, d1[j][1] + v])",
      "mutated_line": "d1.append([d1[j][0] + w, d1[j][-1] + v])",
      "code": "from bisect import bisect_right\n\ndef max_knapsack_value(N, W, items):\n    d1 = [[0, 0]]\n    d2 = [[0, 0]]\n    half = N // 2\n    for i in range(half):\n        (w, v) = items[i]\n        size = len(d1)\n        for j in range(size):\n            d1.append([d1[j][0] + w, d1[j][-1] + v])\n    for i in range(N - half):\n        (w, v) = items[half + i]\n        size = len(d2)\n        for j in range(size):\n            d2.append([d2[j][0] + w, d2[j][1] + v])\n    d1.sort()\n    d2.sort()\n    for i in range(len(d2) - 1):\n        if d2[i + 1][1] < d2[i][1]:\n            d2[i + 1][1] = d2[i][1]\n    ans = 0\n    INF = float('inf')\n    for (w, v) in d1:\n        if w > W:\n            continue\n        rest = W - w\n        idx = bisect_right(d2, [rest, INF])\n        ans = max(ans, d2[idx - 1][1] + v)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "d2.append([d2[j][0] + w, d2[j][1] + v])",
      "mutated_line": "d2.append([d2[j][1] + w, d2[j][1] + v])",
      "code": "from bisect import bisect_right\n\ndef max_knapsack_value(N, W, items):\n    d1 = [[0, 0]]\n    d2 = [[0, 0]]\n    half = N // 2\n    for i in range(half):\n        (w, v) = items[i]\n        size = len(d1)\n        for j in range(size):\n            d1.append([d1[j][0] + w, d1[j][1] + v])\n    for i in range(N - half):\n        (w, v) = items[half + i]\n        size = len(d2)\n        for j in range(size):\n            d2.append([d2[j][1] + w, d2[j][1] + v])\n    d1.sort()\n    d2.sort()\n    for i in range(len(d2) - 1):\n        if d2[i + 1][1] < d2[i][1]:\n            d2[i + 1][1] = d2[i][1]\n    ans = 0\n    INF = float('inf')\n    for (w, v) in d1:\n        if w > W:\n            continue\n        rest = W - w\n        idx = bisect_right(d2, [rest, INF])\n        ans = max(ans, d2[idx - 1][1] + v)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "d2.append([d2[j][0] + w, d2[j][1] + v])",
      "mutated_line": "d2.append([d2[j][-1] + w, d2[j][1] + v])",
      "code": "from bisect import bisect_right\n\ndef max_knapsack_value(N, W, items):\n    d1 = [[0, 0]]\n    d2 = [[0, 0]]\n    half = N // 2\n    for i in range(half):\n        (w, v) = items[i]\n        size = len(d1)\n        for j in range(size):\n            d1.append([d1[j][0] + w, d1[j][1] + v])\n    for i in range(N - half):\n        (w, v) = items[half + i]\n        size = len(d2)\n        for j in range(size):\n            d2.append([d2[j][-1] + w, d2[j][1] + v])\n    d1.sort()\n    d2.sort()\n    for i in range(len(d2) - 1):\n        if d2[i + 1][1] < d2[i][1]:\n            d2[i + 1][1] = d2[i][1]\n    ans = 0\n    INF = float('inf')\n    for (w, v) in d1:\n        if w > W:\n            continue\n        rest = W - w\n        idx = bisect_right(d2, [rest, INF])\n        ans = max(ans, d2[idx - 1][1] + v)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "d2.append([d2[j][0] + w, d2[j][1] + v])",
      "mutated_line": "d2.append([d2[j][1] + w, d2[j][1] + v])",
      "code": "from bisect import bisect_right\n\ndef max_knapsack_value(N, W, items):\n    d1 = [[0, 0]]\n    d2 = [[0, 0]]\n    half = N // 2\n    for i in range(half):\n        (w, v) = items[i]\n        size = len(d1)\n        for j in range(size):\n            d1.append([d1[j][0] + w, d1[j][1] + v])\n    for i in range(N - half):\n        (w, v) = items[half + i]\n        size = len(d2)\n        for j in range(size):\n            d2.append([d2[j][1] + w, d2[j][1] + v])\n    d1.sort()\n    d2.sort()\n    for i in range(len(d2) - 1):\n        if d2[i + 1][1] < d2[i][1]:\n            d2[i + 1][1] = d2[i][1]\n    ans = 0\n    INF = float('inf')\n    for (w, v) in d1:\n        if w > W:\n            continue\n        rest = W - w\n        idx = bisect_right(d2, [rest, INF])\n        ans = max(ans, d2[idx - 1][1] + v)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "d2.append([d2[j][0] + w, d2[j][1] + v])",
      "mutated_line": "d2.append([d2[j][0] + w, d2[j][2] + v])",
      "code": "from bisect import bisect_right\n\ndef max_knapsack_value(N, W, items):\n    d1 = [[0, 0]]\n    d2 = [[0, 0]]\n    half = N // 2\n    for i in range(half):\n        (w, v) = items[i]\n        size = len(d1)\n        for j in range(size):\n            d1.append([d1[j][0] + w, d1[j][1] + v])\n    for i in range(N - half):\n        (w, v) = items[half + i]\n        size = len(d2)\n        for j in range(size):\n            d2.append([d2[j][0] + w, d2[j][2] + v])\n    d1.sort()\n    d2.sort()\n    for i in range(len(d2) - 1):\n        if d2[i + 1][1] < d2[i][1]:\n            d2[i + 1][1] = d2[i][1]\n    ans = 0\n    INF = float('inf')\n    for (w, v) in d1:\n        if w > W:\n            continue\n        rest = W - w\n        idx = bisect_right(d2, [rest, INF])\n        ans = max(ans, d2[idx - 1][1] + v)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "d2.append([d2[j][0] + w, d2[j][1] + v])",
      "mutated_line": "d2.append([d2[j][0] + w, d2[j][0] + v])",
      "code": "from bisect import bisect_right\n\ndef max_knapsack_value(N, W, items):\n    d1 = [[0, 0]]\n    d2 = [[0, 0]]\n    half = N // 2\n    for i in range(half):\n        (w, v) = items[i]\n        size = len(d1)\n        for j in range(size):\n            d1.append([d1[j][0] + w, d1[j][1] + v])\n    for i in range(N - half):\n        (w, v) = items[half + i]\n        size = len(d2)\n        for j in range(size):\n            d2.append([d2[j][0] + w, d2[j][0] + v])\n    d1.sort()\n    d2.sort()\n    for i in range(len(d2) - 1):\n        if d2[i + 1][1] < d2[i][1]:\n            d2[i + 1][1] = d2[i][1]\n    ans = 0\n    INF = float('inf')\n    for (w, v) in d1:\n        if w > W:\n            continue\n        rest = W - w\n        idx = bisect_right(d2, [rest, INF])\n        ans = max(ans, d2[idx - 1][1] + v)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "d2.append([d2[j][0] + w, d2[j][1] + v])",
      "mutated_line": "d2.append([d2[j][0] + w, d2[j][0] + v])",
      "code": "from bisect import bisect_right\n\ndef max_knapsack_value(N, W, items):\n    d1 = [[0, 0]]\n    d2 = [[0, 0]]\n    half = N // 2\n    for i in range(half):\n        (w, v) = items[i]\n        size = len(d1)\n        for j in range(size):\n            d1.append([d1[j][0] + w, d1[j][1] + v])\n    for i in range(N - half):\n        (w, v) = items[half + i]\n        size = len(d2)\n        for j in range(size):\n            d2.append([d2[j][0] + w, d2[j][0] + v])\n    d1.sort()\n    d2.sort()\n    for i in range(len(d2) - 1):\n        if d2[i + 1][1] < d2[i][1]:\n            d2[i + 1][1] = d2[i][1]\n    ans = 0\n    INF = float('inf')\n    for (w, v) in d1:\n        if w > W:\n            continue\n        rest = W - w\n        idx = bisect_right(d2, [rest, INF])\n        ans = max(ans, d2[idx - 1][1] + v)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "d2.append([d2[j][0] + w, d2[j][1] + v])",
      "mutated_line": "d2.append([d2[j][0] + w, d2[j][-1] + v])",
      "code": "from bisect import bisect_right\n\ndef max_knapsack_value(N, W, items):\n    d1 = [[0, 0]]\n    d2 = [[0, 0]]\n    half = N // 2\n    for i in range(half):\n        (w, v) = items[i]\n        size = len(d1)\n        for j in range(size):\n            d1.append([d1[j][0] + w, d1[j][1] + v])\n    for i in range(N - half):\n        (w, v) = items[half + i]\n        size = len(d2)\n        for j in range(size):\n            d2.append([d2[j][0] + w, d2[j][-1] + v])\n    d1.sort()\n    d2.sort()\n    for i in range(len(d2) - 1):\n        if d2[i + 1][1] < d2[i][1]:\n            d2[i + 1][1] = d2[i][1]\n    ans = 0\n    INF = float('inf')\n    for (w, v) in d1:\n        if w > W:\n            continue\n        rest = W - w\n        idx = bisect_right(d2, [rest, INF])\n        ans = max(ans, d2[idx - 1][1] + v)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "ans = max(ans, d2[idx - 1][1] + v)",
      "mutated_line": "ans = max(ans, d2[idx - 2][1] + v)",
      "code": "from bisect import bisect_right\n\ndef max_knapsack_value(N, W, items):\n    d1 = [[0, 0]]\n    d2 = [[0, 0]]\n    half = N // 2\n    for i in range(half):\n        (w, v) = items[i]\n        size = len(d1)\n        for j in range(size):\n            d1.append([d1[j][0] + w, d1[j][1] + v])\n    for i in range(N - half):\n        (w, v) = items[half + i]\n        size = len(d2)\n        for j in range(size):\n            d2.append([d2[j][0] + w, d2[j][1] + v])\n    d1.sort()\n    d2.sort()\n    for i in range(len(d2) - 1):\n        if d2[i + 1][1] < d2[i][1]:\n            d2[i + 1][1] = d2[i][1]\n    ans = 0\n    INF = float('inf')\n    for (w, v) in d1:\n        if w > W:\n            continue\n        rest = W - w\n        idx = bisect_right(d2, [rest, INF])\n        ans = max(ans, d2[idx - 2][1] + v)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "ans = max(ans, d2[idx - 1][1] + v)",
      "mutated_line": "ans = max(ans, d2[idx - 0][1] + v)",
      "code": "from bisect import bisect_right\n\ndef max_knapsack_value(N, W, items):\n    d1 = [[0, 0]]\n    d2 = [[0, 0]]\n    half = N // 2\n    for i in range(half):\n        (w, v) = items[i]\n        size = len(d1)\n        for j in range(size):\n            d1.append([d1[j][0] + w, d1[j][1] + v])\n    for i in range(N - half):\n        (w, v) = items[half + i]\n        size = len(d2)\n        for j in range(size):\n            d2.append([d2[j][0] + w, d2[j][1] + v])\n    d1.sort()\n    d2.sort()\n    for i in range(len(d2) - 1):\n        if d2[i + 1][1] < d2[i][1]:\n            d2[i + 1][1] = d2[i][1]\n    ans = 0\n    INF = float('inf')\n    for (w, v) in d1:\n        if w > W:\n            continue\n        rest = W - w\n        idx = bisect_right(d2, [rest, INF])\n        ans = max(ans, d2[idx - 0][1] + v)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "ans = max(ans, d2[idx - 1][1] + v)",
      "mutated_line": "ans = max(ans, d2[idx - 0][1] + v)",
      "code": "from bisect import bisect_right\n\ndef max_knapsack_value(N, W, items):\n    d1 = [[0, 0]]\n    d2 = [[0, 0]]\n    half = N // 2\n    for i in range(half):\n        (w, v) = items[i]\n        size = len(d1)\n        for j in range(size):\n            d1.append([d1[j][0] + w, d1[j][1] + v])\n    for i in range(N - half):\n        (w, v) = items[half + i]\n        size = len(d2)\n        for j in range(size):\n            d2.append([d2[j][0] + w, d2[j][1] + v])\n    d1.sort()\n    d2.sort()\n    for i in range(len(d2) - 1):\n        if d2[i + 1][1] < d2[i][1]:\n            d2[i + 1][1] = d2[i][1]\n    ans = 0\n    INF = float('inf')\n    for (w, v) in d1:\n        if w > W:\n            continue\n        rest = W - w\n        idx = bisect_right(d2, [rest, INF])\n        ans = max(ans, d2[idx - 0][1] + v)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "ans = max(ans, d2[idx - 1][1] + v)",
      "mutated_line": "ans = max(ans, d2[idx - -1][1] + v)",
      "code": "from bisect import bisect_right\n\ndef max_knapsack_value(N, W, items):\n    d1 = [[0, 0]]\n    d2 = [[0, 0]]\n    half = N // 2\n    for i in range(half):\n        (w, v) = items[i]\n        size = len(d1)\n        for j in range(size):\n            d1.append([d1[j][0] + w, d1[j][1] + v])\n    for i in range(N - half):\n        (w, v) = items[half + i]\n        size = len(d2)\n        for j in range(size):\n            d2.append([d2[j][0] + w, d2[j][1] + v])\n    d1.sort()\n    d2.sort()\n    for i in range(len(d2) - 1):\n        if d2[i + 1][1] < d2[i][1]:\n            d2[i + 1][1] = d2[i][1]\n    ans = 0\n    INF = float('inf')\n    for (w, v) in d1:\n        if w > W:\n            continue\n        rest = W - w\n        idx = bisect_right(d2, [rest, INF])\n        ans = max(ans, d2[idx - -1][1] + v)\n    return ans"
    }
  ]
}