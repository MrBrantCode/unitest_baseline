{
  "task_id": "taco_18135",
  "entry_point": "max_good_integer_product",
  "mutant_count": 121,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if n & 1:",
      "mutated_line": "if n | 1:",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 2, n)\n        generate_good_integers(bin * 10 + 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 2 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 1))\n    if n | 1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 ** 20]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "a = sorted(a) + [10 ** 20]",
      "mutated_line": "a = sorted(a) - [10 ** 20]",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 2, n)\n        generate_good_integers(bin * 10 + 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 2 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) - [10 ** 20]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "a = sorted(a) + [10 ** 20]",
      "mutated_line": "a = sorted(a) * [10 ** 20]",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 2, n)\n        generate_good_integers(bin * 10 + 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 2 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) * [10 ** 20]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -1"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if bin > n:",
      "mutated_line": "if bin >= n:",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin >= n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 2, n)\n        generate_good_integers(bin * 10 + 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 2 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 ** 20]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -1"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if bin > n:",
      "mutated_line": "if bin <= n:",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin <= n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 2, n)\n        generate_good_integers(bin * 10 + 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 2 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 ** 20]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -1"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if bin > n:",
      "mutated_line": "if bin != n:",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin != n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 2, n)\n        generate_good_integers(bin * 10 + 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 2 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 ** 20]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -1"
    },
    {
      "operator": "LCR",
      "lineno": 17,
      "original_line": "if x != len(a) and a[x] == n:",
      "mutated_line": "if x != len(a) or a[x] == n:",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 2, n)\n        generate_good_integers(bin * 10 + 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) or a[x] == n:\n            m = 1\n        if a[p] ** 2 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 ** 20]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -1"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if a[p] ** 2 > n:",
      "mutated_line": "if a[p] ** 2 >= n:",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 2, n)\n        generate_good_integers(bin * 10 + 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 2 >= n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 ** 20]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -1"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if a[p] ** 2 > n:",
      "mutated_line": "if a[p] ** 2 <= n:",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 2, n)\n        generate_good_integers(bin * 10 + 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 2 <= n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 ** 20]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -1"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if a[p] ** 2 > n:",
      "mutated_line": "if a[p] ** 2 != n:",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 2, n)\n        generate_good_integers(bin * 10 + 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 2 != n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 ** 20]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -1"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if n % a[p] == 0:",
      "mutated_line": "if n % a[p] != 0:",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 2, n)\n        generate_good_integers(bin * 10 + 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 2 > n:\n            return m\n        if n % a[p] != 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 ** 20]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if n & 1:",
      "mutated_line": "if n & 2:",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 2, n)\n        generate_good_integers(bin * 10 + 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 2 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 1))\n    if n & 2:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 ** 20]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if n & 1:",
      "mutated_line": "if n & 0:",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 2, n)\n        generate_good_integers(bin * 10 + 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 2 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 1))\n    if n & 0:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 ** 20]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if n & 1:",
      "mutated_line": "if n & 0:",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 2, n)\n        generate_good_integers(bin * 10 + 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 2 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 1))\n    if n & 0:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 ** 20]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if n & 1:",
      "mutated_line": "if n & -1:",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 2, n)\n        generate_good_integers(bin * 10 + 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 2 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 1))\n    if n & -1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 ** 20]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -1"
    },
    {
      "operator": "UOI",
      "lineno": 26,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 2, n)\n        generate_good_integers(bin * 10 + 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 2 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return +1\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 ** 20]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "generate_good_integers(0, n)",
      "mutated_line": "generate_good_integers(1, n)",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 2, n)\n        generate_good_integers(bin * 10 + 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 2 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return -1\n    generate_good_integers(1, n)\n    a = sorted(a) + [10 ** 20]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "generate_good_integers(0, n)",
      "mutated_line": "generate_good_integers(-1, n)",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 2, n)\n        generate_good_integers(bin * 10 + 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 2 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return -1\n    generate_good_integers(-1, n)\n    a = sorted(a) + [10 ** 20]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "generate_good_integers(0, n)",
      "mutated_line": "generate_good_integers(1, n)",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 2, n)\n        generate_good_integers(bin * 10 + 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 2 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return -1\n    generate_good_integers(1, n)\n    a = sorted(a) + [10 ** 20]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "result = find_max_product(n, 0)",
      "mutated_line": "result = find_max_product(n, 1)",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 2, n)\n        generate_good_integers(bin * 10 + 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 2 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 ** 20]\n    result = find_max_product(n, 1)\n    return result if result > 0 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "result = find_max_product(n, 0)",
      "mutated_line": "result = find_max_product(n, -1)",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 2, n)\n        generate_good_integers(bin * 10 + 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 2 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 ** 20]\n    result = find_max_product(n, -1)\n    return result if result > 0 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "result = find_max_product(n, 0)",
      "mutated_line": "result = find_max_product(n, 1)",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 2, n)\n        generate_good_integers(bin * 10 + 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 2 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 ** 20]\n    result = find_max_product(n, 1)\n    return result if result > 0 else -1"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "return result if result > 0 else -1",
      "mutated_line": "return result if result >= 0 else -1",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 2, n)\n        generate_good_integers(bin * 10 + 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 2 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 ** 20]\n    result = find_max_product(n, 0)\n    return result if result >= 0 else -1"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "return result if result > 0 else -1",
      "mutated_line": "return result if result <= 0 else -1",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 2, n)\n        generate_good_integers(bin * 10 + 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 2 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 ** 20]\n    result = find_max_product(n, 0)\n    return result if result <= 0 else -1"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "return result if result > 0 else -1",
      "mutated_line": "return result if result != 0 else -1",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 2, n)\n        generate_good_integers(bin * 10 + 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 2 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 ** 20]\n    result = find_max_product(n, 0)\n    return result if result != 0 else -1"
    },
    {
      "operator": "UOI",
      "lineno": 32,
      "original_line": "return result if result > 0 else -1",
      "mutated_line": "return result if result > 0 else +1",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 2, n)\n        generate_good_integers(bin * 10 + 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 2 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 ** 20]\n    result = find_max_product(n, 0)\n    return result if result > 0 else +1"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "generate_good_integers(bin * 10 + 2, n)",
      "mutated_line": "generate_good_integers(bin * 10 - 2, n)",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 - 2, n)\n        generate_good_integers(bin * 10 + 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 2 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 ** 20]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "generate_good_integers(bin * 10 + 2, n)",
      "mutated_line": "generate_good_integers(bin * 10 * 2, n)",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 * 2, n)\n        generate_good_integers(bin * 10 + 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 2 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 ** 20]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "generate_good_integers(bin * 10 + 8, n)",
      "mutated_line": "generate_good_integers(bin * 10 - 8, n)",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 2, n)\n        generate_good_integers(bin * 10 - 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 2 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 ** 20]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "generate_good_integers(bin * 10 + 8, n)",
      "mutated_line": "generate_good_integers(bin * 10 * 8, n)",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 2, n)\n        generate_good_integers(bin * 10 * 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 2 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 ** 20]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -1"
    },
    {
      "operator": "UOI",
      "lineno": 15,
      "original_line": "m = -1 << 20",
      "mutated_line": "m = +1 << 20",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 2, n)\n        generate_good_integers(bin * 10 + 8, n)\n\n    def find_max_product(n, p):\n        m = +1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 2 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 ** 20]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "m = -1 << 20",
      "mutated_line": "m = -1 << 21",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 2, n)\n        generate_good_integers(bin * 10 + 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 21\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 2 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 ** 20]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "m = -1 << 20",
      "mutated_line": "m = -1 << 19",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 2, n)\n        generate_good_integers(bin * 10 + 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 19\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 2 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 ** 20]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "m = -1 << 20",
      "mutated_line": "m = -1 << 0",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 2, n)\n        generate_good_integers(bin * 10 + 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 0\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 2 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 ** 20]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "m = -1 << 20",
      "mutated_line": "m = -1 << 1",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 2, n)\n        generate_good_integers(bin * 10 + 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 1\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 2 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 ** 20]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "m = -1 << 20",
      "mutated_line": "m = -1 << -20",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 2, n)\n        generate_good_integers(bin * 10 + 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << -20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 2 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 ** 20]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -1"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if x != len(a) and a[x] == n:",
      "mutated_line": "if x == len(a) and a[x] == n:",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 2, n)\n        generate_good_integers(bin * 10 + 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x == len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 2 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 ** 20]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -1"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if x != len(a) and a[x] == n:",
      "mutated_line": "if x != len(a) and a[x] != n:",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 2, n)\n        generate_good_integers(bin * 10 + 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] != n:\n            m = 1\n        if a[p] ** 2 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 ** 20]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "m = 1",
      "mutated_line": "m = 2",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 2, n)\n        generate_good_integers(bin * 10 + 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 2\n        if a[p] ** 2 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 ** 20]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "m = 1",
      "mutated_line": "m = 0",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 2, n)\n        generate_good_integers(bin * 10 + 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 0\n        if a[p] ** 2 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 ** 20]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "m = 1",
      "mutated_line": "m = 0",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 2, n)\n        generate_good_integers(bin * 10 + 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 0\n        if a[p] ** 2 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 ** 20]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "m = 1",
      "mutated_line": "m = -1",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 2, n)\n        generate_good_integers(bin * 10 + 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = -1\n        if a[p] ** 2 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 ** 20]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "if a[p] ** 2 > n:",
      "mutated_line": "if a[p] * 2 > n:",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 2, n)\n        generate_good_integers(bin * 10 + 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] * 2 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 ** 20]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "if a[p] ** 2 > n:",
      "mutated_line": "if a[p] + 2 > n:",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 2, n)\n        generate_good_integers(bin * 10 + 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] + 2 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 ** 20]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "if n % a[p] == 0:",
      "mutated_line": "if n * a[p] == 0:",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 2, n)\n        generate_good_integers(bin * 10 + 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 2 > n:\n            return m\n        if n * a[p] == 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 ** 20]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "if n % a[p] == 0:",
      "mutated_line": "if n + a[p] == 0:",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 2, n)\n        generate_good_integers(bin * 10 + 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 2 > n:\n            return m\n        if n + a[p] == 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 ** 20]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if n % a[p] == 0:",
      "mutated_line": "if n % a[p] == 1:",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 2, n)\n        generate_good_integers(bin * 10 + 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 2 > n:\n            return m\n        if n % a[p] == 1:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 ** 20]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if n % a[p] == 0:",
      "mutated_line": "if n % a[p] == -1:",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 2, n)\n        generate_good_integers(bin * 10 + 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 2 > n:\n            return m\n        if n % a[p] == -1:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 ** 20]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if n % a[p] == 0:",
      "mutated_line": "if n % a[p] == 1:",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 2, n)\n        generate_good_integers(bin * 10 + 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 2 > n:\n            return m\n        if n % a[p] == 1:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 ** 20]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "m = find_max_product(n // a[p], p) + 1",
      "mutated_line": "m = find_max_product(n // a[p], p) - 1",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 2, n)\n        generate_good_integers(bin * 10 + 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 2 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) - 1\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 ** 20]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "m = find_max_product(n // a[p], p) + 1",
      "mutated_line": "m = find_max_product(n // a[p], p) * 1",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 2, n)\n        generate_good_integers(bin * 10 + 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 2 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) * 1\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 ** 20]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 2, n)\n        generate_good_integers(bin * 10 + 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 2 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return -2\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 ** 20]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 2, n)\n        generate_good_integers(bin * 10 + 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 2 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return -0\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 ** 20]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 2, n)\n        generate_good_integers(bin * 10 + 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 2 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return -0\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 ** 20]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 2, n)\n        generate_good_integers(bin * 10 + 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 2 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return --1\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 ** 20]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "a = sorted(a) + [10 ** 20]",
      "mutated_line": "a = sorted(a) + [10 * 20]",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 2, n)\n        generate_good_integers(bin * 10 + 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 2 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 * 20]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "a = sorted(a) + [10 ** 20]",
      "mutated_line": "a = sorted(a) + [10 + 20]",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 2, n)\n        generate_good_integers(bin * 10 + 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 2 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 + 20]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "return result if result > 0 else -1",
      "mutated_line": "return result if result > 1 else -1",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 2, n)\n        generate_good_integers(bin * 10 + 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 2 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 ** 20]\n    result = find_max_product(n, 0)\n    return result if result > 1 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "return result if result > 0 else -1",
      "mutated_line": "return result if result > -1 else -1",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 2, n)\n        generate_good_integers(bin * 10 + 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 2 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 ** 20]\n    result = find_max_product(n, 0)\n    return result if result > -1 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "return result if result > 0 else -1",
      "mutated_line": "return result if result > 1 else -1",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 2, n)\n        generate_good_integers(bin * 10 + 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 2 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 ** 20]\n    result = find_max_product(n, 0)\n    return result if result > 1 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "return result if result > 0 else -1",
      "mutated_line": "return result if result > 0 else -2",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 2, n)\n        generate_good_integers(bin * 10 + 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 2 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 ** 20]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -2"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "return result if result > 0 else -1",
      "mutated_line": "return result if result > 0 else -0",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 2, n)\n        generate_good_integers(bin * 10 + 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 2 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 ** 20]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -0"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "return result if result > 0 else -1",
      "mutated_line": "return result if result > 0 else -0",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 2, n)\n        generate_good_integers(bin * 10 + 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 2 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 ** 20]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -0"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "return result if result > 0 else -1",
      "mutated_line": "return result if result > 0 else --1",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 2, n)\n        generate_good_integers(bin * 10 + 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 2 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 ** 20]\n    result = find_max_product(n, 0)\n    return result if result > 0 else --1"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "generate_good_integers(bin * 10 + 2, n)",
      "mutated_line": "generate_good_integers(bin / 10 + 2, n)",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin / 10 + 2, n)\n        generate_good_integers(bin * 10 + 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 2 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 ** 20]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "generate_good_integers(bin * 10 + 2, n)",
      "mutated_line": "generate_good_integers(bin + 10 + 2, n)",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin + 10 + 2, n)\n        generate_good_integers(bin * 10 + 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 2 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 ** 20]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "generate_good_integers(bin * 10 + 2, n)",
      "mutated_line": "generate_good_integers(bin ** 10 + 2, n)",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin ** 10 + 2, n)\n        generate_good_integers(bin * 10 + 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 2 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 ** 20]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "generate_good_integers(bin * 10 + 2, n)",
      "mutated_line": "generate_good_integers(bin * 10 + 3, n)",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 3, n)\n        generate_good_integers(bin * 10 + 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 2 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 ** 20]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "generate_good_integers(bin * 10 + 2, n)",
      "mutated_line": "generate_good_integers(bin * 10 + 1, n)",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 1, n)\n        generate_good_integers(bin * 10 + 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 2 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 ** 20]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "generate_good_integers(bin * 10 + 2, n)",
      "mutated_line": "generate_good_integers(bin * 10 + 0, n)",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 0, n)\n        generate_good_integers(bin * 10 + 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 2 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 ** 20]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "generate_good_integers(bin * 10 + 2, n)",
      "mutated_line": "generate_good_integers(bin * 10 + 1, n)",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 1, n)\n        generate_good_integers(bin * 10 + 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 2 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 ** 20]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "generate_good_integers(bin * 10 + 2, n)",
      "mutated_line": "generate_good_integers(bin * 10 + -2, n)",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + -2, n)\n        generate_good_integers(bin * 10 + 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 2 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 ** 20]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "generate_good_integers(bin * 10 + 8, n)",
      "mutated_line": "generate_good_integers(bin / 10 + 8, n)",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 2, n)\n        generate_good_integers(bin / 10 + 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 2 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 ** 20]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "generate_good_integers(bin * 10 + 8, n)",
      "mutated_line": "generate_good_integers(bin + 10 + 8, n)",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 2, n)\n        generate_good_integers(bin + 10 + 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 2 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 ** 20]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "generate_good_integers(bin * 10 + 8, n)",
      "mutated_line": "generate_good_integers(bin ** 10 + 8, n)",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 2, n)\n        generate_good_integers(bin ** 10 + 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 2 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 ** 20]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "generate_good_integers(bin * 10 + 8, n)",
      "mutated_line": "generate_good_integers(bin * 10 + 9, n)",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 2, n)\n        generate_good_integers(bin * 10 + 9, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 2 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 ** 20]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "generate_good_integers(bin * 10 + 8, n)",
      "mutated_line": "generate_good_integers(bin * 10 + 7, n)",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 2, n)\n        generate_good_integers(bin * 10 + 7, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 2 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 ** 20]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "generate_good_integers(bin * 10 + 8, n)",
      "mutated_line": "generate_good_integers(bin * 10 + 0, n)",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 2, n)\n        generate_good_integers(bin * 10 + 0, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 2 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 ** 20]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "generate_good_integers(bin * 10 + 8, n)",
      "mutated_line": "generate_good_integers(bin * 10 + 1, n)",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 2, n)\n        generate_good_integers(bin * 10 + 1, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 2 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 ** 20]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "generate_good_integers(bin * 10 + 8, n)",
      "mutated_line": "generate_good_integers(bin * 10 + -8, n)",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 2, n)\n        generate_good_integers(bin * 10 + -8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 2 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 ** 20]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "m = -1 << 20",
      "mutated_line": "m = -2 << 20",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 2, n)\n        generate_good_integers(bin * 10 + 8, n)\n\n    def find_max_product(n, p):\n        m = -2 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 2 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 ** 20]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "m = -1 << 20",
      "mutated_line": "m = -0 << 20",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 2, n)\n        generate_good_integers(bin * 10 + 8, n)\n\n    def find_max_product(n, p):\n        m = -0 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 2 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 ** 20]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "m = -1 << 20",
      "mutated_line": "m = -0 << 20",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 2, n)\n        generate_good_integers(bin * 10 + 8, n)\n\n    def find_max_product(n, p):\n        m = -0 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 2 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 ** 20]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "m = -1 << 20",
      "mutated_line": "m = --1 << 20",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 2, n)\n        generate_good_integers(bin * 10 + 8, n)\n\n    def find_max_product(n, p):\n        m = --1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 2 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 ** 20]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if a[p] ** 2 > n:",
      "mutated_line": "if a[p] ** 3 > n:",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 2, n)\n        generate_good_integers(bin * 10 + 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 3 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 ** 20]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if a[p] ** 2 > n:",
      "mutated_line": "if a[p] ** 1 > n:",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 2, n)\n        generate_good_integers(bin * 10 + 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 1 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 ** 20]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if a[p] ** 2 > n:",
      "mutated_line": "if a[p] ** 0 > n:",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 2, n)\n        generate_good_integers(bin * 10 + 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 0 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 ** 20]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if a[p] ** 2 > n:",
      "mutated_line": "if a[p] ** 1 > n:",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 2, n)\n        generate_good_integers(bin * 10 + 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 1 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 ** 20]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if a[p] ** 2 > n:",
      "mutated_line": "if a[p] ** -2 > n:",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 2, n)\n        generate_good_integers(bin * 10 + 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** -2 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 ** 20]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "m = find_max_product(n // a[p], p) + 1",
      "mutated_line": "m = find_max_product(n // a[p], p) + 2",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 2, n)\n        generate_good_integers(bin * 10 + 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 2 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 2\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 ** 20]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "m = find_max_product(n // a[p], p) + 1",
      "mutated_line": "m = find_max_product(n // a[p], p) + 0",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 2, n)\n        generate_good_integers(bin * 10 + 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 2 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 0\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 ** 20]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "m = find_max_product(n // a[p], p) + 1",
      "mutated_line": "m = find_max_product(n // a[p], p) + 0",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 2, n)\n        generate_good_integers(bin * 10 + 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 2 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 0\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 ** 20]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "m = find_max_product(n // a[p], p) + 1",
      "mutated_line": "m = find_max_product(n // a[p], p) + -1",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 2, n)\n        generate_good_integers(bin * 10 + 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 2 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + -1\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 ** 20]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "return max(m, find_max_product(n, p + 1))",
      "mutated_line": "return max(m, find_max_product(n, p - 1))",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 2, n)\n        generate_good_integers(bin * 10 + 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 2 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p - 1))\n    if n & 1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 ** 20]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "return max(m, find_max_product(n, p + 1))",
      "mutated_line": "return max(m, find_max_product(n, p * 1))",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 2, n)\n        generate_good_integers(bin * 10 + 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 2 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p * 1))\n    if n & 1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 ** 20]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "a = sorted(a) + [10 ** 20]",
      "mutated_line": "a = sorted(a) + [11 ** 20]",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 2, n)\n        generate_good_integers(bin * 10 + 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 2 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [11 ** 20]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "a = sorted(a) + [10 ** 20]",
      "mutated_line": "a = sorted(a) + [9 ** 20]",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 2, n)\n        generate_good_integers(bin * 10 + 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 2 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [9 ** 20]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "a = sorted(a) + [10 ** 20]",
      "mutated_line": "a = sorted(a) + [0 ** 20]",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 2, n)\n        generate_good_integers(bin * 10 + 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 2 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [0 ** 20]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "a = sorted(a) + [10 ** 20]",
      "mutated_line": "a = sorted(a) + [1 ** 20]",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 2, n)\n        generate_good_integers(bin * 10 + 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 2 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [1 ** 20]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "a = sorted(a) + [10 ** 20]",
      "mutated_line": "a = sorted(a) + [-10 ** 20]",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 2, n)\n        generate_good_integers(bin * 10 + 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 2 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [-10 ** 20]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "a = sorted(a) + [10 ** 20]",
      "mutated_line": "a = sorted(a) + [10 ** 21]",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 2, n)\n        generate_good_integers(bin * 10 + 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 2 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 ** 21]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "a = sorted(a) + [10 ** 20]",
      "mutated_line": "a = sorted(a) + [10 ** 19]",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 2, n)\n        generate_good_integers(bin * 10 + 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 2 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 ** 19]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "a = sorted(a) + [10 ** 20]",
      "mutated_line": "a = sorted(a) + [10 ** 0]",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 2, n)\n        generate_good_integers(bin * 10 + 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 2 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 ** 0]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "a = sorted(a) + [10 ** 20]",
      "mutated_line": "a = sorted(a) + [10 ** 1]",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 2, n)\n        generate_good_integers(bin * 10 + 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 2 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 ** 1]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "a = sorted(a) + [10 ** 20]",
      "mutated_line": "a = sorted(a) + [10 ** -20]",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 2, n)\n        generate_good_integers(bin * 10 + 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 2 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 ** -20]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "generate_good_integers(bin * 10 + 2, n)",
      "mutated_line": "generate_good_integers(bin * 11 + 2, n)",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 11 + 2, n)\n        generate_good_integers(bin * 10 + 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 2 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 ** 20]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "generate_good_integers(bin * 10 + 2, n)",
      "mutated_line": "generate_good_integers(bin * 9 + 2, n)",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 9 + 2, n)\n        generate_good_integers(bin * 10 + 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 2 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 ** 20]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "generate_good_integers(bin * 10 + 2, n)",
      "mutated_line": "generate_good_integers(bin * 0 + 2, n)",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 0 + 2, n)\n        generate_good_integers(bin * 10 + 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 2 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 ** 20]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "generate_good_integers(bin * 10 + 2, n)",
      "mutated_line": "generate_good_integers(bin * 1 + 2, n)",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 1 + 2, n)\n        generate_good_integers(bin * 10 + 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 2 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 ** 20]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "generate_good_integers(bin * 10 + 2, n)",
      "mutated_line": "generate_good_integers(bin * -10 + 2, n)",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * -10 + 2, n)\n        generate_good_integers(bin * 10 + 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 2 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 ** 20]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "generate_good_integers(bin * 10 + 8, n)",
      "mutated_line": "generate_good_integers(bin * 11 + 8, n)",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 2, n)\n        generate_good_integers(bin * 11 + 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 2 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 ** 20]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "generate_good_integers(bin * 10 + 8, n)",
      "mutated_line": "generate_good_integers(bin * 9 + 8, n)",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 2, n)\n        generate_good_integers(bin * 9 + 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 2 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 ** 20]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "generate_good_integers(bin * 10 + 8, n)",
      "mutated_line": "generate_good_integers(bin * 0 + 8, n)",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 2, n)\n        generate_good_integers(bin * 0 + 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 2 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 ** 20]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "generate_good_integers(bin * 10 + 8, n)",
      "mutated_line": "generate_good_integers(bin * 1 + 8, n)",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 2, n)\n        generate_good_integers(bin * 1 + 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 2 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 ** 20]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "generate_good_integers(bin * 10 + 8, n)",
      "mutated_line": "generate_good_integers(bin * -10 + 8, n)",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 2, n)\n        generate_good_integers(bin * -10 + 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 2 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 ** 20]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "m = find_max_product(n // a[p], p) + 1",
      "mutated_line": "m = find_max_product(n / a[p], p) + 1",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 2, n)\n        generate_good_integers(bin * 10 + 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 2 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n / a[p], p) + 1\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 ** 20]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "m = find_max_product(n // a[p], p) + 1",
      "mutated_line": "m = find_max_product(n * a[p], p) + 1",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 2, n)\n        generate_good_integers(bin * 10 + 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 2 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n * a[p], p) + 1\n        return max(m, find_max_product(n, p + 1))\n    if n & 1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 ** 20]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return max(m, find_max_product(n, p + 1))",
      "mutated_line": "return max(m, find_max_product(n, p + 2))",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 2, n)\n        generate_good_integers(bin * 10 + 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 2 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 2))\n    if n & 1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 ** 20]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return max(m, find_max_product(n, p + 1))",
      "mutated_line": "return max(m, find_max_product(n, p + 0))",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 2, n)\n        generate_good_integers(bin * 10 + 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 2 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 0))\n    if n & 1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 ** 20]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return max(m, find_max_product(n, p + 1))",
      "mutated_line": "return max(m, find_max_product(n, p + 0))",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 2, n)\n        generate_good_integers(bin * 10 + 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 2 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + 0))\n    if n & 1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 ** 20]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return max(m, find_max_product(n, p + 1))",
      "mutated_line": "return max(m, find_max_product(n, p + -1))",
      "code": "import bisect\n\ndef max_good_integer_product(n):\n    a = []\n\n    def generate_good_integers(bin, n):\n        if bin > n:\n            return\n        if bin:\n            a.append(bin)\n        generate_good_integers(bin * 10 + 2, n)\n        generate_good_integers(bin * 10 + 8, n)\n\n    def find_max_product(n, p):\n        m = -1 << 20\n        x = bisect.bisect_left(a, n)\n        if x != len(a) and a[x] == n:\n            m = 1\n        if a[p] ** 2 > n:\n            return m\n        if n % a[p] == 0:\n            m = find_max_product(n // a[p], p) + 1\n        return max(m, find_max_product(n, p + -1))\n    if n & 1:\n        return -1\n    generate_good_integers(0, n)\n    a = sorted(a) + [10 ** 20]\n    result = find_max_product(n, 0)\n    return result if result > 0 else -1"
    }
  ]
}