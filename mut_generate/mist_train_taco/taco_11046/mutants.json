{
  "task_id": "taco_11046",
  "entry_point": "count_painting_ways",
  "mutant_count": 117,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def count_painting_ways(N: int, M: int, K: int, mod: int = 998244353) -> int:",
      "mutated_line": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244354) -> int:",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244354) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [1]\n    for m in range(1, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [1] * (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 1, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 0\n    for i in range(K + 1):\n        color = pow(M - 1, N - 1 - i, mod)\n        order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod\n        ans += color * order * M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def count_painting_ways(N: int, M: int, K: int, mod: int = 998244353) -> int:",
      "mutated_line": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244352) -> int:",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244352) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [1]\n    for m in range(1, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [1] * (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 1, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 0\n    for i in range(K + 1):\n        color = pow(M - 1, N - 1 - i, mod)\n        order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod\n        ans += color * order * M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def count_painting_ways(N: int, M: int, K: int, mod: int = 998244353) -> int:",
      "mutated_line": "def count_painting_ways(N: int, M: int, K: int, mod: int=0) -> int:",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=0) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [1]\n    for m in range(1, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [1] * (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 1, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 0\n    for i in range(K + 1):\n        color = pow(M - 1, N - 1 - i, mod)\n        order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod\n        ans += color * order * M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def count_painting_ways(N: int, M: int, K: int, mod: int = 998244353) -> int:",
      "mutated_line": "def count_painting_ways(N: int, M: int, K: int, mod: int=1) -> int:",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=1) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [1]\n    for m in range(1, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [1] * (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 1, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 0\n    for i in range(K + 1):\n        color = pow(M - 1, N - 1 - i, mod)\n        order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod\n        ans += color * order * M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def count_painting_ways(N: int, M: int, K: int, mod: int = 998244353) -> int:",
      "mutated_line": "def count_painting_ways(N: int, M: int, K: int, mod: int=-998244353) -> int:",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=-998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [1]\n    for m in range(1, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [1] * (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 1, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 0\n    for i in range(K + 1):\n        color = pow(M - 1, N - 1 - i, mod)\n        order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod\n        ans += color * order * M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\"\"\"\n    f = 1\n    f_list = [1]\n    for m in range(1, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [1] * (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 1, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 0\n    for i in range(K + 1):\n        color = pow(M - 1, N - 1 - i, mod)\n        order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod\n        ans += color * order * M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "f = 1",
      "mutated_line": "f = 2",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 2\n    f_list = [1]\n    for m in range(1, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [1] * (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 1, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 0\n    for i in range(K + 1):\n        color = pow(M - 1, N - 1 - i, mod)\n        order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod\n        ans += color * order * M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "f = 1",
      "mutated_line": "f = 0",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 0\n    f_list = [1]\n    for m in range(1, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [1] * (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 1, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 0\n    for i in range(K + 1):\n        color = pow(M - 1, N - 1 - i, mod)\n        order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod\n        ans += color * order * M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "f = 1",
      "mutated_line": "f = 0",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 0\n    f_list = [1]\n    for m in range(1, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [1] * (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 1, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 0\n    for i in range(K + 1):\n        color = pow(M - 1, N - 1 - i, mod)\n        order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod\n        ans += color * order * M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "f = 1",
      "mutated_line": "f = -1",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = -1\n    f_list = [1]\n    for m in range(1, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [1] * (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 1, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 0\n    for i in range(K + 1):\n        color = pow(M - 1, N - 1 - i, mod)\n        order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod\n        ans += color * order * M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 19,
      "original_line": "f *= m",
      "mutated_line": "f /= m",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [1]\n    for m in range(1, N + 1):\n        f /= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [1] * (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 1, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 0\n    for i in range(K + 1):\n        color = pow(M - 1, N - 1 - i, mod)\n        order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod\n        ans += color * order * M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "inv_list = [1] * (N + 1)",
      "mutated_line": "inv_list = [1] / (N + 1)",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [1]\n    for m in range(1, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [1] / (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 1, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 0\n    for i in range(K + 1):\n        color = pow(M - 1, N - 1 - i, mod)\n        order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod\n        ans += color * order * M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "inv_list = [1] * (N + 1)",
      "mutated_line": "inv_list = [1] + (N + 1)",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [1]\n    for m in range(1, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [1] + (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 1, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 0\n    for i in range(K + 1):\n        color = pow(M - 1, N - 1 - i, mod)\n        order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod\n        ans += color * order * M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "inv_list = [1] * (N + 1)",
      "mutated_line": "inv_list = [1] ** (N + 1)",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [1]\n    for m in range(1, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [1] ** (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 1, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 0\n    for i in range(K + 1):\n        color = pow(M - 1, N - 1 - i, mod)\n        order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod\n        ans += color * order * M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 27,
      "original_line": "inv *= m",
      "mutated_line": "inv /= m",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [1]\n    for m in range(1, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [1] * (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 1, -1):\n        inv /= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 0\n    for i in range(K + 1):\n        color = pow(M - 1, N - 1 - i, mod)\n        order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod\n        ans += color * order * M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [1]\n    for m in range(1, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [1] * (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 1, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 1\n    for i in range(K + 1):\n        color = pow(M - 1, N - 1 - i, mod)\n        order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod\n        ans += color * order * M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "ans = 0",
      "mutated_line": "ans = -1",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [1]\n    for m in range(1, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [1] * (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 1, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = -1\n    for i in range(K + 1):\n        color = pow(M - 1, N - 1 - i, mod)\n        order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod\n        ans += color * order * M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [1]\n    for m in range(1, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [1] * (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 1, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 1\n    for i in range(K + 1):\n        color = pow(M - 1, N - 1 - i, mod)\n        order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod\n        ans += color * order * M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 36,
      "original_line": "ans += color * order * M % mod",
      "mutated_line": "ans -= color * order * M % mod",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [1]\n    for m in range(1, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [1] * (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 1, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 0\n    for i in range(K + 1):\n        color = pow(M - 1, N - 1 - i, mod)\n        order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod\n        ans -= color * order * M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "f_list = [1]",
      "mutated_line": "f_list = [2]",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [2]\n    for m in range(1, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [1] * (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 1, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 0\n    for i in range(K + 1):\n        color = pow(M - 1, N - 1 - i, mod)\n        order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod\n        ans += color * order * M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "f_list = [1]",
      "mutated_line": "f_list = [0]",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [0]\n    for m in range(1, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [1] * (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 1, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 0\n    for i in range(K + 1):\n        color = pow(M - 1, N - 1 - i, mod)\n        order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod\n        ans += color * order * M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "f_list = [1]",
      "mutated_line": "f_list = [0]",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [0]\n    for m in range(1, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [1] * (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 1, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 0\n    for i in range(K + 1):\n        color = pow(M - 1, N - 1 - i, mod)\n        order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod\n        ans += color * order * M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "f_list = [1]",
      "mutated_line": "f_list = [-1]",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [-1]\n    for m in range(1, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [1] * (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 1, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 0\n    for i in range(K + 1):\n        color = pow(M - 1, N - 1 - i, mod)\n        order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod\n        ans += color * order * M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for m in range(1, N + 1):",
      "mutated_line": "for m in range(2, N + 1):",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [1]\n    for m in range(2, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [1] * (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 1, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 0\n    for i in range(K + 1):\n        color = pow(M - 1, N - 1 - i, mod)\n        order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod\n        ans += color * order * M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for m in range(1, N + 1):",
      "mutated_line": "for m in range(0, N + 1):",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [1]\n    for m in range(0, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [1] * (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 1, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 0\n    for i in range(K + 1):\n        color = pow(M - 1, N - 1 - i, mod)\n        order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod\n        ans += color * order * M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for m in range(1, N + 1):",
      "mutated_line": "for m in range(0, N + 1):",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [1]\n    for m in range(0, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [1] * (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 1, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 0\n    for i in range(K + 1):\n        color = pow(M - 1, N - 1 - i, mod)\n        order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod\n        ans += color * order * M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for m in range(1, N + 1):",
      "mutated_line": "for m in range(-1, N + 1):",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [1]\n    for m in range(-1, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [1] * (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 1, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 0\n    for i in range(K + 1):\n        color = pow(M - 1, N - 1 - i, mod)\n        order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod\n        ans += color * order * M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "for m in range(1, N + 1):",
      "mutated_line": "for m in range(1, N - 1):",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [1]\n    for m in range(1, N - 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [1] * (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 1, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 0\n    for i in range(K + 1):\n        color = pow(M - 1, N - 1 - i, mod)\n        order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod\n        ans += color * order * M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "for m in range(1, N + 1):",
      "mutated_line": "for m in range(1, N * 1):",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [1]\n    for m in range(1, N * 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [1] * (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 1, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 0\n    for i in range(K + 1):\n        color = pow(M - 1, N - 1 - i, mod)\n        order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod\n        ans += color * order * M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "inv = pow(f, mod - 2, mod)",
      "mutated_line": "inv = pow(f, mod + 2, mod)",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [1]\n    for m in range(1, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod + 2, mod)\n    inv_list = [1] * (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 1, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 0\n    for i in range(K + 1):\n        color = pow(M - 1, N - 1 - i, mod)\n        order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod\n        ans += color * order * M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "inv = pow(f, mod - 2, mod)",
      "mutated_line": "inv = pow(f, mod * 2, mod)",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [1]\n    for m in range(1, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod * 2, mod)\n    inv_list = [1] * (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 1, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 0\n    for i in range(K + 1):\n        color = pow(M - 1, N - 1 - i, mod)\n        order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod\n        ans += color * order * M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "inv_list = [1] * (N + 1)",
      "mutated_line": "inv_list = [1] * (N - 1)",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [1]\n    for m in range(1, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [1] * (N - 1)\n    inv_list[N] = inv\n    for m in range(N, 1, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 0\n    for i in range(K + 1):\n        color = pow(M - 1, N - 1 - i, mod)\n        order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod\n        ans += color * order * M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "inv_list = [1] * (N + 1)",
      "mutated_line": "inv_list = [1] * (N * 1)",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [1]\n    for m in range(1, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [1] * (N * 1)\n    inv_list[N] = inv\n    for m in range(N, 1, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 0\n    for i in range(K + 1):\n        color = pow(M - 1, N - 1 - i, mod)\n        order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod\n        ans += color * order * M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for m in range(N, 1, -1):",
      "mutated_line": "for m in range(N, 2, -1):",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [1]\n    for m in range(1, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [1] * (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 2, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 0\n    for i in range(K + 1):\n        color = pow(M - 1, N - 1 - i, mod)\n        order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod\n        ans += color * order * M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for m in range(N, 1, -1):",
      "mutated_line": "for m in range(N, 0, -1):",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [1]\n    for m in range(1, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [1] * (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 0, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 0\n    for i in range(K + 1):\n        color = pow(M - 1, N - 1 - i, mod)\n        order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod\n        ans += color * order * M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for m in range(N, 1, -1):",
      "mutated_line": "for m in range(N, 0, -1):",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [1]\n    for m in range(1, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [1] * (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 0, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 0\n    for i in range(K + 1):\n        color = pow(M - 1, N - 1 - i, mod)\n        order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod\n        ans += color * order * M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for m in range(N, 1, -1):",
      "mutated_line": "for m in range(N, -1, -1):",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [1]\n    for m in range(1, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [1] * (N + 1)\n    inv_list[N] = inv\n    for m in range(N, -1, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 0\n    for i in range(K + 1):\n        color = pow(M - 1, N - 1 - i, mod)\n        order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod\n        ans += color * order * M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 26,
      "original_line": "for m in range(N, 1, -1):",
      "mutated_line": "for m in range(N, 1, +1):",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [1]\n    for m in range(1, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [1] * (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 1, +1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 0\n    for i in range(K + 1):\n        color = pow(M - 1, N - 1 - i, mod)\n        order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod\n        ans += color * order * M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "for i in range(K + 1):",
      "mutated_line": "for i in range(K - 1):",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [1]\n    for m in range(1, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [1] * (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 1, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 0\n    for i in range(K - 1):\n        color = pow(M - 1, N - 1 - i, mod)\n        order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod\n        ans += color * order * M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "for i in range(K + 1):",
      "mutated_line": "for i in range(K * 1):",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [1]\n    for m in range(1, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [1] * (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 1, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 0\n    for i in range(K * 1):\n        color = pow(M - 1, N - 1 - i, mod)\n        order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod\n        ans += color * order * M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod",
      "mutated_line": "order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] * mod",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [1]\n    for m in range(1, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [1] * (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 1, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 0\n    for i in range(K + 1):\n        color = pow(M - 1, N - 1 - i, mod)\n        order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] * mod\n        ans += color * order * M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod",
      "mutated_line": "order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] + mod",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [1]\n    for m in range(1, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [1] * (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 1, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 0\n    for i in range(K + 1):\n        color = pow(M - 1, N - 1 - i, mod)\n        order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] + mod\n        ans += color * order * M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ans += color * order * M % mod",
      "mutated_line": "ans += color * order * M * mod",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [1]\n    for m in range(1, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [1] * (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 1, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 0\n    for i in range(K + 1):\n        color = pow(M - 1, N - 1 - i, mod)\n        order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod\n        ans += color * order * M * mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ans += color * order * M % mod",
      "mutated_line": "ans += color * order * M + mod",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [1]\n    for m in range(1, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [1] * (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 1, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 0\n    for i in range(K + 1):\n        color = pow(M - 1, N - 1 - i, mod)\n        order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod\n        ans += color * order * M + mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "ans = ans % mod",
      "mutated_line": "ans = ans * mod",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [1]\n    for m in range(1, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [1] * (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 1, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 0\n    for i in range(K + 1):\n        color = pow(M - 1, N - 1 - i, mod)\n        order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod\n        ans += color * order * M % mod\n        ans = ans * mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "ans = ans % mod",
      "mutated_line": "ans = ans + mod",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [1]\n    for m in range(1, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [1] * (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 1, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 0\n    for i in range(K + 1):\n        color = pow(M - 1, N - 1 - i, mod)\n        order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod\n        ans += color * order * M % mod\n        ans = ans + mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for m in range(1, N + 1):",
      "mutated_line": "for m in range(1, N + 2):",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [1]\n    for m in range(1, N + 2):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [1] * (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 1, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 0\n    for i in range(K + 1):\n        color = pow(M - 1, N - 1 - i, mod)\n        order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod\n        ans += color * order * M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for m in range(1, N + 1):",
      "mutated_line": "for m in range(1, N + 0):",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [1]\n    for m in range(1, N + 0):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [1] * (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 1, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 0\n    for i in range(K + 1):\n        color = pow(M - 1, N - 1 - i, mod)\n        order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod\n        ans += color * order * M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for m in range(1, N + 1):",
      "mutated_line": "for m in range(1, N + 0):",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [1]\n    for m in range(1, N + 0):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [1] * (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 1, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 0\n    for i in range(K + 1):\n        color = pow(M - 1, N - 1 - i, mod)\n        order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod\n        ans += color * order * M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for m in range(1, N + 1):",
      "mutated_line": "for m in range(1, N + -1):",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [1]\n    for m in range(1, N + -1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [1] * (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 1, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 0\n    for i in range(K + 1):\n        color = pow(M - 1, N - 1 - i, mod)\n        order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod\n        ans += color * order * M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "inv = pow(f, mod - 2, mod)",
      "mutated_line": "inv = pow(f, mod - 3, mod)",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [1]\n    for m in range(1, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 3, mod)\n    inv_list = [1] * (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 1, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 0\n    for i in range(K + 1):\n        color = pow(M - 1, N - 1 - i, mod)\n        order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod\n        ans += color * order * M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "inv = pow(f, mod - 2, mod)",
      "mutated_line": "inv = pow(f, mod - 1, mod)",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [1]\n    for m in range(1, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 1, mod)\n    inv_list = [1] * (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 1, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 0\n    for i in range(K + 1):\n        color = pow(M - 1, N - 1 - i, mod)\n        order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod\n        ans += color * order * M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "inv = pow(f, mod - 2, mod)",
      "mutated_line": "inv = pow(f, mod - 0, mod)",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [1]\n    for m in range(1, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 0, mod)\n    inv_list = [1] * (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 1, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 0\n    for i in range(K + 1):\n        color = pow(M - 1, N - 1 - i, mod)\n        order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod\n        ans += color * order * M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "inv = pow(f, mod - 2, mod)",
      "mutated_line": "inv = pow(f, mod - 1, mod)",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [1]\n    for m in range(1, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 1, mod)\n    inv_list = [1] * (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 1, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 0\n    for i in range(K + 1):\n        color = pow(M - 1, N - 1 - i, mod)\n        order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod\n        ans += color * order * M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "inv = pow(f, mod - 2, mod)",
      "mutated_line": "inv = pow(f, mod - -2, mod)",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [1]\n    for m in range(1, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - -2, mod)\n    inv_list = [1] * (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 1, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 0\n    for i in range(K + 1):\n        color = pow(M - 1, N - 1 - i, mod)\n        order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod\n        ans += color * order * M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "inv_list = [1] * (N + 1)",
      "mutated_line": "inv_list = [2] * (N + 1)",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [1]\n    for m in range(1, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [2] * (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 1, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 0\n    for i in range(K + 1):\n        color = pow(M - 1, N - 1 - i, mod)\n        order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod\n        ans += color * order * M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "inv_list = [1] * (N + 1)",
      "mutated_line": "inv_list = [0] * (N + 1)",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [1]\n    for m in range(1, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [0] * (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 1, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 0\n    for i in range(K + 1):\n        color = pow(M - 1, N - 1 - i, mod)\n        order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod\n        ans += color * order * M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "inv_list = [1] * (N + 1)",
      "mutated_line": "inv_list = [0] * (N + 1)",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [1]\n    for m in range(1, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [0] * (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 1, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 0\n    for i in range(K + 1):\n        color = pow(M - 1, N - 1 - i, mod)\n        order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod\n        ans += color * order * M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "inv_list = [1] * (N + 1)",
      "mutated_line": "inv_list = [-1] * (N + 1)",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [1]\n    for m in range(1, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [-1] * (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 1, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 0\n    for i in range(K + 1):\n        color = pow(M - 1, N - 1 - i, mod)\n        order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod\n        ans += color * order * M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "inv_list = [1] * (N + 1)",
      "mutated_line": "inv_list = [1] * (N + 2)",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [1]\n    for m in range(1, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [1] * (N + 2)\n    inv_list[N] = inv\n    for m in range(N, 1, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 0\n    for i in range(K + 1):\n        color = pow(M - 1, N - 1 - i, mod)\n        order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod\n        ans += color * order * M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "inv_list = [1] * (N + 1)",
      "mutated_line": "inv_list = [1] * (N + 0)",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [1]\n    for m in range(1, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [1] * (N + 0)\n    inv_list[N] = inv\n    for m in range(N, 1, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 0\n    for i in range(K + 1):\n        color = pow(M - 1, N - 1 - i, mod)\n        order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod\n        ans += color * order * M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "inv_list = [1] * (N + 1)",
      "mutated_line": "inv_list = [1] * (N + 0)",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [1]\n    for m in range(1, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [1] * (N + 0)\n    inv_list[N] = inv\n    for m in range(N, 1, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 0\n    for i in range(K + 1):\n        color = pow(M - 1, N - 1 - i, mod)\n        order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod\n        ans += color * order * M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "inv_list = [1] * (N + 1)",
      "mutated_line": "inv_list = [1] * (N + -1)",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [1]\n    for m in range(1, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [1] * (N + -1)\n    inv_list[N] = inv\n    for m in range(N, 1, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 0\n    for i in range(K + 1):\n        color = pow(M - 1, N - 1 - i, mod)\n        order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod\n        ans += color * order * M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for m in range(N, 1, -1):",
      "mutated_line": "for m in range(N, 1, -2):",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [1]\n    for m in range(1, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [1] * (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 1, -2):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 0\n    for i in range(K + 1):\n        color = pow(M - 1, N - 1 - i, mod)\n        order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod\n        ans += color * order * M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for m in range(N, 1, -1):",
      "mutated_line": "for m in range(N, 1, -0):",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [1]\n    for m in range(1, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [1] * (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 1, -0):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 0\n    for i in range(K + 1):\n        color = pow(M - 1, N - 1 - i, mod)\n        order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod\n        ans += color * order * M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for m in range(N, 1, -1):",
      "mutated_line": "for m in range(N, 1, -0):",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [1]\n    for m in range(1, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [1] * (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 1, -0):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 0\n    for i in range(K + 1):\n        color = pow(M - 1, N - 1 - i, mod)\n        order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod\n        ans += color * order * M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for m in range(N, 1, -1):",
      "mutated_line": "for m in range(N, 1, --1):",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [1]\n    for m in range(1, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [1] * (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 1, --1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 0\n    for i in range(K + 1):\n        color = pow(M - 1, N - 1 - i, mod)\n        order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod\n        ans += color * order * M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "inv_list[m - 1] = inv",
      "mutated_line": "inv_list[m + 1] = inv",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [1]\n    for m in range(1, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [1] * (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 1, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m + 1] = inv\n    ans = 0\n    for i in range(K + 1):\n        color = pow(M - 1, N - 1 - i, mod)\n        order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod\n        ans += color * order * M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "inv_list[m - 1] = inv",
      "mutated_line": "inv_list[m * 1] = inv",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [1]\n    for m in range(1, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [1] * (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 1, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m * 1] = inv\n    ans = 0\n    for i in range(K + 1):\n        color = pow(M - 1, N - 1 - i, mod)\n        order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod\n        ans += color * order * M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for i in range(K + 1):",
      "mutated_line": "for i in range(K + 2):",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [1]\n    for m in range(1, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [1] * (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 1, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 0\n    for i in range(K + 2):\n        color = pow(M - 1, N - 1 - i, mod)\n        order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod\n        ans += color * order * M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for i in range(K + 1):",
      "mutated_line": "for i in range(K + 0):",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [1]\n    for m in range(1, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [1] * (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 1, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 0\n    for i in range(K + 0):\n        color = pow(M - 1, N - 1 - i, mod)\n        order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod\n        ans += color * order * M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for i in range(K + 1):",
      "mutated_line": "for i in range(K + 0):",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [1]\n    for m in range(1, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [1] * (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 1, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 0\n    for i in range(K + 0):\n        color = pow(M - 1, N - 1 - i, mod)\n        order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod\n        ans += color * order * M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for i in range(K + 1):",
      "mutated_line": "for i in range(K + -1):",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [1]\n    for m in range(1, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [1] * (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 1, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 0\n    for i in range(K + -1):\n        color = pow(M - 1, N - 1 - i, mod)\n        order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod\n        ans += color * order * M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "color = pow(M - 1, N - 1 - i, mod)",
      "mutated_line": "color = pow(M + 1, N - 1 - i, mod)",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [1]\n    for m in range(1, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [1] * (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 1, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 0\n    for i in range(K + 1):\n        color = pow(M + 1, N - 1 - i, mod)\n        order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod\n        ans += color * order * M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "color = pow(M - 1, N - 1 - i, mod)",
      "mutated_line": "color = pow(M * 1, N - 1 - i, mod)",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [1]\n    for m in range(1, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [1] * (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 1, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 0\n    for i in range(K + 1):\n        color = pow(M * 1, N - 1 - i, mod)\n        order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod\n        ans += color * order * M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "color = pow(M - 1, N - 1 - i, mod)",
      "mutated_line": "color = pow(M - 1, N - 1 + i, mod)",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [1]\n    for m in range(1, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [1] * (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 1, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 0\n    for i in range(K + 1):\n        color = pow(M - 1, N - 1 + i, mod)\n        order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod\n        ans += color * order * M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "color = pow(M - 1, N - 1 - i, mod)",
      "mutated_line": "color = pow(M - 1, (N - 1) * i, mod)",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [1]\n    for m in range(1, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [1] * (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 1, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 0\n    for i in range(K + 1):\n        color = pow(M - 1, (N - 1) * i, mod)\n        order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod\n        ans += color * order * M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod",
      "mutated_line": "order = f_list[N - 1] * inv_list[i] / inv_list[N - i - 1] % mod",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [1]\n    for m in range(1, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [1] * (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 1, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 0\n    for i in range(K + 1):\n        color = pow(M - 1, N - 1 - i, mod)\n        order = f_list[N - 1] * inv_list[i] / inv_list[N - i - 1] % mod\n        ans += color * order * M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod",
      "mutated_line": "order = (f_list[N - 1] * inv_list[i] + inv_list[N - i - 1]) % mod",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [1]\n    for m in range(1, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [1] * (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 1, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 0\n    for i in range(K + 1):\n        color = pow(M - 1, N - 1 - i, mod)\n        order = (f_list[N - 1] * inv_list[i] + inv_list[N - i - 1]) % mod\n        ans += color * order * M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod",
      "mutated_line": "order = (f_list[N - 1] * inv_list[i]) ** inv_list[N - i - 1] % mod",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [1]\n    for m in range(1, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [1] * (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 1, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 0\n    for i in range(K + 1):\n        color = pow(M - 1, N - 1 - i, mod)\n        order = (f_list[N - 1] * inv_list[i]) ** inv_list[N - i - 1] % mod\n        ans += color * order * M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ans += color * order * M % mod",
      "mutated_line": "ans += color * order / M % mod",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [1]\n    for m in range(1, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [1] * (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 1, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 0\n    for i in range(K + 1):\n        color = pow(M - 1, N - 1 - i, mod)\n        order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod\n        ans += color * order / M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ans += color * order * M % mod",
      "mutated_line": "ans += (color * order + M) % mod",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [1]\n    for m in range(1, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [1] * (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 1, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 0\n    for i in range(K + 1):\n        color = pow(M - 1, N - 1 - i, mod)\n        order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod\n        ans += (color * order + M) % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ans += color * order * M % mod",
      "mutated_line": "ans += (color * order) ** M % mod",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [1]\n    for m in range(1, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [1] * (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 1, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 0\n    for i in range(K + 1):\n        color = pow(M - 1, N - 1 - i, mod)\n        order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod\n        ans += (color * order) ** M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "inv_list[m - 1] = inv",
      "mutated_line": "inv_list[m - 2] = inv",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [1]\n    for m in range(1, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [1] * (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 1, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 2] = inv\n    ans = 0\n    for i in range(K + 1):\n        color = pow(M - 1, N - 1 - i, mod)\n        order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod\n        ans += color * order * M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "inv_list[m - 1] = inv",
      "mutated_line": "inv_list[m - 0] = inv",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [1]\n    for m in range(1, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [1] * (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 1, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 0] = inv\n    ans = 0\n    for i in range(K + 1):\n        color = pow(M - 1, N - 1 - i, mod)\n        order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod\n        ans += color * order * M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "inv_list[m - 1] = inv",
      "mutated_line": "inv_list[m - 0] = inv",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [1]\n    for m in range(1, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [1] * (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 1, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 0] = inv\n    ans = 0\n    for i in range(K + 1):\n        color = pow(M - 1, N - 1 - i, mod)\n        order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod\n        ans += color * order * M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "inv_list[m - 1] = inv",
      "mutated_line": "inv_list[m - -1] = inv",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [1]\n    for m in range(1, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [1] * (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 1, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m - -1] = inv\n    ans = 0\n    for i in range(K + 1):\n        color = pow(M - 1, N - 1 - i, mod)\n        order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod\n        ans += color * order * M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "color = pow(M - 1, N - 1 - i, mod)",
      "mutated_line": "color = pow(M - 2, N - 1 - i, mod)",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [1]\n    for m in range(1, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [1] * (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 1, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 0\n    for i in range(K + 1):\n        color = pow(M - 2, N - 1 - i, mod)\n        order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod\n        ans += color * order * M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "color = pow(M - 1, N - 1 - i, mod)",
      "mutated_line": "color = pow(M - 0, N - 1 - i, mod)",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [1]\n    for m in range(1, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [1] * (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 1, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 0\n    for i in range(K + 1):\n        color = pow(M - 0, N - 1 - i, mod)\n        order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod\n        ans += color * order * M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "color = pow(M - 1, N - 1 - i, mod)",
      "mutated_line": "color = pow(M - 0, N - 1 - i, mod)",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [1]\n    for m in range(1, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [1] * (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 1, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 0\n    for i in range(K + 1):\n        color = pow(M - 0, N - 1 - i, mod)\n        order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod\n        ans += color * order * M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "color = pow(M - 1, N - 1 - i, mod)",
      "mutated_line": "color = pow(M - -1, N - 1 - i, mod)",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [1]\n    for m in range(1, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [1] * (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 1, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 0\n    for i in range(K + 1):\n        color = pow(M - -1, N - 1 - i, mod)\n        order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod\n        ans += color * order * M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "color = pow(M - 1, N - 1 - i, mod)",
      "mutated_line": "color = pow(M - 1, N + 1 - i, mod)",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [1]\n    for m in range(1, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [1] * (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 1, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 0\n    for i in range(K + 1):\n        color = pow(M - 1, N + 1 - i, mod)\n        order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod\n        ans += color * order * M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "color = pow(M - 1, N - 1 - i, mod)",
      "mutated_line": "color = pow(M - 1, N * 1 - i, mod)",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [1]\n    for m in range(1, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [1] * (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 1, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 0\n    for i in range(K + 1):\n        color = pow(M - 1, N * 1 - i, mod)\n        order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod\n        ans += color * order * M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod",
      "mutated_line": "order = f_list[N - 1] / inv_list[i] * inv_list[N - i - 1] % mod",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [1]\n    for m in range(1, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [1] * (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 1, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 0\n    for i in range(K + 1):\n        color = pow(M - 1, N - 1 - i, mod)\n        order = f_list[N - 1] / inv_list[i] * inv_list[N - i - 1] % mod\n        ans += color * order * M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod",
      "mutated_line": "order = (f_list[N - 1] + inv_list[i]) * inv_list[N - i - 1] % mod",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [1]\n    for m in range(1, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [1] * (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 1, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 0\n    for i in range(K + 1):\n        color = pow(M - 1, N - 1 - i, mod)\n        order = (f_list[N - 1] + inv_list[i]) * inv_list[N - i - 1] % mod\n        ans += color * order * M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod",
      "mutated_line": "order = f_list[N - 1] ** inv_list[i] * inv_list[N - i - 1] % mod",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [1]\n    for m in range(1, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [1] * (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 1, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 0\n    for i in range(K + 1):\n        color = pow(M - 1, N - 1 - i, mod)\n        order = f_list[N - 1] ** inv_list[i] * inv_list[N - i - 1] % mod\n        ans += color * order * M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ans += color * order * M % mod",
      "mutated_line": "ans += color / order * M % mod",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [1]\n    for m in range(1, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [1] * (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 1, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 0\n    for i in range(K + 1):\n        color = pow(M - 1, N - 1 - i, mod)\n        order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod\n        ans += color / order * M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ans += color * order * M % mod",
      "mutated_line": "ans += (color + order) * M % mod",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [1]\n    for m in range(1, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [1] * (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 1, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 0\n    for i in range(K + 1):\n        color = pow(M - 1, N - 1 - i, mod)\n        order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod\n        ans += (color + order) * M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ans += color * order * M % mod",
      "mutated_line": "ans += color ** order * M % mod",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [1]\n    for m in range(1, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [1] * (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 1, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 0\n    for i in range(K + 1):\n        color = pow(M - 1, N - 1 - i, mod)\n        order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod\n        ans += color ** order * M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "color = pow(M - 1, N - 1 - i, mod)",
      "mutated_line": "color = pow(M - 1, N - 2 - i, mod)",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [1]\n    for m in range(1, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [1] * (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 1, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 0\n    for i in range(K + 1):\n        color = pow(M - 1, N - 2 - i, mod)\n        order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod\n        ans += color * order * M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "color = pow(M - 1, N - 1 - i, mod)",
      "mutated_line": "color = pow(M - 1, N - 0 - i, mod)",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [1]\n    for m in range(1, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [1] * (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 1, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 0\n    for i in range(K + 1):\n        color = pow(M - 1, N - 0 - i, mod)\n        order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod\n        ans += color * order * M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "color = pow(M - 1, N - 1 - i, mod)",
      "mutated_line": "color = pow(M - 1, N - 0 - i, mod)",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [1]\n    for m in range(1, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [1] * (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 1, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 0\n    for i in range(K + 1):\n        color = pow(M - 1, N - 0 - i, mod)\n        order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod\n        ans += color * order * M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "color = pow(M - 1, N - 1 - i, mod)",
      "mutated_line": "color = pow(M - 1, N - -1 - i, mod)",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [1]\n    for m in range(1, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [1] * (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 1, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 0\n    for i in range(K + 1):\n        color = pow(M - 1, N - -1 - i, mod)\n        order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod\n        ans += color * order * M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod",
      "mutated_line": "order = f_list[N - 1] * inv_list[i] * inv_list[N - i + 1] % mod",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [1]\n    for m in range(1, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [1] * (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 1, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 0\n    for i in range(K + 1):\n        color = pow(M - 1, N - 1 - i, mod)\n        order = f_list[N - 1] * inv_list[i] * inv_list[N - i + 1] % mod\n        ans += color * order * M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod",
      "mutated_line": "order = f_list[N - 1] * inv_list[i] * inv_list[(N - i) * 1] % mod",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [1]\n    for m in range(1, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [1] * (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 1, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 0\n    for i in range(K + 1):\n        color = pow(M - 1, N - 1 - i, mod)\n        order = f_list[N - 1] * inv_list[i] * inv_list[(N - i) * 1] % mod\n        ans += color * order * M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod",
      "mutated_line": "order = f_list[N + 1] * inv_list[i] * inv_list[N - i - 1] % mod",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [1]\n    for m in range(1, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [1] * (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 1, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 0\n    for i in range(K + 1):\n        color = pow(M - 1, N - 1 - i, mod)\n        order = f_list[N + 1] * inv_list[i] * inv_list[N - i - 1] % mod\n        ans += color * order * M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod",
      "mutated_line": "order = f_list[N * 1] * inv_list[i] * inv_list[N - i - 1] % mod",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [1]\n    for m in range(1, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [1] * (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 1, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 0\n    for i in range(K + 1):\n        color = pow(M - 1, N - 1 - i, mod)\n        order = f_list[N * 1] * inv_list[i] * inv_list[N - i - 1] % mod\n        ans += color * order * M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod",
      "mutated_line": "order = f_list[N - 1] * inv_list[i] * inv_list[N + i - 1] % mod",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [1]\n    for m in range(1, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [1] * (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 1, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 0\n    for i in range(K + 1):\n        color = pow(M - 1, N - 1 - i, mod)\n        order = f_list[N - 1] * inv_list[i] * inv_list[N + i - 1] % mod\n        ans += color * order * M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod",
      "mutated_line": "order = f_list[N - 1] * inv_list[i] * inv_list[N * i - 1] % mod",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [1]\n    for m in range(1, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [1] * (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 1, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 0\n    for i in range(K + 1):\n        color = pow(M - 1, N - 1 - i, mod)\n        order = f_list[N - 1] * inv_list[i] * inv_list[N * i - 1] % mod\n        ans += color * order * M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod",
      "mutated_line": "order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 2] % mod",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [1]\n    for m in range(1, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [1] * (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 1, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 0\n    for i in range(K + 1):\n        color = pow(M - 1, N - 1 - i, mod)\n        order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 2] % mod\n        ans += color * order * M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod",
      "mutated_line": "order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 0] % mod",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [1]\n    for m in range(1, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [1] * (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 1, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 0\n    for i in range(K + 1):\n        color = pow(M - 1, N - 1 - i, mod)\n        order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 0] % mod\n        ans += color * order * M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod",
      "mutated_line": "order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 0] % mod",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [1]\n    for m in range(1, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [1] * (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 1, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 0\n    for i in range(K + 1):\n        color = pow(M - 1, N - 1 - i, mod)\n        order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 0] % mod\n        ans += color * order * M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod",
      "mutated_line": "order = f_list[N - 1] * inv_list[i] * inv_list[N - i - -1] % mod",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [1]\n    for m in range(1, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [1] * (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 1, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 0\n    for i in range(K + 1):\n        color = pow(M - 1, N - 1 - i, mod)\n        order = f_list[N - 1] * inv_list[i] * inv_list[N - i - -1] % mod\n        ans += color * order * M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod",
      "mutated_line": "order = f_list[N - 2] * inv_list[i] * inv_list[N - i - 1] % mod",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [1]\n    for m in range(1, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [1] * (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 1, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 0\n    for i in range(K + 1):\n        color = pow(M - 1, N - 1 - i, mod)\n        order = f_list[N - 2] * inv_list[i] * inv_list[N - i - 1] % mod\n        ans += color * order * M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod",
      "mutated_line": "order = f_list[N - 0] * inv_list[i] * inv_list[N - i - 1] % mod",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [1]\n    for m in range(1, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [1] * (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 1, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 0\n    for i in range(K + 1):\n        color = pow(M - 1, N - 1 - i, mod)\n        order = f_list[N - 0] * inv_list[i] * inv_list[N - i - 1] % mod\n        ans += color * order * M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod",
      "mutated_line": "order = f_list[N - 0] * inv_list[i] * inv_list[N - i - 1] % mod",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [1]\n    for m in range(1, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [1] * (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 1, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 0\n    for i in range(K + 1):\n        color = pow(M - 1, N - 1 - i, mod)\n        order = f_list[N - 0] * inv_list[i] * inv_list[N - i - 1] % mod\n        ans += color * order * M % mod\n        ans = ans % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod",
      "mutated_line": "order = f_list[N - -1] * inv_list[i] * inv_list[N - i - 1] % mod",
      "code": "def count_painting_ways(N: int, M: int, K: int, mod: int=998244353) -> int:\n    \"\"\"\n    Calculate the number of ways to paint N blocks using M colors such that at most K pairs of adjacent blocks\n    are painted in the same color, modulo 998244353.\n\n    Parameters:\n    - N (int): The number of blocks.\n    - M (int): The number of colors available.\n    - K (int): The maximum number of pairs of adjacent blocks that can be painted in the same color.\n    - mod (int): The modulo value (default is 998244353).\n\n    Returns:\n    - int: The number of ways to paint the blocks modulo mod.\n    \"\"\"\n    f = 1\n    f_list = [1]\n    for m in range(1, N + 1):\n        f *= m\n        f %= mod\n        f_list.append(f)\n    inv = pow(f, mod - 2, mod)\n    inv_list = [1] * (N + 1)\n    inv_list[N] = inv\n    for m in range(N, 1, -1):\n        inv *= m\n        inv %= mod\n        inv_list[m - 1] = inv\n    ans = 0\n    for i in range(K + 1):\n        color = pow(M - 1, N - 1 - i, mod)\n        order = f_list[N - -1] * inv_list[i] * inv_list[N - i - 1] % mod\n        ans += color * order * M % mod\n        ans = ans % mod\n    return ans"
    }
  ]
}