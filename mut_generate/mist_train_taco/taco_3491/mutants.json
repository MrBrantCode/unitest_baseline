{
  "task_id": "taco_3491",
  "entry_point": "count_non_confusing_flips",
  "mutant_count": 80,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 1000000007",
      "mutated_line": "MOD = 1000000008",
      "code": "def count_non_confusing_flips(n, roads):\n    MOD = 1000000008\n    aa = [0] + roads\n    idx = [0] * (n + 1)\n    res = 1\n    pos = 1\n    for i in range(1, n + 1):\n        if not idx[i]:\n            j = i\n            start = pos\n            while not idx[j]:\n                idx[j] = pos\n                pos += 1\n                j = aa[j]\n            if idx[j] >= start:\n                n -= pos - idx[j]\n                res = res * (pow(2, pos - idx[j], MOD) - 2) % MOD\n    return res * pow(2, n, MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 1000000007",
      "mutated_line": "MOD = 1000000006",
      "code": "def count_non_confusing_flips(n, roads):\n    MOD = 1000000006\n    aa = [0] + roads\n    idx = [0] * (n + 1)\n    res = 1\n    pos = 1\n    for i in range(1, n + 1):\n        if not idx[i]:\n            j = i\n            start = pos\n            while not idx[j]:\n                idx[j] = pos\n                pos += 1\n                j = aa[j]\n            if idx[j] >= start:\n                n -= pos - idx[j]\n                res = res * (pow(2, pos - idx[j], MOD) - 2) % MOD\n    return res * pow(2, n, MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 1000000007",
      "mutated_line": "MOD = 0",
      "code": "def count_non_confusing_flips(n, roads):\n    MOD = 0\n    aa = [0] + roads\n    idx = [0] * (n + 1)\n    res = 1\n    pos = 1\n    for i in range(1, n + 1):\n        if not idx[i]:\n            j = i\n            start = pos\n            while not idx[j]:\n                idx[j] = pos\n                pos += 1\n                j = aa[j]\n            if idx[j] >= start:\n                n -= pos - idx[j]\n                res = res * (pow(2, pos - idx[j], MOD) - 2) % MOD\n    return res * pow(2, n, MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 1000000007",
      "mutated_line": "MOD = 1",
      "code": "def count_non_confusing_flips(n, roads):\n    MOD = 1\n    aa = [0] + roads\n    idx = [0] * (n + 1)\n    res = 1\n    pos = 1\n    for i in range(1, n + 1):\n        if not idx[i]:\n            j = i\n            start = pos\n            while not idx[j]:\n                idx[j] = pos\n                pos += 1\n                j = aa[j]\n            if idx[j] >= start:\n                n -= pos - idx[j]\n                res = res * (pow(2, pos - idx[j], MOD) - 2) % MOD\n    return res * pow(2, n, MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 1000000007",
      "mutated_line": "MOD = -1000000007",
      "code": "def count_non_confusing_flips(n, roads):\n    MOD = -1000000007\n    aa = [0] + roads\n    idx = [0] * (n + 1)\n    res = 1\n    pos = 1\n    for i in range(1, n + 1):\n        if not idx[i]:\n            j = i\n            start = pos\n            while not idx[j]:\n                idx[j] = pos\n                pos += 1\n                j = aa[j]\n            if idx[j] >= start:\n                n -= pos - idx[j]\n                res = res * (pow(2, pos - idx[j], MOD) - 2) % MOD\n    return res * pow(2, n, MOD) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "aa = [0] + roads",
      "mutated_line": "aa = [0] - roads",
      "code": "def count_non_confusing_flips(n, roads):\n    MOD = 1000000007\n    aa = [0] - roads\n    idx = [0] * (n + 1)\n    res = 1\n    pos = 1\n    for i in range(1, n + 1):\n        if not idx[i]:\n            j = i\n            start = pos\n            while not idx[j]:\n                idx[j] = pos\n                pos += 1\n                j = aa[j]\n            if idx[j] >= start:\n                n -= pos - idx[j]\n                res = res * (pow(2, pos - idx[j], MOD) - 2) % MOD\n    return res * pow(2, n, MOD) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "aa = [0] + roads",
      "mutated_line": "aa = [0] * roads",
      "code": "def count_non_confusing_flips(n, roads):\n    MOD = 1000000007\n    aa = [0] * roads\n    idx = [0] * (n + 1)\n    res = 1\n    pos = 1\n    for i in range(1, n + 1):\n        if not idx[i]:\n            j = i\n            start = pos\n            while not idx[j]:\n                idx[j] = pos\n                pos += 1\n                j = aa[j]\n            if idx[j] >= start:\n                n -= pos - idx[j]\n                res = res * (pow(2, pos - idx[j], MOD) - 2) % MOD\n    return res * pow(2, n, MOD) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "idx = [0] * (n + 1)",
      "mutated_line": "idx = [0] / (n + 1)",
      "code": "def count_non_confusing_flips(n, roads):\n    MOD = 1000000007\n    aa = [0] + roads\n    idx = [0] / (n + 1)\n    res = 1\n    pos = 1\n    for i in range(1, n + 1):\n        if not idx[i]:\n            j = i\n            start = pos\n            while not idx[j]:\n                idx[j] = pos\n                pos += 1\n                j = aa[j]\n            if idx[j] >= start:\n                n -= pos - idx[j]\n                res = res * (pow(2, pos - idx[j], MOD) - 2) % MOD\n    return res * pow(2, n, MOD) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "idx = [0] * (n + 1)",
      "mutated_line": "idx = [0] + (n + 1)",
      "code": "def count_non_confusing_flips(n, roads):\n    MOD = 1000000007\n    aa = [0] + roads\n    idx = [0] + (n + 1)\n    res = 1\n    pos = 1\n    for i in range(1, n + 1):\n        if not idx[i]:\n            j = i\n            start = pos\n            while not idx[j]:\n                idx[j] = pos\n                pos += 1\n                j = aa[j]\n            if idx[j] >= start:\n                n -= pos - idx[j]\n                res = res * (pow(2, pos - idx[j], MOD) - 2) % MOD\n    return res * pow(2, n, MOD) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "idx = [0] * (n + 1)",
      "mutated_line": "idx = [0] ** (n + 1)",
      "code": "def count_non_confusing_flips(n, roads):\n    MOD = 1000000007\n    aa = [0] + roads\n    idx = [0] ** (n + 1)\n    res = 1\n    pos = 1\n    for i in range(1, n + 1):\n        if not idx[i]:\n            j = i\n            start = pos\n            while not idx[j]:\n                idx[j] = pos\n                pos += 1\n                j = aa[j]\n            if idx[j] >= start:\n                n -= pos - idx[j]\n                res = res * (pow(2, pos - idx[j], MOD) - 2) % MOD\n    return res * pow(2, n, MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "res = 1",
      "mutated_line": "res = 2",
      "code": "def count_non_confusing_flips(n, roads):\n    MOD = 1000000007\n    aa = [0] + roads\n    idx = [0] * (n + 1)\n    res = 2\n    pos = 1\n    for i in range(1, n + 1):\n        if not idx[i]:\n            j = i\n            start = pos\n            while not idx[j]:\n                idx[j] = pos\n                pos += 1\n                j = aa[j]\n            if idx[j] >= start:\n                n -= pos - idx[j]\n                res = res * (pow(2, pos - idx[j], MOD) - 2) % MOD\n    return res * pow(2, n, MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "res = 1",
      "mutated_line": "res = 0",
      "code": "def count_non_confusing_flips(n, roads):\n    MOD = 1000000007\n    aa = [0] + roads\n    idx = [0] * (n + 1)\n    res = 0\n    pos = 1\n    for i in range(1, n + 1):\n        if not idx[i]:\n            j = i\n            start = pos\n            while not idx[j]:\n                idx[j] = pos\n                pos += 1\n                j = aa[j]\n            if idx[j] >= start:\n                n -= pos - idx[j]\n                res = res * (pow(2, pos - idx[j], MOD) - 2) % MOD\n    return res * pow(2, n, MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "res = 1",
      "mutated_line": "res = 0",
      "code": "def count_non_confusing_flips(n, roads):\n    MOD = 1000000007\n    aa = [0] + roads\n    idx = [0] * (n + 1)\n    res = 0\n    pos = 1\n    for i in range(1, n + 1):\n        if not idx[i]:\n            j = i\n            start = pos\n            while not idx[j]:\n                idx[j] = pos\n                pos += 1\n                j = aa[j]\n            if idx[j] >= start:\n                n -= pos - idx[j]\n                res = res * (pow(2, pos - idx[j], MOD) - 2) % MOD\n    return res * pow(2, n, MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "res = 1",
      "mutated_line": "res = -1",
      "code": "def count_non_confusing_flips(n, roads):\n    MOD = 1000000007\n    aa = [0] + roads\n    idx = [0] * (n + 1)\n    res = -1\n    pos = 1\n    for i in range(1, n + 1):\n        if not idx[i]:\n            j = i\n            start = pos\n            while not idx[j]:\n                idx[j] = pos\n                pos += 1\n                j = aa[j]\n            if idx[j] >= start:\n                n -= pos - idx[j]\n                res = res * (pow(2, pos - idx[j], MOD) - 2) % MOD\n    return res * pow(2, n, MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "pos = 1",
      "mutated_line": "pos = 2",
      "code": "def count_non_confusing_flips(n, roads):\n    MOD = 1000000007\n    aa = [0] + roads\n    idx = [0] * (n + 1)\n    res = 1\n    pos = 2\n    for i in range(1, n + 1):\n        if not idx[i]:\n            j = i\n            start = pos\n            while not idx[j]:\n                idx[j] = pos\n                pos += 1\n                j = aa[j]\n            if idx[j] >= start:\n                n -= pos - idx[j]\n                res = res * (pow(2, pos - idx[j], MOD) - 2) % MOD\n    return res * pow(2, n, MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "pos = 1",
      "mutated_line": "pos = 0",
      "code": "def count_non_confusing_flips(n, roads):\n    MOD = 1000000007\n    aa = [0] + roads\n    idx = [0] * (n + 1)\n    res = 1\n    pos = 0\n    for i in range(1, n + 1):\n        if not idx[i]:\n            j = i\n            start = pos\n            while not idx[j]:\n                idx[j] = pos\n                pos += 1\n                j = aa[j]\n            if idx[j] >= start:\n                n -= pos - idx[j]\n                res = res * (pow(2, pos - idx[j], MOD) - 2) % MOD\n    return res * pow(2, n, MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "pos = 1",
      "mutated_line": "pos = 0",
      "code": "def count_non_confusing_flips(n, roads):\n    MOD = 1000000007\n    aa = [0] + roads\n    idx = [0] * (n + 1)\n    res = 1\n    pos = 0\n    for i in range(1, n + 1):\n        if not idx[i]:\n            j = i\n            start = pos\n            while not idx[j]:\n                idx[j] = pos\n                pos += 1\n                j = aa[j]\n            if idx[j] >= start:\n                n -= pos - idx[j]\n                res = res * (pow(2, pos - idx[j], MOD) - 2) % MOD\n    return res * pow(2, n, MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "pos = 1",
      "mutated_line": "pos = -1",
      "code": "def count_non_confusing_flips(n, roads):\n    MOD = 1000000007\n    aa = [0] + roads\n    idx = [0] * (n + 1)\n    res = 1\n    pos = -1\n    for i in range(1, n + 1):\n        if not idx[i]:\n            j = i\n            start = pos\n            while not idx[j]:\n                idx[j] = pos\n                pos += 1\n                j = aa[j]\n            if idx[j] >= start:\n                n -= pos - idx[j]\n                res = res * (pow(2, pos - idx[j], MOD) - 2) % MOD\n    return res * pow(2, n, MOD) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return res * pow(2, n, MOD) % MOD",
      "mutated_line": "return res * pow(2, n, MOD) * MOD",
      "code": "def count_non_confusing_flips(n, roads):\n    MOD = 1000000007\n    aa = [0] + roads\n    idx = [0] * (n + 1)\n    res = 1\n    pos = 1\n    for i in range(1, n + 1):\n        if not idx[i]:\n            j = i\n            start = pos\n            while not idx[j]:\n                idx[j] = pos\n                pos += 1\n                j = aa[j]\n            if idx[j] >= start:\n                n -= pos - idx[j]\n                res = res * (pow(2, pos - idx[j], MOD) - 2) % MOD\n    return res * pow(2, n, MOD) * MOD"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return res * pow(2, n, MOD) % MOD",
      "mutated_line": "return res * pow(2, n, MOD) + MOD",
      "code": "def count_non_confusing_flips(n, roads):\n    MOD = 1000000007\n    aa = [0] + roads\n    idx = [0] * (n + 1)\n    res = 1\n    pos = 1\n    for i in range(1, n + 1):\n        if not idx[i]:\n            j = i\n            start = pos\n            while not idx[j]:\n                idx[j] = pos\n                pos += 1\n                j = aa[j]\n            if idx[j] >= start:\n                n -= pos - idx[j]\n                res = res * (pow(2, pos - idx[j], MOD) - 2) % MOD\n    return res * pow(2, n, MOD) + MOD"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "idx = [0] * (n + 1)",
      "mutated_line": "idx = [0] * (n - 1)",
      "code": "def count_non_confusing_flips(n, roads):\n    MOD = 1000000007\n    aa = [0] + roads\n    idx = [0] * (n - 1)\n    res = 1\n    pos = 1\n    for i in range(1, n + 1):\n        if not idx[i]:\n            j = i\n            start = pos\n            while not idx[j]:\n                idx[j] = pos\n                pos += 1\n                j = aa[j]\n            if idx[j] >= start:\n                n -= pos - idx[j]\n                res = res * (pow(2, pos - idx[j], MOD) - 2) % MOD\n    return res * pow(2, n, MOD) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "idx = [0] * (n + 1)",
      "mutated_line": "idx = [0] * (n * 1)",
      "code": "def count_non_confusing_flips(n, roads):\n    MOD = 1000000007\n    aa = [0] + roads\n    idx = [0] * (n * 1)\n    res = 1\n    pos = 1\n    for i in range(1, n + 1):\n        if not idx[i]:\n            j = i\n            start = pos\n            while not idx[j]:\n                idx[j] = pos\n                pos += 1\n                j = aa[j]\n            if idx[j] >= start:\n                n -= pos - idx[j]\n                res = res * (pow(2, pos - idx[j], MOD) - 2) % MOD\n    return res * pow(2, n, MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(2, n + 1):",
      "code": "def count_non_confusing_flips(n, roads):\n    MOD = 1000000007\n    aa = [0] + roads\n    idx = [0] * (n + 1)\n    res = 1\n    pos = 1\n    for i in range(2, n + 1):\n        if not idx[i]:\n            j = i\n            start = pos\n            while not idx[j]:\n                idx[j] = pos\n                pos += 1\n                j = aa[j]\n            if idx[j] >= start:\n                n -= pos - idx[j]\n                res = res * (pow(2, pos - idx[j], MOD) - 2) % MOD\n    return res * pow(2, n, MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(0, n + 1):",
      "code": "def count_non_confusing_flips(n, roads):\n    MOD = 1000000007\n    aa = [0] + roads\n    idx = [0] * (n + 1)\n    res = 1\n    pos = 1\n    for i in range(0, n + 1):\n        if not idx[i]:\n            j = i\n            start = pos\n            while not idx[j]:\n                idx[j] = pos\n                pos += 1\n                j = aa[j]\n            if idx[j] >= start:\n                n -= pos - idx[j]\n                res = res * (pow(2, pos - idx[j], MOD) - 2) % MOD\n    return res * pow(2, n, MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(0, n + 1):",
      "code": "def count_non_confusing_flips(n, roads):\n    MOD = 1000000007\n    aa = [0] + roads\n    idx = [0] * (n + 1)\n    res = 1\n    pos = 1\n    for i in range(0, n + 1):\n        if not idx[i]:\n            j = i\n            start = pos\n            while not idx[j]:\n                idx[j] = pos\n                pos += 1\n                j = aa[j]\n            if idx[j] >= start:\n                n -= pos - idx[j]\n                res = res * (pow(2, pos - idx[j], MOD) - 2) % MOD\n    return res * pow(2, n, MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(-1, n + 1):",
      "code": "def count_non_confusing_flips(n, roads):\n    MOD = 1000000007\n    aa = [0] + roads\n    idx = [0] * (n + 1)\n    res = 1\n    pos = 1\n    for i in range(-1, n + 1):\n        if not idx[i]:\n            j = i\n            start = pos\n            while not idx[j]:\n                idx[j] = pos\n                pos += 1\n                j = aa[j]\n            if idx[j] >= start:\n                n -= pos - idx[j]\n                res = res * (pow(2, pos - idx[j], MOD) - 2) % MOD\n    return res * pow(2, n, MOD) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n - 1):",
      "code": "def count_non_confusing_flips(n, roads):\n    MOD = 1000000007\n    aa = [0] + roads\n    idx = [0] * (n + 1)\n    res = 1\n    pos = 1\n    for i in range(1, n - 1):\n        if not idx[i]:\n            j = i\n            start = pos\n            while not idx[j]:\n                idx[j] = pos\n                pos += 1\n                j = aa[j]\n            if idx[j] >= start:\n                n -= pos - idx[j]\n                res = res * (pow(2, pos - idx[j], MOD) - 2) % MOD\n    return res * pow(2, n, MOD) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n * 1):",
      "code": "def count_non_confusing_flips(n, roads):\n    MOD = 1000000007\n    aa = [0] + roads\n    idx = [0] * (n + 1)\n    res = 1\n    pos = 1\n    for i in range(1, n * 1):\n        if not idx[i]:\n            j = i\n            start = pos\n            while not idx[j]:\n                idx[j] = pos\n                pos += 1\n                j = aa[j]\n            if idx[j] >= start:\n                n -= pos - idx[j]\n                res = res * (pow(2, pos - idx[j], MOD) - 2) % MOD\n    return res * pow(2, n, MOD) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return res * pow(2, n, MOD) % MOD",
      "mutated_line": "return res / pow(2, n, MOD) % MOD",
      "code": "def count_non_confusing_flips(n, roads):\n    MOD = 1000000007\n    aa = [0] + roads\n    idx = [0] * (n + 1)\n    res = 1\n    pos = 1\n    for i in range(1, n + 1):\n        if not idx[i]:\n            j = i\n            start = pos\n            while not idx[j]:\n                idx[j] = pos\n                pos += 1\n                j = aa[j]\n            if idx[j] >= start:\n                n -= pos - idx[j]\n                res = res * (pow(2, pos - idx[j], MOD) - 2) % MOD\n    return res / pow(2, n, MOD) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return res * pow(2, n, MOD) % MOD",
      "mutated_line": "return (res + pow(2, n, MOD)) % MOD",
      "code": "def count_non_confusing_flips(n, roads):\n    MOD = 1000000007\n    aa = [0] + roads\n    idx = [0] * (n + 1)\n    res = 1\n    pos = 1\n    for i in range(1, n + 1):\n        if not idx[i]:\n            j = i\n            start = pos\n            while not idx[j]:\n                idx[j] = pos\n                pos += 1\n                j = aa[j]\n            if idx[j] >= start:\n                n -= pos - idx[j]\n                res = res * (pow(2, pos - idx[j], MOD) - 2) % MOD\n    return (res + pow(2, n, MOD)) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return res * pow(2, n, MOD) % MOD",
      "mutated_line": "return res ** pow(2, n, MOD) % MOD",
      "code": "def count_non_confusing_flips(n, roads):\n    MOD = 1000000007\n    aa = [0] + roads\n    idx = [0] * (n + 1)\n    res = 1\n    pos = 1\n    for i in range(1, n + 1):\n        if not idx[i]:\n            j = i\n            start = pos\n            while not idx[j]:\n                idx[j] = pos\n                pos += 1\n                j = aa[j]\n            if idx[j] >= start:\n                n -= pos - idx[j]\n                res = res * (pow(2, pos - idx[j], MOD) - 2) % MOD\n    return res ** pow(2, n, MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "aa = [0] + roads",
      "mutated_line": "aa = [1] + roads",
      "code": "def count_non_confusing_flips(n, roads):\n    MOD = 1000000007\n    aa = [1] + roads\n    idx = [0] * (n + 1)\n    res = 1\n    pos = 1\n    for i in range(1, n + 1):\n        if not idx[i]:\n            j = i\n            start = pos\n            while not idx[j]:\n                idx[j] = pos\n                pos += 1\n                j = aa[j]\n            if idx[j] >= start:\n                n -= pos - idx[j]\n                res = res * (pow(2, pos - idx[j], MOD) - 2) % MOD\n    return res * pow(2, n, MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "aa = [0] + roads",
      "mutated_line": "aa = [-1] + roads",
      "code": "def count_non_confusing_flips(n, roads):\n    MOD = 1000000007\n    aa = [-1] + roads\n    idx = [0] * (n + 1)\n    res = 1\n    pos = 1\n    for i in range(1, n + 1):\n        if not idx[i]:\n            j = i\n            start = pos\n            while not idx[j]:\n                idx[j] = pos\n                pos += 1\n                j = aa[j]\n            if idx[j] >= start:\n                n -= pos - idx[j]\n                res = res * (pow(2, pos - idx[j], MOD) - 2) % MOD\n    return res * pow(2, n, MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "aa = [0] + roads",
      "mutated_line": "aa = [1] + roads",
      "code": "def count_non_confusing_flips(n, roads):\n    MOD = 1000000007\n    aa = [1] + roads\n    idx = [0] * (n + 1)\n    res = 1\n    pos = 1\n    for i in range(1, n + 1):\n        if not idx[i]:\n            j = i\n            start = pos\n            while not idx[j]:\n                idx[j] = pos\n                pos += 1\n                j = aa[j]\n            if idx[j] >= start:\n                n -= pos - idx[j]\n                res = res * (pow(2, pos - idx[j], MOD) - 2) % MOD\n    return res * pow(2, n, MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "idx = [0] * (n + 1)",
      "mutated_line": "idx = [1] * (n + 1)",
      "code": "def count_non_confusing_flips(n, roads):\n    MOD = 1000000007\n    aa = [0] + roads\n    idx = [1] * (n + 1)\n    res = 1\n    pos = 1\n    for i in range(1, n + 1):\n        if not idx[i]:\n            j = i\n            start = pos\n            while not idx[j]:\n                idx[j] = pos\n                pos += 1\n                j = aa[j]\n            if idx[j] >= start:\n                n -= pos - idx[j]\n                res = res * (pow(2, pos - idx[j], MOD) - 2) % MOD\n    return res * pow(2, n, MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "idx = [0] * (n + 1)",
      "mutated_line": "idx = [-1] * (n + 1)",
      "code": "def count_non_confusing_flips(n, roads):\n    MOD = 1000000007\n    aa = [0] + roads\n    idx = [-1] * (n + 1)\n    res = 1\n    pos = 1\n    for i in range(1, n + 1):\n        if not idx[i]:\n            j = i\n            start = pos\n            while not idx[j]:\n                idx[j] = pos\n                pos += 1\n                j = aa[j]\n            if idx[j] >= start:\n                n -= pos - idx[j]\n                res = res * (pow(2, pos - idx[j], MOD) - 2) % MOD\n    return res * pow(2, n, MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "idx = [0] * (n + 1)",
      "mutated_line": "idx = [1] * (n + 1)",
      "code": "def count_non_confusing_flips(n, roads):\n    MOD = 1000000007\n    aa = [0] + roads\n    idx = [1] * (n + 1)\n    res = 1\n    pos = 1\n    for i in range(1, n + 1):\n        if not idx[i]:\n            j = i\n            start = pos\n            while not idx[j]:\n                idx[j] = pos\n                pos += 1\n                j = aa[j]\n            if idx[j] >= start:\n                n -= pos - idx[j]\n                res = res * (pow(2, pos - idx[j], MOD) - 2) % MOD\n    return res * pow(2, n, MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "idx = [0] * (n + 1)",
      "mutated_line": "idx = [0] * (n + 2)",
      "code": "def count_non_confusing_flips(n, roads):\n    MOD = 1000000007\n    aa = [0] + roads\n    idx = [0] * (n + 2)\n    res = 1\n    pos = 1\n    for i in range(1, n + 1):\n        if not idx[i]:\n            j = i\n            start = pos\n            while not idx[j]:\n                idx[j] = pos\n                pos += 1\n                j = aa[j]\n            if idx[j] >= start:\n                n -= pos - idx[j]\n                res = res * (pow(2, pos - idx[j], MOD) - 2) % MOD\n    return res * pow(2, n, MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "idx = [0] * (n + 1)",
      "mutated_line": "idx = [0] * (n + 0)",
      "code": "def count_non_confusing_flips(n, roads):\n    MOD = 1000000007\n    aa = [0] + roads\n    idx = [0] * (n + 0)\n    res = 1\n    pos = 1\n    for i in range(1, n + 1):\n        if not idx[i]:\n            j = i\n            start = pos\n            while not idx[j]:\n                idx[j] = pos\n                pos += 1\n                j = aa[j]\n            if idx[j] >= start:\n                n -= pos - idx[j]\n                res = res * (pow(2, pos - idx[j], MOD) - 2) % MOD\n    return res * pow(2, n, MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "idx = [0] * (n + 1)",
      "mutated_line": "idx = [0] * (n + 0)",
      "code": "def count_non_confusing_flips(n, roads):\n    MOD = 1000000007\n    aa = [0] + roads\n    idx = [0] * (n + 0)\n    res = 1\n    pos = 1\n    for i in range(1, n + 1):\n        if not idx[i]:\n            j = i\n            start = pos\n            while not idx[j]:\n                idx[j] = pos\n                pos += 1\n                j = aa[j]\n            if idx[j] >= start:\n                n -= pos - idx[j]\n                res = res * (pow(2, pos - idx[j], MOD) - 2) % MOD\n    return res * pow(2, n, MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "idx = [0] * (n + 1)",
      "mutated_line": "idx = [0] * (n + -1)",
      "code": "def count_non_confusing_flips(n, roads):\n    MOD = 1000000007\n    aa = [0] + roads\n    idx = [0] * (n + -1)\n    res = 1\n    pos = 1\n    for i in range(1, n + 1):\n        if not idx[i]:\n            j = i\n            start = pos\n            while not idx[j]:\n                idx[j] = pos\n                pos += 1\n                j = aa[j]\n            if idx[j] >= start:\n                n -= pos - idx[j]\n                res = res * (pow(2, pos - idx[j], MOD) - 2) % MOD\n    return res * pow(2, n, MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + 2):",
      "code": "def count_non_confusing_flips(n, roads):\n    MOD = 1000000007\n    aa = [0] + roads\n    idx = [0] * (n + 1)\n    res = 1\n    pos = 1\n    for i in range(1, n + 2):\n        if not idx[i]:\n            j = i\n            start = pos\n            while not idx[j]:\n                idx[j] = pos\n                pos += 1\n                j = aa[j]\n            if idx[j] >= start:\n                n -= pos - idx[j]\n                res = res * (pow(2, pos - idx[j], MOD) - 2) % MOD\n    return res * pow(2, n, MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + 0):",
      "code": "def count_non_confusing_flips(n, roads):\n    MOD = 1000000007\n    aa = [0] + roads\n    idx = [0] * (n + 1)\n    res = 1\n    pos = 1\n    for i in range(1, n + 0):\n        if not idx[i]:\n            j = i\n            start = pos\n            while not idx[j]:\n                idx[j] = pos\n                pos += 1\n                j = aa[j]\n            if idx[j] >= start:\n                n -= pos - idx[j]\n                res = res * (pow(2, pos - idx[j], MOD) - 2) % MOD\n    return res * pow(2, n, MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + 0):",
      "code": "def count_non_confusing_flips(n, roads):\n    MOD = 1000000007\n    aa = [0] + roads\n    idx = [0] * (n + 1)\n    res = 1\n    pos = 1\n    for i in range(1, n + 0):\n        if not idx[i]:\n            j = i\n            start = pos\n            while not idx[j]:\n                idx[j] = pos\n                pos += 1\n                j = aa[j]\n            if idx[j] >= start:\n                n -= pos - idx[j]\n                res = res * (pow(2, pos - idx[j], MOD) - 2) % MOD\n    return res * pow(2, n, MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + -1):",
      "code": "def count_non_confusing_flips(n, roads):\n    MOD = 1000000007\n    aa = [0] + roads\n    idx = [0] * (n + 1)\n    res = 1\n    pos = 1\n    for i in range(1, n + -1):\n        if not idx[i]:\n            j = i\n            start = pos\n            while not idx[j]:\n                idx[j] = pos\n                pos += 1\n                j = aa[j]\n            if idx[j] >= start:\n                n -= pos - idx[j]\n                res = res * (pow(2, pos - idx[j], MOD) - 2) % MOD\n    return res * pow(2, n, MOD) % MOD"
    },
    {
      "operator": "ASR",
      "lineno": 14,
      "original_line": "pos += 1",
      "mutated_line": "pos -= 1",
      "code": "def count_non_confusing_flips(n, roads):\n    MOD = 1000000007\n    aa = [0] + roads\n    idx = [0] * (n + 1)\n    res = 1\n    pos = 1\n    for i in range(1, n + 1):\n        if not idx[i]:\n            j = i\n            start = pos\n            while not idx[j]:\n                idx[j] = pos\n                pos -= 1\n                j = aa[j]\n            if idx[j] >= start:\n                n -= pos - idx[j]\n                res = res * (pow(2, pos - idx[j], MOD) - 2) % MOD\n    return res * pow(2, n, MOD) % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if idx[j] >= start:",
      "mutated_line": "if idx[j] > start:",
      "code": "def count_non_confusing_flips(n, roads):\n    MOD = 1000000007\n    aa = [0] + roads\n    idx = [0] * (n + 1)\n    res = 1\n    pos = 1\n    for i in range(1, n + 1):\n        if not idx[i]:\n            j = i\n            start = pos\n            while not idx[j]:\n                idx[j] = pos\n                pos += 1\n                j = aa[j]\n            if idx[j] > start:\n                n -= pos - idx[j]\n                res = res * (pow(2, pos - idx[j], MOD) - 2) % MOD\n    return res * pow(2, n, MOD) % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if idx[j] >= start:",
      "mutated_line": "if idx[j] < start:",
      "code": "def count_non_confusing_flips(n, roads):\n    MOD = 1000000007\n    aa = [0] + roads\n    idx = [0] * (n + 1)\n    res = 1\n    pos = 1\n    for i in range(1, n + 1):\n        if not idx[i]:\n            j = i\n            start = pos\n            while not idx[j]:\n                idx[j] = pos\n                pos += 1\n                j = aa[j]\n            if idx[j] < start:\n                n -= pos - idx[j]\n                res = res * (pow(2, pos - idx[j], MOD) - 2) % MOD\n    return res * pow(2, n, MOD) % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if idx[j] >= start:",
      "mutated_line": "if idx[j] == start:",
      "code": "def count_non_confusing_flips(n, roads):\n    MOD = 1000000007\n    aa = [0] + roads\n    idx = [0] * (n + 1)\n    res = 1\n    pos = 1\n    for i in range(1, n + 1):\n        if not idx[i]:\n            j = i\n            start = pos\n            while not idx[j]:\n                idx[j] = pos\n                pos += 1\n                j = aa[j]\n            if idx[j] == start:\n                n -= pos - idx[j]\n                res = res * (pow(2, pos - idx[j], MOD) - 2) % MOD\n    return res * pow(2, n, MOD) % MOD"
    },
    {
      "operator": "ASR",
      "lineno": 17,
      "original_line": "n -= pos - idx[j]",
      "mutated_line": "n += pos - idx[j]",
      "code": "def count_non_confusing_flips(n, roads):\n    MOD = 1000000007\n    aa = [0] + roads\n    idx = [0] * (n + 1)\n    res = 1\n    pos = 1\n    for i in range(1, n + 1):\n        if not idx[i]:\n            j = i\n            start = pos\n            while not idx[j]:\n                idx[j] = pos\n                pos += 1\n                j = aa[j]\n            if idx[j] >= start:\n                n += pos - idx[j]\n                res = res * (pow(2, pos - idx[j], MOD) - 2) % MOD\n    return res * pow(2, n, MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "pos += 1",
      "mutated_line": "pos += 2",
      "code": "def count_non_confusing_flips(n, roads):\n    MOD = 1000000007\n    aa = [0] + roads\n    idx = [0] * (n + 1)\n    res = 1\n    pos = 1\n    for i in range(1, n + 1):\n        if not idx[i]:\n            j = i\n            start = pos\n            while not idx[j]:\n                idx[j] = pos\n                pos += 2\n                j = aa[j]\n            if idx[j] >= start:\n                n -= pos - idx[j]\n                res = res * (pow(2, pos - idx[j], MOD) - 2) % MOD\n    return res * pow(2, n, MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "pos += 1",
      "mutated_line": "pos += 0",
      "code": "def count_non_confusing_flips(n, roads):\n    MOD = 1000000007\n    aa = [0] + roads\n    idx = [0] * (n + 1)\n    res = 1\n    pos = 1\n    for i in range(1, n + 1):\n        if not idx[i]:\n            j = i\n            start = pos\n            while not idx[j]:\n                idx[j] = pos\n                pos += 0\n                j = aa[j]\n            if idx[j] >= start:\n                n -= pos - idx[j]\n                res = res * (pow(2, pos - idx[j], MOD) - 2) % MOD\n    return res * pow(2, n, MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "pos += 1",
      "mutated_line": "pos += 0",
      "code": "def count_non_confusing_flips(n, roads):\n    MOD = 1000000007\n    aa = [0] + roads\n    idx = [0] * (n + 1)\n    res = 1\n    pos = 1\n    for i in range(1, n + 1):\n        if not idx[i]:\n            j = i\n            start = pos\n            while not idx[j]:\n                idx[j] = pos\n                pos += 0\n                j = aa[j]\n            if idx[j] >= start:\n                n -= pos - idx[j]\n                res = res * (pow(2, pos - idx[j], MOD) - 2) % MOD\n    return res * pow(2, n, MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "pos += 1",
      "mutated_line": "pos += -1",
      "code": "def count_non_confusing_flips(n, roads):\n    MOD = 1000000007\n    aa = [0] + roads\n    idx = [0] * (n + 1)\n    res = 1\n    pos = 1\n    for i in range(1, n + 1):\n        if not idx[i]:\n            j = i\n            start = pos\n            while not idx[j]:\n                idx[j] = pos\n                pos += -1\n                j = aa[j]\n            if idx[j] >= start:\n                n -= pos - idx[j]\n                res = res * (pow(2, pos - idx[j], MOD) - 2) % MOD\n    return res * pow(2, n, MOD) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "n -= pos - idx[j]",
      "mutated_line": "n -= pos + idx[j]",
      "code": "def count_non_confusing_flips(n, roads):\n    MOD = 1000000007\n    aa = [0] + roads\n    idx = [0] * (n + 1)\n    res = 1\n    pos = 1\n    for i in range(1, n + 1):\n        if not idx[i]:\n            j = i\n            start = pos\n            while not idx[j]:\n                idx[j] = pos\n                pos += 1\n                j = aa[j]\n            if idx[j] >= start:\n                n -= pos + idx[j]\n                res = res * (pow(2, pos - idx[j], MOD) - 2) % MOD\n    return res * pow(2, n, MOD) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "n -= pos - idx[j]",
      "mutated_line": "n -= pos * idx[j]",
      "code": "def count_non_confusing_flips(n, roads):\n    MOD = 1000000007\n    aa = [0] + roads\n    idx = [0] * (n + 1)\n    res = 1\n    pos = 1\n    for i in range(1, n + 1):\n        if not idx[i]:\n            j = i\n            start = pos\n            while not idx[j]:\n                idx[j] = pos\n                pos += 1\n                j = aa[j]\n            if idx[j] >= start:\n                n -= pos * idx[j]\n                res = res * (pow(2, pos - idx[j], MOD) - 2) % MOD\n    return res * pow(2, n, MOD) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "res = res * (pow(2, pos - idx[j], MOD) - 2) % MOD",
      "mutated_line": "res = res * (pow(2, pos - idx[j], MOD) - 2) * MOD",
      "code": "def count_non_confusing_flips(n, roads):\n    MOD = 1000000007\n    aa = [0] + roads\n    idx = [0] * (n + 1)\n    res = 1\n    pos = 1\n    for i in range(1, n + 1):\n        if not idx[i]:\n            j = i\n            start = pos\n            while not idx[j]:\n                idx[j] = pos\n                pos += 1\n                j = aa[j]\n            if idx[j] >= start:\n                n -= pos - idx[j]\n                res = res * (pow(2, pos - idx[j], MOD) - 2) * MOD\n    return res * pow(2, n, MOD) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "res = res * (pow(2, pos - idx[j], MOD) - 2) % MOD",
      "mutated_line": "res = res * (pow(2, pos - idx[j], MOD) - 2) + MOD",
      "code": "def count_non_confusing_flips(n, roads):\n    MOD = 1000000007\n    aa = [0] + roads\n    idx = [0] * (n + 1)\n    res = 1\n    pos = 1\n    for i in range(1, n + 1):\n        if not idx[i]:\n            j = i\n            start = pos\n            while not idx[j]:\n                idx[j] = pos\n                pos += 1\n                j = aa[j]\n            if idx[j] >= start:\n                n -= pos - idx[j]\n                res = res * (pow(2, pos - idx[j], MOD) - 2) + MOD\n    return res * pow(2, n, MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return res * pow(2, n, MOD) % MOD",
      "mutated_line": "return res * pow(3, n, MOD) % MOD",
      "code": "def count_non_confusing_flips(n, roads):\n    MOD = 1000000007\n    aa = [0] + roads\n    idx = [0] * (n + 1)\n    res = 1\n    pos = 1\n    for i in range(1, n + 1):\n        if not idx[i]:\n            j = i\n            start = pos\n            while not idx[j]:\n                idx[j] = pos\n                pos += 1\n                j = aa[j]\n            if idx[j] >= start:\n                n -= pos - idx[j]\n                res = res * (pow(2, pos - idx[j], MOD) - 2) % MOD\n    return res * pow(3, n, MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return res * pow(2, n, MOD) % MOD",
      "mutated_line": "return res * pow(1, n, MOD) % MOD",
      "code": "def count_non_confusing_flips(n, roads):\n    MOD = 1000000007\n    aa = [0] + roads\n    idx = [0] * (n + 1)\n    res = 1\n    pos = 1\n    for i in range(1, n + 1):\n        if not idx[i]:\n            j = i\n            start = pos\n            while not idx[j]:\n                idx[j] = pos\n                pos += 1\n                j = aa[j]\n            if idx[j] >= start:\n                n -= pos - idx[j]\n                res = res * (pow(2, pos - idx[j], MOD) - 2) % MOD\n    return res * pow(1, n, MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return res * pow(2, n, MOD) % MOD",
      "mutated_line": "return res * pow(0, n, MOD) % MOD",
      "code": "def count_non_confusing_flips(n, roads):\n    MOD = 1000000007\n    aa = [0] + roads\n    idx = [0] * (n + 1)\n    res = 1\n    pos = 1\n    for i in range(1, n + 1):\n        if not idx[i]:\n            j = i\n            start = pos\n            while not idx[j]:\n                idx[j] = pos\n                pos += 1\n                j = aa[j]\n            if idx[j] >= start:\n                n -= pos - idx[j]\n                res = res * (pow(2, pos - idx[j], MOD) - 2) % MOD\n    return res * pow(0, n, MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return res * pow(2, n, MOD) % MOD",
      "mutated_line": "return res * pow(1, n, MOD) % MOD",
      "code": "def count_non_confusing_flips(n, roads):\n    MOD = 1000000007\n    aa = [0] + roads\n    idx = [0] * (n + 1)\n    res = 1\n    pos = 1\n    for i in range(1, n + 1):\n        if not idx[i]:\n            j = i\n            start = pos\n            while not idx[j]:\n                idx[j] = pos\n                pos += 1\n                j = aa[j]\n            if idx[j] >= start:\n                n -= pos - idx[j]\n                res = res * (pow(2, pos - idx[j], MOD) - 2) % MOD\n    return res * pow(1, n, MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return res * pow(2, n, MOD) % MOD",
      "mutated_line": "return res * pow(-2, n, MOD) % MOD",
      "code": "def count_non_confusing_flips(n, roads):\n    MOD = 1000000007\n    aa = [0] + roads\n    idx = [0] * (n + 1)\n    res = 1\n    pos = 1\n    for i in range(1, n + 1):\n        if not idx[i]:\n            j = i\n            start = pos\n            while not idx[j]:\n                idx[j] = pos\n                pos += 1\n                j = aa[j]\n            if idx[j] >= start:\n                n -= pos - idx[j]\n                res = res * (pow(2, pos - idx[j], MOD) - 2) % MOD\n    return res * pow(-2, n, MOD) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "res = res * (pow(2, pos - idx[j], MOD) - 2) % MOD",
      "mutated_line": "res = res / (pow(2, pos - idx[j], MOD) - 2) % MOD",
      "code": "def count_non_confusing_flips(n, roads):\n    MOD = 1000000007\n    aa = [0] + roads\n    idx = [0] * (n + 1)\n    res = 1\n    pos = 1\n    for i in range(1, n + 1):\n        if not idx[i]:\n            j = i\n            start = pos\n            while not idx[j]:\n                idx[j] = pos\n                pos += 1\n                j = aa[j]\n            if idx[j] >= start:\n                n -= pos - idx[j]\n                res = res / (pow(2, pos - idx[j], MOD) - 2) % MOD\n    return res * pow(2, n, MOD) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "res = res * (pow(2, pos - idx[j], MOD) - 2) % MOD",
      "mutated_line": "res = (res + (pow(2, pos - idx[j], MOD) - 2)) % MOD",
      "code": "def count_non_confusing_flips(n, roads):\n    MOD = 1000000007\n    aa = [0] + roads\n    idx = [0] * (n + 1)\n    res = 1\n    pos = 1\n    for i in range(1, n + 1):\n        if not idx[i]:\n            j = i\n            start = pos\n            while not idx[j]:\n                idx[j] = pos\n                pos += 1\n                j = aa[j]\n            if idx[j] >= start:\n                n -= pos - idx[j]\n                res = (res + (pow(2, pos - idx[j], MOD) - 2)) % MOD\n    return res * pow(2, n, MOD) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "res = res * (pow(2, pos - idx[j], MOD) - 2) % MOD",
      "mutated_line": "res = res ** (pow(2, pos - idx[j], MOD) - 2) % MOD",
      "code": "def count_non_confusing_flips(n, roads):\n    MOD = 1000000007\n    aa = [0] + roads\n    idx = [0] * (n + 1)\n    res = 1\n    pos = 1\n    for i in range(1, n + 1):\n        if not idx[i]:\n            j = i\n            start = pos\n            while not idx[j]:\n                idx[j] = pos\n                pos += 1\n                j = aa[j]\n            if idx[j] >= start:\n                n -= pos - idx[j]\n                res = res ** (pow(2, pos - idx[j], MOD) - 2) % MOD\n    return res * pow(2, n, MOD) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "res = res * (pow(2, pos - idx[j], MOD) - 2) % MOD",
      "mutated_line": "res = res * (pow(2, pos - idx[j], MOD) + 2) % MOD",
      "code": "def count_non_confusing_flips(n, roads):\n    MOD = 1000000007\n    aa = [0] + roads\n    idx = [0] * (n + 1)\n    res = 1\n    pos = 1\n    for i in range(1, n + 1):\n        if not idx[i]:\n            j = i\n            start = pos\n            while not idx[j]:\n                idx[j] = pos\n                pos += 1\n                j = aa[j]\n            if idx[j] >= start:\n                n -= pos - idx[j]\n                res = res * (pow(2, pos - idx[j], MOD) + 2) % MOD\n    return res * pow(2, n, MOD) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "res = res * (pow(2, pos - idx[j], MOD) - 2) % MOD",
      "mutated_line": "res = res * (pow(2, pos - idx[j], MOD) * 2) % MOD",
      "code": "def count_non_confusing_flips(n, roads):\n    MOD = 1000000007\n    aa = [0] + roads\n    idx = [0] * (n + 1)\n    res = 1\n    pos = 1\n    for i in range(1, n + 1):\n        if not idx[i]:\n            j = i\n            start = pos\n            while not idx[j]:\n                idx[j] = pos\n                pos += 1\n                j = aa[j]\n            if idx[j] >= start:\n                n -= pos - idx[j]\n                res = res * (pow(2, pos - idx[j], MOD) * 2) % MOD\n    return res * pow(2, n, MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "res = res * (pow(2, pos - idx[j], MOD) - 2) % MOD",
      "mutated_line": "res = res * (pow(2, pos - idx[j], MOD) - 3) % MOD",
      "code": "def count_non_confusing_flips(n, roads):\n    MOD = 1000000007\n    aa = [0] + roads\n    idx = [0] * (n + 1)\n    res = 1\n    pos = 1\n    for i in range(1, n + 1):\n        if not idx[i]:\n            j = i\n            start = pos\n            while not idx[j]:\n                idx[j] = pos\n                pos += 1\n                j = aa[j]\n            if idx[j] >= start:\n                n -= pos - idx[j]\n                res = res * (pow(2, pos - idx[j], MOD) - 3) % MOD\n    return res * pow(2, n, MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "res = res * (pow(2, pos - idx[j], MOD) - 2) % MOD",
      "mutated_line": "res = res * (pow(2, pos - idx[j], MOD) - 1) % MOD",
      "code": "def count_non_confusing_flips(n, roads):\n    MOD = 1000000007\n    aa = [0] + roads\n    idx = [0] * (n + 1)\n    res = 1\n    pos = 1\n    for i in range(1, n + 1):\n        if not idx[i]:\n            j = i\n            start = pos\n            while not idx[j]:\n                idx[j] = pos\n                pos += 1\n                j = aa[j]\n            if idx[j] >= start:\n                n -= pos - idx[j]\n                res = res * (pow(2, pos - idx[j], MOD) - 1) % MOD\n    return res * pow(2, n, MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "res = res * (pow(2, pos - idx[j], MOD) - 2) % MOD",
      "mutated_line": "res = res * (pow(2, pos - idx[j], MOD) - 0) % MOD",
      "code": "def count_non_confusing_flips(n, roads):\n    MOD = 1000000007\n    aa = [0] + roads\n    idx = [0] * (n + 1)\n    res = 1\n    pos = 1\n    for i in range(1, n + 1):\n        if not idx[i]:\n            j = i\n            start = pos\n            while not idx[j]:\n                idx[j] = pos\n                pos += 1\n                j = aa[j]\n            if idx[j] >= start:\n                n -= pos - idx[j]\n                res = res * (pow(2, pos - idx[j], MOD) - 0) % MOD\n    return res * pow(2, n, MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "res = res * (pow(2, pos - idx[j], MOD) - 2) % MOD",
      "mutated_line": "res = res * (pow(2, pos - idx[j], MOD) - 1) % MOD",
      "code": "def count_non_confusing_flips(n, roads):\n    MOD = 1000000007\n    aa = [0] + roads\n    idx = [0] * (n + 1)\n    res = 1\n    pos = 1\n    for i in range(1, n + 1):\n        if not idx[i]:\n            j = i\n            start = pos\n            while not idx[j]:\n                idx[j] = pos\n                pos += 1\n                j = aa[j]\n            if idx[j] >= start:\n                n -= pos - idx[j]\n                res = res * (pow(2, pos - idx[j], MOD) - 1) % MOD\n    return res * pow(2, n, MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "res = res * (pow(2, pos - idx[j], MOD) - 2) % MOD",
      "mutated_line": "res = res * (pow(2, pos - idx[j], MOD) - -2) % MOD",
      "code": "def count_non_confusing_flips(n, roads):\n    MOD = 1000000007\n    aa = [0] + roads\n    idx = [0] * (n + 1)\n    res = 1\n    pos = 1\n    for i in range(1, n + 1):\n        if not idx[i]:\n            j = i\n            start = pos\n            while not idx[j]:\n                idx[j] = pos\n                pos += 1\n                j = aa[j]\n            if idx[j] >= start:\n                n -= pos - idx[j]\n                res = res * (pow(2, pos - idx[j], MOD) - -2) % MOD\n    return res * pow(2, n, MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "res = res * (pow(2, pos - idx[j], MOD) - 2) % MOD",
      "mutated_line": "res = res * (pow(3, pos - idx[j], MOD) - 2) % MOD",
      "code": "def count_non_confusing_flips(n, roads):\n    MOD = 1000000007\n    aa = [0] + roads\n    idx = [0] * (n + 1)\n    res = 1\n    pos = 1\n    for i in range(1, n + 1):\n        if not idx[i]:\n            j = i\n            start = pos\n            while not idx[j]:\n                idx[j] = pos\n                pos += 1\n                j = aa[j]\n            if idx[j] >= start:\n                n -= pos - idx[j]\n                res = res * (pow(3, pos - idx[j], MOD) - 2) % MOD\n    return res * pow(2, n, MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "res = res * (pow(2, pos - idx[j], MOD) - 2) % MOD",
      "mutated_line": "res = res * (pow(1, pos - idx[j], MOD) - 2) % MOD",
      "code": "def count_non_confusing_flips(n, roads):\n    MOD = 1000000007\n    aa = [0] + roads\n    idx = [0] * (n + 1)\n    res = 1\n    pos = 1\n    for i in range(1, n + 1):\n        if not idx[i]:\n            j = i\n            start = pos\n            while not idx[j]:\n                idx[j] = pos\n                pos += 1\n                j = aa[j]\n            if idx[j] >= start:\n                n -= pos - idx[j]\n                res = res * (pow(1, pos - idx[j], MOD) - 2) % MOD\n    return res * pow(2, n, MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "res = res * (pow(2, pos - idx[j], MOD) - 2) % MOD",
      "mutated_line": "res = res * (pow(0, pos - idx[j], MOD) - 2) % MOD",
      "code": "def count_non_confusing_flips(n, roads):\n    MOD = 1000000007\n    aa = [0] + roads\n    idx = [0] * (n + 1)\n    res = 1\n    pos = 1\n    for i in range(1, n + 1):\n        if not idx[i]:\n            j = i\n            start = pos\n            while not idx[j]:\n                idx[j] = pos\n                pos += 1\n                j = aa[j]\n            if idx[j] >= start:\n                n -= pos - idx[j]\n                res = res * (pow(0, pos - idx[j], MOD) - 2) % MOD\n    return res * pow(2, n, MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "res = res * (pow(2, pos - idx[j], MOD) - 2) % MOD",
      "mutated_line": "res = res * (pow(1, pos - idx[j], MOD) - 2) % MOD",
      "code": "def count_non_confusing_flips(n, roads):\n    MOD = 1000000007\n    aa = [0] + roads\n    idx = [0] * (n + 1)\n    res = 1\n    pos = 1\n    for i in range(1, n + 1):\n        if not idx[i]:\n            j = i\n            start = pos\n            while not idx[j]:\n                idx[j] = pos\n                pos += 1\n                j = aa[j]\n            if idx[j] >= start:\n                n -= pos - idx[j]\n                res = res * (pow(1, pos - idx[j], MOD) - 2) % MOD\n    return res * pow(2, n, MOD) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "res = res * (pow(2, pos - idx[j], MOD) - 2) % MOD",
      "mutated_line": "res = res * (pow(-2, pos - idx[j], MOD) - 2) % MOD",
      "code": "def count_non_confusing_flips(n, roads):\n    MOD = 1000000007\n    aa = [0] + roads\n    idx = [0] * (n + 1)\n    res = 1\n    pos = 1\n    for i in range(1, n + 1):\n        if not idx[i]:\n            j = i\n            start = pos\n            while not idx[j]:\n                idx[j] = pos\n                pos += 1\n                j = aa[j]\n            if idx[j] >= start:\n                n -= pos - idx[j]\n                res = res * (pow(-2, pos - idx[j], MOD) - 2) % MOD\n    return res * pow(2, n, MOD) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "res = res * (pow(2, pos - idx[j], MOD) - 2) % MOD",
      "mutated_line": "res = res * (pow(2, pos + idx[j], MOD) - 2) % MOD",
      "code": "def count_non_confusing_flips(n, roads):\n    MOD = 1000000007\n    aa = [0] + roads\n    idx = [0] * (n + 1)\n    res = 1\n    pos = 1\n    for i in range(1, n + 1):\n        if not idx[i]:\n            j = i\n            start = pos\n            while not idx[j]:\n                idx[j] = pos\n                pos += 1\n                j = aa[j]\n            if idx[j] >= start:\n                n -= pos - idx[j]\n                res = res * (pow(2, pos + idx[j], MOD) - 2) % MOD\n    return res * pow(2, n, MOD) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "res = res * (pow(2, pos - idx[j], MOD) - 2) % MOD",
      "mutated_line": "res = res * (pow(2, pos * idx[j], MOD) - 2) % MOD",
      "code": "def count_non_confusing_flips(n, roads):\n    MOD = 1000000007\n    aa = [0] + roads\n    idx = [0] * (n + 1)\n    res = 1\n    pos = 1\n    for i in range(1, n + 1):\n        if not idx[i]:\n            j = i\n            start = pos\n            while not idx[j]:\n                idx[j] = pos\n                pos += 1\n                j = aa[j]\n            if idx[j] >= start:\n                n -= pos - idx[j]\n                res = res * (pow(2, pos * idx[j], MOD) - 2) % MOD\n    return res * pow(2, n, MOD) % MOD"
    }
  ]
}