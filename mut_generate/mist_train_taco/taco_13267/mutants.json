{
  "task_id": "taco_13267",
  "entry_point": "max_product_of_connected_components",
  "mutant_count": 132,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "H = [0] * n",
      "mutated_line": "H = [0] / n",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] / n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "H = [0] * n",
      "mutated_line": "H = [0] + n",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] + n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "H = [0] * n",
      "mutated_line": "H = [0] ** n",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] ** n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "F = [0] * n",
      "mutated_line": "F = [0] / n",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] / n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "F = [0] * n",
      "mutated_line": "F = [0] + n",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] + n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "F = [0] * n",
      "mutated_line": "F = [0] ** n",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] ** n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "sz = 0",
      "mutated_line": "sz = 1",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 1\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "sz = 0",
      "mutated_line": "sz = -1",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = -1\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "sz = 0",
      "mutated_line": "sz = 1",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 1\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "order = [0] * n",
      "mutated_line": "order = [0] / n",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] / n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "order = [0] * n",
      "mutated_line": "order = [0] + n",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] + n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "order = [0] * n",
      "mutated_line": "order = [0] ** n",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] ** n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "pi = [-1] * n",
      "mutated_line": "pi = [-1] / n",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] / n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "pi = [-1] * n",
      "mutated_line": "pi = [-1] + n",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] + n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "pi = [-1] * n",
      "mutated_line": "pi = [-1] ** n",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] ** n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "ASR",
      "lineno": 19,
      "original_line": "sz += 1",
      "mutated_line": "sz -= 1",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz -= 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "T1 = [0] * n",
      "mutated_line": "T1 = [0] / n",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] / n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "T1 = [0] * n",
      "mutated_line": "T1 = [0] + n",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] + n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "T1 = [0] * n",
      "mutated_line": "T1 = [0] ** n",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] ** n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "T2 = [0] * n",
      "mutated_line": "T2 = [0] / n",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] / n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "T2 = [0] * n",
      "mutated_line": "T2 = [0] + n",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] + n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "T2 = [0] * n",
      "mutated_line": "T2 = [0] ** n",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] ** n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "T3 = [0] * n",
      "mutated_line": "T3 = [0] / n",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] / n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "T3 = [0] * n",
      "mutated_line": "T3 = [0] + n",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] + n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "T3 = [0] * n",
      "mutated_line": "T3 = [0] ** n",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] ** n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "UOI",
      "lineno": 12,
      "original_line": "def dfs(u, p=-1):",
      "mutated_line": "def dfs(u, p=+1):",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=+1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "sz += 1",
      "mutated_line": "sz += 2",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 2\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "sz += 1",
      "mutated_line": "sz += 0",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 0\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "sz += 1",
      "mutated_line": "sz += 0",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 0\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "sz += 1",
      "mutated_line": "sz += -1",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += -1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "UOI",
      "lineno": 25,
      "original_line": "def solve(u, p=-1):",
      "mutated_line": "def solve(u, p=+1):",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=+1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "F[u] = 1",
      "mutated_line": "F[u] = 2",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 2\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "F[u] = 1",
      "mutated_line": "F[u] = 0",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 0\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "F[u] = 1",
      "mutated_line": "F[u] = 0",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 0\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "F[u] = 1",
      "mutated_line": "F[u] = -1",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = -1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "pd = 1",
      "mutated_line": "pd = 2",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 2\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "pd = 1",
      "mutated_line": "pd = 0",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 0\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "pd = 1",
      "mutated_line": "pd = 0",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 0\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "pd = 1",
      "mutated_line": "pd = -1",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = -1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "s = 0",
      "mutated_line": "s = 1",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 1\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "s = 0",
      "mutated_line": "s = -1",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = -1\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "s = 0",
      "mutated_line": "s = 1",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 1\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "ASR",
      "lineno": 38,
      "original_line": "pd *= x",
      "mutated_line": "pd /= x",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd /= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "ASR",
      "lineno": 39,
      "original_line": "s += 1",
      "mutated_line": "s -= 1",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s -= 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "dfs(0)",
      "mutated_line": "dfs(1)",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(1)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "dfs(0)",
      "mutated_line": "dfs(-1)",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(-1)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "dfs(0)",
      "mutated_line": "dfs(1)",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(1)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "CRP",
      "lineno": 59,
      "original_line": "return H[0]",
      "mutated_line": "return H[1]",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[1]"
    },
    {
      "operator": "CRP",
      "lineno": 59,
      "original_line": "return H[0]",
      "mutated_line": "return H[-1]",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 59,
      "original_line": "return H[0]",
      "mutated_line": "return H[1]",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[1]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "H = [0] * n",
      "mutated_line": "H = [1] * n",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [1] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "H = [0] * n",
      "mutated_line": "H = [-1] * n",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [-1] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "H = [0] * n",
      "mutated_line": "H = [1] * n",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [1] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "F = [0] * n",
      "mutated_line": "F = [1] * n",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [1] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "F = [0] * n",
      "mutated_line": "F = [-1] * n",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [-1] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "F = [0] * n",
      "mutated_line": "F = [1] * n",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [1] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "order = [0] * n",
      "mutated_line": "order = [1] * n",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [1] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "order = [0] * n",
      "mutated_line": "order = [-1] * n",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [-1] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "order = [0] * n",
      "mutated_line": "order = [1] * n",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [1] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "UOI",
      "lineno": 10,
      "original_line": "pi = [-1] * n",
      "mutated_line": "pi = [+1] * n",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [+1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "def dfs(u, p=-1):",
      "mutated_line": "def dfs(u, p=-2):",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-2):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "def dfs(u, p=-1):",
      "mutated_line": "def dfs(u, p=-0):",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-0):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "def dfs(u, p=-1):",
      "mutated_line": "def dfs(u, p=-0):",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-0):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "def dfs(u, p=-1):",
      "mutated_line": "def dfs(u, p=--1):",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=--1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if v != p:",
      "mutated_line": "if v == p:",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v == p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "T1 = [0] * n",
      "mutated_line": "T1 = [1] * n",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [1] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "T1 = [0] * n",
      "mutated_line": "T1 = [-1] * n",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [-1] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "T1 = [0] * n",
      "mutated_line": "T1 = [1] * n",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [1] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "T2 = [0] * n",
      "mutated_line": "T2 = [1] * n",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [1] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "T2 = [0] * n",
      "mutated_line": "T2 = [-1] * n",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [-1] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "T2 = [0] * n",
      "mutated_line": "T2 = [1] * n",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [1] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "T3 = [0] * n",
      "mutated_line": "T3 = [1] * n",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [1] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "T3 = [0] * n",
      "mutated_line": "T3 = [-1] * n",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [-1] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "T3 = [0] * n",
      "mutated_line": "T3 = [1] * n",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [1] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "def solve(u, p=-1):",
      "mutated_line": "def solve(u, p=-2):",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-2):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "def solve(u, p=-1):",
      "mutated_line": "def solve(u, p=-0):",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-0):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "def solve(u, p=-1):",
      "mutated_line": "def solve(u, p=-0):",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-0):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "def solve(u, p=-1):",
      "mutated_line": "def solve(u, p=--1):",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=--1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if v != p:",
      "mutated_line": "if v == p:",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v == p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "ASR",
      "lineno": 30,
      "original_line": "F[u] *= H[v]",
      "mutated_line": "F[u] /= H[v]",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] /= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "s += 1",
      "mutated_line": "s += 2",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 2\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "s += 1",
      "mutated_line": "s += 0",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 0\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "s += 1",
      "mutated_line": "s += 0",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 0\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "s += 1",
      "mutated_line": "s += -1",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += -1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if v != p:",
      "mutated_line": "if v == p:",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v == p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "pi = [-1] * n",
      "mutated_line": "pi = [-2] * n",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-2] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "pi = [-1] * n",
      "mutated_line": "pi = [-0] * n",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-0] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "pi = [-1] * n",
      "mutated_line": "pi = [-0] * n",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-0] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "pi = [-1] * n",
      "mutated_line": "pi = [--1] * n",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [--1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "ans = max(ans, int(pd * F[u]) * (s + 1))",
      "mutated_line": "ans = max(ans, int(pd * F[u]) / (s + 1))",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) / (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "ans = max(ans, int(pd * F[u]) * (s + 1))",
      "mutated_line": "ans = max(ans, int(pd * F[u]) + (s + 1))",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) + (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "ans = max(ans, int(pd * F[u]) * (s + 1))",
      "mutated_line": "ans = max(ans, int(pd * F[u]) ** (s + 1))",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) ** (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "pd = 1",
      "mutated_line": "pd = 2",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 2\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "pd = 1",
      "mutated_line": "pd = 0",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 0\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "pd = 1",
      "mutated_line": "pd = 0",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 0\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "pd = 1",
      "mutated_line": "pd = -1",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = -1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "s = 0",
      "mutated_line": "s = 1",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 1\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "s = 0",
      "mutated_line": "s = -1",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = -1\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "s = 0",
      "mutated_line": "s = 1",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 1\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "ASR",
      "lineno": 46,
      "original_line": "pd *= x",
      "mutated_line": "pd /= x",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd /= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "ASR",
      "lineno": 47,
      "original_line": "s += 1",
      "mutated_line": "s -= 1",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s -= 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "ans = max(ans, int(pd * F[u]) * (s + 1))",
      "mutated_line": "ans = max(ans, int(pd * F[u]) * (s - 1))",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s - 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "ans = max(ans, int(pd * F[u]) * (s + 1))",
      "mutated_line": "ans = max(ans, int(pd * F[u]) * (s * 1))",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s * 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "s += 1",
      "mutated_line": "s += 2",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 2\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "s += 1",
      "mutated_line": "s += 0",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 0\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "s += 1",
      "mutated_line": "s += 0",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 0\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "s += 1",
      "mutated_line": "s += -1",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += -1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "ans = max(ans, int(pd * F[u]) * (s + 1))",
      "mutated_line": "ans = max(ans, int(pd / F[u]) * (s + 1))",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd / F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "ans = max(ans, int(pd * F[u]) * (s + 1))",
      "mutated_line": "ans = max(ans, int(pd + F[u]) * (s + 1))",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd + F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "ans = max(ans, int(pd * F[u]) * (s + 1))",
      "mutated_line": "ans = max(ans, int(pd ** F[u]) * (s + 1))",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd ** F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "ans = max(ans, int(pd * F[u]) * (s + 1))",
      "mutated_line": "ans = max(ans, int(pd * F[u]) * (s + 2))",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 2))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "ans = max(ans, int(pd * F[u]) * (s + 1))",
      "mutated_line": "ans = max(ans, int(pd * F[u]) * (s + 0))",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 0))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "ans = max(ans, int(pd * F[u]) * (s + 1))",
      "mutated_line": "ans = max(ans, int(pd * F[u]) * (s + 0))",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 0))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "ans = max(ans, int(pd * F[u]) * (s + 1))",
      "mutated_line": "ans = max(ans, int(pd * F[u]) * (s + -1))",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + -1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))",
      "mutated_line": "ans = max(ans, int(pd * F[u] * F[v]) // H[v] / (s + 2))",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] / (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))",
      "mutated_line": "ans = max(ans, int(pd * F[u] * F[v]) // H[v] + (s + 2))",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] + (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))",
      "mutated_line": "ans = max(ans, (int(pd * F[u] * F[v]) // H[v]) ** (s + 2))",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, (int(pd * F[u] * F[v]) // H[v]) ** (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))",
      "mutated_line": "ans = max(ans, int(pd * F[u] * F[v]) / H[v] * (s + 2))",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) / H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))",
      "mutated_line": "ans = max(ans, int(pd * F[u] * F[v]) * H[v] * (s + 2))",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) * H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))",
      "mutated_line": "ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s - 2))",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s - 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))",
      "mutated_line": "ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s * 2))",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s * 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))",
      "mutated_line": "ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 3))",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 3))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))",
      "mutated_line": "ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 1))",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 1))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))",
      "mutated_line": "ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 0))",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 0))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))",
      "mutated_line": "ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 1))",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 1))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))",
      "mutated_line": "ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + -2))",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + -2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))",
      "mutated_line": "ans = max(ans, int(pd * F[u] / F[v]) // H[v] * (s + 2))",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] / F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))",
      "mutated_line": "ans = max(ans, int(pd * F[u] + F[v]) // H[v] * (s + 2))",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd * F[u] + F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))",
      "mutated_line": "ans = max(ans, int((pd * F[u]) ** F[v]) // H[v] * (s + 2))",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int((pd * F[u]) ** F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))",
      "mutated_line": "ans = max(ans, int(pd / F[u] * F[v]) // H[v] * (s + 2))",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd / F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))",
      "mutated_line": "ans = max(ans, int((pd + F[u]) * F[v]) // H[v] * (s + 2))",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int((pd + F[u]) * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "ans = max(ans, int(pd * F[u] * F[v]) // H[v] * (s + 2))",
      "mutated_line": "ans = max(ans, int(pd ** F[u] * F[v]) // H[v] * (s + 2))",
      "code": "def max_product_of_connected_components(n, edges):\n    from fractions import Fraction\n    adj = [list() for _ in range(n)]\n    H = [0] * n\n    F = [0] * n\n    FoH = [list() for _ in range(n)]\n    sz = 0\n    order = [0] * n\n    pi = [-1] * n\n\n    def dfs(u, p=-1):\n        nonlocal pi, order, sz\n        pi[u] = p\n        for v in adj[u]:\n            if v != p:\n                dfs(v, u)\n        order[sz] = u\n        sz += 1\n    T1 = [0] * n\n    T2 = [0] * n\n    T3 = [0] * n\n\n    def solve(u, p=-1):\n        nonlocal H, F, FoH\n        F[u] = 1\n        for v in adj[u]:\n            if v != p:\n                F[u] *= H[v]\n                FoH[u].append(Fraction(F[v], H[v]))\n        ans = F[u]\n        FoH[u].sort()\n        FoH[u].reverse()\n        pd = 1\n        s = 0\n        for x in FoH[u]:\n            pd *= x\n            s += 1\n            ans = max(ans, int(pd * F[u]) * (s + 1))\n        for v in adj[u]:\n            if v != p:\n                pd = 1\n                s = 0\n                for x in FoH[v]:\n                    pd *= x\n                    s += 1\n                    ans = max(ans, int(pd ** F[u] * F[v]) // H[v] * (s + 2))\n        H[u] = ans\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0)\n    for x in order:\n        solve(x, pi[x])\n    return H[0]"
    }
  ]
}