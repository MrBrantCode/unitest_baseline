{
  "task_id": "taco_15761",
  "entry_point": "reorder_coins",
  "mutant_count": 168,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "A = [0] + coins  # Adjusting the list to be 1-indexed",
      "mutated_line": "A = [0] - coins",
      "code": "def reorder_coins(n, coins):\n    A = [0] - coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "A = [0] + coins  # Adjusting the list to be 1-indexed",
      "mutated_line": "A = [0] * coins",
      "code": "def reorder_coins(n, coins):\n    A = [0] * coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "seen = [0] * (n + 1)",
      "mutated_line": "seen = [0] / (n + 1)",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] / (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "seen = [0] * (n + 1)",
      "mutated_line": "seen = [0] + (n + 1)",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] + (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "seen = [0] * (n + 1)",
      "mutated_line": "seen = [0] ** (n + 1)",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] ** (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "if len(cycles) % 2:",
      "mutated_line": "if len(cycles) * 2:",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) * 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "if len(cycles) % 2:",
      "mutated_line": "if len(cycles) + 2:",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) + 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "seen = [0] * (n + 1)",
      "mutated_line": "seen = [0] * (n - 1)",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n - 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "seen = [0] * (n + 1)",
      "mutated_line": "seen = [0] * (n * 1)",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n * 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(2, n + 1):",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(2, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(0, n + 1):",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(0, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(0, n + 1):",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(0, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(-1, n + 1):",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(-1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n - 1):",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n - 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n * 1):",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n * 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if len(cur) > 1:",
      "mutated_line": "if len(cur) >= 1:",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) >= 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if len(cur) > 1:",
      "mutated_line": "if len(cur) <= 1:",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) <= 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if len(cur) > 1:",
      "mutated_line": "if len(cur) != 1:",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) != 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(1, len(cycles), 2):",
      "mutated_line": "(X, Y) = (cycles[i - 1], cycles[i])",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(2, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(1, len(cycles), 2):",
      "mutated_line": "(X, Y) = (cycles[i - 1], cycles[i])",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(0, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(1, len(cycles), 2):",
      "mutated_line": "(X, Y) = (cycles[i - 1], cycles[i])",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(0, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(1, len(cycles), 2):",
      "mutated_line": "(X, Y) = (cycles[i - 1], cycles[i])",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(-1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(1, len(cycles), 2):",
      "mutated_line": "(X, Y) = (cycles[i - 1], cycles[i])",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 3):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(1, len(cycles), 2):",
      "mutated_line": "(X, Y) = (cycles[i - 1], cycles[i])",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 1):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(1, len(cycles), 2):",
      "mutated_line": "(X, Y) = (cycles[i - 1], cycles[i])",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 0):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(1, len(cycles), 2):",
      "mutated_line": "(X, Y) = (cycles[i - 1], cycles[i])",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 1):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(1, len(cycles), 2):",
      "mutated_line": "(X, Y) = (cycles[i - 1], cycles[i])",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), -2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if len(cycles) % 2:",
      "mutated_line": "if len(cycles) % 3:",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 3:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if len(cycles) % 2:",
      "mutated_line": "if len(cycles) % 1:",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 1:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if len(cycles) % 2:",
      "mutated_line": "if len(cycles) % 0:",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 0:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if len(cycles) % 2:",
      "mutated_line": "if len(cycles) % 1:",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 1:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if len(cycles) % 2:",
      "mutated_line": "if len(cycles) % -2:",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % -2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if len(X) > 2:",
      "mutated_line": "if len(X) >= 2:",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) >= 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if len(X) > 2:",
      "mutated_line": "if len(X) <= 2:",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) <= 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if len(X) > 2:",
      "mutated_line": "if len(X) != 2:",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) != 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "A = [0] + coins  # Adjusting the list to be 1-indexed",
      "mutated_line": "A = [1] + coins",
      "code": "def reorder_coins(n, coins):\n    A = [1] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "A = [0] + coins  # Adjusting the list to be 1-indexed",
      "mutated_line": "A = [-1] + coins",
      "code": "def reorder_coins(n, coins):\n    A = [-1] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "A = [0] + coins  # Adjusting the list to be 1-indexed",
      "mutated_line": "A = [1] + coins",
      "code": "def reorder_coins(n, coins):\n    A = [1] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "seen = [0] * (n + 1)",
      "mutated_line": "seen = [1] * (n + 1)",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [1] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "seen = [0] * (n + 1)",
      "mutated_line": "seen = [-1] * (n + 1)",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [-1] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "seen = [0] * (n + 1)",
      "mutated_line": "seen = [1] * (n + 1)",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [1] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "seen = [0] * (n + 1)",
      "mutated_line": "seen = [0] * (n + 2)",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 2)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "seen = [0] * (n + 1)",
      "mutated_line": "seen = [0] * (n + 0)",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 0)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "seen = [0] * (n + 1)",
      "mutated_line": "seen = [0] * (n + 0)",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 0)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "seen = [0] * (n + 1)",
      "mutated_line": "seen = [0] * (n + -1)",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + -1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + 2):",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 2):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + 0):",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 0):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + 0):",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 0):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + -1):",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + -1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "seen[j] = 1",
      "mutated_line": "seen[j] = 2",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 2\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "seen[j] = 1",
      "mutated_line": "seen[j] = 0",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 0\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "seen[j] = 1",
      "mutated_line": "seen[j] = 0",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 0\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "seen[j] = 1",
      "mutated_line": "seen[j] = -1",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = -1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if len(cur) > 1:",
      "mutated_line": "if len(cur) > 2:",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 2:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if len(cur) > 1:",
      "mutated_line": "if len(cur) > 0:",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 0:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if len(cur) > 1:",
      "mutated_line": "if len(cur) > 0:",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 0:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if len(cur) > 1:",
      "mutated_line": "if len(cur) > -1:",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > -1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "UOI",
      "lineno": 35,
      "original_line": "X = cycles[-1]",
      "mutated_line": "X = cycles[+1]",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[+1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if len(X) > 2:",
      "mutated_line": "if len(X) > 3:",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 3:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if len(X) > 2:",
      "mutated_line": "if len(X) > 1:",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 1:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if len(X) > 2:",
      "mutated_line": "if len(X) > 0:",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 0:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if len(X) > 2:",
      "mutated_line": "if len(X) > 1:",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 1:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if len(X) > 2:",
      "mutated_line": "if len(X) > -2:",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > -2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "X, Y = cycles[i - 1], cycles[i]",
      "mutated_line": "(X, Y) = (cycles[i + 1], cycles[i])",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i + 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "X, Y = cycles[i - 1], cycles[i]",
      "mutated_line": "(X, Y) = (cycles[i * 1], cycles[i])",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i * 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "swap(X[0], Y[0])",
      "mutated_line": "swap(X[1], Y[0])",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[1], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "swap(X[0], Y[0])",
      "mutated_line": "swap(X[-1], Y[0])",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[-1], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "swap(X[0], Y[0])",
      "mutated_line": "swap(X[1], Y[0])",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[1], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "swap(X[0], Y[0])",
      "mutated_line": "swap(X[0], Y[1])",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[1])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "swap(X[0], Y[0])",
      "mutated_line": "swap(X[0], Y[-1])",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[-1])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "swap(X[0], Y[0])",
      "mutated_line": "swap(X[0], Y[1])",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[1])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for x in X[1:]:",
      "mutated_line": "for x in X[2:]:",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[2:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for x in X[1:]:",
      "mutated_line": "for x in X[0:]:",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[0:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for x in X[1:]:",
      "mutated_line": "for x in X[0:]:",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[0:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for x in X[1:]:",
      "mutated_line": "for x in X[-1:]:",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[-1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for y in Y[1:]:",
      "mutated_line": "for y in Y[2:]:",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[2:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for y in Y[1:]:",
      "mutated_line": "for y in Y[0:]:",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[0:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for y in Y[1:]:",
      "mutated_line": "for y in Y[0:]:",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[0:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for y in Y[1:]:",
      "mutated_line": "for y in Y[-1:]:",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[-1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "swap(X[0], Y[0])",
      "mutated_line": "swap(X[1], Y[0])",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[1], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "swap(X[0], Y[0])",
      "mutated_line": "swap(X[-1], Y[0])",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[-1], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "swap(X[0], Y[0])",
      "mutated_line": "swap(X[1], Y[0])",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[1], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "swap(X[0], Y[0])",
      "mutated_line": "swap(X[0], Y[1])",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[1])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "swap(X[0], Y[0])",
      "mutated_line": "swap(X[0], Y[-1])",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[-1])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "swap(X[0], Y[0])",
      "mutated_line": "swap(X[0], Y[1])",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[1])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "X = cycles[-1]",
      "mutated_line": "X = cycles[-2]",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-2]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "X = cycles[-1]",
      "mutated_line": "X = cycles[-0]",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-0]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "X = cycles[-1]",
      "mutated_line": "X = cycles[-0]",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-0]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "X = cycles[-1]",
      "mutated_line": "X = cycles[--1]",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[--1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(2, n + 1):",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(2, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(0, n + 1):",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(0, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(0, n + 1):",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(0, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(-1, n + 1):",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(-1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n - 1):",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n - 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n * 1):",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n * 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "LCR",
      "lineno": 45,
      "original_line": "if i != X[0] and i != X[1]:",
      "mutated_line": "if i != X[0] or i != X[1]:",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] or i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "X, Y = cycles[i - 1], cycles[i]",
      "mutated_line": "(X, Y) = (cycles[i - 2], cycles[i])",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 2], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "X, Y = cycles[i - 1], cycles[i]",
      "mutated_line": "(X, Y) = (cycles[i - 0], cycles[i])",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 0], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "X, Y = cycles[i - 1], cycles[i]",
      "mutated_line": "(X, Y) = (cycles[i - 0], cycles[i])",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 0], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "X, Y = cycles[i - 1], cycles[i]",
      "mutated_line": "(X, Y) = (cycles[i - -1], cycles[i])",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - -1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "swap(x, Y[0])",
      "mutated_line": "swap(x, Y[1])",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[1])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "swap(x, Y[0])",
      "mutated_line": "swap(x, Y[-1])",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[-1])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "swap(x, Y[0])",
      "mutated_line": "swap(x, Y[1])",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[1])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "swap(y, X[0])",
      "mutated_line": "swap(y, X[1])",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[1])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "swap(y, X[0])",
      "mutated_line": "swap(y, X[-1])",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[-1])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "swap(y, X[0])",
      "mutated_line": "swap(y, X[1])",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[1])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "UOI",
      "lineno": 37,
      "original_line": "for x in X[:-2]:",
      "mutated_line": "for x in X[:+2]:",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:+2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "swap(X[0], X[-2])",
      "mutated_line": "swap(X[1], X[-2])",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[1], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "swap(X[0], X[-2])",
      "mutated_line": "swap(X[-1], X[-2])",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[-1], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "swap(X[0], X[-2])",
      "mutated_line": "swap(X[1], X[-2])",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[1], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "UOI",
      "lineno": 39,
      "original_line": "swap(X[0], X[-2])",
      "mutated_line": "swap(X[0], X[+2])",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[+2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "UOI",
      "lineno": 40,
      "original_line": "swap(X[-2], X[-1])",
      "mutated_line": "swap(X[+2], X[-1])",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[+2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "UOI",
      "lineno": 40,
      "original_line": "swap(X[-2], X[-1])",
      "mutated_line": "swap(X[-2], X[+1])",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[+1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "swap(X[0], X[-1])",
      "mutated_line": "swap(X[1], X[-1])",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[1], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "swap(X[0], X[-1])",
      "mutated_line": "swap(X[-1], X[-1])",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[-1], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "swap(X[0], X[-1])",
      "mutated_line": "swap(X[1], X[-1])",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[1], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "UOI",
      "lineno": 41,
      "original_line": "swap(X[0], X[-1])",
      "mutated_line": "swap(X[0], X[+1])",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[+1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + 2):",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 2):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + 0):",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 0):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + 0):",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 0):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + -1):",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + -1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "if i != X[0] and i != X[1]:",
      "mutated_line": "if i == X[0] and i != X[1]:",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i == X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "if i != X[0] and i != X[1]:",
      "mutated_line": "if i != X[0] and i == X[1]:",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i == X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "swap(i, X[0])",
      "mutated_line": "swap(i, X[1])",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[1])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "swap(i, X[0])",
      "mutated_line": "swap(i, X[-1])",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[-1])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "swap(i, X[0])",
      "mutated_line": "swap(i, X[1])",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[1])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "swap(i, X[1])",
      "mutated_line": "swap(i, X[2])",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[2])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "swap(i, X[1])",
      "mutated_line": "",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[0])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "swap(i, X[1])",
      "mutated_line": "",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[0])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "swap(i, X[1])",
      "mutated_line": "swap(i, X[-1])",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[-1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "swap(i, X[0])",
      "mutated_line": "swap(i, X[1])",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[1])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "swap(i, X[0])",
      "mutated_line": "swap(i, X[-1])",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[-1])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "swap(i, X[0])",
      "mutated_line": "swap(i, X[1])",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[1])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for x in X[:-2]:",
      "mutated_line": "for x in X[:-3]:",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-3]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for x in X[:-2]:",
      "mutated_line": "for x in X[:-1]:",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-1]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for x in X[:-2]:",
      "mutated_line": "for x in X[:-0]:",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-0]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for x in X[:-2]:",
      "mutated_line": "for x in X[:-1]:",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-1]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for x in X[:-2]:",
      "mutated_line": "for x in X[:--2]:",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:--2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "UOI",
      "lineno": 38,
      "original_line": "swap(x, X[-1])",
      "mutated_line": "swap(x, X[+1])",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[+1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "swap(X[0], X[-2])",
      "mutated_line": "swap(X[0], X[-3])",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-3])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "swap(X[0], X[-2])",
      "mutated_line": "swap(X[0], X[-1])",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-1])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "swap(X[0], X[-2])",
      "mutated_line": "swap(X[0], X[-0])",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-0])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "swap(X[0], X[-2])",
      "mutated_line": "swap(X[0], X[-1])",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-1])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "swap(X[0], X[-2])",
      "mutated_line": "swap(X[0], X[--2])",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[--2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "swap(X[-2], X[-1])",
      "mutated_line": "swap(X[-3], X[-1])",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-3], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "swap(X[-2], X[-1])",
      "mutated_line": "swap(X[-1], X[-1])",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-1], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "swap(X[-2], X[-1])",
      "mutated_line": "swap(X[-0], X[-1])",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-0], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "swap(X[-2], X[-1])",
      "mutated_line": "swap(X[-1], X[-1])",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-1], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "swap(X[-2], X[-1])",
      "mutated_line": "swap(X[--2], X[-1])",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[--2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "swap(X[-2], X[-1])",
      "mutated_line": "swap(X[-2], X[-2])",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-2])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "swap(X[-2], X[-1])",
      "mutated_line": "swap(X[-2], X[-0])",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-0])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "swap(X[-2], X[-1])",
      "mutated_line": "swap(X[-2], X[-0])",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-0])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "swap(X[-2], X[-1])",
      "mutated_line": "swap(X[-2], X[--1])",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[--1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "swap(X[0], X[-1])",
      "mutated_line": "swap(X[0], X[-2])",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-2])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "swap(X[0], X[-1])",
      "mutated_line": "swap(X[0], X[-0])",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-0])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "swap(X[0], X[-1])",
      "mutated_line": "swap(X[0], X[-0])",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-0])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "swap(X[0], X[-1])",
      "mutated_line": "swap(X[0], X[--1])",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[--1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "swap(x, X[-1])",
      "mutated_line": "swap(x, X[-2])",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-2])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "swap(x, X[-1])",
      "mutated_line": "swap(x, X[-0])",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-0])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "swap(x, X[-1])",
      "mutated_line": "swap(x, X[-0])",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-0])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "swap(x, X[-1])",
      "mutated_line": "swap(x, X[--1])",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[--1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if i != X[0] and i != X[1]:",
      "mutated_line": "if i != X[1] and i != X[1]:",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[1] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if i != X[0] and i != X[1]:",
      "mutated_line": "if i != X[-1] and i != X[1]:",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[-1] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if i != X[0] and i != X[1]:",
      "mutated_line": "if i != X[1] and i != X[1]:",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[1] and i != X[1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if i != X[0] and i != X[1]:",
      "mutated_line": "if i != X[0] and i != X[2]:",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[2]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if i != X[0] and i != X[1]:",
      "mutated_line": "if i != X[0] and i != X[0]:",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[0]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if i != X[0] and i != X[1]:",
      "mutated_line": "if i != X[0] and i != X[0]:",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[0]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if i != X[0] and i != X[1]:",
      "mutated_line": "if i != X[0] and i != X[-1]:",
      "code": "def reorder_coins(n, coins):\n    A = [0] + coins\n    seen = [0] * (n + 1)\n    cycles = []\n    ans = []\n    for i in range(1, n + 1):\n        cur = []\n        j = i\n        while not seen[j]:\n            cur.append(j)\n            seen[j] = 1\n            j = A[j]\n        if len(cur) > 1:\n            cycles.append(cur)\n\n    def swap(x, y):\n        (A[x], A[y]) = (A[y], A[x])\n        ans.append((x, y))\n    for i in range(1, len(cycles), 2):\n        (X, Y) = (cycles[i - 1], cycles[i])\n        swap(X[0], Y[0])\n        for x in X[1:]:\n            swap(x, Y[0])\n        for y in Y[1:]:\n            swap(y, X[0])\n        swap(X[0], Y[0])\n    if len(cycles) % 2:\n        X = cycles[-1]\n        if len(X) > 2:\n            for x in X[:-2]:\n                swap(x, X[-1])\n            swap(X[0], X[-2])\n            swap(X[-2], X[-1])\n            swap(X[0], X[-1])\n        else:\n            Y = []\n            for i in range(1, n + 1):\n                if i != X[0] and i != X[-1]:\n                    break\n            swap(i, X[0])\n            swap(i, X[1])\n            swap(i, X[0])\n    operations_count = len(ans)\n    return (operations_count, ans)"
    }
  ]
}