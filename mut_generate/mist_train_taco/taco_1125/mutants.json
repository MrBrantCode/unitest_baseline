{
  "task_id": "taco_1125",
  "entry_point": "reconstruct_graph",
  "mutant_count": 109,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "reconstructed_edges = [[]] * m",
      "mutated_line": "reconstructed_edges = [[]] / m",
      "code": "from heapq import heapify, heappop, heappush\n\ndef reconstruct_graph(n, m, edges):\n    sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][1])\n    reconstructed_edges = [[]] / m\n    c = []\n    for i in range(1, n - 1):\n        c.append((i + 2, i))\n    heapify(c)\n    j = 1\n    for i in sorted_indices:\n        if edges[i][1] == 1:\n            reconstructed_edges[i] = [j, j + 1]\n            j += 1\n        else:\n            if not c:\n                return -1\n            z = heappop(c)\n            if j < z[0]:\n                return -1\n            else:\n                reconstructed_edges[i] = [z[1], z[0]]\n                if z[0] + 1 <= n:\n                    heappush(c, (z[0] + 1, z[1]))\n    return reconstructed_edges"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "reconstructed_edges = [[]] * m",
      "mutated_line": "reconstructed_edges = [[]] + m",
      "code": "from heapq import heapify, heappop, heappush\n\ndef reconstruct_graph(n, m, edges):\n    sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][1])\n    reconstructed_edges = [[]] + m\n    c = []\n    for i in range(1, n - 1):\n        c.append((i + 2, i))\n    heapify(c)\n    j = 1\n    for i in sorted_indices:\n        if edges[i][1] == 1:\n            reconstructed_edges[i] = [j, j + 1]\n            j += 1\n        else:\n            if not c:\n                return -1\n            z = heappop(c)\n            if j < z[0]:\n                return -1\n            else:\n                reconstructed_edges[i] = [z[1], z[0]]\n                if z[0] + 1 <= n:\n                    heappush(c, (z[0] + 1, z[1]))\n    return reconstructed_edges"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "reconstructed_edges = [[]] * m",
      "mutated_line": "reconstructed_edges = [[]] ** m",
      "code": "from heapq import heapify, heappop, heappush\n\ndef reconstruct_graph(n, m, edges):\n    sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][1])\n    reconstructed_edges = [[]] ** m\n    c = []\n    for i in range(1, n - 1):\n        c.append((i + 2, i))\n    heapify(c)\n    j = 1\n    for i in sorted_indices:\n        if edges[i][1] == 1:\n            reconstructed_edges[i] = [j, j + 1]\n            j += 1\n        else:\n            if not c:\n                return -1\n            z = heappop(c)\n            if j < z[0]:\n                return -1\n            else:\n                reconstructed_edges[i] = [z[1], z[0]]\n                if z[0] + 1 <= n:\n                    heappush(c, (z[0] + 1, z[1]))\n    return reconstructed_edges"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "j = 1",
      "mutated_line": "j = 2",
      "code": "from heapq import heapify, heappop, heappush\n\ndef reconstruct_graph(n, m, edges):\n    sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][1])\n    reconstructed_edges = [[]] * m\n    c = []\n    for i in range(1, n - 1):\n        c.append((i + 2, i))\n    heapify(c)\n    j = 2\n    for i in sorted_indices:\n        if edges[i][1] == 1:\n            reconstructed_edges[i] = [j, j + 1]\n            j += 1\n        else:\n            if not c:\n                return -1\n            z = heappop(c)\n            if j < z[0]:\n                return -1\n            else:\n                reconstructed_edges[i] = [z[1], z[0]]\n                if z[0] + 1 <= n:\n                    heappush(c, (z[0] + 1, z[1]))\n    return reconstructed_edges"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "j = 1",
      "mutated_line": "j = 0",
      "code": "from heapq import heapify, heappop, heappush\n\ndef reconstruct_graph(n, m, edges):\n    sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][1])\n    reconstructed_edges = [[]] * m\n    c = []\n    for i in range(1, n - 1):\n        c.append((i + 2, i))\n    heapify(c)\n    j = 0\n    for i in sorted_indices:\n        if edges[i][1] == 1:\n            reconstructed_edges[i] = [j, j + 1]\n            j += 1\n        else:\n            if not c:\n                return -1\n            z = heappop(c)\n            if j < z[0]:\n                return -1\n            else:\n                reconstructed_edges[i] = [z[1], z[0]]\n                if z[0] + 1 <= n:\n                    heappush(c, (z[0] + 1, z[1]))\n    return reconstructed_edges"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "j = 1",
      "mutated_line": "j = 0",
      "code": "from heapq import heapify, heappop, heappush\n\ndef reconstruct_graph(n, m, edges):\n    sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][1])\n    reconstructed_edges = [[]] * m\n    c = []\n    for i in range(1, n - 1):\n        c.append((i + 2, i))\n    heapify(c)\n    j = 0\n    for i in sorted_indices:\n        if edges[i][1] == 1:\n            reconstructed_edges[i] = [j, j + 1]\n            j += 1\n        else:\n            if not c:\n                return -1\n            z = heappop(c)\n            if j < z[0]:\n                return -1\n            else:\n                reconstructed_edges[i] = [z[1], z[0]]\n                if z[0] + 1 <= n:\n                    heappush(c, (z[0] + 1, z[1]))\n    return reconstructed_edges"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "j = 1",
      "mutated_line": "j = -1",
      "code": "from heapq import heapify, heappop, heappush\n\ndef reconstruct_graph(n, m, edges):\n    sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][1])\n    reconstructed_edges = [[]] * m\n    c = []\n    for i in range(1, n - 1):\n        c.append((i + 2, i))\n    heapify(c)\n    j = -1\n    for i in sorted_indices:\n        if edges[i][1] == 1:\n            reconstructed_edges[i] = [j, j + 1]\n            j += 1\n        else:\n            if not c:\n                return -1\n            z = heappop(c)\n            if j < z[0]:\n                return -1\n            else:\n                reconstructed_edges[i] = [z[1], z[0]]\n                if z[0] + 1 <= n:\n                    heappush(c, (z[0] + 1, z[1]))\n    return reconstructed_edges"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for i in range(1, n - 1):",
      "mutated_line": "for i in range(2, n - 1):",
      "code": "from heapq import heapify, heappop, heappush\n\ndef reconstruct_graph(n, m, edges):\n    sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][1])\n    reconstructed_edges = [[]] * m\n    c = []\n    for i in range(2, n - 1):\n        c.append((i + 2, i))\n    heapify(c)\n    j = 1\n    for i in sorted_indices:\n        if edges[i][1] == 1:\n            reconstructed_edges[i] = [j, j + 1]\n            j += 1\n        else:\n            if not c:\n                return -1\n            z = heappop(c)\n            if j < z[0]:\n                return -1\n            else:\n                reconstructed_edges[i] = [z[1], z[0]]\n                if z[0] + 1 <= n:\n                    heappush(c, (z[0] + 1, z[1]))\n    return reconstructed_edges"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for i in range(1, n - 1):",
      "mutated_line": "for i in range(0, n - 1):",
      "code": "from heapq import heapify, heappop, heappush\n\ndef reconstruct_graph(n, m, edges):\n    sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][1])\n    reconstructed_edges = [[]] * m\n    c = []\n    for i in range(0, n - 1):\n        c.append((i + 2, i))\n    heapify(c)\n    j = 1\n    for i in sorted_indices:\n        if edges[i][1] == 1:\n            reconstructed_edges[i] = [j, j + 1]\n            j += 1\n        else:\n            if not c:\n                return -1\n            z = heappop(c)\n            if j < z[0]:\n                return -1\n            else:\n                reconstructed_edges[i] = [z[1], z[0]]\n                if z[0] + 1 <= n:\n                    heappush(c, (z[0] + 1, z[1]))\n    return reconstructed_edges"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for i in range(1, n - 1):",
      "mutated_line": "for i in range(0, n - 1):",
      "code": "from heapq import heapify, heappop, heappush\n\ndef reconstruct_graph(n, m, edges):\n    sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][1])\n    reconstructed_edges = [[]] * m\n    c = []\n    for i in range(0, n - 1):\n        c.append((i + 2, i))\n    heapify(c)\n    j = 1\n    for i in sorted_indices:\n        if edges[i][1] == 1:\n            reconstructed_edges[i] = [j, j + 1]\n            j += 1\n        else:\n            if not c:\n                return -1\n            z = heappop(c)\n            if j < z[0]:\n                return -1\n            else:\n                reconstructed_edges[i] = [z[1], z[0]]\n                if z[0] + 1 <= n:\n                    heappush(c, (z[0] + 1, z[1]))\n    return reconstructed_edges"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for i in range(1, n - 1):",
      "mutated_line": "for i in range(-1, n - 1):",
      "code": "from heapq import heapify, heappop, heappush\n\ndef reconstruct_graph(n, m, edges):\n    sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][1])\n    reconstructed_edges = [[]] * m\n    c = []\n    for i in range(-1, n - 1):\n        c.append((i + 2, i))\n    heapify(c)\n    j = 1\n    for i in sorted_indices:\n        if edges[i][1] == 1:\n            reconstructed_edges[i] = [j, j + 1]\n            j += 1\n        else:\n            if not c:\n                return -1\n            z = heappop(c)\n            if j < z[0]:\n                return -1\n            else:\n                reconstructed_edges[i] = [z[1], z[0]]\n                if z[0] + 1 <= n:\n                    heappush(c, (z[0] + 1, z[1]))\n    return reconstructed_edges"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "for i in range(1, n - 1):",
      "mutated_line": "for i in range(1, n + 1):",
      "code": "from heapq import heapify, heappop, heappush\n\ndef reconstruct_graph(n, m, edges):\n    sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][1])\n    reconstructed_edges = [[]] * m\n    c = []\n    for i in range(1, n + 1):\n        c.append((i + 2, i))\n    heapify(c)\n    j = 1\n    for i in sorted_indices:\n        if edges[i][1] == 1:\n            reconstructed_edges[i] = [j, j + 1]\n            j += 1\n        else:\n            if not c:\n                return -1\n            z = heappop(c)\n            if j < z[0]:\n                return -1\n            else:\n                reconstructed_edges[i] = [z[1], z[0]]\n                if z[0] + 1 <= n:\n                    heappush(c, (z[0] + 1, z[1]))\n    return reconstructed_edges"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "for i in range(1, n - 1):",
      "mutated_line": "for i in range(1, n * 1):",
      "code": "from heapq import heapify, heappop, heappush\n\ndef reconstruct_graph(n, m, edges):\n    sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][1])\n    reconstructed_edges = [[]] * m\n    c = []\n    for i in range(1, n * 1):\n        c.append((i + 2, i))\n    heapify(c)\n    j = 1\n    for i in sorted_indices:\n        if edges[i][1] == 1:\n            reconstructed_edges[i] = [j, j + 1]\n            j += 1\n        else:\n            if not c:\n                return -1\n            z = heappop(c)\n            if j < z[0]:\n                return -1\n            else:\n                reconstructed_edges[i] = [z[1], z[0]]\n                if z[0] + 1 <= n:\n                    heappush(c, (z[0] + 1, z[1]))\n    return reconstructed_edges"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if edges[i][1] == 1:",
      "mutated_line": "if edges[i][1] != 1:",
      "code": "from heapq import heapify, heappop, heappush\n\ndef reconstruct_graph(n, m, edges):\n    sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][1])\n    reconstructed_edges = [[]] * m\n    c = []\n    for i in range(1, n - 1):\n        c.append((i + 2, i))\n    heapify(c)\n    j = 1\n    for i in sorted_indices:\n        if edges[i][1] != 1:\n            reconstructed_edges[i] = [j, j + 1]\n            j += 1\n        else:\n            if not c:\n                return -1\n            z = heappop(c)\n            if j < z[0]:\n                return -1\n            else:\n                reconstructed_edges[i] = [z[1], z[0]]\n                if z[0] + 1 <= n:\n                    heappush(c, (z[0] + 1, z[1]))\n    return reconstructed_edges"
    },
    {
      "operator": "ASR",
      "lineno": 23,
      "original_line": "j += 1",
      "mutated_line": "j -= 1",
      "code": "from heapq import heapify, heappop, heappush\n\ndef reconstruct_graph(n, m, edges):\n    sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][1])\n    reconstructed_edges = [[]] * m\n    c = []\n    for i in range(1, n - 1):\n        c.append((i + 2, i))\n    heapify(c)\n    j = 1\n    for i in sorted_indices:\n        if edges[i][1] == 1:\n            reconstructed_edges[i] = [j, j + 1]\n            j -= 1\n        else:\n            if not c:\n                return -1\n            z = heappop(c)\n            if j < z[0]:\n                return -1\n            else:\n                reconstructed_edges[i] = [z[1], z[0]]\n                if z[0] + 1 <= n:\n                    heappush(c, (z[0] + 1, z[1]))\n    return reconstructed_edges"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for i in range(1, n - 1):",
      "mutated_line": "for i in range(1, n - 2):",
      "code": "from heapq import heapify, heappop, heappush\n\ndef reconstruct_graph(n, m, edges):\n    sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][1])\n    reconstructed_edges = [[]] * m\n    c = []\n    for i in range(1, n - 2):\n        c.append((i + 2, i))\n    heapify(c)\n    j = 1\n    for i in sorted_indices:\n        if edges[i][1] == 1:\n            reconstructed_edges[i] = [j, j + 1]\n            j += 1\n        else:\n            if not c:\n                return -1\n            z = heappop(c)\n            if j < z[0]:\n                return -1\n            else:\n                reconstructed_edges[i] = [z[1], z[0]]\n                if z[0] + 1 <= n:\n                    heappush(c, (z[0] + 1, z[1]))\n    return reconstructed_edges"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for i in range(1, n - 1):",
      "mutated_line": "for i in range(1, n - 0):",
      "code": "from heapq import heapify, heappop, heappush\n\ndef reconstruct_graph(n, m, edges):\n    sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][1])\n    reconstructed_edges = [[]] * m\n    c = []\n    for i in range(1, n - 0):\n        c.append((i + 2, i))\n    heapify(c)\n    j = 1\n    for i in sorted_indices:\n        if edges[i][1] == 1:\n            reconstructed_edges[i] = [j, j + 1]\n            j += 1\n        else:\n            if not c:\n                return -1\n            z = heappop(c)\n            if j < z[0]:\n                return -1\n            else:\n                reconstructed_edges[i] = [z[1], z[0]]\n                if z[0] + 1 <= n:\n                    heappush(c, (z[0] + 1, z[1]))\n    return reconstructed_edges"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for i in range(1, n - 1):",
      "mutated_line": "for i in range(1, n - 0):",
      "code": "from heapq import heapify, heappop, heappush\n\ndef reconstruct_graph(n, m, edges):\n    sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][1])\n    reconstructed_edges = [[]] * m\n    c = []\n    for i in range(1, n - 0):\n        c.append((i + 2, i))\n    heapify(c)\n    j = 1\n    for i in sorted_indices:\n        if edges[i][1] == 1:\n            reconstructed_edges[i] = [j, j + 1]\n            j += 1\n        else:\n            if not c:\n                return -1\n            z = heappop(c)\n            if j < z[0]:\n                return -1\n            else:\n                reconstructed_edges[i] = [z[1], z[0]]\n                if z[0] + 1 <= n:\n                    heappush(c, (z[0] + 1, z[1]))\n    return reconstructed_edges"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for i in range(1, n - 1):",
      "mutated_line": "for i in range(1, n - -1):",
      "code": "from heapq import heapify, heappop, heappush\n\ndef reconstruct_graph(n, m, edges):\n    sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][1])\n    reconstructed_edges = [[]] * m\n    c = []\n    for i in range(1, n - -1):\n        c.append((i + 2, i))\n    heapify(c)\n    j = 1\n    for i in sorted_indices:\n        if edges[i][1] == 1:\n            reconstructed_edges[i] = [j, j + 1]\n            j += 1\n        else:\n            if not c:\n                return -1\n            z = heappop(c)\n            if j < z[0]:\n                return -1\n            else:\n                reconstructed_edges[i] = [z[1], z[0]]\n                if z[0] + 1 <= n:\n                    heappush(c, (z[0] + 1, z[1]))\n    return reconstructed_edges"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if edges[i][1] == 1:",
      "mutated_line": "if edges[i][1] == 2:",
      "code": "from heapq import heapify, heappop, heappush\n\ndef reconstruct_graph(n, m, edges):\n    sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][1])\n    reconstructed_edges = [[]] * m\n    c = []\n    for i in range(1, n - 1):\n        c.append((i + 2, i))\n    heapify(c)\n    j = 1\n    for i in sorted_indices:\n        if edges[i][1] == 2:\n            reconstructed_edges[i] = [j, j + 1]\n            j += 1\n        else:\n            if not c:\n                return -1\n            z = heappop(c)\n            if j < z[0]:\n                return -1\n            else:\n                reconstructed_edges[i] = [z[1], z[0]]\n                if z[0] + 1 <= n:\n                    heappush(c, (z[0] + 1, z[1]))\n    return reconstructed_edges"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if edges[i][1] == 1:",
      "mutated_line": "if edges[i][1] == 0:",
      "code": "from heapq import heapify, heappop, heappush\n\ndef reconstruct_graph(n, m, edges):\n    sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][1])\n    reconstructed_edges = [[]] * m\n    c = []\n    for i in range(1, n - 1):\n        c.append((i + 2, i))\n    heapify(c)\n    j = 1\n    for i in sorted_indices:\n        if edges[i][1] == 0:\n            reconstructed_edges[i] = [j, j + 1]\n            j += 1\n        else:\n            if not c:\n                return -1\n            z = heappop(c)\n            if j < z[0]:\n                return -1\n            else:\n                reconstructed_edges[i] = [z[1], z[0]]\n                if z[0] + 1 <= n:\n                    heappush(c, (z[0] + 1, z[1]))\n    return reconstructed_edges"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if edges[i][1] == 1:",
      "mutated_line": "if edges[i][1] == 0:",
      "code": "from heapq import heapify, heappop, heappush\n\ndef reconstruct_graph(n, m, edges):\n    sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][1])\n    reconstructed_edges = [[]] * m\n    c = []\n    for i in range(1, n - 1):\n        c.append((i + 2, i))\n    heapify(c)\n    j = 1\n    for i in sorted_indices:\n        if edges[i][1] == 0:\n            reconstructed_edges[i] = [j, j + 1]\n            j += 1\n        else:\n            if not c:\n                return -1\n            z = heappop(c)\n            if j < z[0]:\n                return -1\n            else:\n                reconstructed_edges[i] = [z[1], z[0]]\n                if z[0] + 1 <= n:\n                    heappush(c, (z[0] + 1, z[1]))\n    return reconstructed_edges"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if edges[i][1] == 1:",
      "mutated_line": "if edges[i][1] == -1:",
      "code": "from heapq import heapify, heappop, heappush\n\ndef reconstruct_graph(n, m, edges):\n    sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][1])\n    reconstructed_edges = [[]] * m\n    c = []\n    for i in range(1, n - 1):\n        c.append((i + 2, i))\n    heapify(c)\n    j = 1\n    for i in sorted_indices:\n        if edges[i][1] == -1:\n            reconstructed_edges[i] = [j, j + 1]\n            j += 1\n        else:\n            if not c:\n                return -1\n            z = heappop(c)\n            if j < z[0]:\n                return -1\n            else:\n                reconstructed_edges[i] = [z[1], z[0]]\n                if z[0] + 1 <= n:\n                    heappush(c, (z[0] + 1, z[1]))\n    return reconstructed_edges"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "j += 1",
      "mutated_line": "j += 2",
      "code": "from heapq import heapify, heappop, heappush\n\ndef reconstruct_graph(n, m, edges):\n    sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][1])\n    reconstructed_edges = [[]] * m\n    c = []\n    for i in range(1, n - 1):\n        c.append((i + 2, i))\n    heapify(c)\n    j = 1\n    for i in sorted_indices:\n        if edges[i][1] == 1:\n            reconstructed_edges[i] = [j, j + 1]\n            j += 2\n        else:\n            if not c:\n                return -1\n            z = heappop(c)\n            if j < z[0]:\n                return -1\n            else:\n                reconstructed_edges[i] = [z[1], z[0]]\n                if z[0] + 1 <= n:\n                    heappush(c, (z[0] + 1, z[1]))\n    return reconstructed_edges"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "j += 1",
      "mutated_line": "j += 0",
      "code": "from heapq import heapify, heappop, heappush\n\ndef reconstruct_graph(n, m, edges):\n    sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][1])\n    reconstructed_edges = [[]] * m\n    c = []\n    for i in range(1, n - 1):\n        c.append((i + 2, i))\n    heapify(c)\n    j = 1\n    for i in sorted_indices:\n        if edges[i][1] == 1:\n            reconstructed_edges[i] = [j, j + 1]\n            j += 0\n        else:\n            if not c:\n                return -1\n            z = heappop(c)\n            if j < z[0]:\n                return -1\n            else:\n                reconstructed_edges[i] = [z[1], z[0]]\n                if z[0] + 1 <= n:\n                    heappush(c, (z[0] + 1, z[1]))\n    return reconstructed_edges"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "j += 1",
      "mutated_line": "j += 0",
      "code": "from heapq import heapify, heappop, heappush\n\ndef reconstruct_graph(n, m, edges):\n    sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][1])\n    reconstructed_edges = [[]] * m\n    c = []\n    for i in range(1, n - 1):\n        c.append((i + 2, i))\n    heapify(c)\n    j = 1\n    for i in sorted_indices:\n        if edges[i][1] == 1:\n            reconstructed_edges[i] = [j, j + 1]\n            j += 0\n        else:\n            if not c:\n                return -1\n            z = heappop(c)\n            if j < z[0]:\n                return -1\n            else:\n                reconstructed_edges[i] = [z[1], z[0]]\n                if z[0] + 1 <= n:\n                    heappush(c, (z[0] + 1, z[1]))\n    return reconstructed_edges"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "j += 1",
      "mutated_line": "j += -1",
      "code": "from heapq import heapify, heappop, heappush\n\ndef reconstruct_graph(n, m, edges):\n    sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][1])\n    reconstructed_edges = [[]] * m\n    c = []\n    for i in range(1, n - 1):\n        c.append((i + 2, i))\n    heapify(c)\n    j = 1\n    for i in sorted_indices:\n        if edges[i][1] == 1:\n            reconstructed_edges[i] = [j, j + 1]\n            j += -1\n        else:\n            if not c:\n                return -1\n            z = heappop(c)\n            if j < z[0]:\n                return -1\n            else:\n                reconstructed_edges[i] = [z[1], z[0]]\n                if z[0] + 1 <= n:\n                    heappush(c, (z[0] + 1, z[1]))\n    return reconstructed_edges"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if j < z[0]:",
      "mutated_line": "if j <= z[0]:",
      "code": "from heapq import heapify, heappop, heappush\n\ndef reconstruct_graph(n, m, edges):\n    sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][1])\n    reconstructed_edges = [[]] * m\n    c = []\n    for i in range(1, n - 1):\n        c.append((i + 2, i))\n    heapify(c)\n    j = 1\n    for i in sorted_indices:\n        if edges[i][1] == 1:\n            reconstructed_edges[i] = [j, j + 1]\n            j += 1\n        else:\n            if not c:\n                return -1\n            z = heappop(c)\n            if j <= z[0]:\n                return -1\n            else:\n                reconstructed_edges[i] = [z[1], z[0]]\n                if z[0] + 1 <= n:\n                    heappush(c, (z[0] + 1, z[1]))\n    return reconstructed_edges"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if j < z[0]:",
      "mutated_line": "if j >= z[0]:",
      "code": "from heapq import heapify, heappop, heappush\n\ndef reconstruct_graph(n, m, edges):\n    sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][1])\n    reconstructed_edges = [[]] * m\n    c = []\n    for i in range(1, n - 1):\n        c.append((i + 2, i))\n    heapify(c)\n    j = 1\n    for i in sorted_indices:\n        if edges[i][1] == 1:\n            reconstructed_edges[i] = [j, j + 1]\n            j += 1\n        else:\n            if not c:\n                return -1\n            z = heappop(c)\n            if j >= z[0]:\n                return -1\n            else:\n                reconstructed_edges[i] = [z[1], z[0]]\n                if z[0] + 1 <= n:\n                    heappush(c, (z[0] + 1, z[1]))\n    return reconstructed_edges"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if j < z[0]:",
      "mutated_line": "if j != z[0]:",
      "code": "from heapq import heapify, heappop, heappush\n\ndef reconstruct_graph(n, m, edges):\n    sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][1])\n    reconstructed_edges = [[]] * m\n    c = []\n    for i in range(1, n - 1):\n        c.append((i + 2, i))\n    heapify(c)\n    j = 1\n    for i in sorted_indices:\n        if edges[i][1] == 1:\n            reconstructed_edges[i] = [j, j + 1]\n            j += 1\n        else:\n            if not c:\n                return -1\n            z = heappop(c)\n            if j != z[0]:\n                return -1\n            else:\n                reconstructed_edges[i] = [z[1], z[0]]\n                if z[0] + 1 <= n:\n                    heappush(c, (z[0] + 1, z[1]))\n    return reconstructed_edges"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][1])",
      "mutated_line": "sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 + edges[x][1])",
      "code": "from heapq import heapify, heappop, heappush\n\ndef reconstruct_graph(n, m, edges):\n    sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 + edges[x][1])\n    reconstructed_edges = [[]] * m\n    c = []\n    for i in range(1, n - 1):\n        c.append((i + 2, i))\n    heapify(c)\n    j = 1\n    for i in sorted_indices:\n        if edges[i][1] == 1:\n            reconstructed_edges[i] = [j, j + 1]\n            j += 1\n        else:\n            if not c:\n                return -1\n            z = heappop(c)\n            if j < z[0]:\n                return -1\n            else:\n                reconstructed_edges[i] = [z[1], z[0]]\n                if z[0] + 1 <= n:\n                    heappush(c, (z[0] + 1, z[1]))\n    return reconstructed_edges"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][1])",
      "mutated_line": "sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 * edges[x][1])",
      "code": "from heapq import heapify, heappop, heappush\n\ndef reconstruct_graph(n, m, edges):\n    sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 * edges[x][1])\n    reconstructed_edges = [[]] * m\n    c = []\n    for i in range(1, n - 1):\n        c.append((i + 2, i))\n    heapify(c)\n    j = 1\n    for i in sorted_indices:\n        if edges[i][1] == 1:\n            reconstructed_edges[i] = [j, j + 1]\n            j += 1\n        else:\n            if not c:\n                return -1\n            z = heappop(c)\n            if j < z[0]:\n                return -1\n            else:\n                reconstructed_edges[i] = [z[1], z[0]]\n                if z[0] + 1 <= n:\n                    heappush(c, (z[0] + 1, z[1]))\n    return reconstructed_edges"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "c.append((i + 2, i))",
      "mutated_line": "c.append((i - 2, i))",
      "code": "from heapq import heapify, heappop, heappush\n\ndef reconstruct_graph(n, m, edges):\n    sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][1])\n    reconstructed_edges = [[]] * m\n    c = []\n    for i in range(1, n - 1):\n        c.append((i - 2, i))\n    heapify(c)\n    j = 1\n    for i in sorted_indices:\n        if edges[i][1] == 1:\n            reconstructed_edges[i] = [j, j + 1]\n            j += 1\n        else:\n            if not c:\n                return -1\n            z = heappop(c)\n            if j < z[0]:\n                return -1\n            else:\n                reconstructed_edges[i] = [z[1], z[0]]\n                if z[0] + 1 <= n:\n                    heappush(c, (z[0] + 1, z[1]))\n    return reconstructed_edges"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "c.append((i + 2, i))",
      "mutated_line": "c.append((i * 2, i))",
      "code": "from heapq import heapify, heappop, heappush\n\ndef reconstruct_graph(n, m, edges):\n    sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][1])\n    reconstructed_edges = [[]] * m\n    c = []\n    for i in range(1, n - 1):\n        c.append((i * 2, i))\n    heapify(c)\n    j = 1\n    for i in sorted_indices:\n        if edges[i][1] == 1:\n            reconstructed_edges[i] = [j, j + 1]\n            j += 1\n        else:\n            if not c:\n                return -1\n            z = heappop(c)\n            if j < z[0]:\n                return -1\n            else:\n                reconstructed_edges[i] = [z[1], z[0]]\n                if z[0] + 1 <= n:\n                    heappush(c, (z[0] + 1, z[1]))\n    return reconstructed_edges"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if edges[i][1] == 1:",
      "mutated_line": "if edges[i][2] == 1:",
      "code": "from heapq import heapify, heappop, heappush\n\ndef reconstruct_graph(n, m, edges):\n    sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][1])\n    reconstructed_edges = [[]] * m\n    c = []\n    for i in range(1, n - 1):\n        c.append((i + 2, i))\n    heapify(c)\n    j = 1\n    for i in sorted_indices:\n        if edges[i][2] == 1:\n            reconstructed_edges[i] = [j, j + 1]\n            j += 1\n        else:\n            if not c:\n                return -1\n            z = heappop(c)\n            if j < z[0]:\n                return -1\n            else:\n                reconstructed_edges[i] = [z[1], z[0]]\n                if z[0] + 1 <= n:\n                    heappush(c, (z[0] + 1, z[1]))\n    return reconstructed_edges"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if edges[i][1] == 1:",
      "mutated_line": "if edges[i][0] == 1:",
      "code": "from heapq import heapify, heappop, heappush\n\ndef reconstruct_graph(n, m, edges):\n    sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][1])\n    reconstructed_edges = [[]] * m\n    c = []\n    for i in range(1, n - 1):\n        c.append((i + 2, i))\n    heapify(c)\n    j = 1\n    for i in sorted_indices:\n        if edges[i][0] == 1:\n            reconstructed_edges[i] = [j, j + 1]\n            j += 1\n        else:\n            if not c:\n                return -1\n            z = heappop(c)\n            if j < z[0]:\n                return -1\n            else:\n                reconstructed_edges[i] = [z[1], z[0]]\n                if z[0] + 1 <= n:\n                    heappush(c, (z[0] + 1, z[1]))\n    return reconstructed_edges"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if edges[i][1] == 1:",
      "mutated_line": "if edges[i][0] == 1:",
      "code": "from heapq import heapify, heappop, heappush\n\ndef reconstruct_graph(n, m, edges):\n    sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][1])\n    reconstructed_edges = [[]] * m\n    c = []\n    for i in range(1, n - 1):\n        c.append((i + 2, i))\n    heapify(c)\n    j = 1\n    for i in sorted_indices:\n        if edges[i][0] == 1:\n            reconstructed_edges[i] = [j, j + 1]\n            j += 1\n        else:\n            if not c:\n                return -1\n            z = heappop(c)\n            if j < z[0]:\n                return -1\n            else:\n                reconstructed_edges[i] = [z[1], z[0]]\n                if z[0] + 1 <= n:\n                    heappush(c, (z[0] + 1, z[1]))\n    return reconstructed_edges"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if edges[i][1] == 1:",
      "mutated_line": "if edges[i][-1] == 1:",
      "code": "from heapq import heapify, heappop, heappush\n\ndef reconstruct_graph(n, m, edges):\n    sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][1])\n    reconstructed_edges = [[]] * m\n    c = []\n    for i in range(1, n - 1):\n        c.append((i + 2, i))\n    heapify(c)\n    j = 1\n    for i in sorted_indices:\n        if edges[i][-1] == 1:\n            reconstructed_edges[i] = [j, j + 1]\n            j += 1\n        else:\n            if not c:\n                return -1\n            z = heappop(c)\n            if j < z[0]:\n                return -1\n            else:\n                reconstructed_edges[i] = [z[1], z[0]]\n                if z[0] + 1 <= n:\n                    heappush(c, (z[0] + 1, z[1]))\n    return reconstructed_edges"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "reconstructed_edges[i] = [j, j + 1]",
      "mutated_line": "reconstructed_edges[i] = [j, j - 1]",
      "code": "from heapq import heapify, heappop, heappush\n\ndef reconstruct_graph(n, m, edges):\n    sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][1])\n    reconstructed_edges = [[]] * m\n    c = []\n    for i in range(1, n - 1):\n        c.append((i + 2, i))\n    heapify(c)\n    j = 1\n    for i in sorted_indices:\n        if edges[i][1] == 1:\n            reconstructed_edges[i] = [j, j - 1]\n            j += 1\n        else:\n            if not c:\n                return -1\n            z = heappop(c)\n            if j < z[0]:\n                return -1\n            else:\n                reconstructed_edges[i] = [z[1], z[0]]\n                if z[0] + 1 <= n:\n                    heappush(c, (z[0] + 1, z[1]))\n    return reconstructed_edges"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "reconstructed_edges[i] = [j, j + 1]",
      "mutated_line": "reconstructed_edges[i] = [j, j * 1]",
      "code": "from heapq import heapify, heappop, heappush\n\ndef reconstruct_graph(n, m, edges):\n    sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][1])\n    reconstructed_edges = [[]] * m\n    c = []\n    for i in range(1, n - 1):\n        c.append((i + 2, i))\n    heapify(c)\n    j = 1\n    for i in sorted_indices:\n        if edges[i][1] == 1:\n            reconstructed_edges[i] = [j, j * 1]\n            j += 1\n        else:\n            if not c:\n                return -1\n            z = heappop(c)\n            if j < z[0]:\n                return -1\n            else:\n                reconstructed_edges[i] = [z[1], z[0]]\n                if z[0] + 1 <= n:\n                    heappush(c, (z[0] + 1, z[1]))\n    return reconstructed_edges"
    },
    {
      "operator": "UOI",
      "lineno": 27,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "from heapq import heapify, heappop, heappush\n\ndef reconstruct_graph(n, m, edges):\n    sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][1])\n    reconstructed_edges = [[]] * m\n    c = []\n    for i in range(1, n - 1):\n        c.append((i + 2, i))\n    heapify(c)\n    j = 1\n    for i in sorted_indices:\n        if edges[i][1] == 1:\n            reconstructed_edges[i] = [j, j + 1]\n            j += 1\n        else:\n            if not c:\n                return +1\n            z = heappop(c)\n            if j < z[0]:\n                return -1\n            else:\n                reconstructed_edges[i] = [z[1], z[0]]\n                if z[0] + 1 <= n:\n                    heappush(c, (z[0] + 1, z[1]))\n    return reconstructed_edges"
    },
    {
      "operator": "UOI",
      "lineno": 30,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "from heapq import heapify, heappop, heappush\n\ndef reconstruct_graph(n, m, edges):\n    sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][1])\n    reconstructed_edges = [[]] * m\n    c = []\n    for i in range(1, n - 1):\n        c.append((i + 2, i))\n    heapify(c)\n    j = 1\n    for i in sorted_indices:\n        if edges[i][1] == 1:\n            reconstructed_edges[i] = [j, j + 1]\n            j += 1\n        else:\n            if not c:\n                return -1\n            z = heappop(c)\n            if j < z[0]:\n                return +1\n            else:\n                reconstructed_edges[i] = [z[1], z[0]]\n                if z[0] + 1 <= n:\n                    heappush(c, (z[0] + 1, z[1]))\n    return reconstructed_edges"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if z[0] + 1 <= n:",
      "mutated_line": "if z[0] + 1 < n:",
      "code": "from heapq import heapify, heappop, heappush\n\ndef reconstruct_graph(n, m, edges):\n    sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][1])\n    reconstructed_edges = [[]] * m\n    c = []\n    for i in range(1, n - 1):\n        c.append((i + 2, i))\n    heapify(c)\n    j = 1\n    for i in sorted_indices:\n        if edges[i][1] == 1:\n            reconstructed_edges[i] = [j, j + 1]\n            j += 1\n        else:\n            if not c:\n                return -1\n            z = heappop(c)\n            if j < z[0]:\n                return -1\n            else:\n                reconstructed_edges[i] = [z[1], z[0]]\n                if z[0] + 1 < n:\n                    heappush(c, (z[0] + 1, z[1]))\n    return reconstructed_edges"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if z[0] + 1 <= n:",
      "mutated_line": "if z[0] + 1 > n:",
      "code": "from heapq import heapify, heappop, heappush\n\ndef reconstruct_graph(n, m, edges):\n    sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][1])\n    reconstructed_edges = [[]] * m\n    c = []\n    for i in range(1, n - 1):\n        c.append((i + 2, i))\n    heapify(c)\n    j = 1\n    for i in sorted_indices:\n        if edges[i][1] == 1:\n            reconstructed_edges[i] = [j, j + 1]\n            j += 1\n        else:\n            if not c:\n                return -1\n            z = heappop(c)\n            if j < z[0]:\n                return -1\n            else:\n                reconstructed_edges[i] = [z[1], z[0]]\n                if z[0] + 1 > n:\n                    heappush(c, (z[0] + 1, z[1]))\n    return reconstructed_edges"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if z[0] + 1 <= n:",
      "mutated_line": "if z[0] + 1 == n:",
      "code": "from heapq import heapify, heappop, heappush\n\ndef reconstruct_graph(n, m, edges):\n    sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][1])\n    reconstructed_edges = [[]] * m\n    c = []\n    for i in range(1, n - 1):\n        c.append((i + 2, i))\n    heapify(c)\n    j = 1\n    for i in sorted_indices:\n        if edges[i][1] == 1:\n            reconstructed_edges[i] = [j, j + 1]\n            j += 1\n        else:\n            if not c:\n                return -1\n            z = heappop(c)\n            if j < z[0]:\n                return -1\n            else:\n                reconstructed_edges[i] = [z[1], z[0]]\n                if z[0] + 1 == n:\n                    heappush(c, (z[0] + 1, z[1]))\n    return reconstructed_edges"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][1])",
      "mutated_line": "sorted_indices = sorted(range(m), key=lambda x: edges[x][0] / 10000000000 - edges[x][1])",
      "code": "from heapq import heapify, heappop, heappush\n\ndef reconstruct_graph(n, m, edges):\n    sorted_indices = sorted(range(m), key=lambda x: edges[x][0] / 10000000000 - edges[x][1])\n    reconstructed_edges = [[]] * m\n    c = []\n    for i in range(1, n - 1):\n        c.append((i + 2, i))\n    heapify(c)\n    j = 1\n    for i in sorted_indices:\n        if edges[i][1] == 1:\n            reconstructed_edges[i] = [j, j + 1]\n            j += 1\n        else:\n            if not c:\n                return -1\n            z = heappop(c)\n            if j < z[0]:\n                return -1\n            else:\n                reconstructed_edges[i] = [z[1], z[0]]\n                if z[0] + 1 <= n:\n                    heappush(c, (z[0] + 1, z[1]))\n    return reconstructed_edges"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][1])",
      "mutated_line": "sorted_indices = sorted(range(m), key=lambda x: edges[x][0] + 10000000000 - edges[x][1])",
      "code": "from heapq import heapify, heappop, heappush\n\ndef reconstruct_graph(n, m, edges):\n    sorted_indices = sorted(range(m), key=lambda x: edges[x][0] + 10000000000 - edges[x][1])\n    reconstructed_edges = [[]] * m\n    c = []\n    for i in range(1, n - 1):\n        c.append((i + 2, i))\n    heapify(c)\n    j = 1\n    for i in sorted_indices:\n        if edges[i][1] == 1:\n            reconstructed_edges[i] = [j, j + 1]\n            j += 1\n        else:\n            if not c:\n                return -1\n            z = heappop(c)\n            if j < z[0]:\n                return -1\n            else:\n                reconstructed_edges[i] = [z[1], z[0]]\n                if z[0] + 1 <= n:\n                    heappush(c, (z[0] + 1, z[1]))\n    return reconstructed_edges"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][1])",
      "mutated_line": "sorted_indices = sorted(range(m), key=lambda x: edges[x][0] ** 10000000000 - edges[x][1])",
      "code": "from heapq import heapify, heappop, heappush\n\ndef reconstruct_graph(n, m, edges):\n    sorted_indices = sorted(range(m), key=lambda x: edges[x][0] ** 10000000000 - edges[x][1])\n    reconstructed_edges = [[]] * m\n    c = []\n    for i in range(1, n - 1):\n        c.append((i + 2, i))\n    heapify(c)\n    j = 1\n    for i in sorted_indices:\n        if edges[i][1] == 1:\n            reconstructed_edges[i] = [j, j + 1]\n            j += 1\n        else:\n            if not c:\n                return -1\n            z = heappop(c)\n            if j < z[0]:\n                return -1\n            else:\n                reconstructed_edges[i] = [z[1], z[0]]\n                if z[0] + 1 <= n:\n                    heappush(c, (z[0] + 1, z[1]))\n    return reconstructed_edges"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "c.append((i + 2, i))",
      "mutated_line": "c.append((i + 3, i))",
      "code": "from heapq import heapify, heappop, heappush\n\ndef reconstruct_graph(n, m, edges):\n    sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][1])\n    reconstructed_edges = [[]] * m\n    c = []\n    for i in range(1, n - 1):\n        c.append((i + 3, i))\n    heapify(c)\n    j = 1\n    for i in sorted_indices:\n        if edges[i][1] == 1:\n            reconstructed_edges[i] = [j, j + 1]\n            j += 1\n        else:\n            if not c:\n                return -1\n            z = heappop(c)\n            if j < z[0]:\n                return -1\n            else:\n                reconstructed_edges[i] = [z[1], z[0]]\n                if z[0] + 1 <= n:\n                    heappush(c, (z[0] + 1, z[1]))\n    return reconstructed_edges"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "c.append((i + 2, i))",
      "mutated_line": "c.append((i + 1, i))",
      "code": "from heapq import heapify, heappop, heappush\n\ndef reconstruct_graph(n, m, edges):\n    sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][1])\n    reconstructed_edges = [[]] * m\n    c = []\n    for i in range(1, n - 1):\n        c.append((i + 1, i))\n    heapify(c)\n    j = 1\n    for i in sorted_indices:\n        if edges[i][1] == 1:\n            reconstructed_edges[i] = [j, j + 1]\n            j += 1\n        else:\n            if not c:\n                return -1\n            z = heappop(c)\n            if j < z[0]:\n                return -1\n            else:\n                reconstructed_edges[i] = [z[1], z[0]]\n                if z[0] + 1 <= n:\n                    heappush(c, (z[0] + 1, z[1]))\n    return reconstructed_edges"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "c.append((i + 2, i))",
      "mutated_line": "c.append((i + 0, i))",
      "code": "from heapq import heapify, heappop, heappush\n\ndef reconstruct_graph(n, m, edges):\n    sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][1])\n    reconstructed_edges = [[]] * m\n    c = []\n    for i in range(1, n - 1):\n        c.append((i + 0, i))\n    heapify(c)\n    j = 1\n    for i in sorted_indices:\n        if edges[i][1] == 1:\n            reconstructed_edges[i] = [j, j + 1]\n            j += 1\n        else:\n            if not c:\n                return -1\n            z = heappop(c)\n            if j < z[0]:\n                return -1\n            else:\n                reconstructed_edges[i] = [z[1], z[0]]\n                if z[0] + 1 <= n:\n                    heappush(c, (z[0] + 1, z[1]))\n    return reconstructed_edges"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "c.append((i + 2, i))",
      "mutated_line": "c.append((i + 1, i))",
      "code": "from heapq import heapify, heappop, heappush\n\ndef reconstruct_graph(n, m, edges):\n    sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][1])\n    reconstructed_edges = [[]] * m\n    c = []\n    for i in range(1, n - 1):\n        c.append((i + 1, i))\n    heapify(c)\n    j = 1\n    for i in sorted_indices:\n        if edges[i][1] == 1:\n            reconstructed_edges[i] = [j, j + 1]\n            j += 1\n        else:\n            if not c:\n                return -1\n            z = heappop(c)\n            if j < z[0]:\n                return -1\n            else:\n                reconstructed_edges[i] = [z[1], z[0]]\n                if z[0] + 1 <= n:\n                    heappush(c, (z[0] + 1, z[1]))\n    return reconstructed_edges"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "c.append((i + 2, i))",
      "mutated_line": "c.append((i + -2, i))",
      "code": "from heapq import heapify, heappop, heappush\n\ndef reconstruct_graph(n, m, edges):\n    sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][1])\n    reconstructed_edges = [[]] * m\n    c = []\n    for i in range(1, n - 1):\n        c.append((i + -2, i))\n    heapify(c)\n    j = 1\n    for i in sorted_indices:\n        if edges[i][1] == 1:\n            reconstructed_edges[i] = [j, j + 1]\n            j += 1\n        else:\n            if not c:\n                return -1\n            z = heappop(c)\n            if j < z[0]:\n                return -1\n            else:\n                reconstructed_edges[i] = [z[1], z[0]]\n                if z[0] + 1 <= n:\n                    heappush(c, (z[0] + 1, z[1]))\n    return reconstructed_edges"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "reconstructed_edges[i] = [j, j + 1]",
      "mutated_line": "reconstructed_edges[i] = [j, j + 2]",
      "code": "from heapq import heapify, heappop, heappush\n\ndef reconstruct_graph(n, m, edges):\n    sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][1])\n    reconstructed_edges = [[]] * m\n    c = []\n    for i in range(1, n - 1):\n        c.append((i + 2, i))\n    heapify(c)\n    j = 1\n    for i in sorted_indices:\n        if edges[i][1] == 1:\n            reconstructed_edges[i] = [j, j + 2]\n            j += 1\n        else:\n            if not c:\n                return -1\n            z = heappop(c)\n            if j < z[0]:\n                return -1\n            else:\n                reconstructed_edges[i] = [z[1], z[0]]\n                if z[0] + 1 <= n:\n                    heappush(c, (z[0] + 1, z[1]))\n    return reconstructed_edges"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "reconstructed_edges[i] = [j, j + 1]",
      "mutated_line": "reconstructed_edges[i] = [j, j + 0]",
      "code": "from heapq import heapify, heappop, heappush\n\ndef reconstruct_graph(n, m, edges):\n    sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][1])\n    reconstructed_edges = [[]] * m\n    c = []\n    for i in range(1, n - 1):\n        c.append((i + 2, i))\n    heapify(c)\n    j = 1\n    for i in sorted_indices:\n        if edges[i][1] == 1:\n            reconstructed_edges[i] = [j, j + 0]\n            j += 1\n        else:\n            if not c:\n                return -1\n            z = heappop(c)\n            if j < z[0]:\n                return -1\n            else:\n                reconstructed_edges[i] = [z[1], z[0]]\n                if z[0] + 1 <= n:\n                    heappush(c, (z[0] + 1, z[1]))\n    return reconstructed_edges"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "reconstructed_edges[i] = [j, j + 1]",
      "mutated_line": "reconstructed_edges[i] = [j, j + 0]",
      "code": "from heapq import heapify, heappop, heappush\n\ndef reconstruct_graph(n, m, edges):\n    sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][1])\n    reconstructed_edges = [[]] * m\n    c = []\n    for i in range(1, n - 1):\n        c.append((i + 2, i))\n    heapify(c)\n    j = 1\n    for i in sorted_indices:\n        if edges[i][1] == 1:\n            reconstructed_edges[i] = [j, j + 0]\n            j += 1\n        else:\n            if not c:\n                return -1\n            z = heappop(c)\n            if j < z[0]:\n                return -1\n            else:\n                reconstructed_edges[i] = [z[1], z[0]]\n                if z[0] + 1 <= n:\n                    heappush(c, (z[0] + 1, z[1]))\n    return reconstructed_edges"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "reconstructed_edges[i] = [j, j + 1]",
      "mutated_line": "reconstructed_edges[i] = [j, j + -1]",
      "code": "from heapq import heapify, heappop, heappush\n\ndef reconstruct_graph(n, m, edges):\n    sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][1])\n    reconstructed_edges = [[]] * m\n    c = []\n    for i in range(1, n - 1):\n        c.append((i + 2, i))\n    heapify(c)\n    j = 1\n    for i in sorted_indices:\n        if edges[i][1] == 1:\n            reconstructed_edges[i] = [j, j + -1]\n            j += 1\n        else:\n            if not c:\n                return -1\n            z = heappop(c)\n            if j < z[0]:\n                return -1\n            else:\n                reconstructed_edges[i] = [z[1], z[0]]\n                if z[0] + 1 <= n:\n                    heappush(c, (z[0] + 1, z[1]))\n    return reconstructed_edges"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "from heapq import heapify, heappop, heappush\n\ndef reconstruct_graph(n, m, edges):\n    sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][1])\n    reconstructed_edges = [[]] * m\n    c = []\n    for i in range(1, n - 1):\n        c.append((i + 2, i))\n    heapify(c)\n    j = 1\n    for i in sorted_indices:\n        if edges[i][1] == 1:\n            reconstructed_edges[i] = [j, j + 1]\n            j += 1\n        else:\n            if not c:\n                return -2\n            z = heappop(c)\n            if j < z[0]:\n                return -1\n            else:\n                reconstructed_edges[i] = [z[1], z[0]]\n                if z[0] + 1 <= n:\n                    heappush(c, (z[0] + 1, z[1]))\n    return reconstructed_edges"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from heapq import heapify, heappop, heappush\n\ndef reconstruct_graph(n, m, edges):\n    sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][1])\n    reconstructed_edges = [[]] * m\n    c = []\n    for i in range(1, n - 1):\n        c.append((i + 2, i))\n    heapify(c)\n    j = 1\n    for i in sorted_indices:\n        if edges[i][1] == 1:\n            reconstructed_edges[i] = [j, j + 1]\n            j += 1\n        else:\n            if not c:\n                return -0\n            z = heappop(c)\n            if j < z[0]:\n                return -1\n            else:\n                reconstructed_edges[i] = [z[1], z[0]]\n                if z[0] + 1 <= n:\n                    heappush(c, (z[0] + 1, z[1]))\n    return reconstructed_edges"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from heapq import heapify, heappop, heappush\n\ndef reconstruct_graph(n, m, edges):\n    sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][1])\n    reconstructed_edges = [[]] * m\n    c = []\n    for i in range(1, n - 1):\n        c.append((i + 2, i))\n    heapify(c)\n    j = 1\n    for i in sorted_indices:\n        if edges[i][1] == 1:\n            reconstructed_edges[i] = [j, j + 1]\n            j += 1\n        else:\n            if not c:\n                return -0\n            z = heappop(c)\n            if j < z[0]:\n                return -1\n            else:\n                reconstructed_edges[i] = [z[1], z[0]]\n                if z[0] + 1 <= n:\n                    heappush(c, (z[0] + 1, z[1]))\n    return reconstructed_edges"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "from heapq import heapify, heappop, heappush\n\ndef reconstruct_graph(n, m, edges):\n    sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][1])\n    reconstructed_edges = [[]] * m\n    c = []\n    for i in range(1, n - 1):\n        c.append((i + 2, i))\n    heapify(c)\n    j = 1\n    for i in sorted_indices:\n        if edges[i][1] == 1:\n            reconstructed_edges[i] = [j, j + 1]\n            j += 1\n        else:\n            if not c:\n                return --1\n            z = heappop(c)\n            if j < z[0]:\n                return -1\n            else:\n                reconstructed_edges[i] = [z[1], z[0]]\n                if z[0] + 1 <= n:\n                    heappush(c, (z[0] + 1, z[1]))\n    return reconstructed_edges"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if j < z[0]:",
      "mutated_line": "if j < z[1]:",
      "code": "from heapq import heapify, heappop, heappush\n\ndef reconstruct_graph(n, m, edges):\n    sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][1])\n    reconstructed_edges = [[]] * m\n    c = []\n    for i in range(1, n - 1):\n        c.append((i + 2, i))\n    heapify(c)\n    j = 1\n    for i in sorted_indices:\n        if edges[i][1] == 1:\n            reconstructed_edges[i] = [j, j + 1]\n            j += 1\n        else:\n            if not c:\n                return -1\n            z = heappop(c)\n            if j < z[1]:\n                return -1\n            else:\n                reconstructed_edges[i] = [z[1], z[0]]\n                if z[0] + 1 <= n:\n                    heappush(c, (z[0] + 1, z[1]))\n    return reconstructed_edges"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if j < z[0]:",
      "mutated_line": "if j < z[-1]:",
      "code": "from heapq import heapify, heappop, heappush\n\ndef reconstruct_graph(n, m, edges):\n    sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][1])\n    reconstructed_edges = [[]] * m\n    c = []\n    for i in range(1, n - 1):\n        c.append((i + 2, i))\n    heapify(c)\n    j = 1\n    for i in sorted_indices:\n        if edges[i][1] == 1:\n            reconstructed_edges[i] = [j, j + 1]\n            j += 1\n        else:\n            if not c:\n                return -1\n            z = heappop(c)\n            if j < z[-1]:\n                return -1\n            else:\n                reconstructed_edges[i] = [z[1], z[0]]\n                if z[0] + 1 <= n:\n                    heappush(c, (z[0] + 1, z[1]))\n    return reconstructed_edges"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if j < z[0]:",
      "mutated_line": "if j < z[1]:",
      "code": "from heapq import heapify, heappop, heappush\n\ndef reconstruct_graph(n, m, edges):\n    sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][1])\n    reconstructed_edges = [[]] * m\n    c = []\n    for i in range(1, n - 1):\n        c.append((i + 2, i))\n    heapify(c)\n    j = 1\n    for i in sorted_indices:\n        if edges[i][1] == 1:\n            reconstructed_edges[i] = [j, j + 1]\n            j += 1\n        else:\n            if not c:\n                return -1\n            z = heappop(c)\n            if j < z[1]:\n                return -1\n            else:\n                reconstructed_edges[i] = [z[1], z[0]]\n                if z[0] + 1 <= n:\n                    heappush(c, (z[0] + 1, z[1]))\n    return reconstructed_edges"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "from heapq import heapify, heappop, heappush\n\ndef reconstruct_graph(n, m, edges):\n    sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][1])\n    reconstructed_edges = [[]] * m\n    c = []\n    for i in range(1, n - 1):\n        c.append((i + 2, i))\n    heapify(c)\n    j = 1\n    for i in sorted_indices:\n        if edges[i][1] == 1:\n            reconstructed_edges[i] = [j, j + 1]\n            j += 1\n        else:\n            if not c:\n                return -1\n            z = heappop(c)\n            if j < z[0]:\n                return -2\n            else:\n                reconstructed_edges[i] = [z[1], z[0]]\n                if z[0] + 1 <= n:\n                    heappush(c, (z[0] + 1, z[1]))\n    return reconstructed_edges"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from heapq import heapify, heappop, heappush\n\ndef reconstruct_graph(n, m, edges):\n    sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][1])\n    reconstructed_edges = [[]] * m\n    c = []\n    for i in range(1, n - 1):\n        c.append((i + 2, i))\n    heapify(c)\n    j = 1\n    for i in sorted_indices:\n        if edges[i][1] == 1:\n            reconstructed_edges[i] = [j, j + 1]\n            j += 1\n        else:\n            if not c:\n                return -1\n            z = heappop(c)\n            if j < z[0]:\n                return -0\n            else:\n                reconstructed_edges[i] = [z[1], z[0]]\n                if z[0] + 1 <= n:\n                    heappush(c, (z[0] + 1, z[1]))\n    return reconstructed_edges"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from heapq import heapify, heappop, heappush\n\ndef reconstruct_graph(n, m, edges):\n    sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][1])\n    reconstructed_edges = [[]] * m\n    c = []\n    for i in range(1, n - 1):\n        c.append((i + 2, i))\n    heapify(c)\n    j = 1\n    for i in sorted_indices:\n        if edges[i][1] == 1:\n            reconstructed_edges[i] = [j, j + 1]\n            j += 1\n        else:\n            if not c:\n                return -1\n            z = heappop(c)\n            if j < z[0]:\n                return -0\n            else:\n                reconstructed_edges[i] = [z[1], z[0]]\n                if z[0] + 1 <= n:\n                    heappush(c, (z[0] + 1, z[1]))\n    return reconstructed_edges"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "from heapq import heapify, heappop, heappush\n\ndef reconstruct_graph(n, m, edges):\n    sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][1])\n    reconstructed_edges = [[]] * m\n    c = []\n    for i in range(1, n - 1):\n        c.append((i + 2, i))\n    heapify(c)\n    j = 1\n    for i in sorted_indices:\n        if edges[i][1] == 1:\n            reconstructed_edges[i] = [j, j + 1]\n            j += 1\n        else:\n            if not c:\n                return -1\n            z = heappop(c)\n            if j < z[0]:\n                return --1\n            else:\n                reconstructed_edges[i] = [z[1], z[0]]\n                if z[0] + 1 <= n:\n                    heappush(c, (z[0] + 1, z[1]))\n    return reconstructed_edges"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "if z[0] + 1 <= n:",
      "mutated_line": "if z[0] - 1 <= n:",
      "code": "from heapq import heapify, heappop, heappush\n\ndef reconstruct_graph(n, m, edges):\n    sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][1])\n    reconstructed_edges = [[]] * m\n    c = []\n    for i in range(1, n - 1):\n        c.append((i + 2, i))\n    heapify(c)\n    j = 1\n    for i in sorted_indices:\n        if edges[i][1] == 1:\n            reconstructed_edges[i] = [j, j + 1]\n            j += 1\n        else:\n            if not c:\n                return -1\n            z = heappop(c)\n            if j < z[0]:\n                return -1\n            else:\n                reconstructed_edges[i] = [z[1], z[0]]\n                if z[0] - 1 <= n:\n                    heappush(c, (z[0] + 1, z[1]))\n    return reconstructed_edges"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "if z[0] + 1 <= n:",
      "mutated_line": "if z[0] * 1 <= n:",
      "code": "from heapq import heapify, heappop, heappush\n\ndef reconstruct_graph(n, m, edges):\n    sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][1])\n    reconstructed_edges = [[]] * m\n    c = []\n    for i in range(1, n - 1):\n        c.append((i + 2, i))\n    heapify(c)\n    j = 1\n    for i in sorted_indices:\n        if edges[i][1] == 1:\n            reconstructed_edges[i] = [j, j + 1]\n            j += 1\n        else:\n            if not c:\n                return -1\n            z = heappop(c)\n            if j < z[0]:\n                return -1\n            else:\n                reconstructed_edges[i] = [z[1], z[0]]\n                if z[0] * 1 <= n:\n                    heappush(c, (z[0] + 1, z[1]))\n    return reconstructed_edges"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][1])",
      "mutated_line": "sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000001 - edges[x][1])",
      "code": "from heapq import heapify, heappop, heappush\n\ndef reconstruct_graph(n, m, edges):\n    sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000001 - edges[x][1])\n    reconstructed_edges = [[]] * m\n    c = []\n    for i in range(1, n - 1):\n        c.append((i + 2, i))\n    heapify(c)\n    j = 1\n    for i in sorted_indices:\n        if edges[i][1] == 1:\n            reconstructed_edges[i] = [j, j + 1]\n            j += 1\n        else:\n            if not c:\n                return -1\n            z = heappop(c)\n            if j < z[0]:\n                return -1\n            else:\n                reconstructed_edges[i] = [z[1], z[0]]\n                if z[0] + 1 <= n:\n                    heappush(c, (z[0] + 1, z[1]))\n    return reconstructed_edges"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][1])",
      "mutated_line": "sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 9999999999 - edges[x][1])",
      "code": "from heapq import heapify, heappop, heappush\n\ndef reconstruct_graph(n, m, edges):\n    sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 9999999999 - edges[x][1])\n    reconstructed_edges = [[]] * m\n    c = []\n    for i in range(1, n - 1):\n        c.append((i + 2, i))\n    heapify(c)\n    j = 1\n    for i in sorted_indices:\n        if edges[i][1] == 1:\n            reconstructed_edges[i] = [j, j + 1]\n            j += 1\n        else:\n            if not c:\n                return -1\n            z = heappop(c)\n            if j < z[0]:\n                return -1\n            else:\n                reconstructed_edges[i] = [z[1], z[0]]\n                if z[0] + 1 <= n:\n                    heappush(c, (z[0] + 1, z[1]))\n    return reconstructed_edges"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][1])",
      "mutated_line": "sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 0 - edges[x][1])",
      "code": "from heapq import heapify, heappop, heappush\n\ndef reconstruct_graph(n, m, edges):\n    sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 0 - edges[x][1])\n    reconstructed_edges = [[]] * m\n    c = []\n    for i in range(1, n - 1):\n        c.append((i + 2, i))\n    heapify(c)\n    j = 1\n    for i in sorted_indices:\n        if edges[i][1] == 1:\n            reconstructed_edges[i] = [j, j + 1]\n            j += 1\n        else:\n            if not c:\n                return -1\n            z = heappop(c)\n            if j < z[0]:\n                return -1\n            else:\n                reconstructed_edges[i] = [z[1], z[0]]\n                if z[0] + 1 <= n:\n                    heappush(c, (z[0] + 1, z[1]))\n    return reconstructed_edges"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][1])",
      "mutated_line": "sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 1 - edges[x][1])",
      "code": "from heapq import heapify, heappop, heappush\n\ndef reconstruct_graph(n, m, edges):\n    sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 1 - edges[x][1])\n    reconstructed_edges = [[]] * m\n    c = []\n    for i in range(1, n - 1):\n        c.append((i + 2, i))\n    heapify(c)\n    j = 1\n    for i in sorted_indices:\n        if edges[i][1] == 1:\n            reconstructed_edges[i] = [j, j + 1]\n            j += 1\n        else:\n            if not c:\n                return -1\n            z = heappop(c)\n            if j < z[0]:\n                return -1\n            else:\n                reconstructed_edges[i] = [z[1], z[0]]\n                if z[0] + 1 <= n:\n                    heappush(c, (z[0] + 1, z[1]))\n    return reconstructed_edges"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][1])",
      "mutated_line": "sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * -10000000000 - edges[x][1])",
      "code": "from heapq import heapify, heappop, heappush\n\ndef reconstruct_graph(n, m, edges):\n    sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * -10000000000 - edges[x][1])\n    reconstructed_edges = [[]] * m\n    c = []\n    for i in range(1, n - 1):\n        c.append((i + 2, i))\n    heapify(c)\n    j = 1\n    for i in sorted_indices:\n        if edges[i][1] == 1:\n            reconstructed_edges[i] = [j, j + 1]\n            j += 1\n        else:\n            if not c:\n                return -1\n            z = heappop(c)\n            if j < z[0]:\n                return -1\n            else:\n                reconstructed_edges[i] = [z[1], z[0]]\n                if z[0] + 1 <= n:\n                    heappush(c, (z[0] + 1, z[1]))\n    return reconstructed_edges"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][1])",
      "mutated_line": "sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][2])",
      "code": "from heapq import heapify, heappop, heappush\n\ndef reconstruct_graph(n, m, edges):\n    sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][2])\n    reconstructed_edges = [[]] * m\n    c = []\n    for i in range(1, n - 1):\n        c.append((i + 2, i))\n    heapify(c)\n    j = 1\n    for i in sorted_indices:\n        if edges[i][1] == 1:\n            reconstructed_edges[i] = [j, j + 1]\n            j += 1\n        else:\n            if not c:\n                return -1\n            z = heappop(c)\n            if j < z[0]:\n                return -1\n            else:\n                reconstructed_edges[i] = [z[1], z[0]]\n                if z[0] + 1 <= n:\n                    heappush(c, (z[0] + 1, z[1]))\n    return reconstructed_edges"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][1])",
      "mutated_line": "sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][0])",
      "code": "from heapq import heapify, heappop, heappush\n\ndef reconstruct_graph(n, m, edges):\n    sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][0])\n    reconstructed_edges = [[]] * m\n    c = []\n    for i in range(1, n - 1):\n        c.append((i + 2, i))\n    heapify(c)\n    j = 1\n    for i in sorted_indices:\n        if edges[i][1] == 1:\n            reconstructed_edges[i] = [j, j + 1]\n            j += 1\n        else:\n            if not c:\n                return -1\n            z = heappop(c)\n            if j < z[0]:\n                return -1\n            else:\n                reconstructed_edges[i] = [z[1], z[0]]\n                if z[0] + 1 <= n:\n                    heappush(c, (z[0] + 1, z[1]))\n    return reconstructed_edges"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][1])",
      "mutated_line": "sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][0])",
      "code": "from heapq import heapify, heappop, heappush\n\ndef reconstruct_graph(n, m, edges):\n    sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][0])\n    reconstructed_edges = [[]] * m\n    c = []\n    for i in range(1, n - 1):\n        c.append((i + 2, i))\n    heapify(c)\n    j = 1\n    for i in sorted_indices:\n        if edges[i][1] == 1:\n            reconstructed_edges[i] = [j, j + 1]\n            j += 1\n        else:\n            if not c:\n                return -1\n            z = heappop(c)\n            if j < z[0]:\n                return -1\n            else:\n                reconstructed_edges[i] = [z[1], z[0]]\n                if z[0] + 1 <= n:\n                    heappush(c, (z[0] + 1, z[1]))\n    return reconstructed_edges"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][1])",
      "mutated_line": "sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][-1])",
      "code": "from heapq import heapify, heappop, heappush\n\ndef reconstruct_graph(n, m, edges):\n    sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][-1])\n    reconstructed_edges = [[]] * m\n    c = []\n    for i in range(1, n - 1):\n        c.append((i + 2, i))\n    heapify(c)\n    j = 1\n    for i in sorted_indices:\n        if edges[i][1] == 1:\n            reconstructed_edges[i] = [j, j + 1]\n            j += 1\n        else:\n            if not c:\n                return -1\n            z = heappop(c)\n            if j < z[0]:\n                return -1\n            else:\n                reconstructed_edges[i] = [z[1], z[0]]\n                if z[0] + 1 <= n:\n                    heappush(c, (z[0] + 1, z[1]))\n    return reconstructed_edges"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "reconstructed_edges[i] = [z[1], z[0]]",
      "mutated_line": "reconstructed_edges[i] = [z[2], z[0]]",
      "code": "from heapq import heapify, heappop, heappush\n\ndef reconstruct_graph(n, m, edges):\n    sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][1])\n    reconstructed_edges = [[]] * m\n    c = []\n    for i in range(1, n - 1):\n        c.append((i + 2, i))\n    heapify(c)\n    j = 1\n    for i in sorted_indices:\n        if edges[i][1] == 1:\n            reconstructed_edges[i] = [j, j + 1]\n            j += 1\n        else:\n            if not c:\n                return -1\n            z = heappop(c)\n            if j < z[0]:\n                return -1\n            else:\n                reconstructed_edges[i] = [z[2], z[0]]\n                if z[0] + 1 <= n:\n                    heappush(c, (z[0] + 1, z[1]))\n    return reconstructed_edges"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "reconstructed_edges[i] = [z[1], z[0]]",
      "mutated_line": "reconstructed_edges[i] = [z[0], z[0]]",
      "code": "from heapq import heapify, heappop, heappush\n\ndef reconstruct_graph(n, m, edges):\n    sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][1])\n    reconstructed_edges = [[]] * m\n    c = []\n    for i in range(1, n - 1):\n        c.append((i + 2, i))\n    heapify(c)\n    j = 1\n    for i in sorted_indices:\n        if edges[i][1] == 1:\n            reconstructed_edges[i] = [j, j + 1]\n            j += 1\n        else:\n            if not c:\n                return -1\n            z = heappop(c)\n            if j < z[0]:\n                return -1\n            else:\n                reconstructed_edges[i] = [z[0], z[0]]\n                if z[0] + 1 <= n:\n                    heappush(c, (z[0] + 1, z[1]))\n    return reconstructed_edges"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "reconstructed_edges[i] = [z[1], z[0]]",
      "mutated_line": "reconstructed_edges[i] = [z[0], z[0]]",
      "code": "from heapq import heapify, heappop, heappush\n\ndef reconstruct_graph(n, m, edges):\n    sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][1])\n    reconstructed_edges = [[]] * m\n    c = []\n    for i in range(1, n - 1):\n        c.append((i + 2, i))\n    heapify(c)\n    j = 1\n    for i in sorted_indices:\n        if edges[i][1] == 1:\n            reconstructed_edges[i] = [j, j + 1]\n            j += 1\n        else:\n            if not c:\n                return -1\n            z = heappop(c)\n            if j < z[0]:\n                return -1\n            else:\n                reconstructed_edges[i] = [z[0], z[0]]\n                if z[0] + 1 <= n:\n                    heappush(c, (z[0] + 1, z[1]))\n    return reconstructed_edges"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "reconstructed_edges[i] = [z[1], z[0]]",
      "mutated_line": "reconstructed_edges[i] = [z[-1], z[0]]",
      "code": "from heapq import heapify, heappop, heappush\n\ndef reconstruct_graph(n, m, edges):\n    sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][1])\n    reconstructed_edges = [[]] * m\n    c = []\n    for i in range(1, n - 1):\n        c.append((i + 2, i))\n    heapify(c)\n    j = 1\n    for i in sorted_indices:\n        if edges[i][1] == 1:\n            reconstructed_edges[i] = [j, j + 1]\n            j += 1\n        else:\n            if not c:\n                return -1\n            z = heappop(c)\n            if j < z[0]:\n                return -1\n            else:\n                reconstructed_edges[i] = [z[-1], z[0]]\n                if z[0] + 1 <= n:\n                    heappush(c, (z[0] + 1, z[1]))\n    return reconstructed_edges"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "reconstructed_edges[i] = [z[1], z[0]]",
      "mutated_line": "reconstructed_edges[i] = [z[1], z[1]]",
      "code": "from heapq import heapify, heappop, heappush\n\ndef reconstruct_graph(n, m, edges):\n    sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][1])\n    reconstructed_edges = [[]] * m\n    c = []\n    for i in range(1, n - 1):\n        c.append((i + 2, i))\n    heapify(c)\n    j = 1\n    for i in sorted_indices:\n        if edges[i][1] == 1:\n            reconstructed_edges[i] = [j, j + 1]\n            j += 1\n        else:\n            if not c:\n                return -1\n            z = heappop(c)\n            if j < z[0]:\n                return -1\n            else:\n                reconstructed_edges[i] = [z[1], z[1]]\n                if z[0] + 1 <= n:\n                    heappush(c, (z[0] + 1, z[1]))\n    return reconstructed_edges"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "reconstructed_edges[i] = [z[1], z[0]]",
      "mutated_line": "reconstructed_edges[i] = [z[1], z[-1]]",
      "code": "from heapq import heapify, heappop, heappush\n\ndef reconstruct_graph(n, m, edges):\n    sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][1])\n    reconstructed_edges = [[]] * m\n    c = []\n    for i in range(1, n - 1):\n        c.append((i + 2, i))\n    heapify(c)\n    j = 1\n    for i in sorted_indices:\n        if edges[i][1] == 1:\n            reconstructed_edges[i] = [j, j + 1]\n            j += 1\n        else:\n            if not c:\n                return -1\n            z = heappop(c)\n            if j < z[0]:\n                return -1\n            else:\n                reconstructed_edges[i] = [z[1], z[-1]]\n                if z[0] + 1 <= n:\n                    heappush(c, (z[0] + 1, z[1]))\n    return reconstructed_edges"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "reconstructed_edges[i] = [z[1], z[0]]",
      "mutated_line": "reconstructed_edges[i] = [z[1], z[1]]",
      "code": "from heapq import heapify, heappop, heappush\n\ndef reconstruct_graph(n, m, edges):\n    sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][1])\n    reconstructed_edges = [[]] * m\n    c = []\n    for i in range(1, n - 1):\n        c.append((i + 2, i))\n    heapify(c)\n    j = 1\n    for i in sorted_indices:\n        if edges[i][1] == 1:\n            reconstructed_edges[i] = [j, j + 1]\n            j += 1\n        else:\n            if not c:\n                return -1\n            z = heappop(c)\n            if j < z[0]:\n                return -1\n            else:\n                reconstructed_edges[i] = [z[1], z[1]]\n                if z[0] + 1 <= n:\n                    heappush(c, (z[0] + 1, z[1]))\n    return reconstructed_edges"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if z[0] + 1 <= n:",
      "mutated_line": "if z[0] + 2 <= n:",
      "code": "from heapq import heapify, heappop, heappush\n\ndef reconstruct_graph(n, m, edges):\n    sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][1])\n    reconstructed_edges = [[]] * m\n    c = []\n    for i in range(1, n - 1):\n        c.append((i + 2, i))\n    heapify(c)\n    j = 1\n    for i in sorted_indices:\n        if edges[i][1] == 1:\n            reconstructed_edges[i] = [j, j + 1]\n            j += 1\n        else:\n            if not c:\n                return -1\n            z = heappop(c)\n            if j < z[0]:\n                return -1\n            else:\n                reconstructed_edges[i] = [z[1], z[0]]\n                if z[0] + 2 <= n:\n                    heappush(c, (z[0] + 1, z[1]))\n    return reconstructed_edges"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if z[0] + 1 <= n:",
      "mutated_line": "if z[0] + 0 <= n:",
      "code": "from heapq import heapify, heappop, heappush\n\ndef reconstruct_graph(n, m, edges):\n    sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][1])\n    reconstructed_edges = [[]] * m\n    c = []\n    for i in range(1, n - 1):\n        c.append((i + 2, i))\n    heapify(c)\n    j = 1\n    for i in sorted_indices:\n        if edges[i][1] == 1:\n            reconstructed_edges[i] = [j, j + 1]\n            j += 1\n        else:\n            if not c:\n                return -1\n            z = heappop(c)\n            if j < z[0]:\n                return -1\n            else:\n                reconstructed_edges[i] = [z[1], z[0]]\n                if z[0] + 0 <= n:\n                    heappush(c, (z[0] + 1, z[1]))\n    return reconstructed_edges"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if z[0] + 1 <= n:",
      "mutated_line": "if z[0] + 0 <= n:",
      "code": "from heapq import heapify, heappop, heappush\n\ndef reconstruct_graph(n, m, edges):\n    sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][1])\n    reconstructed_edges = [[]] * m\n    c = []\n    for i in range(1, n - 1):\n        c.append((i + 2, i))\n    heapify(c)\n    j = 1\n    for i in sorted_indices:\n        if edges[i][1] == 1:\n            reconstructed_edges[i] = [j, j + 1]\n            j += 1\n        else:\n            if not c:\n                return -1\n            z = heappop(c)\n            if j < z[0]:\n                return -1\n            else:\n                reconstructed_edges[i] = [z[1], z[0]]\n                if z[0] + 0 <= n:\n                    heappush(c, (z[0] + 1, z[1]))\n    return reconstructed_edges"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if z[0] + 1 <= n:",
      "mutated_line": "if z[0] + -1 <= n:",
      "code": "from heapq import heapify, heappop, heappush\n\ndef reconstruct_graph(n, m, edges):\n    sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][1])\n    reconstructed_edges = [[]] * m\n    c = []\n    for i in range(1, n - 1):\n        c.append((i + 2, i))\n    heapify(c)\n    j = 1\n    for i in sorted_indices:\n        if edges[i][1] == 1:\n            reconstructed_edges[i] = [j, j + 1]\n            j += 1\n        else:\n            if not c:\n                return -1\n            z = heappop(c)\n            if j < z[0]:\n                return -1\n            else:\n                reconstructed_edges[i] = [z[1], z[0]]\n                if z[0] + -1 <= n:\n                    heappush(c, (z[0] + 1, z[1]))\n    return reconstructed_edges"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][1])",
      "mutated_line": "sorted_indices = sorted(range(m), key=lambda x: edges[x][1] * 10000000000 - edges[x][1])",
      "code": "from heapq import heapify, heappop, heappush\n\ndef reconstruct_graph(n, m, edges):\n    sorted_indices = sorted(range(m), key=lambda x: edges[x][1] * 10000000000 - edges[x][1])\n    reconstructed_edges = [[]] * m\n    c = []\n    for i in range(1, n - 1):\n        c.append((i + 2, i))\n    heapify(c)\n    j = 1\n    for i in sorted_indices:\n        if edges[i][1] == 1:\n            reconstructed_edges[i] = [j, j + 1]\n            j += 1\n        else:\n            if not c:\n                return -1\n            z = heappop(c)\n            if j < z[0]:\n                return -1\n            else:\n                reconstructed_edges[i] = [z[1], z[0]]\n                if z[0] + 1 <= n:\n                    heappush(c, (z[0] + 1, z[1]))\n    return reconstructed_edges"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][1])",
      "mutated_line": "sorted_indices = sorted(range(m), key=lambda x: edges[x][-1] * 10000000000 - edges[x][1])",
      "code": "from heapq import heapify, heappop, heappush\n\ndef reconstruct_graph(n, m, edges):\n    sorted_indices = sorted(range(m), key=lambda x: edges[x][-1] * 10000000000 - edges[x][1])\n    reconstructed_edges = [[]] * m\n    c = []\n    for i in range(1, n - 1):\n        c.append((i + 2, i))\n    heapify(c)\n    j = 1\n    for i in sorted_indices:\n        if edges[i][1] == 1:\n            reconstructed_edges[i] = [j, j + 1]\n            j += 1\n        else:\n            if not c:\n                return -1\n            z = heappop(c)\n            if j < z[0]:\n                return -1\n            else:\n                reconstructed_edges[i] = [z[1], z[0]]\n                if z[0] + 1 <= n:\n                    heappush(c, (z[0] + 1, z[1]))\n    return reconstructed_edges"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][1])",
      "mutated_line": "sorted_indices = sorted(range(m), key=lambda x: edges[x][1] * 10000000000 - edges[x][1])",
      "code": "from heapq import heapify, heappop, heappush\n\ndef reconstruct_graph(n, m, edges):\n    sorted_indices = sorted(range(m), key=lambda x: edges[x][1] * 10000000000 - edges[x][1])\n    reconstructed_edges = [[]] * m\n    c = []\n    for i in range(1, n - 1):\n        c.append((i + 2, i))\n    heapify(c)\n    j = 1\n    for i in sorted_indices:\n        if edges[i][1] == 1:\n            reconstructed_edges[i] = [j, j + 1]\n            j += 1\n        else:\n            if not c:\n                return -1\n            z = heappop(c)\n            if j < z[0]:\n                return -1\n            else:\n                reconstructed_edges[i] = [z[1], z[0]]\n                if z[0] + 1 <= n:\n                    heappush(c, (z[0] + 1, z[1]))\n    return reconstructed_edges"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if z[0] + 1 <= n:",
      "mutated_line": "if z[1] + 1 <= n:",
      "code": "from heapq import heapify, heappop, heappush\n\ndef reconstruct_graph(n, m, edges):\n    sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][1])\n    reconstructed_edges = [[]] * m\n    c = []\n    for i in range(1, n - 1):\n        c.append((i + 2, i))\n    heapify(c)\n    j = 1\n    for i in sorted_indices:\n        if edges[i][1] == 1:\n            reconstructed_edges[i] = [j, j + 1]\n            j += 1\n        else:\n            if not c:\n                return -1\n            z = heappop(c)\n            if j < z[0]:\n                return -1\n            else:\n                reconstructed_edges[i] = [z[1], z[0]]\n                if z[1] + 1 <= n:\n                    heappush(c, (z[0] + 1, z[1]))\n    return reconstructed_edges"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if z[0] + 1 <= n:",
      "mutated_line": "if z[-1] + 1 <= n:",
      "code": "from heapq import heapify, heappop, heappush\n\ndef reconstruct_graph(n, m, edges):\n    sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][1])\n    reconstructed_edges = [[]] * m\n    c = []\n    for i in range(1, n - 1):\n        c.append((i + 2, i))\n    heapify(c)\n    j = 1\n    for i in sorted_indices:\n        if edges[i][1] == 1:\n            reconstructed_edges[i] = [j, j + 1]\n            j += 1\n        else:\n            if not c:\n                return -1\n            z = heappop(c)\n            if j < z[0]:\n                return -1\n            else:\n                reconstructed_edges[i] = [z[1], z[0]]\n                if z[-1] + 1 <= n:\n                    heappush(c, (z[0] + 1, z[1]))\n    return reconstructed_edges"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if z[0] + 1 <= n:",
      "mutated_line": "if z[1] + 1 <= n:",
      "code": "from heapq import heapify, heappop, heappush\n\ndef reconstruct_graph(n, m, edges):\n    sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][1])\n    reconstructed_edges = [[]] * m\n    c = []\n    for i in range(1, n - 1):\n        c.append((i + 2, i))\n    heapify(c)\n    j = 1\n    for i in sorted_indices:\n        if edges[i][1] == 1:\n            reconstructed_edges[i] = [j, j + 1]\n            j += 1\n        else:\n            if not c:\n                return -1\n            z = heappop(c)\n            if j < z[0]:\n                return -1\n            else:\n                reconstructed_edges[i] = [z[1], z[0]]\n                if z[1] + 1 <= n:\n                    heappush(c, (z[0] + 1, z[1]))\n    return reconstructed_edges"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "heappush(c, (z[0] + 1, z[1]))",
      "mutated_line": "heappush(c, (z[0] - 1, z[1]))",
      "code": "from heapq import heapify, heappop, heappush\n\ndef reconstruct_graph(n, m, edges):\n    sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][1])\n    reconstructed_edges = [[]] * m\n    c = []\n    for i in range(1, n - 1):\n        c.append((i + 2, i))\n    heapify(c)\n    j = 1\n    for i in sorted_indices:\n        if edges[i][1] == 1:\n            reconstructed_edges[i] = [j, j + 1]\n            j += 1\n        else:\n            if not c:\n                return -1\n            z = heappop(c)\n            if j < z[0]:\n                return -1\n            else:\n                reconstructed_edges[i] = [z[1], z[0]]\n                if z[0] + 1 <= n:\n                    heappush(c, (z[0] - 1, z[1]))\n    return reconstructed_edges"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "heappush(c, (z[0] + 1, z[1]))",
      "mutated_line": "heappush(c, (z[0] * 1, z[1]))",
      "code": "from heapq import heapify, heappop, heappush\n\ndef reconstruct_graph(n, m, edges):\n    sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][1])\n    reconstructed_edges = [[]] * m\n    c = []\n    for i in range(1, n - 1):\n        c.append((i + 2, i))\n    heapify(c)\n    j = 1\n    for i in sorted_indices:\n        if edges[i][1] == 1:\n            reconstructed_edges[i] = [j, j + 1]\n            j += 1\n        else:\n            if not c:\n                return -1\n            z = heappop(c)\n            if j < z[0]:\n                return -1\n            else:\n                reconstructed_edges[i] = [z[1], z[0]]\n                if z[0] + 1 <= n:\n                    heappush(c, (z[0] * 1, z[1]))\n    return reconstructed_edges"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "heappush(c, (z[0] + 1, z[1]))",
      "mutated_line": "heappush(c, (z[0] + 2, z[1]))",
      "code": "from heapq import heapify, heappop, heappush\n\ndef reconstruct_graph(n, m, edges):\n    sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][1])\n    reconstructed_edges = [[]] * m\n    c = []\n    for i in range(1, n - 1):\n        c.append((i + 2, i))\n    heapify(c)\n    j = 1\n    for i in sorted_indices:\n        if edges[i][1] == 1:\n            reconstructed_edges[i] = [j, j + 1]\n            j += 1\n        else:\n            if not c:\n                return -1\n            z = heappop(c)\n            if j < z[0]:\n                return -1\n            else:\n                reconstructed_edges[i] = [z[1], z[0]]\n                if z[0] + 1 <= n:\n                    heappush(c, (z[0] + 2, z[1]))\n    return reconstructed_edges"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "heappush(c, (z[0] + 1, z[1]))",
      "mutated_line": "heappush(c, (z[0] + 0, z[1]))",
      "code": "from heapq import heapify, heappop, heappush\n\ndef reconstruct_graph(n, m, edges):\n    sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][1])\n    reconstructed_edges = [[]] * m\n    c = []\n    for i in range(1, n - 1):\n        c.append((i + 2, i))\n    heapify(c)\n    j = 1\n    for i in sorted_indices:\n        if edges[i][1] == 1:\n            reconstructed_edges[i] = [j, j + 1]\n            j += 1\n        else:\n            if not c:\n                return -1\n            z = heappop(c)\n            if j < z[0]:\n                return -1\n            else:\n                reconstructed_edges[i] = [z[1], z[0]]\n                if z[0] + 1 <= n:\n                    heappush(c, (z[0] + 0, z[1]))\n    return reconstructed_edges"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "heappush(c, (z[0] + 1, z[1]))",
      "mutated_line": "heappush(c, (z[0] + 0, z[1]))",
      "code": "from heapq import heapify, heappop, heappush\n\ndef reconstruct_graph(n, m, edges):\n    sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][1])\n    reconstructed_edges = [[]] * m\n    c = []\n    for i in range(1, n - 1):\n        c.append((i + 2, i))\n    heapify(c)\n    j = 1\n    for i in sorted_indices:\n        if edges[i][1] == 1:\n            reconstructed_edges[i] = [j, j + 1]\n            j += 1\n        else:\n            if not c:\n                return -1\n            z = heappop(c)\n            if j < z[0]:\n                return -1\n            else:\n                reconstructed_edges[i] = [z[1], z[0]]\n                if z[0] + 1 <= n:\n                    heappush(c, (z[0] + 0, z[1]))\n    return reconstructed_edges"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "heappush(c, (z[0] + 1, z[1]))",
      "mutated_line": "heappush(c, (z[0] + -1, z[1]))",
      "code": "from heapq import heapify, heappop, heappush\n\ndef reconstruct_graph(n, m, edges):\n    sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][1])\n    reconstructed_edges = [[]] * m\n    c = []\n    for i in range(1, n - 1):\n        c.append((i + 2, i))\n    heapify(c)\n    j = 1\n    for i in sorted_indices:\n        if edges[i][1] == 1:\n            reconstructed_edges[i] = [j, j + 1]\n            j += 1\n        else:\n            if not c:\n                return -1\n            z = heappop(c)\n            if j < z[0]:\n                return -1\n            else:\n                reconstructed_edges[i] = [z[1], z[0]]\n                if z[0] + 1 <= n:\n                    heappush(c, (z[0] + -1, z[1]))\n    return reconstructed_edges"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "heappush(c, (z[0] + 1, z[1]))",
      "mutated_line": "heappush(c, (z[0] + 1, z[2]))",
      "code": "from heapq import heapify, heappop, heappush\n\ndef reconstruct_graph(n, m, edges):\n    sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][1])\n    reconstructed_edges = [[]] * m\n    c = []\n    for i in range(1, n - 1):\n        c.append((i + 2, i))\n    heapify(c)\n    j = 1\n    for i in sorted_indices:\n        if edges[i][1] == 1:\n            reconstructed_edges[i] = [j, j + 1]\n            j += 1\n        else:\n            if not c:\n                return -1\n            z = heappop(c)\n            if j < z[0]:\n                return -1\n            else:\n                reconstructed_edges[i] = [z[1], z[0]]\n                if z[0] + 1 <= n:\n                    heappush(c, (z[0] + 1, z[2]))\n    return reconstructed_edges"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "heappush(c, (z[0] + 1, z[1]))",
      "mutated_line": "heappush(c, (z[0] + 1, z[0]))",
      "code": "from heapq import heapify, heappop, heappush\n\ndef reconstruct_graph(n, m, edges):\n    sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][1])\n    reconstructed_edges = [[]] * m\n    c = []\n    for i in range(1, n - 1):\n        c.append((i + 2, i))\n    heapify(c)\n    j = 1\n    for i in sorted_indices:\n        if edges[i][1] == 1:\n            reconstructed_edges[i] = [j, j + 1]\n            j += 1\n        else:\n            if not c:\n                return -1\n            z = heappop(c)\n            if j < z[0]:\n                return -1\n            else:\n                reconstructed_edges[i] = [z[1], z[0]]\n                if z[0] + 1 <= n:\n                    heappush(c, (z[0] + 1, z[0]))\n    return reconstructed_edges"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "heappush(c, (z[0] + 1, z[1]))",
      "mutated_line": "heappush(c, (z[0] + 1, z[0]))",
      "code": "from heapq import heapify, heappop, heappush\n\ndef reconstruct_graph(n, m, edges):\n    sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][1])\n    reconstructed_edges = [[]] * m\n    c = []\n    for i in range(1, n - 1):\n        c.append((i + 2, i))\n    heapify(c)\n    j = 1\n    for i in sorted_indices:\n        if edges[i][1] == 1:\n            reconstructed_edges[i] = [j, j + 1]\n            j += 1\n        else:\n            if not c:\n                return -1\n            z = heappop(c)\n            if j < z[0]:\n                return -1\n            else:\n                reconstructed_edges[i] = [z[1], z[0]]\n                if z[0] + 1 <= n:\n                    heappush(c, (z[0] + 1, z[0]))\n    return reconstructed_edges"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "heappush(c, (z[0] + 1, z[1]))",
      "mutated_line": "heappush(c, (z[0] + 1, z[-1]))",
      "code": "from heapq import heapify, heappop, heappush\n\ndef reconstruct_graph(n, m, edges):\n    sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][1])\n    reconstructed_edges = [[]] * m\n    c = []\n    for i in range(1, n - 1):\n        c.append((i + 2, i))\n    heapify(c)\n    j = 1\n    for i in sorted_indices:\n        if edges[i][1] == 1:\n            reconstructed_edges[i] = [j, j + 1]\n            j += 1\n        else:\n            if not c:\n                return -1\n            z = heappop(c)\n            if j < z[0]:\n                return -1\n            else:\n                reconstructed_edges[i] = [z[1], z[0]]\n                if z[0] + 1 <= n:\n                    heappush(c, (z[0] + 1, z[-1]))\n    return reconstructed_edges"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "heappush(c, (z[0] + 1, z[1]))",
      "mutated_line": "heappush(c, (z[1] + 1, z[1]))",
      "code": "from heapq import heapify, heappop, heappush\n\ndef reconstruct_graph(n, m, edges):\n    sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][1])\n    reconstructed_edges = [[]] * m\n    c = []\n    for i in range(1, n - 1):\n        c.append((i + 2, i))\n    heapify(c)\n    j = 1\n    for i in sorted_indices:\n        if edges[i][1] == 1:\n            reconstructed_edges[i] = [j, j + 1]\n            j += 1\n        else:\n            if not c:\n                return -1\n            z = heappop(c)\n            if j < z[0]:\n                return -1\n            else:\n                reconstructed_edges[i] = [z[1], z[0]]\n                if z[0] + 1 <= n:\n                    heappush(c, (z[1] + 1, z[1]))\n    return reconstructed_edges"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "heappush(c, (z[0] + 1, z[1]))",
      "mutated_line": "heappush(c, (z[-1] + 1, z[1]))",
      "code": "from heapq import heapify, heappop, heappush\n\ndef reconstruct_graph(n, m, edges):\n    sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][1])\n    reconstructed_edges = [[]] * m\n    c = []\n    for i in range(1, n - 1):\n        c.append((i + 2, i))\n    heapify(c)\n    j = 1\n    for i in sorted_indices:\n        if edges[i][1] == 1:\n            reconstructed_edges[i] = [j, j + 1]\n            j += 1\n        else:\n            if not c:\n                return -1\n            z = heappop(c)\n            if j < z[0]:\n                return -1\n            else:\n                reconstructed_edges[i] = [z[1], z[0]]\n                if z[0] + 1 <= n:\n                    heappush(c, (z[-1] + 1, z[1]))\n    return reconstructed_edges"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "heappush(c, (z[0] + 1, z[1]))",
      "mutated_line": "heappush(c, (z[1] + 1, z[1]))",
      "code": "from heapq import heapify, heappop, heappush\n\ndef reconstruct_graph(n, m, edges):\n    sorted_indices = sorted(range(m), key=lambda x: edges[x][0] * 10000000000 - edges[x][1])\n    reconstructed_edges = [[]] * m\n    c = []\n    for i in range(1, n - 1):\n        c.append((i + 2, i))\n    heapify(c)\n    j = 1\n    for i in sorted_indices:\n        if edges[i][1] == 1:\n            reconstructed_edges[i] = [j, j + 1]\n            j += 1\n        else:\n            if not c:\n                return -1\n            z = heappop(c)\n            if j < z[0]:\n                return -1\n            else:\n                reconstructed_edges[i] = [z[1], z[0]]\n                if z[0] + 1 <= n:\n                    heappush(c, (z[1] + 1, z[1]))\n    return reconstructed_edges"
    }
  ]
}