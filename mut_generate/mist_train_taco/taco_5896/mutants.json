{
  "task_id": "taco_5896",
  "entry_point": "calculate_minimum_cost",
  "mutant_count": 71,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "import heapq\n\ndef calculate_minimum_cost(voters):\n    \"\"\"\"\"\"\n    voters.sort()\n    prices = []\n    cost = 0\n    bribed = 0\n    i = len(voters) - 1\n    while i >= 0:\n        currM = voters[i][0]\n        heapq.heappush(prices, voters[i][1])\n        while i >= 1 and voters[i - 1][0] == currM:\n            i -= 1\n            heapq.heappush(prices, voters[i][1])\n        already = i + bribed\n        for k in range(max(0, currM - already)):\n            cost += heapq.heappop(prices)\n            bribed += 1\n        i -= 1\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "cost = 0",
      "mutated_line": "cost = 1",
      "code": "import heapq\n\ndef calculate_minimum_cost(voters):\n    \"\"\"\n    Calculate the minimum number of coins required to ensure everyone votes for you.\n\n    Parameters:\n    voters (list of tuples): A list of tuples where each tuple contains two integers (m_i, p_i).\n                             m_i is the number of other voters needed to convince the i-th voter.\n                             p_i is the cost to pay the i-th voter.\n\n    Returns:\n    int: The minimum number of coins required.\n    \"\"\"\n    voters.sort()\n    prices = []\n    cost = 1\n    bribed = 0\n    i = len(voters) - 1\n    while i >= 0:\n        currM = voters[i][0]\n        heapq.heappush(prices, voters[i][1])\n        while i >= 1 and voters[i - 1][0] == currM:\n            i -= 1\n            heapq.heappush(prices, voters[i][1])\n        already = i + bribed\n        for k in range(max(0, currM - already)):\n            cost += heapq.heappop(prices)\n            bribed += 1\n        i -= 1\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "cost = 0",
      "mutated_line": "cost = -1",
      "code": "import heapq\n\ndef calculate_minimum_cost(voters):\n    \"\"\"\n    Calculate the minimum number of coins required to ensure everyone votes for you.\n\n    Parameters:\n    voters (list of tuples): A list of tuples where each tuple contains two integers (m_i, p_i).\n                             m_i is the number of other voters needed to convince the i-th voter.\n                             p_i is the cost to pay the i-th voter.\n\n    Returns:\n    int: The minimum number of coins required.\n    \"\"\"\n    voters.sort()\n    prices = []\n    cost = -1\n    bribed = 0\n    i = len(voters) - 1\n    while i >= 0:\n        currM = voters[i][0]\n        heapq.heappush(prices, voters[i][1])\n        while i >= 1 and voters[i - 1][0] == currM:\n            i -= 1\n            heapq.heappush(prices, voters[i][1])\n        already = i + bribed\n        for k in range(max(0, currM - already)):\n            cost += heapq.heappop(prices)\n            bribed += 1\n        i -= 1\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "cost = 0",
      "mutated_line": "cost = 1",
      "code": "import heapq\n\ndef calculate_minimum_cost(voters):\n    \"\"\"\n    Calculate the minimum number of coins required to ensure everyone votes for you.\n\n    Parameters:\n    voters (list of tuples): A list of tuples where each tuple contains two integers (m_i, p_i).\n                             m_i is the number of other voters needed to convince the i-th voter.\n                             p_i is the cost to pay the i-th voter.\n\n    Returns:\n    int: The minimum number of coins required.\n    \"\"\"\n    voters.sort()\n    prices = []\n    cost = 1\n    bribed = 0\n    i = len(voters) - 1\n    while i >= 0:\n        currM = voters[i][0]\n        heapq.heappush(prices, voters[i][1])\n        while i >= 1 and voters[i - 1][0] == currM:\n            i -= 1\n            heapq.heappush(prices, voters[i][1])\n        already = i + bribed\n        for k in range(max(0, currM - already)):\n            cost += heapq.heappop(prices)\n            bribed += 1\n        i -= 1\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "bribed = 0",
      "mutated_line": "bribed = 1",
      "code": "import heapq\n\ndef calculate_minimum_cost(voters):\n    \"\"\"\n    Calculate the minimum number of coins required to ensure everyone votes for you.\n\n    Parameters:\n    voters (list of tuples): A list of tuples where each tuple contains two integers (m_i, p_i).\n                             m_i is the number of other voters needed to convince the i-th voter.\n                             p_i is the cost to pay the i-th voter.\n\n    Returns:\n    int: The minimum number of coins required.\n    \"\"\"\n    voters.sort()\n    prices = []\n    cost = 0\n    bribed = 1\n    i = len(voters) - 1\n    while i >= 0:\n        currM = voters[i][0]\n        heapq.heappush(prices, voters[i][1])\n        while i >= 1 and voters[i - 1][0] == currM:\n            i -= 1\n            heapq.heappush(prices, voters[i][1])\n        already = i + bribed\n        for k in range(max(0, currM - already)):\n            cost += heapq.heappop(prices)\n            bribed += 1\n        i -= 1\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "bribed = 0",
      "mutated_line": "bribed = -1",
      "code": "import heapq\n\ndef calculate_minimum_cost(voters):\n    \"\"\"\n    Calculate the minimum number of coins required to ensure everyone votes for you.\n\n    Parameters:\n    voters (list of tuples): A list of tuples where each tuple contains two integers (m_i, p_i).\n                             m_i is the number of other voters needed to convince the i-th voter.\n                             p_i is the cost to pay the i-th voter.\n\n    Returns:\n    int: The minimum number of coins required.\n    \"\"\"\n    voters.sort()\n    prices = []\n    cost = 0\n    bribed = -1\n    i = len(voters) - 1\n    while i >= 0:\n        currM = voters[i][0]\n        heapq.heappush(prices, voters[i][1])\n        while i >= 1 and voters[i - 1][0] == currM:\n            i -= 1\n            heapq.heappush(prices, voters[i][1])\n        already = i + bribed\n        for k in range(max(0, currM - already)):\n            cost += heapq.heappop(prices)\n            bribed += 1\n        i -= 1\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "bribed = 0",
      "mutated_line": "bribed = 1",
      "code": "import heapq\n\ndef calculate_minimum_cost(voters):\n    \"\"\"\n    Calculate the minimum number of coins required to ensure everyone votes for you.\n\n    Parameters:\n    voters (list of tuples): A list of tuples where each tuple contains two integers (m_i, p_i).\n                             m_i is the number of other voters needed to convince the i-th voter.\n                             p_i is the cost to pay the i-th voter.\n\n    Returns:\n    int: The minimum number of coins required.\n    \"\"\"\n    voters.sort()\n    prices = []\n    cost = 0\n    bribed = 1\n    i = len(voters) - 1\n    while i >= 0:\n        currM = voters[i][0]\n        heapq.heappush(prices, voters[i][1])\n        while i >= 1 and voters[i - 1][0] == currM:\n            i -= 1\n            heapq.heappush(prices, voters[i][1])\n        already = i + bribed\n        for k in range(max(0, currM - already)):\n            cost += heapq.heappop(prices)\n            bribed += 1\n        i -= 1\n    return cost"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "i = len(voters) - 1",
      "mutated_line": "i = len(voters) + 1",
      "code": "import heapq\n\ndef calculate_minimum_cost(voters):\n    \"\"\"\n    Calculate the minimum number of coins required to ensure everyone votes for you.\n\n    Parameters:\n    voters (list of tuples): A list of tuples where each tuple contains two integers (m_i, p_i).\n                             m_i is the number of other voters needed to convince the i-th voter.\n                             p_i is the cost to pay the i-th voter.\n\n    Returns:\n    int: The minimum number of coins required.\n    \"\"\"\n    voters.sort()\n    prices = []\n    cost = 0\n    bribed = 0\n    i = len(voters) + 1\n    while i >= 0:\n        currM = voters[i][0]\n        heapq.heappush(prices, voters[i][1])\n        while i >= 1 and voters[i - 1][0] == currM:\n            i -= 1\n            heapq.heappush(prices, voters[i][1])\n        already = i + bribed\n        for k in range(max(0, currM - already)):\n            cost += heapq.heappop(prices)\n            bribed += 1\n        i -= 1\n    return cost"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "i = len(voters) - 1",
      "mutated_line": "i = len(voters) * 1",
      "code": "import heapq\n\ndef calculate_minimum_cost(voters):\n    \"\"\"\n    Calculate the minimum number of coins required to ensure everyone votes for you.\n\n    Parameters:\n    voters (list of tuples): A list of tuples where each tuple contains two integers (m_i, p_i).\n                             m_i is the number of other voters needed to convince the i-th voter.\n                             p_i is the cost to pay the i-th voter.\n\n    Returns:\n    int: The minimum number of coins required.\n    \"\"\"\n    voters.sort()\n    prices = []\n    cost = 0\n    bribed = 0\n    i = len(voters) * 1\n    while i >= 0:\n        currM = voters[i][0]\n        heapq.heappush(prices, voters[i][1])\n        while i >= 1 and voters[i - 1][0] == currM:\n            i -= 1\n            heapq.heappush(prices, voters[i][1])\n        already = i + bribed\n        for k in range(max(0, currM - already)):\n            cost += heapq.heappop(prices)\n            bribed += 1\n        i -= 1\n    return cost"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "while i >= 0:",
      "mutated_line": "while i > 0:",
      "code": "import heapq\n\ndef calculate_minimum_cost(voters):\n    \"\"\"\n    Calculate the minimum number of coins required to ensure everyone votes for you.\n\n    Parameters:\n    voters (list of tuples): A list of tuples where each tuple contains two integers (m_i, p_i).\n                             m_i is the number of other voters needed to convince the i-th voter.\n                             p_i is the cost to pay the i-th voter.\n\n    Returns:\n    int: The minimum number of coins required.\n    \"\"\"\n    voters.sort()\n    prices = []\n    cost = 0\n    bribed = 0\n    i = len(voters) - 1\n    while i > 0:\n        currM = voters[i][0]\n        heapq.heappush(prices, voters[i][1])\n        while i >= 1 and voters[i - 1][0] == currM:\n            i -= 1\n            heapq.heappush(prices, voters[i][1])\n        already = i + bribed\n        for k in range(max(0, currM - already)):\n            cost += heapq.heappop(prices)\n            bribed += 1\n        i -= 1\n    return cost"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "while i >= 0:",
      "mutated_line": "while i < 0:",
      "code": "import heapq\n\ndef calculate_minimum_cost(voters):\n    \"\"\"\n    Calculate the minimum number of coins required to ensure everyone votes for you.\n\n    Parameters:\n    voters (list of tuples): A list of tuples where each tuple contains two integers (m_i, p_i).\n                             m_i is the number of other voters needed to convince the i-th voter.\n                             p_i is the cost to pay the i-th voter.\n\n    Returns:\n    int: The minimum number of coins required.\n    \"\"\"\n    voters.sort()\n    prices = []\n    cost = 0\n    bribed = 0\n    i = len(voters) - 1\n    while i < 0:\n        currM = voters[i][0]\n        heapq.heappush(prices, voters[i][1])\n        while i >= 1 and voters[i - 1][0] == currM:\n            i -= 1\n            heapq.heappush(prices, voters[i][1])\n        already = i + bribed\n        for k in range(max(0, currM - already)):\n            cost += heapq.heappop(prices)\n            bribed += 1\n        i -= 1\n    return cost"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "while i >= 0:",
      "mutated_line": "while i == 0:",
      "code": "import heapq\n\ndef calculate_minimum_cost(voters):\n    \"\"\"\n    Calculate the minimum number of coins required to ensure everyone votes for you.\n\n    Parameters:\n    voters (list of tuples): A list of tuples where each tuple contains two integers (m_i, p_i).\n                             m_i is the number of other voters needed to convince the i-th voter.\n                             p_i is the cost to pay the i-th voter.\n\n    Returns:\n    int: The minimum number of coins required.\n    \"\"\"\n    voters.sort()\n    prices = []\n    cost = 0\n    bribed = 0\n    i = len(voters) - 1\n    while i == 0:\n        currM = voters[i][0]\n        heapq.heappush(prices, voters[i][1])\n        while i >= 1 and voters[i - 1][0] == currM:\n            i -= 1\n            heapq.heappush(prices, voters[i][1])\n        already = i + bribed\n        for k in range(max(0, currM - already)):\n            cost += heapq.heappop(prices)\n            bribed += 1\n        i -= 1\n    return cost"
    },
    {
      "operator": "ASR",
      "lineno": 34,
      "original_line": "i -= 1",
      "mutated_line": "i += 1",
      "code": "import heapq\n\ndef calculate_minimum_cost(voters):\n    \"\"\"\n    Calculate the minimum number of coins required to ensure everyone votes for you.\n\n    Parameters:\n    voters (list of tuples): A list of tuples where each tuple contains two integers (m_i, p_i).\n                             m_i is the number of other voters needed to convince the i-th voter.\n                             p_i is the cost to pay the i-th voter.\n\n    Returns:\n    int: The minimum number of coins required.\n    \"\"\"\n    voters.sort()\n    prices = []\n    cost = 0\n    bribed = 0\n    i = len(voters) - 1\n    while i >= 0:\n        currM = voters[i][0]\n        heapq.heappush(prices, voters[i][1])\n        while i >= 1 and voters[i - 1][0] == currM:\n            i -= 1\n            heapq.heappush(prices, voters[i][1])\n        already = i + bribed\n        for k in range(max(0, currM - already)):\n            cost += heapq.heappop(prices)\n            bribed += 1\n        i += 1\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "i = len(voters) - 1",
      "mutated_line": "i = len(voters) - 2",
      "code": "import heapq\n\ndef calculate_minimum_cost(voters):\n    \"\"\"\n    Calculate the minimum number of coins required to ensure everyone votes for you.\n\n    Parameters:\n    voters (list of tuples): A list of tuples where each tuple contains two integers (m_i, p_i).\n                             m_i is the number of other voters needed to convince the i-th voter.\n                             p_i is the cost to pay the i-th voter.\n\n    Returns:\n    int: The minimum number of coins required.\n    \"\"\"\n    voters.sort()\n    prices = []\n    cost = 0\n    bribed = 0\n    i = len(voters) - 2\n    while i >= 0:\n        currM = voters[i][0]\n        heapq.heappush(prices, voters[i][1])\n        while i >= 1 and voters[i - 1][0] == currM:\n            i -= 1\n            heapq.heappush(prices, voters[i][1])\n        already = i + bribed\n        for k in range(max(0, currM - already)):\n            cost += heapq.heappop(prices)\n            bribed += 1\n        i -= 1\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "i = len(voters) - 1",
      "mutated_line": "i = len(voters) - 0",
      "code": "import heapq\n\ndef calculate_minimum_cost(voters):\n    \"\"\"\n    Calculate the minimum number of coins required to ensure everyone votes for you.\n\n    Parameters:\n    voters (list of tuples): A list of tuples where each tuple contains two integers (m_i, p_i).\n                             m_i is the number of other voters needed to convince the i-th voter.\n                             p_i is the cost to pay the i-th voter.\n\n    Returns:\n    int: The minimum number of coins required.\n    \"\"\"\n    voters.sort()\n    prices = []\n    cost = 0\n    bribed = 0\n    i = len(voters) - 0\n    while i >= 0:\n        currM = voters[i][0]\n        heapq.heappush(prices, voters[i][1])\n        while i >= 1 and voters[i - 1][0] == currM:\n            i -= 1\n            heapq.heappush(prices, voters[i][1])\n        already = i + bribed\n        for k in range(max(0, currM - already)):\n            cost += heapq.heappop(prices)\n            bribed += 1\n        i -= 1\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "i = len(voters) - 1",
      "mutated_line": "i = len(voters) - 0",
      "code": "import heapq\n\ndef calculate_minimum_cost(voters):\n    \"\"\"\n    Calculate the minimum number of coins required to ensure everyone votes for you.\n\n    Parameters:\n    voters (list of tuples): A list of tuples where each tuple contains two integers (m_i, p_i).\n                             m_i is the number of other voters needed to convince the i-th voter.\n                             p_i is the cost to pay the i-th voter.\n\n    Returns:\n    int: The minimum number of coins required.\n    \"\"\"\n    voters.sort()\n    prices = []\n    cost = 0\n    bribed = 0\n    i = len(voters) - 0\n    while i >= 0:\n        currM = voters[i][0]\n        heapq.heappush(prices, voters[i][1])\n        while i >= 1 and voters[i - 1][0] == currM:\n            i -= 1\n            heapq.heappush(prices, voters[i][1])\n        already = i + bribed\n        for k in range(max(0, currM - already)):\n            cost += heapq.heappop(prices)\n            bribed += 1\n        i -= 1\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "i = len(voters) - 1",
      "mutated_line": "i = len(voters) - -1",
      "code": "import heapq\n\ndef calculate_minimum_cost(voters):\n    \"\"\"\n    Calculate the minimum number of coins required to ensure everyone votes for you.\n\n    Parameters:\n    voters (list of tuples): A list of tuples where each tuple contains two integers (m_i, p_i).\n                             m_i is the number of other voters needed to convince the i-th voter.\n                             p_i is the cost to pay the i-th voter.\n\n    Returns:\n    int: The minimum number of coins required.\n    \"\"\"\n    voters.sort()\n    prices = []\n    cost = 0\n    bribed = 0\n    i = len(voters) - -1\n    while i >= 0:\n        currM = voters[i][0]\n        heapq.heappush(prices, voters[i][1])\n        while i >= 1 and voters[i - 1][0] == currM:\n            i -= 1\n            heapq.heappush(prices, voters[i][1])\n        already = i + bribed\n        for k in range(max(0, currM - already)):\n            cost += heapq.heappop(prices)\n            bribed += 1\n        i -= 1\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "while i >= 0:",
      "mutated_line": "while i >= 1:",
      "code": "import heapq\n\ndef calculate_minimum_cost(voters):\n    \"\"\"\n    Calculate the minimum number of coins required to ensure everyone votes for you.\n\n    Parameters:\n    voters (list of tuples): A list of tuples where each tuple contains two integers (m_i, p_i).\n                             m_i is the number of other voters needed to convince the i-th voter.\n                             p_i is the cost to pay the i-th voter.\n\n    Returns:\n    int: The minimum number of coins required.\n    \"\"\"\n    voters.sort()\n    prices = []\n    cost = 0\n    bribed = 0\n    i = len(voters) - 1\n    while i >= 1:\n        currM = voters[i][0]\n        heapq.heappush(prices, voters[i][1])\n        while i >= 1 and voters[i - 1][0] == currM:\n            i -= 1\n            heapq.heappush(prices, voters[i][1])\n        already = i + bribed\n        for k in range(max(0, currM - already)):\n            cost += heapq.heappop(prices)\n            bribed += 1\n        i -= 1\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "while i >= 0:",
      "mutated_line": "while i >= -1:",
      "code": "import heapq\n\ndef calculate_minimum_cost(voters):\n    \"\"\"\n    Calculate the minimum number of coins required to ensure everyone votes for you.\n\n    Parameters:\n    voters (list of tuples): A list of tuples where each tuple contains two integers (m_i, p_i).\n                             m_i is the number of other voters needed to convince the i-th voter.\n                             p_i is the cost to pay the i-th voter.\n\n    Returns:\n    int: The minimum number of coins required.\n    \"\"\"\n    voters.sort()\n    prices = []\n    cost = 0\n    bribed = 0\n    i = len(voters) - 1\n    while i >= -1:\n        currM = voters[i][0]\n        heapq.heappush(prices, voters[i][1])\n        while i >= 1 and voters[i - 1][0] == currM:\n            i -= 1\n            heapq.heappush(prices, voters[i][1])\n        already = i + bribed\n        for k in range(max(0, currM - already)):\n            cost += heapq.heappop(prices)\n            bribed += 1\n        i -= 1\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "while i >= 0:",
      "mutated_line": "while i >= 1:",
      "code": "import heapq\n\ndef calculate_minimum_cost(voters):\n    \"\"\"\n    Calculate the minimum number of coins required to ensure everyone votes for you.\n\n    Parameters:\n    voters (list of tuples): A list of tuples where each tuple contains two integers (m_i, p_i).\n                             m_i is the number of other voters needed to convince the i-th voter.\n                             p_i is the cost to pay the i-th voter.\n\n    Returns:\n    int: The minimum number of coins required.\n    \"\"\"\n    voters.sort()\n    prices = []\n    cost = 0\n    bribed = 0\n    i = len(voters) - 1\n    while i >= 1:\n        currM = voters[i][0]\n        heapq.heappush(prices, voters[i][1])\n        while i >= 1 and voters[i - 1][0] == currM:\n            i -= 1\n            heapq.heappush(prices, voters[i][1])\n        already = i + bribed\n        for k in range(max(0, currM - already)):\n            cost += heapq.heappop(prices)\n            bribed += 1\n        i -= 1\n    return cost"
    },
    {
      "operator": "LCR",
      "lineno": 25,
      "original_line": "while i >= 1 and voters[i - 1][0] == currM:",
      "mutated_line": "while i >= 1 or voters[i - 1][0] == currM:",
      "code": "import heapq\n\ndef calculate_minimum_cost(voters):\n    \"\"\"\n    Calculate the minimum number of coins required to ensure everyone votes for you.\n\n    Parameters:\n    voters (list of tuples): A list of tuples where each tuple contains two integers (m_i, p_i).\n                             m_i is the number of other voters needed to convince the i-th voter.\n                             p_i is the cost to pay the i-th voter.\n\n    Returns:\n    int: The minimum number of coins required.\n    \"\"\"\n    voters.sort()\n    prices = []\n    cost = 0\n    bribed = 0\n    i = len(voters) - 1\n    while i >= 0:\n        currM = voters[i][0]\n        heapq.heappush(prices, voters[i][1])\n        while i >= 1 or voters[i - 1][0] == currM:\n            i -= 1\n            heapq.heappush(prices, voters[i][1])\n        already = i + bribed\n        for k in range(max(0, currM - already)):\n            cost += heapq.heappop(prices)\n            bribed += 1\n        i -= 1\n    return cost"
    },
    {
      "operator": "ASR",
      "lineno": 26,
      "original_line": "i -= 1",
      "mutated_line": "i += 1",
      "code": "import heapq\n\ndef calculate_minimum_cost(voters):\n    \"\"\"\n    Calculate the minimum number of coins required to ensure everyone votes for you.\n\n    Parameters:\n    voters (list of tuples): A list of tuples where each tuple contains two integers (m_i, p_i).\n                             m_i is the number of other voters needed to convince the i-th voter.\n                             p_i is the cost to pay the i-th voter.\n\n    Returns:\n    int: The minimum number of coins required.\n    \"\"\"\n    voters.sort()\n    prices = []\n    cost = 0\n    bribed = 0\n    i = len(voters) - 1\n    while i >= 0:\n        currM = voters[i][0]\n        heapq.heappush(prices, voters[i][1])\n        while i >= 1 and voters[i - 1][0] == currM:\n            i += 1\n            heapq.heappush(prices, voters[i][1])\n        already = i + bribed\n        for k in range(max(0, currM - already)):\n            cost += heapq.heappop(prices)\n            bribed += 1\n        i -= 1\n    return cost"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "already = i + bribed",
      "mutated_line": "already = i - bribed",
      "code": "import heapq\n\ndef calculate_minimum_cost(voters):\n    \"\"\"\n    Calculate the minimum number of coins required to ensure everyone votes for you.\n\n    Parameters:\n    voters (list of tuples): A list of tuples where each tuple contains two integers (m_i, p_i).\n                             m_i is the number of other voters needed to convince the i-th voter.\n                             p_i is the cost to pay the i-th voter.\n\n    Returns:\n    int: The minimum number of coins required.\n    \"\"\"\n    voters.sort()\n    prices = []\n    cost = 0\n    bribed = 0\n    i = len(voters) - 1\n    while i >= 0:\n        currM = voters[i][0]\n        heapq.heappush(prices, voters[i][1])\n        while i >= 1 and voters[i - 1][0] == currM:\n            i -= 1\n            heapq.heappush(prices, voters[i][1])\n        already = i - bribed\n        for k in range(max(0, currM - already)):\n            cost += heapq.heappop(prices)\n            bribed += 1\n        i -= 1\n    return cost"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "already = i + bribed",
      "mutated_line": "already = i * bribed",
      "code": "import heapq\n\ndef calculate_minimum_cost(voters):\n    \"\"\"\n    Calculate the minimum number of coins required to ensure everyone votes for you.\n\n    Parameters:\n    voters (list of tuples): A list of tuples where each tuple contains two integers (m_i, p_i).\n                             m_i is the number of other voters needed to convince the i-th voter.\n                             p_i is the cost to pay the i-th voter.\n\n    Returns:\n    int: The minimum number of coins required.\n    \"\"\"\n    voters.sort()\n    prices = []\n    cost = 0\n    bribed = 0\n    i = len(voters) - 1\n    while i >= 0:\n        currM = voters[i][0]\n        heapq.heappush(prices, voters[i][1])\n        while i >= 1 and voters[i - 1][0] == currM:\n            i -= 1\n            heapq.heappush(prices, voters[i][1])\n        already = i * bribed\n        for k in range(max(0, currM - already)):\n            cost += heapq.heappop(prices)\n            bribed += 1\n        i -= 1\n    return cost"
    },
    {
      "operator": "ASR",
      "lineno": 31,
      "original_line": "cost += heapq.heappop(prices)",
      "mutated_line": "cost -= heapq.heappop(prices)",
      "code": "import heapq\n\ndef calculate_minimum_cost(voters):\n    \"\"\"\n    Calculate the minimum number of coins required to ensure everyone votes for you.\n\n    Parameters:\n    voters (list of tuples): A list of tuples where each tuple contains two integers (m_i, p_i).\n                             m_i is the number of other voters needed to convince the i-th voter.\n                             p_i is the cost to pay the i-th voter.\n\n    Returns:\n    int: The minimum number of coins required.\n    \"\"\"\n    voters.sort()\n    prices = []\n    cost = 0\n    bribed = 0\n    i = len(voters) - 1\n    while i >= 0:\n        currM = voters[i][0]\n        heapq.heappush(prices, voters[i][1])\n        while i >= 1 and voters[i - 1][0] == currM:\n            i -= 1\n            heapq.heappush(prices, voters[i][1])\n        already = i + bribed\n        for k in range(max(0, currM - already)):\n            cost -= heapq.heappop(prices)\n            bribed += 1\n        i -= 1\n    return cost"
    },
    {
      "operator": "ASR",
      "lineno": 32,
      "original_line": "bribed += 1",
      "mutated_line": "bribed -= 1",
      "code": "import heapq\n\ndef calculate_minimum_cost(voters):\n    \"\"\"\n    Calculate the minimum number of coins required to ensure everyone votes for you.\n\n    Parameters:\n    voters (list of tuples): A list of tuples where each tuple contains two integers (m_i, p_i).\n                             m_i is the number of other voters needed to convince the i-th voter.\n                             p_i is the cost to pay the i-th voter.\n\n    Returns:\n    int: The minimum number of coins required.\n    \"\"\"\n    voters.sort()\n    prices = []\n    cost = 0\n    bribed = 0\n    i = len(voters) - 1\n    while i >= 0:\n        currM = voters[i][0]\n        heapq.heappush(prices, voters[i][1])\n        while i >= 1 and voters[i - 1][0] == currM:\n            i -= 1\n            heapq.heappush(prices, voters[i][1])\n        already = i + bribed\n        for k in range(max(0, currM - already)):\n            cost += heapq.heappop(prices)\n            bribed -= 1\n        i -= 1\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "i -= 1",
      "mutated_line": "i -= 2",
      "code": "import heapq\n\ndef calculate_minimum_cost(voters):\n    \"\"\"\n    Calculate the minimum number of coins required to ensure everyone votes for you.\n\n    Parameters:\n    voters (list of tuples): A list of tuples where each tuple contains two integers (m_i, p_i).\n                             m_i is the number of other voters needed to convince the i-th voter.\n                             p_i is the cost to pay the i-th voter.\n\n    Returns:\n    int: The minimum number of coins required.\n    \"\"\"\n    voters.sort()\n    prices = []\n    cost = 0\n    bribed = 0\n    i = len(voters) - 1\n    while i >= 0:\n        currM = voters[i][0]\n        heapq.heappush(prices, voters[i][1])\n        while i >= 1 and voters[i - 1][0] == currM:\n            i -= 1\n            heapq.heappush(prices, voters[i][1])\n        already = i + bribed\n        for k in range(max(0, currM - already)):\n            cost += heapq.heappop(prices)\n            bribed += 1\n        i -= 2\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "i -= 1",
      "mutated_line": "i -= 0",
      "code": "import heapq\n\ndef calculate_minimum_cost(voters):\n    \"\"\"\n    Calculate the minimum number of coins required to ensure everyone votes for you.\n\n    Parameters:\n    voters (list of tuples): A list of tuples where each tuple contains two integers (m_i, p_i).\n                             m_i is the number of other voters needed to convince the i-th voter.\n                             p_i is the cost to pay the i-th voter.\n\n    Returns:\n    int: The minimum number of coins required.\n    \"\"\"\n    voters.sort()\n    prices = []\n    cost = 0\n    bribed = 0\n    i = len(voters) - 1\n    while i >= 0:\n        currM = voters[i][0]\n        heapq.heappush(prices, voters[i][1])\n        while i >= 1 and voters[i - 1][0] == currM:\n            i -= 1\n            heapq.heappush(prices, voters[i][1])\n        already = i + bribed\n        for k in range(max(0, currM - already)):\n            cost += heapq.heappop(prices)\n            bribed += 1\n        i -= 0\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "i -= 1",
      "mutated_line": "i -= 0",
      "code": "import heapq\n\ndef calculate_minimum_cost(voters):\n    \"\"\"\n    Calculate the minimum number of coins required to ensure everyone votes for you.\n\n    Parameters:\n    voters (list of tuples): A list of tuples where each tuple contains two integers (m_i, p_i).\n                             m_i is the number of other voters needed to convince the i-th voter.\n                             p_i is the cost to pay the i-th voter.\n\n    Returns:\n    int: The minimum number of coins required.\n    \"\"\"\n    voters.sort()\n    prices = []\n    cost = 0\n    bribed = 0\n    i = len(voters) - 1\n    while i >= 0:\n        currM = voters[i][0]\n        heapq.heappush(prices, voters[i][1])\n        while i >= 1 and voters[i - 1][0] == currM:\n            i -= 1\n            heapq.heappush(prices, voters[i][1])\n        already = i + bribed\n        for k in range(max(0, currM - already)):\n            cost += heapq.heappop(prices)\n            bribed += 1\n        i -= 0\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "i -= 1",
      "mutated_line": "i -= -1",
      "code": "import heapq\n\ndef calculate_minimum_cost(voters):\n    \"\"\"\n    Calculate the minimum number of coins required to ensure everyone votes for you.\n\n    Parameters:\n    voters (list of tuples): A list of tuples where each tuple contains two integers (m_i, p_i).\n                             m_i is the number of other voters needed to convince the i-th voter.\n                             p_i is the cost to pay the i-th voter.\n\n    Returns:\n    int: The minimum number of coins required.\n    \"\"\"\n    voters.sort()\n    prices = []\n    cost = 0\n    bribed = 0\n    i = len(voters) - 1\n    while i >= 0:\n        currM = voters[i][0]\n        heapq.heappush(prices, voters[i][1])\n        while i >= 1 and voters[i - 1][0] == currM:\n            i -= 1\n            heapq.heappush(prices, voters[i][1])\n        already = i + bribed\n        for k in range(max(0, currM - already)):\n            cost += heapq.heappop(prices)\n            bribed += 1\n        i -= -1\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "currM = voters[i][0]",
      "mutated_line": "currM = voters[i][1]",
      "code": "import heapq\n\ndef calculate_minimum_cost(voters):\n    \"\"\"\n    Calculate the minimum number of coins required to ensure everyone votes for you.\n\n    Parameters:\n    voters (list of tuples): A list of tuples where each tuple contains two integers (m_i, p_i).\n                             m_i is the number of other voters needed to convince the i-th voter.\n                             p_i is the cost to pay the i-th voter.\n\n    Returns:\n    int: The minimum number of coins required.\n    \"\"\"\n    voters.sort()\n    prices = []\n    cost = 0\n    bribed = 0\n    i = len(voters) - 1\n    while i >= 0:\n        currM = voters[i][1]\n        heapq.heappush(prices, voters[i][1])\n        while i >= 1 and voters[i - 1][0] == currM:\n            i -= 1\n            heapq.heappush(prices, voters[i][1])\n        already = i + bribed\n        for k in range(max(0, currM - already)):\n            cost += heapq.heappop(prices)\n            bribed += 1\n        i -= 1\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "currM = voters[i][0]",
      "mutated_line": "currM = voters[i][-1]",
      "code": "import heapq\n\ndef calculate_minimum_cost(voters):\n    \"\"\"\n    Calculate the minimum number of coins required to ensure everyone votes for you.\n\n    Parameters:\n    voters (list of tuples): A list of tuples where each tuple contains two integers (m_i, p_i).\n                             m_i is the number of other voters needed to convince the i-th voter.\n                             p_i is the cost to pay the i-th voter.\n\n    Returns:\n    int: The minimum number of coins required.\n    \"\"\"\n    voters.sort()\n    prices = []\n    cost = 0\n    bribed = 0\n    i = len(voters) - 1\n    while i >= 0:\n        currM = voters[i][-1]\n        heapq.heappush(prices, voters[i][1])\n        while i >= 1 and voters[i - 1][0] == currM:\n            i -= 1\n            heapq.heappush(prices, voters[i][1])\n        already = i + bribed\n        for k in range(max(0, currM - already)):\n            cost += heapq.heappop(prices)\n            bribed += 1\n        i -= 1\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "currM = voters[i][0]",
      "mutated_line": "currM = voters[i][1]",
      "code": "import heapq\n\ndef calculate_minimum_cost(voters):\n    \"\"\"\n    Calculate the minimum number of coins required to ensure everyone votes for you.\n\n    Parameters:\n    voters (list of tuples): A list of tuples where each tuple contains two integers (m_i, p_i).\n                             m_i is the number of other voters needed to convince the i-th voter.\n                             p_i is the cost to pay the i-th voter.\n\n    Returns:\n    int: The minimum number of coins required.\n    \"\"\"\n    voters.sort()\n    prices = []\n    cost = 0\n    bribed = 0\n    i = len(voters) - 1\n    while i >= 0:\n        currM = voters[i][1]\n        heapq.heappush(prices, voters[i][1])\n        while i >= 1 and voters[i - 1][0] == currM:\n            i -= 1\n            heapq.heappush(prices, voters[i][1])\n        already = i + bribed\n        for k in range(max(0, currM - already)):\n            cost += heapq.heappop(prices)\n            bribed += 1\n        i -= 1\n    return cost"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "while i >= 1 and voters[i - 1][0] == currM:",
      "mutated_line": "while i > 1 and voters[i - 1][0] == currM:",
      "code": "import heapq\n\ndef calculate_minimum_cost(voters):\n    \"\"\"\n    Calculate the minimum number of coins required to ensure everyone votes for you.\n\n    Parameters:\n    voters (list of tuples): A list of tuples where each tuple contains two integers (m_i, p_i).\n                             m_i is the number of other voters needed to convince the i-th voter.\n                             p_i is the cost to pay the i-th voter.\n\n    Returns:\n    int: The minimum number of coins required.\n    \"\"\"\n    voters.sort()\n    prices = []\n    cost = 0\n    bribed = 0\n    i = len(voters) - 1\n    while i >= 0:\n        currM = voters[i][0]\n        heapq.heappush(prices, voters[i][1])\n        while i > 1 and voters[i - 1][0] == currM:\n            i -= 1\n            heapq.heappush(prices, voters[i][1])\n        already = i + bribed\n        for k in range(max(0, currM - already)):\n            cost += heapq.heappop(prices)\n            bribed += 1\n        i -= 1\n    return cost"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "while i >= 1 and voters[i - 1][0] == currM:",
      "mutated_line": "while i < 1 and voters[i - 1][0] == currM:",
      "code": "import heapq\n\ndef calculate_minimum_cost(voters):\n    \"\"\"\n    Calculate the minimum number of coins required to ensure everyone votes for you.\n\n    Parameters:\n    voters (list of tuples): A list of tuples where each tuple contains two integers (m_i, p_i).\n                             m_i is the number of other voters needed to convince the i-th voter.\n                             p_i is the cost to pay the i-th voter.\n\n    Returns:\n    int: The minimum number of coins required.\n    \"\"\"\n    voters.sort()\n    prices = []\n    cost = 0\n    bribed = 0\n    i = len(voters) - 1\n    while i >= 0:\n        currM = voters[i][0]\n        heapq.heappush(prices, voters[i][1])\n        while i < 1 and voters[i - 1][0] == currM:\n            i -= 1\n            heapq.heappush(prices, voters[i][1])\n        already = i + bribed\n        for k in range(max(0, currM - already)):\n            cost += heapq.heappop(prices)\n            bribed += 1\n        i -= 1\n    return cost"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "while i >= 1 and voters[i - 1][0] == currM:",
      "mutated_line": "while i == 1 and voters[i - 1][0] == currM:",
      "code": "import heapq\n\ndef calculate_minimum_cost(voters):\n    \"\"\"\n    Calculate the minimum number of coins required to ensure everyone votes for you.\n\n    Parameters:\n    voters (list of tuples): A list of tuples where each tuple contains two integers (m_i, p_i).\n                             m_i is the number of other voters needed to convince the i-th voter.\n                             p_i is the cost to pay the i-th voter.\n\n    Returns:\n    int: The minimum number of coins required.\n    \"\"\"\n    voters.sort()\n    prices = []\n    cost = 0\n    bribed = 0\n    i = len(voters) - 1\n    while i >= 0:\n        currM = voters[i][0]\n        heapq.heappush(prices, voters[i][1])\n        while i == 1 and voters[i - 1][0] == currM:\n            i -= 1\n            heapq.heappush(prices, voters[i][1])\n        already = i + bribed\n        for k in range(max(0, currM - already)):\n            cost += heapq.heappop(prices)\n            bribed += 1\n        i -= 1\n    return cost"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "while i >= 1 and voters[i - 1][0] == currM:",
      "mutated_line": "while i >= 1 and voters[i - 1][0] != currM:",
      "code": "import heapq\n\ndef calculate_minimum_cost(voters):\n    \"\"\"\n    Calculate the minimum number of coins required to ensure everyone votes for you.\n\n    Parameters:\n    voters (list of tuples): A list of tuples where each tuple contains two integers (m_i, p_i).\n                             m_i is the number of other voters needed to convince the i-th voter.\n                             p_i is the cost to pay the i-th voter.\n\n    Returns:\n    int: The minimum number of coins required.\n    \"\"\"\n    voters.sort()\n    prices = []\n    cost = 0\n    bribed = 0\n    i = len(voters) - 1\n    while i >= 0:\n        currM = voters[i][0]\n        heapq.heappush(prices, voters[i][1])\n        while i >= 1 and voters[i - 1][0] != currM:\n            i -= 1\n            heapq.heappush(prices, voters[i][1])\n        already = i + bribed\n        for k in range(max(0, currM - already)):\n            cost += heapq.heappop(prices)\n            bribed += 1\n        i -= 1\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "i -= 1",
      "mutated_line": "i -= 2",
      "code": "import heapq\n\ndef calculate_minimum_cost(voters):\n    \"\"\"\n    Calculate the minimum number of coins required to ensure everyone votes for you.\n\n    Parameters:\n    voters (list of tuples): A list of tuples where each tuple contains two integers (m_i, p_i).\n                             m_i is the number of other voters needed to convince the i-th voter.\n                             p_i is the cost to pay the i-th voter.\n\n    Returns:\n    int: The minimum number of coins required.\n    \"\"\"\n    voters.sort()\n    prices = []\n    cost = 0\n    bribed = 0\n    i = len(voters) - 1\n    while i >= 0:\n        currM = voters[i][0]\n        heapq.heappush(prices, voters[i][1])\n        while i >= 1 and voters[i - 1][0] == currM:\n            i -= 2\n            heapq.heappush(prices, voters[i][1])\n        already = i + bribed\n        for k in range(max(0, currM - already)):\n            cost += heapq.heappop(prices)\n            bribed += 1\n        i -= 1\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "i -= 1",
      "mutated_line": "i -= 0",
      "code": "import heapq\n\ndef calculate_minimum_cost(voters):\n    \"\"\"\n    Calculate the minimum number of coins required to ensure everyone votes for you.\n\n    Parameters:\n    voters (list of tuples): A list of tuples where each tuple contains two integers (m_i, p_i).\n                             m_i is the number of other voters needed to convince the i-th voter.\n                             p_i is the cost to pay the i-th voter.\n\n    Returns:\n    int: The minimum number of coins required.\n    \"\"\"\n    voters.sort()\n    prices = []\n    cost = 0\n    bribed = 0\n    i = len(voters) - 1\n    while i >= 0:\n        currM = voters[i][0]\n        heapq.heappush(prices, voters[i][1])\n        while i >= 1 and voters[i - 1][0] == currM:\n            i -= 0\n            heapq.heappush(prices, voters[i][1])\n        already = i + bribed\n        for k in range(max(0, currM - already)):\n            cost += heapq.heappop(prices)\n            bribed += 1\n        i -= 1\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "i -= 1",
      "mutated_line": "i -= 0",
      "code": "import heapq\n\ndef calculate_minimum_cost(voters):\n    \"\"\"\n    Calculate the minimum number of coins required to ensure everyone votes for you.\n\n    Parameters:\n    voters (list of tuples): A list of tuples where each tuple contains two integers (m_i, p_i).\n                             m_i is the number of other voters needed to convince the i-th voter.\n                             p_i is the cost to pay the i-th voter.\n\n    Returns:\n    int: The minimum number of coins required.\n    \"\"\"\n    voters.sort()\n    prices = []\n    cost = 0\n    bribed = 0\n    i = len(voters) - 1\n    while i >= 0:\n        currM = voters[i][0]\n        heapq.heappush(prices, voters[i][1])\n        while i >= 1 and voters[i - 1][0] == currM:\n            i -= 0\n            heapq.heappush(prices, voters[i][1])\n        already = i + bribed\n        for k in range(max(0, currM - already)):\n            cost += heapq.heappop(prices)\n            bribed += 1\n        i -= 1\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "i -= 1",
      "mutated_line": "i -= -1",
      "code": "import heapq\n\ndef calculate_minimum_cost(voters):\n    \"\"\"\n    Calculate the minimum number of coins required to ensure everyone votes for you.\n\n    Parameters:\n    voters (list of tuples): A list of tuples where each tuple contains two integers (m_i, p_i).\n                             m_i is the number of other voters needed to convince the i-th voter.\n                             p_i is the cost to pay the i-th voter.\n\n    Returns:\n    int: The minimum number of coins required.\n    \"\"\"\n    voters.sort()\n    prices = []\n    cost = 0\n    bribed = 0\n    i = len(voters) - 1\n    while i >= 0:\n        currM = voters[i][0]\n        heapq.heappush(prices, voters[i][1])\n        while i >= 1 and voters[i - 1][0] == currM:\n            i -= -1\n            heapq.heappush(prices, voters[i][1])\n        already = i + bribed\n        for k in range(max(0, currM - already)):\n            cost += heapq.heappop(prices)\n            bribed += 1\n        i -= 1\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "bribed += 1",
      "mutated_line": "bribed += 2",
      "code": "import heapq\n\ndef calculate_minimum_cost(voters):\n    \"\"\"\n    Calculate the minimum number of coins required to ensure everyone votes for you.\n\n    Parameters:\n    voters (list of tuples): A list of tuples where each tuple contains two integers (m_i, p_i).\n                             m_i is the number of other voters needed to convince the i-th voter.\n                             p_i is the cost to pay the i-th voter.\n\n    Returns:\n    int: The minimum number of coins required.\n    \"\"\"\n    voters.sort()\n    prices = []\n    cost = 0\n    bribed = 0\n    i = len(voters) - 1\n    while i >= 0:\n        currM = voters[i][0]\n        heapq.heappush(prices, voters[i][1])\n        while i >= 1 and voters[i - 1][0] == currM:\n            i -= 1\n            heapq.heappush(prices, voters[i][1])\n        already = i + bribed\n        for k in range(max(0, currM - already)):\n            cost += heapq.heappop(prices)\n            bribed += 2\n        i -= 1\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "bribed += 1",
      "mutated_line": "bribed += 0",
      "code": "import heapq\n\ndef calculate_minimum_cost(voters):\n    \"\"\"\n    Calculate the minimum number of coins required to ensure everyone votes for you.\n\n    Parameters:\n    voters (list of tuples): A list of tuples where each tuple contains two integers (m_i, p_i).\n                             m_i is the number of other voters needed to convince the i-th voter.\n                             p_i is the cost to pay the i-th voter.\n\n    Returns:\n    int: The minimum number of coins required.\n    \"\"\"\n    voters.sort()\n    prices = []\n    cost = 0\n    bribed = 0\n    i = len(voters) - 1\n    while i >= 0:\n        currM = voters[i][0]\n        heapq.heappush(prices, voters[i][1])\n        while i >= 1 and voters[i - 1][0] == currM:\n            i -= 1\n            heapq.heappush(prices, voters[i][1])\n        already = i + bribed\n        for k in range(max(0, currM - already)):\n            cost += heapq.heappop(prices)\n            bribed += 0\n        i -= 1\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "bribed += 1",
      "mutated_line": "bribed += 0",
      "code": "import heapq\n\ndef calculate_minimum_cost(voters):\n    \"\"\"\n    Calculate the minimum number of coins required to ensure everyone votes for you.\n\n    Parameters:\n    voters (list of tuples): A list of tuples where each tuple contains two integers (m_i, p_i).\n                             m_i is the number of other voters needed to convince the i-th voter.\n                             p_i is the cost to pay the i-th voter.\n\n    Returns:\n    int: The minimum number of coins required.\n    \"\"\"\n    voters.sort()\n    prices = []\n    cost = 0\n    bribed = 0\n    i = len(voters) - 1\n    while i >= 0:\n        currM = voters[i][0]\n        heapq.heappush(prices, voters[i][1])\n        while i >= 1 and voters[i - 1][0] == currM:\n            i -= 1\n            heapq.heappush(prices, voters[i][1])\n        already = i + bribed\n        for k in range(max(0, currM - already)):\n            cost += heapq.heappop(prices)\n            bribed += 0\n        i -= 1\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "bribed += 1",
      "mutated_line": "bribed += -1",
      "code": "import heapq\n\ndef calculate_minimum_cost(voters):\n    \"\"\"\n    Calculate the minimum number of coins required to ensure everyone votes for you.\n\n    Parameters:\n    voters (list of tuples): A list of tuples where each tuple contains two integers (m_i, p_i).\n                             m_i is the number of other voters needed to convince the i-th voter.\n                             p_i is the cost to pay the i-th voter.\n\n    Returns:\n    int: The minimum number of coins required.\n    \"\"\"\n    voters.sort()\n    prices = []\n    cost = 0\n    bribed = 0\n    i = len(voters) - 1\n    while i >= 0:\n        currM = voters[i][0]\n        heapq.heappush(prices, voters[i][1])\n        while i >= 1 and voters[i - 1][0] == currM:\n            i -= 1\n            heapq.heappush(prices, voters[i][1])\n        already = i + bribed\n        for k in range(max(0, currM - already)):\n            cost += heapq.heappop(prices)\n            bribed += -1\n        i -= 1\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "heapq.heappush(prices, voters[i][1])",
      "mutated_line": "heapq.heappush(prices, voters[i][2])",
      "code": "import heapq\n\ndef calculate_minimum_cost(voters):\n    \"\"\"\n    Calculate the minimum number of coins required to ensure everyone votes for you.\n\n    Parameters:\n    voters (list of tuples): A list of tuples where each tuple contains two integers (m_i, p_i).\n                             m_i is the number of other voters needed to convince the i-th voter.\n                             p_i is the cost to pay the i-th voter.\n\n    Returns:\n    int: The minimum number of coins required.\n    \"\"\"\n    voters.sort()\n    prices = []\n    cost = 0\n    bribed = 0\n    i = len(voters) - 1\n    while i >= 0:\n        currM = voters[i][0]\n        heapq.heappush(prices, voters[i][2])\n        while i >= 1 and voters[i - 1][0] == currM:\n            i -= 1\n            heapq.heappush(prices, voters[i][1])\n        already = i + bribed\n        for k in range(max(0, currM - already)):\n            cost += heapq.heappop(prices)\n            bribed += 1\n        i -= 1\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "heapq.heappush(prices, voters[i][1])",
      "mutated_line": "heapq.heappush(prices, voters[i][0])",
      "code": "import heapq\n\ndef calculate_minimum_cost(voters):\n    \"\"\"\n    Calculate the minimum number of coins required to ensure everyone votes for you.\n\n    Parameters:\n    voters (list of tuples): A list of tuples where each tuple contains two integers (m_i, p_i).\n                             m_i is the number of other voters needed to convince the i-th voter.\n                             p_i is the cost to pay the i-th voter.\n\n    Returns:\n    int: The minimum number of coins required.\n    \"\"\"\n    voters.sort()\n    prices = []\n    cost = 0\n    bribed = 0\n    i = len(voters) - 1\n    while i >= 0:\n        currM = voters[i][0]\n        heapq.heappush(prices, voters[i][0])\n        while i >= 1 and voters[i - 1][0] == currM:\n            i -= 1\n            heapq.heappush(prices, voters[i][1])\n        already = i + bribed\n        for k in range(max(0, currM - already)):\n            cost += heapq.heappop(prices)\n            bribed += 1\n        i -= 1\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "heapq.heappush(prices, voters[i][1])",
      "mutated_line": "heapq.heappush(prices, voters[i][0])",
      "code": "import heapq\n\ndef calculate_minimum_cost(voters):\n    \"\"\"\n    Calculate the minimum number of coins required to ensure everyone votes for you.\n\n    Parameters:\n    voters (list of tuples): A list of tuples where each tuple contains two integers (m_i, p_i).\n                             m_i is the number of other voters needed to convince the i-th voter.\n                             p_i is the cost to pay the i-th voter.\n\n    Returns:\n    int: The minimum number of coins required.\n    \"\"\"\n    voters.sort()\n    prices = []\n    cost = 0\n    bribed = 0\n    i = len(voters) - 1\n    while i >= 0:\n        currM = voters[i][0]\n        heapq.heappush(prices, voters[i][0])\n        while i >= 1 and voters[i - 1][0] == currM:\n            i -= 1\n            heapq.heappush(prices, voters[i][1])\n        already = i + bribed\n        for k in range(max(0, currM - already)):\n            cost += heapq.heappop(prices)\n            bribed += 1\n        i -= 1\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "heapq.heappush(prices, voters[i][1])",
      "mutated_line": "heapq.heappush(prices, voters[i][-1])",
      "code": "import heapq\n\ndef calculate_minimum_cost(voters):\n    \"\"\"\n    Calculate the minimum number of coins required to ensure everyone votes for you.\n\n    Parameters:\n    voters (list of tuples): A list of tuples where each tuple contains two integers (m_i, p_i).\n                             m_i is the number of other voters needed to convince the i-th voter.\n                             p_i is the cost to pay the i-th voter.\n\n    Returns:\n    int: The minimum number of coins required.\n    \"\"\"\n    voters.sort()\n    prices = []\n    cost = 0\n    bribed = 0\n    i = len(voters) - 1\n    while i >= 0:\n        currM = voters[i][0]\n        heapq.heappush(prices, voters[i][-1])\n        while i >= 1 and voters[i - 1][0] == currM:\n            i -= 1\n            heapq.heappush(prices, voters[i][1])\n        already = i + bribed\n        for k in range(max(0, currM - already)):\n            cost += heapq.heappop(prices)\n            bribed += 1\n        i -= 1\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "while i >= 1 and voters[i - 1][0] == currM:",
      "mutated_line": "while i >= 2 and voters[i - 1][0] == currM:",
      "code": "import heapq\n\ndef calculate_minimum_cost(voters):\n    \"\"\"\n    Calculate the minimum number of coins required to ensure everyone votes for you.\n\n    Parameters:\n    voters (list of tuples): A list of tuples where each tuple contains two integers (m_i, p_i).\n                             m_i is the number of other voters needed to convince the i-th voter.\n                             p_i is the cost to pay the i-th voter.\n\n    Returns:\n    int: The minimum number of coins required.\n    \"\"\"\n    voters.sort()\n    prices = []\n    cost = 0\n    bribed = 0\n    i = len(voters) - 1\n    while i >= 0:\n        currM = voters[i][0]\n        heapq.heappush(prices, voters[i][1])\n        while i >= 2 and voters[i - 1][0] == currM:\n            i -= 1\n            heapq.heappush(prices, voters[i][1])\n        already = i + bribed\n        for k in range(max(0, currM - already)):\n            cost += heapq.heappop(prices)\n            bribed += 1\n        i -= 1\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "while i >= 1 and voters[i - 1][0] == currM:",
      "mutated_line": "while i >= 0 and voters[i - 1][0] == currM:",
      "code": "import heapq\n\ndef calculate_minimum_cost(voters):\n    \"\"\"\n    Calculate the minimum number of coins required to ensure everyone votes for you.\n\n    Parameters:\n    voters (list of tuples): A list of tuples where each tuple contains two integers (m_i, p_i).\n                             m_i is the number of other voters needed to convince the i-th voter.\n                             p_i is the cost to pay the i-th voter.\n\n    Returns:\n    int: The minimum number of coins required.\n    \"\"\"\n    voters.sort()\n    prices = []\n    cost = 0\n    bribed = 0\n    i = len(voters) - 1\n    while i >= 0:\n        currM = voters[i][0]\n        heapq.heappush(prices, voters[i][1])\n        while i >= 0 and voters[i - 1][0] == currM:\n            i -= 1\n            heapq.heappush(prices, voters[i][1])\n        already = i + bribed\n        for k in range(max(0, currM - already)):\n            cost += heapq.heappop(prices)\n            bribed += 1\n        i -= 1\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "while i >= 1 and voters[i - 1][0] == currM:",
      "mutated_line": "while i >= 0 and voters[i - 1][0] == currM:",
      "code": "import heapq\n\ndef calculate_minimum_cost(voters):\n    \"\"\"\n    Calculate the minimum number of coins required to ensure everyone votes for you.\n\n    Parameters:\n    voters (list of tuples): A list of tuples where each tuple contains two integers (m_i, p_i).\n                             m_i is the number of other voters needed to convince the i-th voter.\n                             p_i is the cost to pay the i-th voter.\n\n    Returns:\n    int: The minimum number of coins required.\n    \"\"\"\n    voters.sort()\n    prices = []\n    cost = 0\n    bribed = 0\n    i = len(voters) - 1\n    while i >= 0:\n        currM = voters[i][0]\n        heapq.heappush(prices, voters[i][1])\n        while i >= 0 and voters[i - 1][0] == currM:\n            i -= 1\n            heapq.heappush(prices, voters[i][1])\n        already = i + bribed\n        for k in range(max(0, currM - already)):\n            cost += heapq.heappop(prices)\n            bribed += 1\n        i -= 1\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "while i >= 1 and voters[i - 1][0] == currM:",
      "mutated_line": "while i >= -1 and voters[i - 1][0] == currM:",
      "code": "import heapq\n\ndef calculate_minimum_cost(voters):\n    \"\"\"\n    Calculate the minimum number of coins required to ensure everyone votes for you.\n\n    Parameters:\n    voters (list of tuples): A list of tuples where each tuple contains two integers (m_i, p_i).\n                             m_i is the number of other voters needed to convince the i-th voter.\n                             p_i is the cost to pay the i-th voter.\n\n    Returns:\n    int: The minimum number of coins required.\n    \"\"\"\n    voters.sort()\n    prices = []\n    cost = 0\n    bribed = 0\n    i = len(voters) - 1\n    while i >= 0:\n        currM = voters[i][0]\n        heapq.heappush(prices, voters[i][1])\n        while i >= -1 and voters[i - 1][0] == currM:\n            i -= 1\n            heapq.heappush(prices, voters[i][1])\n        already = i + bribed\n        for k in range(max(0, currM - already)):\n            cost += heapq.heappop(prices)\n            bribed += 1\n        i -= 1\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for k in range(max(0, currM - already)):",
      "mutated_line": "for k in range(max(1, currM - already)):",
      "code": "import heapq\n\ndef calculate_minimum_cost(voters):\n    \"\"\"\n    Calculate the minimum number of coins required to ensure everyone votes for you.\n\n    Parameters:\n    voters (list of tuples): A list of tuples where each tuple contains two integers (m_i, p_i).\n                             m_i is the number of other voters needed to convince the i-th voter.\n                             p_i is the cost to pay the i-th voter.\n\n    Returns:\n    int: The minimum number of coins required.\n    \"\"\"\n    voters.sort()\n    prices = []\n    cost = 0\n    bribed = 0\n    i = len(voters) - 1\n    while i >= 0:\n        currM = voters[i][0]\n        heapq.heappush(prices, voters[i][1])\n        while i >= 1 and voters[i - 1][0] == currM:\n            i -= 1\n            heapq.heappush(prices, voters[i][1])\n        already = i + bribed\n        for k in range(max(1, currM - already)):\n            cost += heapq.heappop(prices)\n            bribed += 1\n        i -= 1\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for k in range(max(0, currM - already)):",
      "mutated_line": "for k in range(max(-1, currM - already)):",
      "code": "import heapq\n\ndef calculate_minimum_cost(voters):\n    \"\"\"\n    Calculate the minimum number of coins required to ensure everyone votes for you.\n\n    Parameters:\n    voters (list of tuples): A list of tuples where each tuple contains two integers (m_i, p_i).\n                             m_i is the number of other voters needed to convince the i-th voter.\n                             p_i is the cost to pay the i-th voter.\n\n    Returns:\n    int: The minimum number of coins required.\n    \"\"\"\n    voters.sort()\n    prices = []\n    cost = 0\n    bribed = 0\n    i = len(voters) - 1\n    while i >= 0:\n        currM = voters[i][0]\n        heapq.heappush(prices, voters[i][1])\n        while i >= 1 and voters[i - 1][0] == currM:\n            i -= 1\n            heapq.heappush(prices, voters[i][1])\n        already = i + bribed\n        for k in range(max(-1, currM - already)):\n            cost += heapq.heappop(prices)\n            bribed += 1\n        i -= 1\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for k in range(max(0, currM - already)):",
      "mutated_line": "for k in range(max(1, currM - already)):",
      "code": "import heapq\n\ndef calculate_minimum_cost(voters):\n    \"\"\"\n    Calculate the minimum number of coins required to ensure everyone votes for you.\n\n    Parameters:\n    voters (list of tuples): A list of tuples where each tuple contains two integers (m_i, p_i).\n                             m_i is the number of other voters needed to convince the i-th voter.\n                             p_i is the cost to pay the i-th voter.\n\n    Returns:\n    int: The minimum number of coins required.\n    \"\"\"\n    voters.sort()\n    prices = []\n    cost = 0\n    bribed = 0\n    i = len(voters) - 1\n    while i >= 0:\n        currM = voters[i][0]\n        heapq.heappush(prices, voters[i][1])\n        while i >= 1 and voters[i - 1][0] == currM:\n            i -= 1\n            heapq.heappush(prices, voters[i][1])\n        already = i + bribed\n        for k in range(max(1, currM - already)):\n            cost += heapq.heappop(prices)\n            bribed += 1\n        i -= 1\n    return cost"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "for k in range(max(0, currM - already)):",
      "mutated_line": "for k in range(max(0, currM + already)):",
      "code": "import heapq\n\ndef calculate_minimum_cost(voters):\n    \"\"\"\n    Calculate the minimum number of coins required to ensure everyone votes for you.\n\n    Parameters:\n    voters (list of tuples): A list of tuples where each tuple contains two integers (m_i, p_i).\n                             m_i is the number of other voters needed to convince the i-th voter.\n                             p_i is the cost to pay the i-th voter.\n\n    Returns:\n    int: The minimum number of coins required.\n    \"\"\"\n    voters.sort()\n    prices = []\n    cost = 0\n    bribed = 0\n    i = len(voters) - 1\n    while i >= 0:\n        currM = voters[i][0]\n        heapq.heappush(prices, voters[i][1])\n        while i >= 1 and voters[i - 1][0] == currM:\n            i -= 1\n            heapq.heappush(prices, voters[i][1])\n        already = i + bribed\n        for k in range(max(0, currM + already)):\n            cost += heapq.heappop(prices)\n            bribed += 1\n        i -= 1\n    return cost"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "for k in range(max(0, currM - already)):",
      "mutated_line": "for k in range(max(0, currM * already)):",
      "code": "import heapq\n\ndef calculate_minimum_cost(voters):\n    \"\"\"\n    Calculate the minimum number of coins required to ensure everyone votes for you.\n\n    Parameters:\n    voters (list of tuples): A list of tuples where each tuple contains two integers (m_i, p_i).\n                             m_i is the number of other voters needed to convince the i-th voter.\n                             p_i is the cost to pay the i-th voter.\n\n    Returns:\n    int: The minimum number of coins required.\n    \"\"\"\n    voters.sort()\n    prices = []\n    cost = 0\n    bribed = 0\n    i = len(voters) - 1\n    while i >= 0:\n        currM = voters[i][0]\n        heapq.heappush(prices, voters[i][1])\n        while i >= 1 and voters[i - 1][0] == currM:\n            i -= 1\n            heapq.heappush(prices, voters[i][1])\n        already = i + bribed\n        for k in range(max(0, currM * already)):\n            cost += heapq.heappop(prices)\n            bribed += 1\n        i -= 1\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "while i >= 1 and voters[i - 1][0] == currM:",
      "mutated_line": "while i >= 1 and voters[i - 1][1] == currM:",
      "code": "import heapq\n\ndef calculate_minimum_cost(voters):\n    \"\"\"\n    Calculate the minimum number of coins required to ensure everyone votes for you.\n\n    Parameters:\n    voters (list of tuples): A list of tuples where each tuple contains two integers (m_i, p_i).\n                             m_i is the number of other voters needed to convince the i-th voter.\n                             p_i is the cost to pay the i-th voter.\n\n    Returns:\n    int: The minimum number of coins required.\n    \"\"\"\n    voters.sort()\n    prices = []\n    cost = 0\n    bribed = 0\n    i = len(voters) - 1\n    while i >= 0:\n        currM = voters[i][0]\n        heapq.heappush(prices, voters[i][1])\n        while i >= 1 and voters[i - 1][1] == currM:\n            i -= 1\n            heapq.heappush(prices, voters[i][1])\n        already = i + bribed\n        for k in range(max(0, currM - already)):\n            cost += heapq.heappop(prices)\n            bribed += 1\n        i -= 1\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "while i >= 1 and voters[i - 1][0] == currM:",
      "mutated_line": "while i >= 1 and voters[i - 1][-1] == currM:",
      "code": "import heapq\n\ndef calculate_minimum_cost(voters):\n    \"\"\"\n    Calculate the minimum number of coins required to ensure everyone votes for you.\n\n    Parameters:\n    voters (list of tuples): A list of tuples where each tuple contains two integers (m_i, p_i).\n                             m_i is the number of other voters needed to convince the i-th voter.\n                             p_i is the cost to pay the i-th voter.\n\n    Returns:\n    int: The minimum number of coins required.\n    \"\"\"\n    voters.sort()\n    prices = []\n    cost = 0\n    bribed = 0\n    i = len(voters) - 1\n    while i >= 0:\n        currM = voters[i][0]\n        heapq.heappush(prices, voters[i][1])\n        while i >= 1 and voters[i - 1][-1] == currM:\n            i -= 1\n            heapq.heappush(prices, voters[i][1])\n        already = i + bribed\n        for k in range(max(0, currM - already)):\n            cost += heapq.heappop(prices)\n            bribed += 1\n        i -= 1\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "while i >= 1 and voters[i - 1][0] == currM:",
      "mutated_line": "while i >= 1 and voters[i - 1][1] == currM:",
      "code": "import heapq\n\ndef calculate_minimum_cost(voters):\n    \"\"\"\n    Calculate the minimum number of coins required to ensure everyone votes for you.\n\n    Parameters:\n    voters (list of tuples): A list of tuples where each tuple contains two integers (m_i, p_i).\n                             m_i is the number of other voters needed to convince the i-th voter.\n                             p_i is the cost to pay the i-th voter.\n\n    Returns:\n    int: The minimum number of coins required.\n    \"\"\"\n    voters.sort()\n    prices = []\n    cost = 0\n    bribed = 0\n    i = len(voters) - 1\n    while i >= 0:\n        currM = voters[i][0]\n        heapq.heappush(prices, voters[i][1])\n        while i >= 1 and voters[i - 1][1] == currM:\n            i -= 1\n            heapq.heappush(prices, voters[i][1])\n        already = i + bribed\n        for k in range(max(0, currM - already)):\n            cost += heapq.heappop(prices)\n            bribed += 1\n        i -= 1\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "heapq.heappush(prices, voters[i][1])",
      "mutated_line": "heapq.heappush(prices, voters[i][2])",
      "code": "import heapq\n\ndef calculate_minimum_cost(voters):\n    \"\"\"\n    Calculate the minimum number of coins required to ensure everyone votes for you.\n\n    Parameters:\n    voters (list of tuples): A list of tuples where each tuple contains two integers (m_i, p_i).\n                             m_i is the number of other voters needed to convince the i-th voter.\n                             p_i is the cost to pay the i-th voter.\n\n    Returns:\n    int: The minimum number of coins required.\n    \"\"\"\n    voters.sort()\n    prices = []\n    cost = 0\n    bribed = 0\n    i = len(voters) - 1\n    while i >= 0:\n        currM = voters[i][0]\n        heapq.heappush(prices, voters[i][1])\n        while i >= 1 and voters[i - 1][0] == currM:\n            i -= 1\n            heapq.heappush(prices, voters[i][2])\n        already = i + bribed\n        for k in range(max(0, currM - already)):\n            cost += heapq.heappop(prices)\n            bribed += 1\n        i -= 1\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "heapq.heappush(prices, voters[i][1])",
      "mutated_line": "heapq.heappush(prices, voters[i][0])",
      "code": "import heapq\n\ndef calculate_minimum_cost(voters):\n    \"\"\"\n    Calculate the minimum number of coins required to ensure everyone votes for you.\n\n    Parameters:\n    voters (list of tuples): A list of tuples where each tuple contains two integers (m_i, p_i).\n                             m_i is the number of other voters needed to convince the i-th voter.\n                             p_i is the cost to pay the i-th voter.\n\n    Returns:\n    int: The minimum number of coins required.\n    \"\"\"\n    voters.sort()\n    prices = []\n    cost = 0\n    bribed = 0\n    i = len(voters) - 1\n    while i >= 0:\n        currM = voters[i][0]\n        heapq.heappush(prices, voters[i][1])\n        while i >= 1 and voters[i - 1][0] == currM:\n            i -= 1\n            heapq.heappush(prices, voters[i][0])\n        already = i + bribed\n        for k in range(max(0, currM - already)):\n            cost += heapq.heappop(prices)\n            bribed += 1\n        i -= 1\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "heapq.heappush(prices, voters[i][1])",
      "mutated_line": "heapq.heappush(prices, voters[i][0])",
      "code": "import heapq\n\ndef calculate_minimum_cost(voters):\n    \"\"\"\n    Calculate the minimum number of coins required to ensure everyone votes for you.\n\n    Parameters:\n    voters (list of tuples): A list of tuples where each tuple contains two integers (m_i, p_i).\n                             m_i is the number of other voters needed to convince the i-th voter.\n                             p_i is the cost to pay the i-th voter.\n\n    Returns:\n    int: The minimum number of coins required.\n    \"\"\"\n    voters.sort()\n    prices = []\n    cost = 0\n    bribed = 0\n    i = len(voters) - 1\n    while i >= 0:\n        currM = voters[i][0]\n        heapq.heappush(prices, voters[i][1])\n        while i >= 1 and voters[i - 1][0] == currM:\n            i -= 1\n            heapq.heappush(prices, voters[i][0])\n        already = i + bribed\n        for k in range(max(0, currM - already)):\n            cost += heapq.heappop(prices)\n            bribed += 1\n        i -= 1\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "heapq.heappush(prices, voters[i][1])",
      "mutated_line": "heapq.heappush(prices, voters[i][-1])",
      "code": "import heapq\n\ndef calculate_minimum_cost(voters):\n    \"\"\"\n    Calculate the minimum number of coins required to ensure everyone votes for you.\n\n    Parameters:\n    voters (list of tuples): A list of tuples where each tuple contains two integers (m_i, p_i).\n                             m_i is the number of other voters needed to convince the i-th voter.\n                             p_i is the cost to pay the i-th voter.\n\n    Returns:\n    int: The minimum number of coins required.\n    \"\"\"\n    voters.sort()\n    prices = []\n    cost = 0\n    bribed = 0\n    i = len(voters) - 1\n    while i >= 0:\n        currM = voters[i][0]\n        heapq.heappush(prices, voters[i][1])\n        while i >= 1 and voters[i - 1][0] == currM:\n            i -= 1\n            heapq.heappush(prices, voters[i][-1])\n        already = i + bribed\n        for k in range(max(0, currM - already)):\n            cost += heapq.heappop(prices)\n            bribed += 1\n        i -= 1\n    return cost"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "while i >= 1 and voters[i - 1][0] == currM:",
      "mutated_line": "while i >= 1 and voters[i + 1][0] == currM:",
      "code": "import heapq\n\ndef calculate_minimum_cost(voters):\n    \"\"\"\n    Calculate the minimum number of coins required to ensure everyone votes for you.\n\n    Parameters:\n    voters (list of tuples): A list of tuples where each tuple contains two integers (m_i, p_i).\n                             m_i is the number of other voters needed to convince the i-th voter.\n                             p_i is the cost to pay the i-th voter.\n\n    Returns:\n    int: The minimum number of coins required.\n    \"\"\"\n    voters.sort()\n    prices = []\n    cost = 0\n    bribed = 0\n    i = len(voters) - 1\n    while i >= 0:\n        currM = voters[i][0]\n        heapq.heappush(prices, voters[i][1])\n        while i >= 1 and voters[i + 1][0] == currM:\n            i -= 1\n            heapq.heappush(prices, voters[i][1])\n        already = i + bribed\n        for k in range(max(0, currM - already)):\n            cost += heapq.heappop(prices)\n            bribed += 1\n        i -= 1\n    return cost"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "while i >= 1 and voters[i - 1][0] == currM:",
      "mutated_line": "while i >= 1 and voters[i * 1][0] == currM:",
      "code": "import heapq\n\ndef calculate_minimum_cost(voters):\n    \"\"\"\n    Calculate the minimum number of coins required to ensure everyone votes for you.\n\n    Parameters:\n    voters (list of tuples): A list of tuples where each tuple contains two integers (m_i, p_i).\n                             m_i is the number of other voters needed to convince the i-th voter.\n                             p_i is the cost to pay the i-th voter.\n\n    Returns:\n    int: The minimum number of coins required.\n    \"\"\"\n    voters.sort()\n    prices = []\n    cost = 0\n    bribed = 0\n    i = len(voters) - 1\n    while i >= 0:\n        currM = voters[i][0]\n        heapq.heappush(prices, voters[i][1])\n        while i >= 1 and voters[i * 1][0] == currM:\n            i -= 1\n            heapq.heappush(prices, voters[i][1])\n        already = i + bribed\n        for k in range(max(0, currM - already)):\n            cost += heapq.heappop(prices)\n            bribed += 1\n        i -= 1\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "while i >= 1 and voters[i - 1][0] == currM:",
      "mutated_line": "while i >= 1 and voters[i - 2][0] == currM:",
      "code": "import heapq\n\ndef calculate_minimum_cost(voters):\n    \"\"\"\n    Calculate the minimum number of coins required to ensure everyone votes for you.\n\n    Parameters:\n    voters (list of tuples): A list of tuples where each tuple contains two integers (m_i, p_i).\n                             m_i is the number of other voters needed to convince the i-th voter.\n                             p_i is the cost to pay the i-th voter.\n\n    Returns:\n    int: The minimum number of coins required.\n    \"\"\"\n    voters.sort()\n    prices = []\n    cost = 0\n    bribed = 0\n    i = len(voters) - 1\n    while i >= 0:\n        currM = voters[i][0]\n        heapq.heappush(prices, voters[i][1])\n        while i >= 1 and voters[i - 2][0] == currM:\n            i -= 1\n            heapq.heappush(prices, voters[i][1])\n        already = i + bribed\n        for k in range(max(0, currM - already)):\n            cost += heapq.heappop(prices)\n            bribed += 1\n        i -= 1\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "while i >= 1 and voters[i - 1][0] == currM:",
      "mutated_line": "while i >= 1 and voters[i - 0][0] == currM:",
      "code": "import heapq\n\ndef calculate_minimum_cost(voters):\n    \"\"\"\n    Calculate the minimum number of coins required to ensure everyone votes for you.\n\n    Parameters:\n    voters (list of tuples): A list of tuples where each tuple contains two integers (m_i, p_i).\n                             m_i is the number of other voters needed to convince the i-th voter.\n                             p_i is the cost to pay the i-th voter.\n\n    Returns:\n    int: The minimum number of coins required.\n    \"\"\"\n    voters.sort()\n    prices = []\n    cost = 0\n    bribed = 0\n    i = len(voters) - 1\n    while i >= 0:\n        currM = voters[i][0]\n        heapq.heappush(prices, voters[i][1])\n        while i >= 1 and voters[i - 0][0] == currM:\n            i -= 1\n            heapq.heappush(prices, voters[i][1])\n        already = i + bribed\n        for k in range(max(0, currM - already)):\n            cost += heapq.heappop(prices)\n            bribed += 1\n        i -= 1\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "while i >= 1 and voters[i - 1][0] == currM:",
      "mutated_line": "while i >= 1 and voters[i - 0][0] == currM:",
      "code": "import heapq\n\ndef calculate_minimum_cost(voters):\n    \"\"\"\n    Calculate the minimum number of coins required to ensure everyone votes for you.\n\n    Parameters:\n    voters (list of tuples): A list of tuples where each tuple contains two integers (m_i, p_i).\n                             m_i is the number of other voters needed to convince the i-th voter.\n                             p_i is the cost to pay the i-th voter.\n\n    Returns:\n    int: The minimum number of coins required.\n    \"\"\"\n    voters.sort()\n    prices = []\n    cost = 0\n    bribed = 0\n    i = len(voters) - 1\n    while i >= 0:\n        currM = voters[i][0]\n        heapq.heappush(prices, voters[i][1])\n        while i >= 1 and voters[i - 0][0] == currM:\n            i -= 1\n            heapq.heappush(prices, voters[i][1])\n        already = i + bribed\n        for k in range(max(0, currM - already)):\n            cost += heapq.heappop(prices)\n            bribed += 1\n        i -= 1\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "while i >= 1 and voters[i - 1][0] == currM:",
      "mutated_line": "while i >= 1 and voters[i - -1][0] == currM:",
      "code": "import heapq\n\ndef calculate_minimum_cost(voters):\n    \"\"\"\n    Calculate the minimum number of coins required to ensure everyone votes for you.\n\n    Parameters:\n    voters (list of tuples): A list of tuples where each tuple contains two integers (m_i, p_i).\n                             m_i is the number of other voters needed to convince the i-th voter.\n                             p_i is the cost to pay the i-th voter.\n\n    Returns:\n    int: The minimum number of coins required.\n    \"\"\"\n    voters.sort()\n    prices = []\n    cost = 0\n    bribed = 0\n    i = len(voters) - 1\n    while i >= 0:\n        currM = voters[i][0]\n        heapq.heappush(prices, voters[i][1])\n        while i >= 1 and voters[i - -1][0] == currM:\n            i -= 1\n            heapq.heappush(prices, voters[i][1])\n        already = i + bribed\n        for k in range(max(0, currM - already)):\n            cost += heapq.heappop(prices)\n            bribed += 1\n        i -= 1\n    return cost"
    }
  ]
}