{
  "task_id": "taco_13140",
  "entry_point": "minimum_cost_to_make_identical",
  "mutant_count": 90,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if p != q:",
      "mutated_line": "if p == q:",
      "code": "from collections import Counter\n\ndef minimum_cost_to_make_identical(A, B):\n    combined = sorted(A + B)\n    p = [combined[i] for i in range(0, 2 * len(A), 2)]\n    q = [combined[i] for i in range(1, 2 * len(A) + 1, 2)]\n    if p == q:\n        return -1\n    A.sort()\n    B.sort()\n    if A == B:\n        return 0\n    xx = list((Counter(A) - Counter(p)).elements())\n    yy = list((Counter(B) - Counter(p)).elements())\n    num_swaps = len(xx)\n    gb = sorted(xx + yy)\n    min_element = min(combined[0], xx[0], yy[0])\n    cost = 0\n    for i in range(num_swaps):\n        if gb[i] <= min_element * 2:\n            cost += gb[i]\n        else:\n            cost += min_element * 2\n    return cost"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if A == B:",
      "mutated_line": "if A != B:",
      "code": "from collections import Counter\n\ndef minimum_cost_to_make_identical(A, B):\n    combined = sorted(A + B)\n    p = [combined[i] for i in range(0, 2 * len(A), 2)]\n    q = [combined[i] for i in range(1, 2 * len(A) + 1, 2)]\n    if p != q:\n        return -1\n    A.sort()\n    B.sort()\n    if A != B:\n        return 0\n    xx = list((Counter(A) - Counter(p)).elements())\n    yy = list((Counter(B) - Counter(p)).elements())\n    num_swaps = len(xx)\n    gb = sorted(xx + yy)\n    min_element = min(combined[0], xx[0], yy[0])\n    cost = 0\n    for i in range(num_swaps):\n        if gb[i] <= min_element * 2:\n            cost += gb[i]\n        else:\n            cost += min_element * 2\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "cost = 0",
      "mutated_line": "cost = 1",
      "code": "from collections import Counter\n\ndef minimum_cost_to_make_identical(A, B):\n    combined = sorted(A + B)\n    p = [combined[i] for i in range(0, 2 * len(A), 2)]\n    q = [combined[i] for i in range(1, 2 * len(A) + 1, 2)]\n    if p != q:\n        return -1\n    A.sort()\n    B.sort()\n    if A == B:\n        return 0\n    xx = list((Counter(A) - Counter(p)).elements())\n    yy = list((Counter(B) - Counter(p)).elements())\n    num_swaps = len(xx)\n    gb = sorted(xx + yy)\n    min_element = min(combined[0], xx[0], yy[0])\n    cost = 1\n    for i in range(num_swaps):\n        if gb[i] <= min_element * 2:\n            cost += gb[i]\n        else:\n            cost += min_element * 2\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "cost = 0",
      "mutated_line": "cost = -1",
      "code": "from collections import Counter\n\ndef minimum_cost_to_make_identical(A, B):\n    combined = sorted(A + B)\n    p = [combined[i] for i in range(0, 2 * len(A), 2)]\n    q = [combined[i] for i in range(1, 2 * len(A) + 1, 2)]\n    if p != q:\n        return -1\n    A.sort()\n    B.sort()\n    if A == B:\n        return 0\n    xx = list((Counter(A) - Counter(p)).elements())\n    yy = list((Counter(B) - Counter(p)).elements())\n    num_swaps = len(xx)\n    gb = sorted(xx + yy)\n    min_element = min(combined[0], xx[0], yy[0])\n    cost = -1\n    for i in range(num_swaps):\n        if gb[i] <= min_element * 2:\n            cost += gb[i]\n        else:\n            cost += min_element * 2\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "cost = 0",
      "mutated_line": "cost = 1",
      "code": "from collections import Counter\n\ndef minimum_cost_to_make_identical(A, B):\n    combined = sorted(A + B)\n    p = [combined[i] for i in range(0, 2 * len(A), 2)]\n    q = [combined[i] for i in range(1, 2 * len(A) + 1, 2)]\n    if p != q:\n        return -1\n    A.sort()\n    B.sort()\n    if A == B:\n        return 0\n    xx = list((Counter(A) - Counter(p)).elements())\n    yy = list((Counter(B) - Counter(p)).elements())\n    num_swaps = len(xx)\n    gb = sorted(xx + yy)\n    min_element = min(combined[0], xx[0], yy[0])\n    cost = 1\n    for i in range(num_swaps):\n        if gb[i] <= min_element * 2:\n            cost += gb[i]\n        else:\n            cost += min_element * 2\n    return cost"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "combined = sorted(A + B)",
      "mutated_line": "combined = sorted(A - B)",
      "code": "from collections import Counter\n\ndef minimum_cost_to_make_identical(A, B):\n    combined = sorted(A - B)\n    p = [combined[i] for i in range(0, 2 * len(A), 2)]\n    q = [combined[i] for i in range(1, 2 * len(A) + 1, 2)]\n    if p != q:\n        return -1\n    A.sort()\n    B.sort()\n    if A == B:\n        return 0\n    xx = list((Counter(A) - Counter(p)).elements())\n    yy = list((Counter(B) - Counter(p)).elements())\n    num_swaps = len(xx)\n    gb = sorted(xx + yy)\n    min_element = min(combined[0], xx[0], yy[0])\n    cost = 0\n    for i in range(num_swaps):\n        if gb[i] <= min_element * 2:\n            cost += gb[i]\n        else:\n            cost += min_element * 2\n    return cost"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "combined = sorted(A + B)",
      "mutated_line": "combined = sorted(A * B)",
      "code": "from collections import Counter\n\ndef minimum_cost_to_make_identical(A, B):\n    combined = sorted(A * B)\n    p = [combined[i] for i in range(0, 2 * len(A), 2)]\n    q = [combined[i] for i in range(1, 2 * len(A) + 1, 2)]\n    if p != q:\n        return -1\n    A.sort()\n    B.sort()\n    if A == B:\n        return 0\n    xx = list((Counter(A) - Counter(p)).elements())\n    yy = list((Counter(B) - Counter(p)).elements())\n    num_swaps = len(xx)\n    gb = sorted(xx + yy)\n    min_element = min(combined[0], xx[0], yy[0])\n    cost = 0\n    for i in range(num_swaps):\n        if gb[i] <= min_element * 2:\n            cost += gb[i]\n        else:\n            cost += min_element * 2\n    return cost"
    },
    {
      "operator": "UOI",
      "lineno": 13,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "from collections import Counter\n\ndef minimum_cost_to_make_identical(A, B):\n    combined = sorted(A + B)\n    p = [combined[i] for i in range(0, 2 * len(A), 2)]\n    q = [combined[i] for i in range(1, 2 * len(A) + 1, 2)]\n    if p != q:\n        return +1\n    A.sort()\n    B.sort()\n    if A == B:\n        return 0\n    xx = list((Counter(A) - Counter(p)).elements())\n    yy = list((Counter(B) - Counter(p)).elements())\n    num_swaps = len(xx)\n    gb = sorted(xx + yy)\n    min_element = min(combined[0], xx[0], yy[0])\n    cost = 0\n    for i in range(num_swaps):\n        if gb[i] <= min_element * 2:\n            cost += gb[i]\n        else:\n            cost += min_element * 2\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "from collections import Counter\n\ndef minimum_cost_to_make_identical(A, B):\n    combined = sorted(A + B)\n    p = [combined[i] for i in range(0, 2 * len(A), 2)]\n    q = [combined[i] for i in range(1, 2 * len(A) + 1, 2)]\n    if p != q:\n        return -1\n    A.sort()\n    B.sort()\n    if A == B:\n        return 1\n    xx = list((Counter(A) - Counter(p)).elements())\n    yy = list((Counter(B) - Counter(p)).elements())\n    num_swaps = len(xx)\n    gb = sorted(xx + yy)\n    min_element = min(combined[0], xx[0], yy[0])\n    cost = 0\n    for i in range(num_swaps):\n        if gb[i] <= min_element * 2:\n            cost += gb[i]\n        else:\n            cost += min_element * 2\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "from collections import Counter\n\ndef minimum_cost_to_make_identical(A, B):\n    combined = sorted(A + B)\n    p = [combined[i] for i in range(0, 2 * len(A), 2)]\n    q = [combined[i] for i in range(1, 2 * len(A) + 1, 2)]\n    if p != q:\n        return -1\n    A.sort()\n    B.sort()\n    if A == B:\n        return -1\n    xx = list((Counter(A) - Counter(p)).elements())\n    yy = list((Counter(B) - Counter(p)).elements())\n    num_swaps = len(xx)\n    gb = sorted(xx + yy)\n    min_element = min(combined[0], xx[0], yy[0])\n    cost = 0\n    for i in range(num_swaps):\n        if gb[i] <= min_element * 2:\n            cost += gb[i]\n        else:\n            cost += min_element * 2\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "from collections import Counter\n\ndef minimum_cost_to_make_identical(A, B):\n    combined = sorted(A + B)\n    p = [combined[i] for i in range(0, 2 * len(A), 2)]\n    q = [combined[i] for i in range(1, 2 * len(A) + 1, 2)]\n    if p != q:\n        return -1\n    A.sort()\n    B.sort()\n    if A == B:\n        return 1\n    xx = list((Counter(A) - Counter(p)).elements())\n    yy = list((Counter(B) - Counter(p)).elements())\n    num_swaps = len(xx)\n    gb = sorted(xx + yy)\n    min_element = min(combined[0], xx[0], yy[0])\n    cost = 0\n    for i in range(num_swaps):\n        if gb[i] <= min_element * 2:\n            cost += gb[i]\n        else:\n            cost += min_element * 2\n    return cost"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "gb = sorted(xx + yy)",
      "mutated_line": "gb = sorted(xx - yy)",
      "code": "from collections import Counter\n\ndef minimum_cost_to_make_identical(A, B):\n    combined = sorted(A + B)\n    p = [combined[i] for i in range(0, 2 * len(A), 2)]\n    q = [combined[i] for i in range(1, 2 * len(A) + 1, 2)]\n    if p != q:\n        return -1\n    A.sort()\n    B.sort()\n    if A == B:\n        return 0\n    xx = list((Counter(A) - Counter(p)).elements())\n    yy = list((Counter(B) - Counter(p)).elements())\n    num_swaps = len(xx)\n    gb = sorted(xx - yy)\n    min_element = min(combined[0], xx[0], yy[0])\n    cost = 0\n    for i in range(num_swaps):\n        if gb[i] <= min_element * 2:\n            cost += gb[i]\n        else:\n            cost += min_element * 2\n    return cost"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "gb = sorted(xx + yy)",
      "mutated_line": "gb = sorted(xx * yy)",
      "code": "from collections import Counter\n\ndef minimum_cost_to_make_identical(A, B):\n    combined = sorted(A + B)\n    p = [combined[i] for i in range(0, 2 * len(A), 2)]\n    q = [combined[i] for i in range(1, 2 * len(A) + 1, 2)]\n    if p != q:\n        return -1\n    A.sort()\n    B.sort()\n    if A == B:\n        return 0\n    xx = list((Counter(A) - Counter(p)).elements())\n    yy = list((Counter(B) - Counter(p)).elements())\n    num_swaps = len(xx)\n    gb = sorted(xx * yy)\n    min_element = min(combined[0], xx[0], yy[0])\n    cost = 0\n    for i in range(num_swaps):\n        if gb[i] <= min_element * 2:\n            cost += gb[i]\n        else:\n            cost += min_element * 2\n    return cost"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if gb[i] <= min_element * 2:",
      "mutated_line": "if gb[i] < min_element * 2:",
      "code": "from collections import Counter\n\ndef minimum_cost_to_make_identical(A, B):\n    combined = sorted(A + B)\n    p = [combined[i] for i in range(0, 2 * len(A), 2)]\n    q = [combined[i] for i in range(1, 2 * len(A) + 1, 2)]\n    if p != q:\n        return -1\n    A.sort()\n    B.sort()\n    if A == B:\n        return 0\n    xx = list((Counter(A) - Counter(p)).elements())\n    yy = list((Counter(B) - Counter(p)).elements())\n    num_swaps = len(xx)\n    gb = sorted(xx + yy)\n    min_element = min(combined[0], xx[0], yy[0])\n    cost = 0\n    for i in range(num_swaps):\n        if gb[i] < min_element * 2:\n            cost += gb[i]\n        else:\n            cost += min_element * 2\n    return cost"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if gb[i] <= min_element * 2:",
      "mutated_line": "if gb[i] > min_element * 2:",
      "code": "from collections import Counter\n\ndef minimum_cost_to_make_identical(A, B):\n    combined = sorted(A + B)\n    p = [combined[i] for i in range(0, 2 * len(A), 2)]\n    q = [combined[i] for i in range(1, 2 * len(A) + 1, 2)]\n    if p != q:\n        return -1\n    A.sort()\n    B.sort()\n    if A == B:\n        return 0\n    xx = list((Counter(A) - Counter(p)).elements())\n    yy = list((Counter(B) - Counter(p)).elements())\n    num_swaps = len(xx)\n    gb = sorted(xx + yy)\n    min_element = min(combined[0], xx[0], yy[0])\n    cost = 0\n    for i in range(num_swaps):\n        if gb[i] > min_element * 2:\n            cost += gb[i]\n        else:\n            cost += min_element * 2\n    return cost"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if gb[i] <= min_element * 2:",
      "mutated_line": "if gb[i] == min_element * 2:",
      "code": "from collections import Counter\n\ndef minimum_cost_to_make_identical(A, B):\n    combined = sorted(A + B)\n    p = [combined[i] for i in range(0, 2 * len(A), 2)]\n    q = [combined[i] for i in range(1, 2 * len(A) + 1, 2)]\n    if p != q:\n        return -1\n    A.sort()\n    B.sort()\n    if A == B:\n        return 0\n    xx = list((Counter(A) - Counter(p)).elements())\n    yy = list((Counter(B) - Counter(p)).elements())\n    num_swaps = len(xx)\n    gb = sorted(xx + yy)\n    min_element = min(combined[0], xx[0], yy[0])\n    cost = 0\n    for i in range(num_swaps):\n        if gb[i] == min_element * 2:\n            cost += gb[i]\n        else:\n            cost += min_element * 2\n    return cost"
    },
    {
      "operator": "ASR",
      "lineno": 40,
      "original_line": "cost += gb[i]",
      "mutated_line": "cost -= gb[i]",
      "code": "from collections import Counter\n\ndef minimum_cost_to_make_identical(A, B):\n    combined = sorted(A + B)\n    p = [combined[i] for i in range(0, 2 * len(A), 2)]\n    q = [combined[i] for i in range(1, 2 * len(A) + 1, 2)]\n    if p != q:\n        return -1\n    A.sort()\n    B.sort()\n    if A == B:\n        return 0\n    xx = list((Counter(A) - Counter(p)).elements())\n    yy = list((Counter(B) - Counter(p)).elements())\n    num_swaps = len(xx)\n    gb = sorted(xx + yy)\n    min_element = min(combined[0], xx[0], yy[0])\n    cost = 0\n    for i in range(num_swaps):\n        if gb[i] <= min_element * 2:\n            cost -= gb[i]\n        else:\n            cost += min_element * 2\n    return cost"
    },
    {
      "operator": "ASR",
      "lineno": 42,
      "original_line": "cost += min_element * 2",
      "mutated_line": "cost -= min_element * 2",
      "code": "from collections import Counter\n\ndef minimum_cost_to_make_identical(A, B):\n    combined = sorted(A + B)\n    p = [combined[i] for i in range(0, 2 * len(A), 2)]\n    q = [combined[i] for i in range(1, 2 * len(A) + 1, 2)]\n    if p != q:\n        return -1\n    A.sort()\n    B.sort()\n    if A == B:\n        return 0\n    xx = list((Counter(A) - Counter(p)).elements())\n    yy = list((Counter(B) - Counter(p)).elements())\n    num_swaps = len(xx)\n    gb = sorted(xx + yy)\n    min_element = min(combined[0], xx[0], yy[0])\n    cost = 0\n    for i in range(num_swaps):\n        if gb[i] <= min_element * 2:\n            cost += gb[i]\n        else:\n            cost -= min_element * 2\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "from collections import Counter\n\ndef minimum_cost_to_make_identical(A, B):\n    combined = sorted(A + B)\n    p = [combined[i] for i in range(0, 2 * len(A), 2)]\n    q = [combined[i] for i in range(1, 2 * len(A) + 1, 2)]\n    if p != q:\n        return -2\n    A.sort()\n    B.sort()\n    if A == B:\n        return 0\n    xx = list((Counter(A) - Counter(p)).elements())\n    yy = list((Counter(B) - Counter(p)).elements())\n    num_swaps = len(xx)\n    gb = sorted(xx + yy)\n    min_element = min(combined[0], xx[0], yy[0])\n    cost = 0\n    for i in range(num_swaps):\n        if gb[i] <= min_element * 2:\n            cost += gb[i]\n        else:\n            cost += min_element * 2\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from collections import Counter\n\ndef minimum_cost_to_make_identical(A, B):\n    combined = sorted(A + B)\n    p = [combined[i] for i in range(0, 2 * len(A), 2)]\n    q = [combined[i] for i in range(1, 2 * len(A) + 1, 2)]\n    if p != q:\n        return -0\n    A.sort()\n    B.sort()\n    if A == B:\n        return 0\n    xx = list((Counter(A) - Counter(p)).elements())\n    yy = list((Counter(B) - Counter(p)).elements())\n    num_swaps = len(xx)\n    gb = sorted(xx + yy)\n    min_element = min(combined[0], xx[0], yy[0])\n    cost = 0\n    for i in range(num_swaps):\n        if gb[i] <= min_element * 2:\n            cost += gb[i]\n        else:\n            cost += min_element * 2\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from collections import Counter\n\ndef minimum_cost_to_make_identical(A, B):\n    combined = sorted(A + B)\n    p = [combined[i] for i in range(0, 2 * len(A), 2)]\n    q = [combined[i] for i in range(1, 2 * len(A) + 1, 2)]\n    if p != q:\n        return -0\n    A.sort()\n    B.sort()\n    if A == B:\n        return 0\n    xx = list((Counter(A) - Counter(p)).elements())\n    yy = list((Counter(B) - Counter(p)).elements())\n    num_swaps = len(xx)\n    gb = sorted(xx + yy)\n    min_element = min(combined[0], xx[0], yy[0])\n    cost = 0\n    for i in range(num_swaps):\n        if gb[i] <= min_element * 2:\n            cost += gb[i]\n        else:\n            cost += min_element * 2\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "from collections import Counter\n\ndef minimum_cost_to_make_identical(A, B):\n    combined = sorted(A + B)\n    p = [combined[i] for i in range(0, 2 * len(A), 2)]\n    q = [combined[i] for i in range(1, 2 * len(A) + 1, 2)]\n    if p != q:\n        return --1\n    A.sort()\n    B.sort()\n    if A == B:\n        return 0\n    xx = list((Counter(A) - Counter(p)).elements())\n    yy = list((Counter(B) - Counter(p)).elements())\n    num_swaps = len(xx)\n    gb = sorted(xx + yy)\n    min_element = min(combined[0], xx[0], yy[0])\n    cost = 0\n    for i in range(num_swaps):\n        if gb[i] <= min_element * 2:\n            cost += gb[i]\n        else:\n            cost += min_element * 2\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "min_element = min(combined[0], xx[0], yy[0])",
      "mutated_line": "min_element = min(combined[1], xx[0], yy[0])",
      "code": "from collections import Counter\n\ndef minimum_cost_to_make_identical(A, B):\n    combined = sorted(A + B)\n    p = [combined[i] for i in range(0, 2 * len(A), 2)]\n    q = [combined[i] for i in range(1, 2 * len(A) + 1, 2)]\n    if p != q:\n        return -1\n    A.sort()\n    B.sort()\n    if A == B:\n        return 0\n    xx = list((Counter(A) - Counter(p)).elements())\n    yy = list((Counter(B) - Counter(p)).elements())\n    num_swaps = len(xx)\n    gb = sorted(xx + yy)\n    min_element = min(combined[1], xx[0], yy[0])\n    cost = 0\n    for i in range(num_swaps):\n        if gb[i] <= min_element * 2:\n            cost += gb[i]\n        else:\n            cost += min_element * 2\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "min_element = min(combined[0], xx[0], yy[0])",
      "mutated_line": "min_element = min(combined[-1], xx[0], yy[0])",
      "code": "from collections import Counter\n\ndef minimum_cost_to_make_identical(A, B):\n    combined = sorted(A + B)\n    p = [combined[i] for i in range(0, 2 * len(A), 2)]\n    q = [combined[i] for i in range(1, 2 * len(A) + 1, 2)]\n    if p != q:\n        return -1\n    A.sort()\n    B.sort()\n    if A == B:\n        return 0\n    xx = list((Counter(A) - Counter(p)).elements())\n    yy = list((Counter(B) - Counter(p)).elements())\n    num_swaps = len(xx)\n    gb = sorted(xx + yy)\n    min_element = min(combined[-1], xx[0], yy[0])\n    cost = 0\n    for i in range(num_swaps):\n        if gb[i] <= min_element * 2:\n            cost += gb[i]\n        else:\n            cost += min_element * 2\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "min_element = min(combined[0], xx[0], yy[0])",
      "mutated_line": "min_element = min(combined[1], xx[0], yy[0])",
      "code": "from collections import Counter\n\ndef minimum_cost_to_make_identical(A, B):\n    combined = sorted(A + B)\n    p = [combined[i] for i in range(0, 2 * len(A), 2)]\n    q = [combined[i] for i in range(1, 2 * len(A) + 1, 2)]\n    if p != q:\n        return -1\n    A.sort()\n    B.sort()\n    if A == B:\n        return 0\n    xx = list((Counter(A) - Counter(p)).elements())\n    yy = list((Counter(B) - Counter(p)).elements())\n    num_swaps = len(xx)\n    gb = sorted(xx + yy)\n    min_element = min(combined[1], xx[0], yy[0])\n    cost = 0\n    for i in range(num_swaps):\n        if gb[i] <= min_element * 2:\n            cost += gb[i]\n        else:\n            cost += min_element * 2\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "min_element = min(combined[0], xx[0], yy[0])",
      "mutated_line": "min_element = min(combined[0], xx[1], yy[0])",
      "code": "from collections import Counter\n\ndef minimum_cost_to_make_identical(A, B):\n    combined = sorted(A + B)\n    p = [combined[i] for i in range(0, 2 * len(A), 2)]\n    q = [combined[i] for i in range(1, 2 * len(A) + 1, 2)]\n    if p != q:\n        return -1\n    A.sort()\n    B.sort()\n    if A == B:\n        return 0\n    xx = list((Counter(A) - Counter(p)).elements())\n    yy = list((Counter(B) - Counter(p)).elements())\n    num_swaps = len(xx)\n    gb = sorted(xx + yy)\n    min_element = min(combined[0], xx[1], yy[0])\n    cost = 0\n    for i in range(num_swaps):\n        if gb[i] <= min_element * 2:\n            cost += gb[i]\n        else:\n            cost += min_element * 2\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "min_element = min(combined[0], xx[0], yy[0])",
      "mutated_line": "min_element = min(combined[0], xx[-1], yy[0])",
      "code": "from collections import Counter\n\ndef minimum_cost_to_make_identical(A, B):\n    combined = sorted(A + B)\n    p = [combined[i] for i in range(0, 2 * len(A), 2)]\n    q = [combined[i] for i in range(1, 2 * len(A) + 1, 2)]\n    if p != q:\n        return -1\n    A.sort()\n    B.sort()\n    if A == B:\n        return 0\n    xx = list((Counter(A) - Counter(p)).elements())\n    yy = list((Counter(B) - Counter(p)).elements())\n    num_swaps = len(xx)\n    gb = sorted(xx + yy)\n    min_element = min(combined[0], xx[-1], yy[0])\n    cost = 0\n    for i in range(num_swaps):\n        if gb[i] <= min_element * 2:\n            cost += gb[i]\n        else:\n            cost += min_element * 2\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "min_element = min(combined[0], xx[0], yy[0])",
      "mutated_line": "min_element = min(combined[0], xx[1], yy[0])",
      "code": "from collections import Counter\n\ndef minimum_cost_to_make_identical(A, B):\n    combined = sorted(A + B)\n    p = [combined[i] for i in range(0, 2 * len(A), 2)]\n    q = [combined[i] for i in range(1, 2 * len(A) + 1, 2)]\n    if p != q:\n        return -1\n    A.sort()\n    B.sort()\n    if A == B:\n        return 0\n    xx = list((Counter(A) - Counter(p)).elements())\n    yy = list((Counter(B) - Counter(p)).elements())\n    num_swaps = len(xx)\n    gb = sorted(xx + yy)\n    min_element = min(combined[0], xx[1], yy[0])\n    cost = 0\n    for i in range(num_swaps):\n        if gb[i] <= min_element * 2:\n            cost += gb[i]\n        else:\n            cost += min_element * 2\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "min_element = min(combined[0], xx[0], yy[0])",
      "mutated_line": "min_element = min(combined[0], xx[0], yy[1])",
      "code": "from collections import Counter\n\ndef minimum_cost_to_make_identical(A, B):\n    combined = sorted(A + B)\n    p = [combined[i] for i in range(0, 2 * len(A), 2)]\n    q = [combined[i] for i in range(1, 2 * len(A) + 1, 2)]\n    if p != q:\n        return -1\n    A.sort()\n    B.sort()\n    if A == B:\n        return 0\n    xx = list((Counter(A) - Counter(p)).elements())\n    yy = list((Counter(B) - Counter(p)).elements())\n    num_swaps = len(xx)\n    gb = sorted(xx + yy)\n    min_element = min(combined[0], xx[0], yy[1])\n    cost = 0\n    for i in range(num_swaps):\n        if gb[i] <= min_element * 2:\n            cost += gb[i]\n        else:\n            cost += min_element * 2\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "min_element = min(combined[0], xx[0], yy[0])",
      "mutated_line": "min_element = min(combined[0], xx[0], yy[-1])",
      "code": "from collections import Counter\n\ndef minimum_cost_to_make_identical(A, B):\n    combined = sorted(A + B)\n    p = [combined[i] for i in range(0, 2 * len(A), 2)]\n    q = [combined[i] for i in range(1, 2 * len(A) + 1, 2)]\n    if p != q:\n        return -1\n    A.sort()\n    B.sort()\n    if A == B:\n        return 0\n    xx = list((Counter(A) - Counter(p)).elements())\n    yy = list((Counter(B) - Counter(p)).elements())\n    num_swaps = len(xx)\n    gb = sorted(xx + yy)\n    min_element = min(combined[0], xx[0], yy[-1])\n    cost = 0\n    for i in range(num_swaps):\n        if gb[i] <= min_element * 2:\n            cost += gb[i]\n        else:\n            cost += min_element * 2\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "min_element = min(combined[0], xx[0], yy[0])",
      "mutated_line": "min_element = min(combined[0], xx[0], yy[1])",
      "code": "from collections import Counter\n\ndef minimum_cost_to_make_identical(A, B):\n    combined = sorted(A + B)\n    p = [combined[i] for i in range(0, 2 * len(A), 2)]\n    q = [combined[i] for i in range(1, 2 * len(A) + 1, 2)]\n    if p != q:\n        return -1\n    A.sort()\n    B.sort()\n    if A == B:\n        return 0\n    xx = list((Counter(A) - Counter(p)).elements())\n    yy = list((Counter(B) - Counter(p)).elements())\n    num_swaps = len(xx)\n    gb = sorted(xx + yy)\n    min_element = min(combined[0], xx[0], yy[1])\n    cost = 0\n    for i in range(num_swaps):\n        if gb[i] <= min_element * 2:\n            cost += gb[i]\n        else:\n            cost += min_element * 2\n    return cost"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "if gb[i] <= min_element * 2:",
      "mutated_line": "if gb[i] <= min_element / 2:",
      "code": "from collections import Counter\n\ndef minimum_cost_to_make_identical(A, B):\n    combined = sorted(A + B)\n    p = [combined[i] for i in range(0, 2 * len(A), 2)]\n    q = [combined[i] for i in range(1, 2 * len(A) + 1, 2)]\n    if p != q:\n        return -1\n    A.sort()\n    B.sort()\n    if A == B:\n        return 0\n    xx = list((Counter(A) - Counter(p)).elements())\n    yy = list((Counter(B) - Counter(p)).elements())\n    num_swaps = len(xx)\n    gb = sorted(xx + yy)\n    min_element = min(combined[0], xx[0], yy[0])\n    cost = 0\n    for i in range(num_swaps):\n        if gb[i] <= min_element / 2:\n            cost += gb[i]\n        else:\n            cost += min_element * 2\n    return cost"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "if gb[i] <= min_element * 2:",
      "mutated_line": "if gb[i] <= min_element + 2:",
      "code": "from collections import Counter\n\ndef minimum_cost_to_make_identical(A, B):\n    combined = sorted(A + B)\n    p = [combined[i] for i in range(0, 2 * len(A), 2)]\n    q = [combined[i] for i in range(1, 2 * len(A) + 1, 2)]\n    if p != q:\n        return -1\n    A.sort()\n    B.sort()\n    if A == B:\n        return 0\n    xx = list((Counter(A) - Counter(p)).elements())\n    yy = list((Counter(B) - Counter(p)).elements())\n    num_swaps = len(xx)\n    gb = sorted(xx + yy)\n    min_element = min(combined[0], xx[0], yy[0])\n    cost = 0\n    for i in range(num_swaps):\n        if gb[i] <= min_element + 2:\n            cost += gb[i]\n        else:\n            cost += min_element * 2\n    return cost"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "if gb[i] <= min_element * 2:",
      "mutated_line": "if gb[i] <= min_element ** 2:",
      "code": "from collections import Counter\n\ndef minimum_cost_to_make_identical(A, B):\n    combined = sorted(A + B)\n    p = [combined[i] for i in range(0, 2 * len(A), 2)]\n    q = [combined[i] for i in range(1, 2 * len(A) + 1, 2)]\n    if p != q:\n        return -1\n    A.sort()\n    B.sort()\n    if A == B:\n        return 0\n    xx = list((Counter(A) - Counter(p)).elements())\n    yy = list((Counter(B) - Counter(p)).elements())\n    num_swaps = len(xx)\n    gb = sorted(xx + yy)\n    min_element = min(combined[0], xx[0], yy[0])\n    cost = 0\n    for i in range(num_swaps):\n        if gb[i] <= min_element ** 2:\n            cost += gb[i]\n        else:\n            cost += min_element * 2\n    return cost"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "cost += min_element * 2",
      "mutated_line": "cost += min_element / 2",
      "code": "from collections import Counter\n\ndef minimum_cost_to_make_identical(A, B):\n    combined = sorted(A + B)\n    p = [combined[i] for i in range(0, 2 * len(A), 2)]\n    q = [combined[i] for i in range(1, 2 * len(A) + 1, 2)]\n    if p != q:\n        return -1\n    A.sort()\n    B.sort()\n    if A == B:\n        return 0\n    xx = list((Counter(A) - Counter(p)).elements())\n    yy = list((Counter(B) - Counter(p)).elements())\n    num_swaps = len(xx)\n    gb = sorted(xx + yy)\n    min_element = min(combined[0], xx[0], yy[0])\n    cost = 0\n    for i in range(num_swaps):\n        if gb[i] <= min_element * 2:\n            cost += gb[i]\n        else:\n            cost += min_element / 2\n    return cost"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "cost += min_element * 2",
      "mutated_line": "cost += min_element + 2",
      "code": "from collections import Counter\n\ndef minimum_cost_to_make_identical(A, B):\n    combined = sorted(A + B)\n    p = [combined[i] for i in range(0, 2 * len(A), 2)]\n    q = [combined[i] for i in range(1, 2 * len(A) + 1, 2)]\n    if p != q:\n        return -1\n    A.sort()\n    B.sort()\n    if A == B:\n        return 0\n    xx = list((Counter(A) - Counter(p)).elements())\n    yy = list((Counter(B) - Counter(p)).elements())\n    num_swaps = len(xx)\n    gb = sorted(xx + yy)\n    min_element = min(combined[0], xx[0], yy[0])\n    cost = 0\n    for i in range(num_swaps):\n        if gb[i] <= min_element * 2:\n            cost += gb[i]\n        else:\n            cost += min_element + 2\n    return cost"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "cost += min_element * 2",
      "mutated_line": "cost += min_element ** 2",
      "code": "from collections import Counter\n\ndef minimum_cost_to_make_identical(A, B):\n    combined = sorted(A + B)\n    p = [combined[i] for i in range(0, 2 * len(A), 2)]\n    q = [combined[i] for i in range(1, 2 * len(A) + 1, 2)]\n    if p != q:\n        return -1\n    A.sort()\n    B.sort()\n    if A == B:\n        return 0\n    xx = list((Counter(A) - Counter(p)).elements())\n    yy = list((Counter(B) - Counter(p)).elements())\n    num_swaps = len(xx)\n    gb = sorted(xx + yy)\n    min_element = min(combined[0], xx[0], yy[0])\n    cost = 0\n    for i in range(num_swaps):\n        if gb[i] <= min_element * 2:\n            cost += gb[i]\n        else:\n            cost += min_element ** 2\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "p = [combined[i] for i in range(0, 2 * len(A), 2)]",
      "mutated_line": "p = [combined[i] for i in range(1, 2 * len(A), 2)]",
      "code": "from collections import Counter\n\ndef minimum_cost_to_make_identical(A, B):\n    combined = sorted(A + B)\n    p = [combined[i] for i in range(1, 2 * len(A), 2)]\n    q = [combined[i] for i in range(1, 2 * len(A) + 1, 2)]\n    if p != q:\n        return -1\n    A.sort()\n    B.sort()\n    if A == B:\n        return 0\n    xx = list((Counter(A) - Counter(p)).elements())\n    yy = list((Counter(B) - Counter(p)).elements())\n    num_swaps = len(xx)\n    gb = sorted(xx + yy)\n    min_element = min(combined[0], xx[0], yy[0])\n    cost = 0\n    for i in range(num_swaps):\n        if gb[i] <= min_element * 2:\n            cost += gb[i]\n        else:\n            cost += min_element * 2\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "p = [combined[i] for i in range(0, 2 * len(A), 2)]",
      "mutated_line": "p = [combined[i] for i in range(-1, 2 * len(A), 2)]",
      "code": "from collections import Counter\n\ndef minimum_cost_to_make_identical(A, B):\n    combined = sorted(A + B)\n    p = [combined[i] for i in range(-1, 2 * len(A), 2)]\n    q = [combined[i] for i in range(1, 2 * len(A) + 1, 2)]\n    if p != q:\n        return -1\n    A.sort()\n    B.sort()\n    if A == B:\n        return 0\n    xx = list((Counter(A) - Counter(p)).elements())\n    yy = list((Counter(B) - Counter(p)).elements())\n    num_swaps = len(xx)\n    gb = sorted(xx + yy)\n    min_element = min(combined[0], xx[0], yy[0])\n    cost = 0\n    for i in range(num_swaps):\n        if gb[i] <= min_element * 2:\n            cost += gb[i]\n        else:\n            cost += min_element * 2\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "p = [combined[i] for i in range(0, 2 * len(A), 2)]",
      "mutated_line": "p = [combined[i] for i in range(1, 2 * len(A), 2)]",
      "code": "from collections import Counter\n\ndef minimum_cost_to_make_identical(A, B):\n    combined = sorted(A + B)\n    p = [combined[i] for i in range(1, 2 * len(A), 2)]\n    q = [combined[i] for i in range(1, 2 * len(A) + 1, 2)]\n    if p != q:\n        return -1\n    A.sort()\n    B.sort()\n    if A == B:\n        return 0\n    xx = list((Counter(A) - Counter(p)).elements())\n    yy = list((Counter(B) - Counter(p)).elements())\n    num_swaps = len(xx)\n    gb = sorted(xx + yy)\n    min_element = min(combined[0], xx[0], yy[0])\n    cost = 0\n    for i in range(num_swaps):\n        if gb[i] <= min_element * 2:\n            cost += gb[i]\n        else:\n            cost += min_element * 2\n    return cost"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "p = [combined[i] for i in range(0, 2 * len(A), 2)]",
      "mutated_line": "p = [combined[i] for i in range(0, 2 / len(A), 2)]",
      "code": "from collections import Counter\n\ndef minimum_cost_to_make_identical(A, B):\n    combined = sorted(A + B)\n    p = [combined[i] for i in range(0, 2 / len(A), 2)]\n    q = [combined[i] for i in range(1, 2 * len(A) + 1, 2)]\n    if p != q:\n        return -1\n    A.sort()\n    B.sort()\n    if A == B:\n        return 0\n    xx = list((Counter(A) - Counter(p)).elements())\n    yy = list((Counter(B) - Counter(p)).elements())\n    num_swaps = len(xx)\n    gb = sorted(xx + yy)\n    min_element = min(combined[0], xx[0], yy[0])\n    cost = 0\n    for i in range(num_swaps):\n        if gb[i] <= min_element * 2:\n            cost += gb[i]\n        else:\n            cost += min_element * 2\n    return cost"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "p = [combined[i] for i in range(0, 2 * len(A), 2)]",
      "mutated_line": "p = [combined[i] for i in range(0, 2 + len(A), 2)]",
      "code": "from collections import Counter\n\ndef minimum_cost_to_make_identical(A, B):\n    combined = sorted(A + B)\n    p = [combined[i] for i in range(0, 2 + len(A), 2)]\n    q = [combined[i] for i in range(1, 2 * len(A) + 1, 2)]\n    if p != q:\n        return -1\n    A.sort()\n    B.sort()\n    if A == B:\n        return 0\n    xx = list((Counter(A) - Counter(p)).elements())\n    yy = list((Counter(B) - Counter(p)).elements())\n    num_swaps = len(xx)\n    gb = sorted(xx + yy)\n    min_element = min(combined[0], xx[0], yy[0])\n    cost = 0\n    for i in range(num_swaps):\n        if gb[i] <= min_element * 2:\n            cost += gb[i]\n        else:\n            cost += min_element * 2\n    return cost"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "p = [combined[i] for i in range(0, 2 * len(A), 2)]",
      "mutated_line": "p = [combined[i] for i in range(0, 2 ** len(A), 2)]",
      "code": "from collections import Counter\n\ndef minimum_cost_to_make_identical(A, B):\n    combined = sorted(A + B)\n    p = [combined[i] for i in range(0, 2 ** len(A), 2)]\n    q = [combined[i] for i in range(1, 2 * len(A) + 1, 2)]\n    if p != q:\n        return -1\n    A.sort()\n    B.sort()\n    if A == B:\n        return 0\n    xx = list((Counter(A) - Counter(p)).elements())\n    yy = list((Counter(B) - Counter(p)).elements())\n    num_swaps = len(xx)\n    gb = sorted(xx + yy)\n    min_element = min(combined[0], xx[0], yy[0])\n    cost = 0\n    for i in range(num_swaps):\n        if gb[i] <= min_element * 2:\n            cost += gb[i]\n        else:\n            cost += min_element * 2\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "p = [combined[i] for i in range(0, 2 * len(A), 2)]",
      "mutated_line": "p = [combined[i] for i in range(0, 2 * len(A), 3)]",
      "code": "from collections import Counter\n\ndef minimum_cost_to_make_identical(A, B):\n    combined = sorted(A + B)\n    p = [combined[i] for i in range(0, 2 * len(A), 3)]\n    q = [combined[i] for i in range(1, 2 * len(A) + 1, 2)]\n    if p != q:\n        return -1\n    A.sort()\n    B.sort()\n    if A == B:\n        return 0\n    xx = list((Counter(A) - Counter(p)).elements())\n    yy = list((Counter(B) - Counter(p)).elements())\n    num_swaps = len(xx)\n    gb = sorted(xx + yy)\n    min_element = min(combined[0], xx[0], yy[0])\n    cost = 0\n    for i in range(num_swaps):\n        if gb[i] <= min_element * 2:\n            cost += gb[i]\n        else:\n            cost += min_element * 2\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "p = [combined[i] for i in range(0, 2 * len(A), 2)]",
      "mutated_line": "p = [combined[i] for i in range(0, 2 * len(A), 1)]",
      "code": "from collections import Counter\n\ndef minimum_cost_to_make_identical(A, B):\n    combined = sorted(A + B)\n    p = [combined[i] for i in range(0, 2 * len(A), 1)]\n    q = [combined[i] for i in range(1, 2 * len(A) + 1, 2)]\n    if p != q:\n        return -1\n    A.sort()\n    B.sort()\n    if A == B:\n        return 0\n    xx = list((Counter(A) - Counter(p)).elements())\n    yy = list((Counter(B) - Counter(p)).elements())\n    num_swaps = len(xx)\n    gb = sorted(xx + yy)\n    min_element = min(combined[0], xx[0], yy[0])\n    cost = 0\n    for i in range(num_swaps):\n        if gb[i] <= min_element * 2:\n            cost += gb[i]\n        else:\n            cost += min_element * 2\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "p = [combined[i] for i in range(0, 2 * len(A), 2)]",
      "mutated_line": "p = [combined[i] for i in range(0, 2 * len(A), 0)]",
      "code": "from collections import Counter\n\ndef minimum_cost_to_make_identical(A, B):\n    combined = sorted(A + B)\n    p = [combined[i] for i in range(0, 2 * len(A), 0)]\n    q = [combined[i] for i in range(1, 2 * len(A) + 1, 2)]\n    if p != q:\n        return -1\n    A.sort()\n    B.sort()\n    if A == B:\n        return 0\n    xx = list((Counter(A) - Counter(p)).elements())\n    yy = list((Counter(B) - Counter(p)).elements())\n    num_swaps = len(xx)\n    gb = sorted(xx + yy)\n    min_element = min(combined[0], xx[0], yy[0])\n    cost = 0\n    for i in range(num_swaps):\n        if gb[i] <= min_element * 2:\n            cost += gb[i]\n        else:\n            cost += min_element * 2\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "p = [combined[i] for i in range(0, 2 * len(A), 2)]",
      "mutated_line": "p = [combined[i] for i in range(0, 2 * len(A), 1)]",
      "code": "from collections import Counter\n\ndef minimum_cost_to_make_identical(A, B):\n    combined = sorted(A + B)\n    p = [combined[i] for i in range(0, 2 * len(A), 1)]\n    q = [combined[i] for i in range(1, 2 * len(A) + 1, 2)]\n    if p != q:\n        return -1\n    A.sort()\n    B.sort()\n    if A == B:\n        return 0\n    xx = list((Counter(A) - Counter(p)).elements())\n    yy = list((Counter(B) - Counter(p)).elements())\n    num_swaps = len(xx)\n    gb = sorted(xx + yy)\n    min_element = min(combined[0], xx[0], yy[0])\n    cost = 0\n    for i in range(num_swaps):\n        if gb[i] <= min_element * 2:\n            cost += gb[i]\n        else:\n            cost += min_element * 2\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "p = [combined[i] for i in range(0, 2 * len(A), 2)]",
      "mutated_line": "p = [combined[i] for i in range(0, 2 * len(A), -2)]",
      "code": "from collections import Counter\n\ndef minimum_cost_to_make_identical(A, B):\n    combined = sorted(A + B)\n    p = [combined[i] for i in range(0, 2 * len(A), -2)]\n    q = [combined[i] for i in range(1, 2 * len(A) + 1, 2)]\n    if p != q:\n        return -1\n    A.sort()\n    B.sort()\n    if A == B:\n        return 0\n    xx = list((Counter(A) - Counter(p)).elements())\n    yy = list((Counter(B) - Counter(p)).elements())\n    num_swaps = len(xx)\n    gb = sorted(xx + yy)\n    min_element = min(combined[0], xx[0], yy[0])\n    cost = 0\n    for i in range(num_swaps):\n        if gb[i] <= min_element * 2:\n            cost += gb[i]\n        else:\n            cost += min_element * 2\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "q = [combined[i] for i in range(1, 2 * len(A) + 1, 2)]",
      "mutated_line": "q = [combined[i] for i in range(2, 2 * len(A) + 1, 2)]",
      "code": "from collections import Counter\n\ndef minimum_cost_to_make_identical(A, B):\n    combined = sorted(A + B)\n    p = [combined[i] for i in range(0, 2 * len(A), 2)]\n    q = [combined[i] for i in range(2, 2 * len(A) + 1, 2)]\n    if p != q:\n        return -1\n    A.sort()\n    B.sort()\n    if A == B:\n        return 0\n    xx = list((Counter(A) - Counter(p)).elements())\n    yy = list((Counter(B) - Counter(p)).elements())\n    num_swaps = len(xx)\n    gb = sorted(xx + yy)\n    min_element = min(combined[0], xx[0], yy[0])\n    cost = 0\n    for i in range(num_swaps):\n        if gb[i] <= min_element * 2:\n            cost += gb[i]\n        else:\n            cost += min_element * 2\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "q = [combined[i] for i in range(1, 2 * len(A) + 1, 2)]",
      "mutated_line": "q = [combined[i] for i in range(0, 2 * len(A) + 1, 2)]",
      "code": "from collections import Counter\n\ndef minimum_cost_to_make_identical(A, B):\n    combined = sorted(A + B)\n    p = [combined[i] for i in range(0, 2 * len(A), 2)]\n    q = [combined[i] for i in range(0, 2 * len(A) + 1, 2)]\n    if p != q:\n        return -1\n    A.sort()\n    B.sort()\n    if A == B:\n        return 0\n    xx = list((Counter(A) - Counter(p)).elements())\n    yy = list((Counter(B) - Counter(p)).elements())\n    num_swaps = len(xx)\n    gb = sorted(xx + yy)\n    min_element = min(combined[0], xx[0], yy[0])\n    cost = 0\n    for i in range(num_swaps):\n        if gb[i] <= min_element * 2:\n            cost += gb[i]\n        else:\n            cost += min_element * 2\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "q = [combined[i] for i in range(1, 2 * len(A) + 1, 2)]",
      "mutated_line": "q = [combined[i] for i in range(0, 2 * len(A) + 1, 2)]",
      "code": "from collections import Counter\n\ndef minimum_cost_to_make_identical(A, B):\n    combined = sorted(A + B)\n    p = [combined[i] for i in range(0, 2 * len(A), 2)]\n    q = [combined[i] for i in range(0, 2 * len(A) + 1, 2)]\n    if p != q:\n        return -1\n    A.sort()\n    B.sort()\n    if A == B:\n        return 0\n    xx = list((Counter(A) - Counter(p)).elements())\n    yy = list((Counter(B) - Counter(p)).elements())\n    num_swaps = len(xx)\n    gb = sorted(xx + yy)\n    min_element = min(combined[0], xx[0], yy[0])\n    cost = 0\n    for i in range(num_swaps):\n        if gb[i] <= min_element * 2:\n            cost += gb[i]\n        else:\n            cost += min_element * 2\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "q = [combined[i] for i in range(1, 2 * len(A) + 1, 2)]",
      "mutated_line": "q = [combined[i] for i in range(-1, 2 * len(A) + 1, 2)]",
      "code": "from collections import Counter\n\ndef minimum_cost_to_make_identical(A, B):\n    combined = sorted(A + B)\n    p = [combined[i] for i in range(0, 2 * len(A), 2)]\n    q = [combined[i] for i in range(-1, 2 * len(A) + 1, 2)]\n    if p != q:\n        return -1\n    A.sort()\n    B.sort()\n    if A == B:\n        return 0\n    xx = list((Counter(A) - Counter(p)).elements())\n    yy = list((Counter(B) - Counter(p)).elements())\n    num_swaps = len(xx)\n    gb = sorted(xx + yy)\n    min_element = min(combined[0], xx[0], yy[0])\n    cost = 0\n    for i in range(num_swaps):\n        if gb[i] <= min_element * 2:\n            cost += gb[i]\n        else:\n            cost += min_element * 2\n    return cost"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "q = [combined[i] for i in range(1, 2 * len(A) + 1, 2)]",
      "mutated_line": "q = [combined[i] for i in range(1, 2 * len(A) - 1, 2)]",
      "code": "from collections import Counter\n\ndef minimum_cost_to_make_identical(A, B):\n    combined = sorted(A + B)\n    p = [combined[i] for i in range(0, 2 * len(A), 2)]\n    q = [combined[i] for i in range(1, 2 * len(A) - 1, 2)]\n    if p != q:\n        return -1\n    A.sort()\n    B.sort()\n    if A == B:\n        return 0\n    xx = list((Counter(A) - Counter(p)).elements())\n    yy = list((Counter(B) - Counter(p)).elements())\n    num_swaps = len(xx)\n    gb = sorted(xx + yy)\n    min_element = min(combined[0], xx[0], yy[0])\n    cost = 0\n    for i in range(num_swaps):\n        if gb[i] <= min_element * 2:\n            cost += gb[i]\n        else:\n            cost += min_element * 2\n    return cost"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "q = [combined[i] for i in range(1, 2 * len(A) + 1, 2)]",
      "mutated_line": "q = [combined[i] for i in range(1, 2 * len(A) * 1, 2)]",
      "code": "from collections import Counter\n\ndef minimum_cost_to_make_identical(A, B):\n    combined = sorted(A + B)\n    p = [combined[i] for i in range(0, 2 * len(A), 2)]\n    q = [combined[i] for i in range(1, 2 * len(A) * 1, 2)]\n    if p != q:\n        return -1\n    A.sort()\n    B.sort()\n    if A == B:\n        return 0\n    xx = list((Counter(A) - Counter(p)).elements())\n    yy = list((Counter(B) - Counter(p)).elements())\n    num_swaps = len(xx)\n    gb = sorted(xx + yy)\n    min_element = min(combined[0], xx[0], yy[0])\n    cost = 0\n    for i in range(num_swaps):\n        if gb[i] <= min_element * 2:\n            cost += gb[i]\n        else:\n            cost += min_element * 2\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "q = [combined[i] for i in range(1, 2 * len(A) + 1, 2)]",
      "mutated_line": "q = [combined[i] for i in range(1, 2 * len(A) + 1, 3)]",
      "code": "from collections import Counter\n\ndef minimum_cost_to_make_identical(A, B):\n    combined = sorted(A + B)\n    p = [combined[i] for i in range(0, 2 * len(A), 2)]\n    q = [combined[i] for i in range(1, 2 * len(A) + 1, 3)]\n    if p != q:\n        return -1\n    A.sort()\n    B.sort()\n    if A == B:\n        return 0\n    xx = list((Counter(A) - Counter(p)).elements())\n    yy = list((Counter(B) - Counter(p)).elements())\n    num_swaps = len(xx)\n    gb = sorted(xx + yy)\n    min_element = min(combined[0], xx[0], yy[0])\n    cost = 0\n    for i in range(num_swaps):\n        if gb[i] <= min_element * 2:\n            cost += gb[i]\n        else:\n            cost += min_element * 2\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "q = [combined[i] for i in range(1, 2 * len(A) + 1, 2)]",
      "mutated_line": "q = [combined[i] for i in range(1, 2 * len(A) + 1, 1)]",
      "code": "from collections import Counter\n\ndef minimum_cost_to_make_identical(A, B):\n    combined = sorted(A + B)\n    p = [combined[i] for i in range(0, 2 * len(A), 2)]\n    q = [combined[i] for i in range(1, 2 * len(A) + 1, 1)]\n    if p != q:\n        return -1\n    A.sort()\n    B.sort()\n    if A == B:\n        return 0\n    xx = list((Counter(A) - Counter(p)).elements())\n    yy = list((Counter(B) - Counter(p)).elements())\n    num_swaps = len(xx)\n    gb = sorted(xx + yy)\n    min_element = min(combined[0], xx[0], yy[0])\n    cost = 0\n    for i in range(num_swaps):\n        if gb[i] <= min_element * 2:\n            cost += gb[i]\n        else:\n            cost += min_element * 2\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "q = [combined[i] for i in range(1, 2 * len(A) + 1, 2)]",
      "mutated_line": "q = [combined[i] for i in range(1, 2 * len(A) + 1, 0)]",
      "code": "from collections import Counter\n\ndef minimum_cost_to_make_identical(A, B):\n    combined = sorted(A + B)\n    p = [combined[i] for i in range(0, 2 * len(A), 2)]\n    q = [combined[i] for i in range(1, 2 * len(A) + 1, 0)]\n    if p != q:\n        return -1\n    A.sort()\n    B.sort()\n    if A == B:\n        return 0\n    xx = list((Counter(A) - Counter(p)).elements())\n    yy = list((Counter(B) - Counter(p)).elements())\n    num_swaps = len(xx)\n    gb = sorted(xx + yy)\n    min_element = min(combined[0], xx[0], yy[0])\n    cost = 0\n    for i in range(num_swaps):\n        if gb[i] <= min_element * 2:\n            cost += gb[i]\n        else:\n            cost += min_element * 2\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "q = [combined[i] for i in range(1, 2 * len(A) + 1, 2)]",
      "mutated_line": "q = [combined[i] for i in range(1, 2 * len(A) + 1, 1)]",
      "code": "from collections import Counter\n\ndef minimum_cost_to_make_identical(A, B):\n    combined = sorted(A + B)\n    p = [combined[i] for i in range(0, 2 * len(A), 2)]\n    q = [combined[i] for i in range(1, 2 * len(A) + 1, 1)]\n    if p != q:\n        return -1\n    A.sort()\n    B.sort()\n    if A == B:\n        return 0\n    xx = list((Counter(A) - Counter(p)).elements())\n    yy = list((Counter(B) - Counter(p)).elements())\n    num_swaps = len(xx)\n    gb = sorted(xx + yy)\n    min_element = min(combined[0], xx[0], yy[0])\n    cost = 0\n    for i in range(num_swaps):\n        if gb[i] <= min_element * 2:\n            cost += gb[i]\n        else:\n            cost += min_element * 2\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "q = [combined[i] for i in range(1, 2 * len(A) + 1, 2)]",
      "mutated_line": "q = [combined[i] for i in range(1, 2 * len(A) + 1, -2)]",
      "code": "from collections import Counter\n\ndef minimum_cost_to_make_identical(A, B):\n    combined = sorted(A + B)\n    p = [combined[i] for i in range(0, 2 * len(A), 2)]\n    q = [combined[i] for i in range(1, 2 * len(A) + 1, -2)]\n    if p != q:\n        return -1\n    A.sort()\n    B.sort()\n    if A == B:\n        return 0\n    xx = list((Counter(A) - Counter(p)).elements())\n    yy = list((Counter(B) - Counter(p)).elements())\n    num_swaps = len(xx)\n    gb = sorted(xx + yy)\n    min_element = min(combined[0], xx[0], yy[0])\n    cost = 0\n    for i in range(num_swaps):\n        if gb[i] <= min_element * 2:\n            cost += gb[i]\n        else:\n            cost += min_element * 2\n    return cost"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "xx = list((Counter(A) - Counter(p)).elements())",
      "mutated_line": "xx = list((Counter(A) + Counter(p)).elements())",
      "code": "from collections import Counter\n\ndef minimum_cost_to_make_identical(A, B):\n    combined = sorted(A + B)\n    p = [combined[i] for i in range(0, 2 * len(A), 2)]\n    q = [combined[i] for i in range(1, 2 * len(A) + 1, 2)]\n    if p != q:\n        return -1\n    A.sort()\n    B.sort()\n    if A == B:\n        return 0\n    xx = list((Counter(A) + Counter(p)).elements())\n    yy = list((Counter(B) - Counter(p)).elements())\n    num_swaps = len(xx)\n    gb = sorted(xx + yy)\n    min_element = min(combined[0], xx[0], yy[0])\n    cost = 0\n    for i in range(num_swaps):\n        if gb[i] <= min_element * 2:\n            cost += gb[i]\n        else:\n            cost += min_element * 2\n    return cost"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "xx = list((Counter(A) - Counter(p)).elements())",
      "mutated_line": "xx = list((Counter(A) * Counter(p)).elements())",
      "code": "from collections import Counter\n\ndef minimum_cost_to_make_identical(A, B):\n    combined = sorted(A + B)\n    p = [combined[i] for i in range(0, 2 * len(A), 2)]\n    q = [combined[i] for i in range(1, 2 * len(A) + 1, 2)]\n    if p != q:\n        return -1\n    A.sort()\n    B.sort()\n    if A == B:\n        return 0\n    xx = list((Counter(A) * Counter(p)).elements())\n    yy = list((Counter(B) - Counter(p)).elements())\n    num_swaps = len(xx)\n    gb = sorted(xx + yy)\n    min_element = min(combined[0], xx[0], yy[0])\n    cost = 0\n    for i in range(num_swaps):\n        if gb[i] <= min_element * 2:\n            cost += gb[i]\n        else:\n            cost += min_element * 2\n    return cost"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "yy = list((Counter(B) - Counter(p)).elements())",
      "mutated_line": "yy = list((Counter(B) + Counter(p)).elements())",
      "code": "from collections import Counter\n\ndef minimum_cost_to_make_identical(A, B):\n    combined = sorted(A + B)\n    p = [combined[i] for i in range(0, 2 * len(A), 2)]\n    q = [combined[i] for i in range(1, 2 * len(A) + 1, 2)]\n    if p != q:\n        return -1\n    A.sort()\n    B.sort()\n    if A == B:\n        return 0\n    xx = list((Counter(A) - Counter(p)).elements())\n    yy = list((Counter(B) + Counter(p)).elements())\n    num_swaps = len(xx)\n    gb = sorted(xx + yy)\n    min_element = min(combined[0], xx[0], yy[0])\n    cost = 0\n    for i in range(num_swaps):\n        if gb[i] <= min_element * 2:\n            cost += gb[i]\n        else:\n            cost += min_element * 2\n    return cost"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "yy = list((Counter(B) - Counter(p)).elements())",
      "mutated_line": "yy = list((Counter(B) * Counter(p)).elements())",
      "code": "from collections import Counter\n\ndef minimum_cost_to_make_identical(A, B):\n    combined = sorted(A + B)\n    p = [combined[i] for i in range(0, 2 * len(A), 2)]\n    q = [combined[i] for i in range(1, 2 * len(A) + 1, 2)]\n    if p != q:\n        return -1\n    A.sort()\n    B.sort()\n    if A == B:\n        return 0\n    xx = list((Counter(A) - Counter(p)).elements())\n    yy = list((Counter(B) * Counter(p)).elements())\n    num_swaps = len(xx)\n    gb = sorted(xx + yy)\n    min_element = min(combined[0], xx[0], yy[0])\n    cost = 0\n    for i in range(num_swaps):\n        if gb[i] <= min_element * 2:\n            cost += gb[i]\n        else:\n            cost += min_element * 2\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if gb[i] <= min_element * 2:",
      "mutated_line": "if gb[i] <= min_element * 3:",
      "code": "from collections import Counter\n\ndef minimum_cost_to_make_identical(A, B):\n    combined = sorted(A + B)\n    p = [combined[i] for i in range(0, 2 * len(A), 2)]\n    q = [combined[i] for i in range(1, 2 * len(A) + 1, 2)]\n    if p != q:\n        return -1\n    A.sort()\n    B.sort()\n    if A == B:\n        return 0\n    xx = list((Counter(A) - Counter(p)).elements())\n    yy = list((Counter(B) - Counter(p)).elements())\n    num_swaps = len(xx)\n    gb = sorted(xx + yy)\n    min_element = min(combined[0], xx[0], yy[0])\n    cost = 0\n    for i in range(num_swaps):\n        if gb[i] <= min_element * 3:\n            cost += gb[i]\n        else:\n            cost += min_element * 2\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if gb[i] <= min_element * 2:",
      "mutated_line": "if gb[i] <= min_element * 1:",
      "code": "from collections import Counter\n\ndef minimum_cost_to_make_identical(A, B):\n    combined = sorted(A + B)\n    p = [combined[i] for i in range(0, 2 * len(A), 2)]\n    q = [combined[i] for i in range(1, 2 * len(A) + 1, 2)]\n    if p != q:\n        return -1\n    A.sort()\n    B.sort()\n    if A == B:\n        return 0\n    xx = list((Counter(A) - Counter(p)).elements())\n    yy = list((Counter(B) - Counter(p)).elements())\n    num_swaps = len(xx)\n    gb = sorted(xx + yy)\n    min_element = min(combined[0], xx[0], yy[0])\n    cost = 0\n    for i in range(num_swaps):\n        if gb[i] <= min_element * 1:\n            cost += gb[i]\n        else:\n            cost += min_element * 2\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if gb[i] <= min_element * 2:",
      "mutated_line": "if gb[i] <= min_element * 0:",
      "code": "from collections import Counter\n\ndef minimum_cost_to_make_identical(A, B):\n    combined = sorted(A + B)\n    p = [combined[i] for i in range(0, 2 * len(A), 2)]\n    q = [combined[i] for i in range(1, 2 * len(A) + 1, 2)]\n    if p != q:\n        return -1\n    A.sort()\n    B.sort()\n    if A == B:\n        return 0\n    xx = list((Counter(A) - Counter(p)).elements())\n    yy = list((Counter(B) - Counter(p)).elements())\n    num_swaps = len(xx)\n    gb = sorted(xx + yy)\n    min_element = min(combined[0], xx[0], yy[0])\n    cost = 0\n    for i in range(num_swaps):\n        if gb[i] <= min_element * 0:\n            cost += gb[i]\n        else:\n            cost += min_element * 2\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if gb[i] <= min_element * 2:",
      "mutated_line": "if gb[i] <= min_element * 1:",
      "code": "from collections import Counter\n\ndef minimum_cost_to_make_identical(A, B):\n    combined = sorted(A + B)\n    p = [combined[i] for i in range(0, 2 * len(A), 2)]\n    q = [combined[i] for i in range(1, 2 * len(A) + 1, 2)]\n    if p != q:\n        return -1\n    A.sort()\n    B.sort()\n    if A == B:\n        return 0\n    xx = list((Counter(A) - Counter(p)).elements())\n    yy = list((Counter(B) - Counter(p)).elements())\n    num_swaps = len(xx)\n    gb = sorted(xx + yy)\n    min_element = min(combined[0], xx[0], yy[0])\n    cost = 0\n    for i in range(num_swaps):\n        if gb[i] <= min_element * 1:\n            cost += gb[i]\n        else:\n            cost += min_element * 2\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if gb[i] <= min_element * 2:",
      "mutated_line": "if gb[i] <= min_element * -2:",
      "code": "from collections import Counter\n\ndef minimum_cost_to_make_identical(A, B):\n    combined = sorted(A + B)\n    p = [combined[i] for i in range(0, 2 * len(A), 2)]\n    q = [combined[i] for i in range(1, 2 * len(A) + 1, 2)]\n    if p != q:\n        return -1\n    A.sort()\n    B.sort()\n    if A == B:\n        return 0\n    xx = list((Counter(A) - Counter(p)).elements())\n    yy = list((Counter(B) - Counter(p)).elements())\n    num_swaps = len(xx)\n    gb = sorted(xx + yy)\n    min_element = min(combined[0], xx[0], yy[0])\n    cost = 0\n    for i in range(num_swaps):\n        if gb[i] <= min_element * -2:\n            cost += gb[i]\n        else:\n            cost += min_element * 2\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "cost += min_element * 2",
      "mutated_line": "cost += min_element * 3",
      "code": "from collections import Counter\n\ndef minimum_cost_to_make_identical(A, B):\n    combined = sorted(A + B)\n    p = [combined[i] for i in range(0, 2 * len(A), 2)]\n    q = [combined[i] for i in range(1, 2 * len(A) + 1, 2)]\n    if p != q:\n        return -1\n    A.sort()\n    B.sort()\n    if A == B:\n        return 0\n    xx = list((Counter(A) - Counter(p)).elements())\n    yy = list((Counter(B) - Counter(p)).elements())\n    num_swaps = len(xx)\n    gb = sorted(xx + yy)\n    min_element = min(combined[0], xx[0], yy[0])\n    cost = 0\n    for i in range(num_swaps):\n        if gb[i] <= min_element * 2:\n            cost += gb[i]\n        else:\n            cost += min_element * 3\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "cost += min_element * 2",
      "mutated_line": "cost += min_element * 1",
      "code": "from collections import Counter\n\ndef minimum_cost_to_make_identical(A, B):\n    combined = sorted(A + B)\n    p = [combined[i] for i in range(0, 2 * len(A), 2)]\n    q = [combined[i] for i in range(1, 2 * len(A) + 1, 2)]\n    if p != q:\n        return -1\n    A.sort()\n    B.sort()\n    if A == B:\n        return 0\n    xx = list((Counter(A) - Counter(p)).elements())\n    yy = list((Counter(B) - Counter(p)).elements())\n    num_swaps = len(xx)\n    gb = sorted(xx + yy)\n    min_element = min(combined[0], xx[0], yy[0])\n    cost = 0\n    for i in range(num_swaps):\n        if gb[i] <= min_element * 2:\n            cost += gb[i]\n        else:\n            cost += min_element * 1\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "cost += min_element * 2",
      "mutated_line": "cost += min_element * 0",
      "code": "from collections import Counter\n\ndef minimum_cost_to_make_identical(A, B):\n    combined = sorted(A + B)\n    p = [combined[i] for i in range(0, 2 * len(A), 2)]\n    q = [combined[i] for i in range(1, 2 * len(A) + 1, 2)]\n    if p != q:\n        return -1\n    A.sort()\n    B.sort()\n    if A == B:\n        return 0\n    xx = list((Counter(A) - Counter(p)).elements())\n    yy = list((Counter(B) - Counter(p)).elements())\n    num_swaps = len(xx)\n    gb = sorted(xx + yy)\n    min_element = min(combined[0], xx[0], yy[0])\n    cost = 0\n    for i in range(num_swaps):\n        if gb[i] <= min_element * 2:\n            cost += gb[i]\n        else:\n            cost += min_element * 0\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "cost += min_element * 2",
      "mutated_line": "cost += min_element * 1",
      "code": "from collections import Counter\n\ndef minimum_cost_to_make_identical(A, B):\n    combined = sorted(A + B)\n    p = [combined[i] for i in range(0, 2 * len(A), 2)]\n    q = [combined[i] for i in range(1, 2 * len(A) + 1, 2)]\n    if p != q:\n        return -1\n    A.sort()\n    B.sort()\n    if A == B:\n        return 0\n    xx = list((Counter(A) - Counter(p)).elements())\n    yy = list((Counter(B) - Counter(p)).elements())\n    num_swaps = len(xx)\n    gb = sorted(xx + yy)\n    min_element = min(combined[0], xx[0], yy[0])\n    cost = 0\n    for i in range(num_swaps):\n        if gb[i] <= min_element * 2:\n            cost += gb[i]\n        else:\n            cost += min_element * 1\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "cost += min_element * 2",
      "mutated_line": "cost += min_element * -2",
      "code": "from collections import Counter\n\ndef minimum_cost_to_make_identical(A, B):\n    combined = sorted(A + B)\n    p = [combined[i] for i in range(0, 2 * len(A), 2)]\n    q = [combined[i] for i in range(1, 2 * len(A) + 1, 2)]\n    if p != q:\n        return -1\n    A.sort()\n    B.sort()\n    if A == B:\n        return 0\n    xx = list((Counter(A) - Counter(p)).elements())\n    yy = list((Counter(B) - Counter(p)).elements())\n    num_swaps = len(xx)\n    gb = sorted(xx + yy)\n    min_element = min(combined[0], xx[0], yy[0])\n    cost = 0\n    for i in range(num_swaps):\n        if gb[i] <= min_element * 2:\n            cost += gb[i]\n        else:\n            cost += min_element * -2\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "p = [combined[i] for i in range(0, 2 * len(A), 2)]",
      "mutated_line": "p = [combined[i] for i in range(0, 3 * len(A), 2)]",
      "code": "from collections import Counter\n\ndef minimum_cost_to_make_identical(A, B):\n    combined = sorted(A + B)\n    p = [combined[i] for i in range(0, 3 * len(A), 2)]\n    q = [combined[i] for i in range(1, 2 * len(A) + 1, 2)]\n    if p != q:\n        return -1\n    A.sort()\n    B.sort()\n    if A == B:\n        return 0\n    xx = list((Counter(A) - Counter(p)).elements())\n    yy = list((Counter(B) - Counter(p)).elements())\n    num_swaps = len(xx)\n    gb = sorted(xx + yy)\n    min_element = min(combined[0], xx[0], yy[0])\n    cost = 0\n    for i in range(num_swaps):\n        if gb[i] <= min_element * 2:\n            cost += gb[i]\n        else:\n            cost += min_element * 2\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "p = [combined[i] for i in range(0, 2 * len(A), 2)]",
      "mutated_line": "p = [combined[i] for i in range(0, 1 * len(A), 2)]",
      "code": "from collections import Counter\n\ndef minimum_cost_to_make_identical(A, B):\n    combined = sorted(A + B)\n    p = [combined[i] for i in range(0, 1 * len(A), 2)]\n    q = [combined[i] for i in range(1, 2 * len(A) + 1, 2)]\n    if p != q:\n        return -1\n    A.sort()\n    B.sort()\n    if A == B:\n        return 0\n    xx = list((Counter(A) - Counter(p)).elements())\n    yy = list((Counter(B) - Counter(p)).elements())\n    num_swaps = len(xx)\n    gb = sorted(xx + yy)\n    min_element = min(combined[0], xx[0], yy[0])\n    cost = 0\n    for i in range(num_swaps):\n        if gb[i] <= min_element * 2:\n            cost += gb[i]\n        else:\n            cost += min_element * 2\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "p = [combined[i] for i in range(0, 2 * len(A), 2)]",
      "mutated_line": "p = [combined[i] for i in range(0, 0 * len(A), 2)]",
      "code": "from collections import Counter\n\ndef minimum_cost_to_make_identical(A, B):\n    combined = sorted(A + B)\n    p = [combined[i] for i in range(0, 0 * len(A), 2)]\n    q = [combined[i] for i in range(1, 2 * len(A) + 1, 2)]\n    if p != q:\n        return -1\n    A.sort()\n    B.sort()\n    if A == B:\n        return 0\n    xx = list((Counter(A) - Counter(p)).elements())\n    yy = list((Counter(B) - Counter(p)).elements())\n    num_swaps = len(xx)\n    gb = sorted(xx + yy)\n    min_element = min(combined[0], xx[0], yy[0])\n    cost = 0\n    for i in range(num_swaps):\n        if gb[i] <= min_element * 2:\n            cost += gb[i]\n        else:\n            cost += min_element * 2\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "p = [combined[i] for i in range(0, 2 * len(A), 2)]",
      "mutated_line": "p = [combined[i] for i in range(0, 1 * len(A), 2)]",
      "code": "from collections import Counter\n\ndef minimum_cost_to_make_identical(A, B):\n    combined = sorted(A + B)\n    p = [combined[i] for i in range(0, 1 * len(A), 2)]\n    q = [combined[i] for i in range(1, 2 * len(A) + 1, 2)]\n    if p != q:\n        return -1\n    A.sort()\n    B.sort()\n    if A == B:\n        return 0\n    xx = list((Counter(A) - Counter(p)).elements())\n    yy = list((Counter(B) - Counter(p)).elements())\n    num_swaps = len(xx)\n    gb = sorted(xx + yy)\n    min_element = min(combined[0], xx[0], yy[0])\n    cost = 0\n    for i in range(num_swaps):\n        if gb[i] <= min_element * 2:\n            cost += gb[i]\n        else:\n            cost += min_element * 2\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "p = [combined[i] for i in range(0, 2 * len(A), 2)]",
      "mutated_line": "p = [combined[i] for i in range(0, -2 * len(A), 2)]",
      "code": "from collections import Counter\n\ndef minimum_cost_to_make_identical(A, B):\n    combined = sorted(A + B)\n    p = [combined[i] for i in range(0, -2 * len(A), 2)]\n    q = [combined[i] for i in range(1, 2 * len(A) + 1, 2)]\n    if p != q:\n        return -1\n    A.sort()\n    B.sort()\n    if A == B:\n        return 0\n    xx = list((Counter(A) - Counter(p)).elements())\n    yy = list((Counter(B) - Counter(p)).elements())\n    num_swaps = len(xx)\n    gb = sorted(xx + yy)\n    min_element = min(combined[0], xx[0], yy[0])\n    cost = 0\n    for i in range(num_swaps):\n        if gb[i] <= min_element * 2:\n            cost += gb[i]\n        else:\n            cost += min_element * 2\n    return cost"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "q = [combined[i] for i in range(1, 2 * len(A) + 1, 2)]",
      "mutated_line": "q = [combined[i] for i in range(1, 2 / len(A) + 1, 2)]",
      "code": "from collections import Counter\n\ndef minimum_cost_to_make_identical(A, B):\n    combined = sorted(A + B)\n    p = [combined[i] for i in range(0, 2 * len(A), 2)]\n    q = [combined[i] for i in range(1, 2 / len(A) + 1, 2)]\n    if p != q:\n        return -1\n    A.sort()\n    B.sort()\n    if A == B:\n        return 0\n    xx = list((Counter(A) - Counter(p)).elements())\n    yy = list((Counter(B) - Counter(p)).elements())\n    num_swaps = len(xx)\n    gb = sorted(xx + yy)\n    min_element = min(combined[0], xx[0], yy[0])\n    cost = 0\n    for i in range(num_swaps):\n        if gb[i] <= min_element * 2:\n            cost += gb[i]\n        else:\n            cost += min_element * 2\n    return cost"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "q = [combined[i] for i in range(1, 2 * len(A) + 1, 2)]",
      "mutated_line": "q = [combined[i] for i in range(1, 2 + len(A) + 1, 2)]",
      "code": "from collections import Counter\n\ndef minimum_cost_to_make_identical(A, B):\n    combined = sorted(A + B)\n    p = [combined[i] for i in range(0, 2 * len(A), 2)]\n    q = [combined[i] for i in range(1, 2 + len(A) + 1, 2)]\n    if p != q:\n        return -1\n    A.sort()\n    B.sort()\n    if A == B:\n        return 0\n    xx = list((Counter(A) - Counter(p)).elements())\n    yy = list((Counter(B) - Counter(p)).elements())\n    num_swaps = len(xx)\n    gb = sorted(xx + yy)\n    min_element = min(combined[0], xx[0], yy[0])\n    cost = 0\n    for i in range(num_swaps):\n        if gb[i] <= min_element * 2:\n            cost += gb[i]\n        else:\n            cost += min_element * 2\n    return cost"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "q = [combined[i] for i in range(1, 2 * len(A) + 1, 2)]",
      "mutated_line": "q = [combined[i] for i in range(1, 2 ** len(A) + 1, 2)]",
      "code": "from collections import Counter\n\ndef minimum_cost_to_make_identical(A, B):\n    combined = sorted(A + B)\n    p = [combined[i] for i in range(0, 2 * len(A), 2)]\n    q = [combined[i] for i in range(1, 2 ** len(A) + 1, 2)]\n    if p != q:\n        return -1\n    A.sort()\n    B.sort()\n    if A == B:\n        return 0\n    xx = list((Counter(A) - Counter(p)).elements())\n    yy = list((Counter(B) - Counter(p)).elements())\n    num_swaps = len(xx)\n    gb = sorted(xx + yy)\n    min_element = min(combined[0], xx[0], yy[0])\n    cost = 0\n    for i in range(num_swaps):\n        if gb[i] <= min_element * 2:\n            cost += gb[i]\n        else:\n            cost += min_element * 2\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "q = [combined[i] for i in range(1, 2 * len(A) + 1, 2)]",
      "mutated_line": "q = [combined[i] for i in range(1, 2 * len(A) + 2, 2)]",
      "code": "from collections import Counter\n\ndef minimum_cost_to_make_identical(A, B):\n    combined = sorted(A + B)\n    p = [combined[i] for i in range(0, 2 * len(A), 2)]\n    q = [combined[i] for i in range(1, 2 * len(A) + 2, 2)]\n    if p != q:\n        return -1\n    A.sort()\n    B.sort()\n    if A == B:\n        return 0\n    xx = list((Counter(A) - Counter(p)).elements())\n    yy = list((Counter(B) - Counter(p)).elements())\n    num_swaps = len(xx)\n    gb = sorted(xx + yy)\n    min_element = min(combined[0], xx[0], yy[0])\n    cost = 0\n    for i in range(num_swaps):\n        if gb[i] <= min_element * 2:\n            cost += gb[i]\n        else:\n            cost += min_element * 2\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "q = [combined[i] for i in range(1, 2 * len(A) + 1, 2)]",
      "mutated_line": "q = [combined[i] for i in range(1, 2 * len(A) + 0, 2)]",
      "code": "from collections import Counter\n\ndef minimum_cost_to_make_identical(A, B):\n    combined = sorted(A + B)\n    p = [combined[i] for i in range(0, 2 * len(A), 2)]\n    q = [combined[i] for i in range(1, 2 * len(A) + 0, 2)]\n    if p != q:\n        return -1\n    A.sort()\n    B.sort()\n    if A == B:\n        return 0\n    xx = list((Counter(A) - Counter(p)).elements())\n    yy = list((Counter(B) - Counter(p)).elements())\n    num_swaps = len(xx)\n    gb = sorted(xx + yy)\n    min_element = min(combined[0], xx[0], yy[0])\n    cost = 0\n    for i in range(num_swaps):\n        if gb[i] <= min_element * 2:\n            cost += gb[i]\n        else:\n            cost += min_element * 2\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "q = [combined[i] for i in range(1, 2 * len(A) + 1, 2)]",
      "mutated_line": "q = [combined[i] for i in range(1, 2 * len(A) + 0, 2)]",
      "code": "from collections import Counter\n\ndef minimum_cost_to_make_identical(A, B):\n    combined = sorted(A + B)\n    p = [combined[i] for i in range(0, 2 * len(A), 2)]\n    q = [combined[i] for i in range(1, 2 * len(A) + 0, 2)]\n    if p != q:\n        return -1\n    A.sort()\n    B.sort()\n    if A == B:\n        return 0\n    xx = list((Counter(A) - Counter(p)).elements())\n    yy = list((Counter(B) - Counter(p)).elements())\n    num_swaps = len(xx)\n    gb = sorted(xx + yy)\n    min_element = min(combined[0], xx[0], yy[0])\n    cost = 0\n    for i in range(num_swaps):\n        if gb[i] <= min_element * 2:\n            cost += gb[i]\n        else:\n            cost += min_element * 2\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "q = [combined[i] for i in range(1, 2 * len(A) + 1, 2)]",
      "mutated_line": "q = [combined[i] for i in range(1, 2 * len(A) + -1, 2)]",
      "code": "from collections import Counter\n\ndef minimum_cost_to_make_identical(A, B):\n    combined = sorted(A + B)\n    p = [combined[i] for i in range(0, 2 * len(A), 2)]\n    q = [combined[i] for i in range(1, 2 * len(A) + -1, 2)]\n    if p != q:\n        return -1\n    A.sort()\n    B.sort()\n    if A == B:\n        return 0\n    xx = list((Counter(A) - Counter(p)).elements())\n    yy = list((Counter(B) - Counter(p)).elements())\n    num_swaps = len(xx)\n    gb = sorted(xx + yy)\n    min_element = min(combined[0], xx[0], yy[0])\n    cost = 0\n    for i in range(num_swaps):\n        if gb[i] <= min_element * 2:\n            cost += gb[i]\n        else:\n            cost += min_element * 2\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "q = [combined[i] for i in range(1, 2 * len(A) + 1, 2)]",
      "mutated_line": "q = [combined[i] for i in range(1, 3 * len(A) + 1, 2)]",
      "code": "from collections import Counter\n\ndef minimum_cost_to_make_identical(A, B):\n    combined = sorted(A + B)\n    p = [combined[i] for i in range(0, 2 * len(A), 2)]\n    q = [combined[i] for i in range(1, 3 * len(A) + 1, 2)]\n    if p != q:\n        return -1\n    A.sort()\n    B.sort()\n    if A == B:\n        return 0\n    xx = list((Counter(A) - Counter(p)).elements())\n    yy = list((Counter(B) - Counter(p)).elements())\n    num_swaps = len(xx)\n    gb = sorted(xx + yy)\n    min_element = min(combined[0], xx[0], yy[0])\n    cost = 0\n    for i in range(num_swaps):\n        if gb[i] <= min_element * 2:\n            cost += gb[i]\n        else:\n            cost += min_element * 2\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "q = [combined[i] for i in range(1, 2 * len(A) + 1, 2)]",
      "mutated_line": "q = [combined[i] for i in range(1, 1 * len(A) + 1, 2)]",
      "code": "from collections import Counter\n\ndef minimum_cost_to_make_identical(A, B):\n    combined = sorted(A + B)\n    p = [combined[i] for i in range(0, 2 * len(A), 2)]\n    q = [combined[i] for i in range(1, 1 * len(A) + 1, 2)]\n    if p != q:\n        return -1\n    A.sort()\n    B.sort()\n    if A == B:\n        return 0\n    xx = list((Counter(A) - Counter(p)).elements())\n    yy = list((Counter(B) - Counter(p)).elements())\n    num_swaps = len(xx)\n    gb = sorted(xx + yy)\n    min_element = min(combined[0], xx[0], yy[0])\n    cost = 0\n    for i in range(num_swaps):\n        if gb[i] <= min_element * 2:\n            cost += gb[i]\n        else:\n            cost += min_element * 2\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "q = [combined[i] for i in range(1, 2 * len(A) + 1, 2)]",
      "mutated_line": "q = [combined[i] for i in range(1, 0 * len(A) + 1, 2)]",
      "code": "from collections import Counter\n\ndef minimum_cost_to_make_identical(A, B):\n    combined = sorted(A + B)\n    p = [combined[i] for i in range(0, 2 * len(A), 2)]\n    q = [combined[i] for i in range(1, 0 * len(A) + 1, 2)]\n    if p != q:\n        return -1\n    A.sort()\n    B.sort()\n    if A == B:\n        return 0\n    xx = list((Counter(A) - Counter(p)).elements())\n    yy = list((Counter(B) - Counter(p)).elements())\n    num_swaps = len(xx)\n    gb = sorted(xx + yy)\n    min_element = min(combined[0], xx[0], yy[0])\n    cost = 0\n    for i in range(num_swaps):\n        if gb[i] <= min_element * 2:\n            cost += gb[i]\n        else:\n            cost += min_element * 2\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "q = [combined[i] for i in range(1, 2 * len(A) + 1, 2)]",
      "mutated_line": "q = [combined[i] for i in range(1, 1 * len(A) + 1, 2)]",
      "code": "from collections import Counter\n\ndef minimum_cost_to_make_identical(A, B):\n    combined = sorted(A + B)\n    p = [combined[i] for i in range(0, 2 * len(A), 2)]\n    q = [combined[i] for i in range(1, 1 * len(A) + 1, 2)]\n    if p != q:\n        return -1\n    A.sort()\n    B.sort()\n    if A == B:\n        return 0\n    xx = list((Counter(A) - Counter(p)).elements())\n    yy = list((Counter(B) - Counter(p)).elements())\n    num_swaps = len(xx)\n    gb = sorted(xx + yy)\n    min_element = min(combined[0], xx[0], yy[0])\n    cost = 0\n    for i in range(num_swaps):\n        if gb[i] <= min_element * 2:\n            cost += gb[i]\n        else:\n            cost += min_element * 2\n    return cost"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "q = [combined[i] for i in range(1, 2 * len(A) + 1, 2)]",
      "mutated_line": "q = [combined[i] for i in range(1, -2 * len(A) + 1, 2)]",
      "code": "from collections import Counter\n\ndef minimum_cost_to_make_identical(A, B):\n    combined = sorted(A + B)\n    p = [combined[i] for i in range(0, 2 * len(A), 2)]\n    q = [combined[i] for i in range(1, -2 * len(A) + 1, 2)]\n    if p != q:\n        return -1\n    A.sort()\n    B.sort()\n    if A == B:\n        return 0\n    xx = list((Counter(A) - Counter(p)).elements())\n    yy = list((Counter(B) - Counter(p)).elements())\n    num_swaps = len(xx)\n    gb = sorted(xx + yy)\n    min_element = min(combined[0], xx[0], yy[0])\n    cost = 0\n    for i in range(num_swaps):\n        if gb[i] <= min_element * 2:\n            cost += gb[i]\n        else:\n            cost += min_element * 2\n    return cost"
    }
  ]
}