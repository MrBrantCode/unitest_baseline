{
  "task_id": "taco_18483",
  "entry_point": "find_min_max_liars",
  "mutant_count": 114,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "c = j - i + 1 - c",
      "mutated_line": "c = j - i + 1 + c",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N + 1) for _ in range(N + 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 1):\n            for n1 in range(N + 1):\n                for n2 in range(N + 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i + 1 + c\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "c = j - i + 1 - c",
      "mutated_line": "c = (j - i + 1) * c",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N + 1) for _ in range(N + 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 1):\n            for n1 in range(N + 1):\n                for n2 in range(N + 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = (j - i + 1) * c\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "return N - min_val, max_val",
      "mutated_line": "return (N + min_val, max_val)",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N + 1) for _ in range(N + 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 1):\n            for n1 in range(N + 1):\n                for n2 in range(N + 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i + 1 - c\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N + min_val, max_val)"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "return N - min_val, max_val",
      "mutated_line": "return (N * min_val, max_val)",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N + 1) for _ in range(N + 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 1):\n            for n1 in range(N + 1):\n                for n2 in range(N + 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i + 1 - c\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N * min_val, max_val)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "paths = [[inf] * (N + 1) for _ in range(N + 1)]",
      "mutated_line": "paths = [[inf] / (N + 1) for _ in range(N + 1)]",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] / (N + 1) for _ in range(N + 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 1):\n            for n1 in range(N + 1):\n                for n2 in range(N + 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i + 1 - c\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "paths = [[inf] * (N + 1) for _ in range(N + 1)]",
      "mutated_line": "paths = [[inf] + (N + 1) for _ in range(N + 1)]",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] + (N + 1) for _ in range(N + 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 1):\n            for n1 in range(N + 1):\n                for n2 in range(N + 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i + 1 - c\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "paths = [[inf] * (N + 1) for _ in range(N + 1)]",
      "mutated_line": "paths = [[inf] ** (N + 1) for _ in range(N + 1)]",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] ** (N + 1) for _ in range(N + 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 1):\n            for n1 in range(N + 1):\n                for n2 in range(N + 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i + 1 - c\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "for k in range(N + 1):",
      "mutated_line": "for k in range(N - 1):",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N + 1) for _ in range(N + 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N - 1):\n            for n1 in range(N + 1):\n                for n2 in range(N + 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i + 1 - c\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "for k in range(N + 1):",
      "mutated_line": "for k in range(N * 1):",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N + 1) for _ in range(N + 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N * 1):\n            for n1 in range(N + 1):\n                for n2 in range(N + 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i + 1 - c\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "c = j - i + 1 - c",
      "mutated_line": "c = j - i - 1 - c",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N + 1) for _ in range(N + 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 1):\n            for n1 in range(N + 1):\n                for n2 in range(N + 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i - 1 - c\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "c = j - i + 1 - c",
      "mutated_line": "c = (j - i) * 1 - c",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N + 1) for _ in range(N + 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 1):\n            for n1 in range(N + 1):\n                for n2 in range(N + 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = (j - i) * 1 - c\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "paths = [[inf] * (N + 1) for _ in range(N + 1)]",
      "mutated_line": "paths = [[inf] * (N - 1) for _ in range(N + 1)]",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N - 1) for _ in range(N + 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 1):\n            for n1 in range(N + 1):\n                for n2 in range(N + 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i + 1 - c\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "paths = [[inf] * (N + 1) for _ in range(N + 1)]",
      "mutated_line": "paths = [[inf] * (N * 1) for _ in range(N + 1)]",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N * 1) for _ in range(N + 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 1):\n            for n1 in range(N + 1):\n                for n2 in range(N + 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i + 1 - c\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for k in range(N + 1):",
      "mutated_line": "for k in range(N + 2):",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N + 1) for _ in range(N + 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 2):\n            for n1 in range(N + 1):\n                for n2 in range(N + 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i + 1 - c\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for k in range(N + 1):",
      "mutated_line": "for k in range(N + 0):",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N + 1) for _ in range(N + 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 0):\n            for n1 in range(N + 1):\n                for n2 in range(N + 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i + 1 - c\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for k in range(N + 1):",
      "mutated_line": "for k in range(N + 0):",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N + 1) for _ in range(N + 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 0):\n            for n1 in range(N + 1):\n                for n2 in range(N + 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i + 1 - c\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for k in range(N + 1):",
      "mutated_line": "for k in range(N + -1):",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N + 1) for _ in range(N + 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + -1):\n            for n1 in range(N + 1):\n                for n2 in range(N + 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i + 1 - c\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "for n1 in range(N + 1):",
      "mutated_line": "for n1 in range(N - 1):",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N + 1) for _ in range(N + 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 1):\n            for n1 in range(N - 1):\n                for n2 in range(N + 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i + 1 - c\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "for n1 in range(N + 1):",
      "mutated_line": "for n1 in range(N * 1):",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N + 1) for _ in range(N + 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 1):\n            for n1 in range(N * 1):\n                for n2 in range(N + 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i + 1 - c\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return paths[0][N]",
      "mutated_line": "return paths[1][N]",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N + 1) for _ in range(N + 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 1):\n            for n1 in range(N + 1):\n                for n2 in range(N + 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[1][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i + 1 - c\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return paths[0][N]",
      "mutated_line": "return paths[-1][N]",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N + 1) for _ in range(N + 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 1):\n            for n1 in range(N + 1):\n                for n2 in range(N + 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[-1][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i + 1 - c\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return paths[0][N]",
      "mutated_line": "return paths[1][N]",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N + 1) for _ in range(N + 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 1):\n            for n1 in range(N + 1):\n                for n2 in range(N + 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[1][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i + 1 - c\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "edges.append((i - 1, j, c))",
      "mutated_line": "edges.append((i + 1, j, c))",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N + 1) for _ in range(N + 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 1):\n            for n1 in range(N + 1):\n                for n2 in range(N + 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i + 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i + 1 - c\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "edges.append((i - 1, j, c))",
      "mutated_line": "edges.append((i * 1, j, c))",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N + 1) for _ in range(N + 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 1):\n            for n1 in range(N + 1):\n                for n2 in range(N + 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i * 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i + 1 - c\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "edges.append((j, i - 1, -c))",
      "mutated_line": "edges.append((j, i + 1, -c))",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N + 1) for _ in range(N + 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 1):\n            for n1 in range(N + 1):\n                for n2 in range(N + 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 1, j, c))\n        edges.append((j, i + 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i + 1 - c\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "edges.append((j, i - 1, -c))",
      "mutated_line": "edges.append((j, i * 1, -c))",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N + 1) for _ in range(N + 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 1):\n            for n1 in range(N + 1):\n                for n2 in range(N + 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 1, j, c))\n        edges.append((j, i * 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i + 1 - c\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "UOI",
      "lineno": 17,
      "original_line": "edges.append((j, i - 1, -c))",
      "mutated_line": "edges.append((j, i - 1, +c))",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N + 1) for _ in range(N + 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 1):\n            for n1 in range(N + 1):\n                for n2 in range(N + 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, +c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i + 1 - c\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "edges.append((n, n + 1, 1))",
      "mutated_line": "edges.append((n, n - 1, 1))",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N + 1) for _ in range(N + 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 1):\n            for n1 in range(N + 1):\n                for n2 in range(N + 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n - 1, 1))\n        edges.append((n + 1, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i + 1 - c\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "edges.append((n, n + 1, 1))",
      "mutated_line": "edges.append((n, n * 1, 1))",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N + 1) for _ in range(N + 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 1):\n            for n1 in range(N + 1):\n                for n2 in range(N + 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n * 1, 1))\n        edges.append((n + 1, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i + 1 - c\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "edges.append((n, n + 1, 1))",
      "mutated_line": "edges.append((n, n + 1, 2))",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N + 1) for _ in range(N + 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 1):\n            for n1 in range(N + 1):\n                for n2 in range(N + 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 2))\n        edges.append((n + 1, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i + 1 - c\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "edges.append((n, n + 1, 1))",
      "mutated_line": "edges.append((n, n + 1, 0))",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N + 1) for _ in range(N + 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 1):\n            for n1 in range(N + 1):\n                for n2 in range(N + 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 0))\n        edges.append((n + 1, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i + 1 - c\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "edges.append((n, n + 1, 1))",
      "mutated_line": "edges.append((n, n + 1, 0))",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N + 1) for _ in range(N + 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 1):\n            for n1 in range(N + 1):\n                for n2 in range(N + 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 0))\n        edges.append((n + 1, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i + 1 - c\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "edges.append((n, n + 1, 1))",
      "mutated_line": "edges.append((n, n + 1, -1))",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N + 1) for _ in range(N + 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 1):\n            for n1 in range(N + 1):\n                for n2 in range(N + 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, -1))\n        edges.append((n + 1, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i + 1 - c\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "edges.append((n + 1, n, 0))",
      "mutated_line": "edges.append((n - 1, n, 0))",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N + 1) for _ in range(N + 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 1):\n            for n1 in range(N + 1):\n                for n2 in range(N + 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n - 1, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i + 1 - c\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "edges.append((n + 1, n, 0))",
      "mutated_line": "edges.append((n * 1, n, 0))",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N + 1) for _ in range(N + 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 1):\n            for n1 in range(N + 1):\n                for n2 in range(N + 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n * 1, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i + 1 - c\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "edges.append((n + 1, n, 0))",
      "mutated_line": "edges.append((n + 1, n, 1))",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N + 1) for _ in range(N + 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 1):\n            for n1 in range(N + 1):\n                for n2 in range(N + 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 1))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i + 1 - c\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "edges.append((n + 1, n, 0))",
      "mutated_line": "edges.append((n + 1, n, -1))",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N + 1) for _ in range(N + 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 1):\n            for n1 in range(N + 1):\n                for n2 in range(N + 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, -1))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i + 1 - c\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "edges.append((n + 1, n, 0))",
      "mutated_line": "edges.append((n + 1, n, 1))",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N + 1) for _ in range(N + 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 1):\n            for n1 in range(N + 1):\n                for n2 in range(N + 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 1))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i + 1 - c\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "c = j - i + 1 - c",
      "mutated_line": "c = j + i + 1 - c",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N + 1) for _ in range(N + 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 1):\n            for n1 in range(N + 1):\n                for n2 in range(N + 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j + i + 1 - c\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "c = j - i + 1 - c",
      "mutated_line": "c = j * i + 1 - c",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N + 1) for _ in range(N + 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 1):\n            for n1 in range(N + 1):\n                for n2 in range(N + 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j * i + 1 - c\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "c = j - i + 1 - c",
      "mutated_line": "c = j - i + 2 - c",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N + 1) for _ in range(N + 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 1):\n            for n1 in range(N + 1):\n                for n2 in range(N + 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i + 2 - c\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "c = j - i + 1 - c",
      "mutated_line": "c = j - i + 0 - c",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N + 1) for _ in range(N + 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 1):\n            for n1 in range(N + 1):\n                for n2 in range(N + 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i + 0 - c\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "c = j - i + 1 - c",
      "mutated_line": "c = j - i + 0 - c",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N + 1) for _ in range(N + 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 1):\n            for n1 in range(N + 1):\n                for n2 in range(N + 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i + 0 - c\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "c = j - i + 1 - c",
      "mutated_line": "c = j - i + -1 - c",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N + 1) for _ in range(N + 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 1):\n            for n1 in range(N + 1):\n                for n2 in range(N + 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i + -1 - c\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "edges.append((i - 1, j, c))",
      "mutated_line": "edges.append((i + 1, j, c))",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N + 1) for _ in range(N + 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 1):\n            for n1 in range(N + 1):\n                for n2 in range(N + 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i + 1 - c\n        edges.append((i + 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "edges.append((i - 1, j, c))",
      "mutated_line": "edges.append((i * 1, j, c))",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N + 1) for _ in range(N + 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 1):\n            for n1 in range(N + 1):\n                for n2 in range(N + 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i + 1 - c\n        edges.append((i * 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "edges.append((j, i - 1, -c))",
      "mutated_line": "edges.append((j, i + 1, -c))",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N + 1) for _ in range(N + 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 1):\n            for n1 in range(N + 1):\n                for n2 in range(N + 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i + 1 - c\n        edges.append((i - 1, j, c))\n        edges.append((j, i + 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "edges.append((j, i - 1, -c))",
      "mutated_line": "edges.append((j, i * 1, -c))",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N + 1) for _ in range(N + 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 1):\n            for n1 in range(N + 1):\n                for n2 in range(N + 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i + 1 - c\n        edges.append((i - 1, j, c))\n        edges.append((j, i * 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "UOI",
      "lineno": 27,
      "original_line": "edges.append((j, i - 1, -c))",
      "mutated_line": "edges.append((j, i - 1, +c))",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N + 1) for _ in range(N + 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 1):\n            for n1 in range(N + 1):\n                for n2 in range(N + 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i + 1 - c\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, +c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "edges.append((n, n + 1, 1))",
      "mutated_line": "edges.append((n, n - 1, 1))",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N + 1) for _ in range(N + 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 1):\n            for n1 in range(N + 1):\n                for n2 in range(N + 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i + 1 - c\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n - 1, 1))\n        edges.append((n + 1, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "edges.append((n, n + 1, 1))",
      "mutated_line": "edges.append((n, n * 1, 1))",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N + 1) for _ in range(N + 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 1):\n            for n1 in range(N + 1):\n                for n2 in range(N + 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i + 1 - c\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n * 1, 1))\n        edges.append((n + 1, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "edges.append((n, n + 1, 1))",
      "mutated_line": "edges.append((n, n + 1, 2))",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N + 1) for _ in range(N + 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 1):\n            for n1 in range(N + 1):\n                for n2 in range(N + 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i + 1 - c\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 2))\n        edges.append((n + 1, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "edges.append((n, n + 1, 1))",
      "mutated_line": "edges.append((n, n + 1, 0))",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N + 1) for _ in range(N + 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 1):\n            for n1 in range(N + 1):\n                for n2 in range(N + 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i + 1 - c\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 0))\n        edges.append((n + 1, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "edges.append((n, n + 1, 1))",
      "mutated_line": "edges.append((n, n + 1, 0))",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N + 1) for _ in range(N + 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 1):\n            for n1 in range(N + 1):\n                for n2 in range(N + 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i + 1 - c\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 0))\n        edges.append((n + 1, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "edges.append((n, n + 1, 1))",
      "mutated_line": "edges.append((n, n + 1, -1))",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N + 1) for _ in range(N + 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 1):\n            for n1 in range(N + 1):\n                for n2 in range(N + 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i + 1 - c\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, -1))\n        edges.append((n + 1, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "edges.append((n + 1, n, 0))",
      "mutated_line": "edges.append((n - 1, n, 0))",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N + 1) for _ in range(N + 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 1):\n            for n1 in range(N + 1):\n                for n2 in range(N + 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i + 1 - c\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n - 1, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "edges.append((n + 1, n, 0))",
      "mutated_line": "edges.append((n * 1, n, 0))",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N + 1) for _ in range(N + 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 1):\n            for n1 in range(N + 1):\n                for n2 in range(N + 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i + 1 - c\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n * 1, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "edges.append((n + 1, n, 0))",
      "mutated_line": "edges.append((n + 1, n, 1))",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N + 1) for _ in range(N + 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 1):\n            for n1 in range(N + 1):\n                for n2 in range(N + 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i + 1 - c\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 1))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "edges.append((n + 1, n, 0))",
      "mutated_line": "edges.append((n + 1, n, -1))",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N + 1) for _ in range(N + 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 1):\n            for n1 in range(N + 1):\n                for n2 in range(N + 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i + 1 - c\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, -1))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "edges.append((n + 1, n, 0))",
      "mutated_line": "edges.append((n + 1, n, 1))",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N + 1) for _ in range(N + 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 1):\n            for n1 in range(N + 1):\n                for n2 in range(N + 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i + 1 - c\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 1))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "paths = [[inf] * (N + 1) for _ in range(N + 1)]",
      "mutated_line": "paths = [[inf] * (N + 2) for _ in range(N + 1)]",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N + 2) for _ in range(N + 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 1):\n            for n1 in range(N + 1):\n                for n2 in range(N + 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i + 1 - c\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "paths = [[inf] * (N + 1) for _ in range(N + 1)]",
      "mutated_line": "paths = [[inf] * (N + 0) for _ in range(N + 1)]",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N + 0) for _ in range(N + 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 1):\n            for n1 in range(N + 1):\n                for n2 in range(N + 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i + 1 - c\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "paths = [[inf] * (N + 1) for _ in range(N + 1)]",
      "mutated_line": "paths = [[inf] * (N + 0) for _ in range(N + 1)]",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N + 0) for _ in range(N + 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 1):\n            for n1 in range(N + 1):\n                for n2 in range(N + 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i + 1 - c\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "paths = [[inf] * (N + 1) for _ in range(N + 1)]",
      "mutated_line": "paths = [[inf] * (N + -1) for _ in range(N + 1)]",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N + -1) for _ in range(N + 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 1):\n            for n1 in range(N + 1):\n                for n2 in range(N + 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i + 1 - c\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "paths = [[inf] * (N + 1) for _ in range(N + 1)]",
      "mutated_line": "paths = [[inf] * (N + 1) for _ in range(N - 1)]",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N + 1) for _ in range(N - 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 1):\n            for n1 in range(N + 1):\n                for n2 in range(N + 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i + 1 - c\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "paths = [[inf] * (N + 1) for _ in range(N + 1)]",
      "mutated_line": "paths = [[inf] * (N + 1) for _ in range(N * 1)]",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N + 1) for _ in range(N * 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 1):\n            for n1 in range(N + 1):\n                for n2 in range(N + 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i + 1 - c\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for n1 in range(N + 1):",
      "mutated_line": "for n1 in range(N + 2):",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N + 1) for _ in range(N + 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 1):\n            for n1 in range(N + 2):\n                for n2 in range(N + 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i + 1 - c\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for n1 in range(N + 1):",
      "mutated_line": "for n1 in range(N + 0):",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N + 1) for _ in range(N + 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 1):\n            for n1 in range(N + 0):\n                for n2 in range(N + 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i + 1 - c\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for n1 in range(N + 1):",
      "mutated_line": "for n1 in range(N + 0):",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N + 1) for _ in range(N + 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 1):\n            for n1 in range(N + 0):\n                for n2 in range(N + 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i + 1 - c\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for n1 in range(N + 1):",
      "mutated_line": "for n1 in range(N + -1):",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N + 1) for _ in range(N + 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 1):\n            for n1 in range(N + -1):\n                for n2 in range(N + 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i + 1 - c\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "for n2 in range(N + 1):",
      "mutated_line": "for n2 in range(N - 1):",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N + 1) for _ in range(N + 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 1):\n            for n1 in range(N + 1):\n                for n2 in range(N - 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i + 1 - c\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "for n2 in range(N + 1):",
      "mutated_line": "for n2 in range(N * 1):",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N + 1) for _ in range(N + 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 1):\n            for n1 in range(N + 1):\n                for n2 in range(N * 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i + 1 - c\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "edges.append((i - 1, j, c))",
      "mutated_line": "edges.append((i - 2, j, c))",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N + 1) for _ in range(N + 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 1):\n            for n1 in range(N + 1):\n                for n2 in range(N + 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 2, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i + 1 - c\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "edges.append((i - 1, j, c))",
      "mutated_line": "edges.append((i - 0, j, c))",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N + 1) for _ in range(N + 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 1):\n            for n1 in range(N + 1):\n                for n2 in range(N + 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 0, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i + 1 - c\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "edges.append((i - 1, j, c))",
      "mutated_line": "edges.append((i - 0, j, c))",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N + 1) for _ in range(N + 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 1):\n            for n1 in range(N + 1):\n                for n2 in range(N + 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 0, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i + 1 - c\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "edges.append((i - 1, j, c))",
      "mutated_line": "edges.append((i - -1, j, c))",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N + 1) for _ in range(N + 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 1):\n            for n1 in range(N + 1):\n                for n2 in range(N + 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - -1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i + 1 - c\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "edges.append((j, i - 1, -c))",
      "mutated_line": "edges.append((j, i - 2, -c))",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N + 1) for _ in range(N + 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 1):\n            for n1 in range(N + 1):\n                for n2 in range(N + 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 2, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i + 1 - c\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "edges.append((j, i - 1, -c))",
      "mutated_line": "edges.append((j, i - 0, -c))",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N + 1) for _ in range(N + 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 1):\n            for n1 in range(N + 1):\n                for n2 in range(N + 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 0, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i + 1 - c\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "edges.append((j, i - 1, -c))",
      "mutated_line": "edges.append((j, i - 0, -c))",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N + 1) for _ in range(N + 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 1):\n            for n1 in range(N + 1):\n                for n2 in range(N + 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 0, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i + 1 - c\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "edges.append((j, i - 1, -c))",
      "mutated_line": "edges.append((j, i - -1, -c))",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N + 1) for _ in range(N + 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 1):\n            for n1 in range(N + 1):\n                for n2 in range(N + 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 1, j, c))\n        edges.append((j, i - -1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i + 1 - c\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "edges.append((n, n + 1, 1))",
      "mutated_line": "edges.append((n, n + 2, 1))",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N + 1) for _ in range(N + 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 1):\n            for n1 in range(N + 1):\n                for n2 in range(N + 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 2, 1))\n        edges.append((n + 1, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i + 1 - c\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "edges.append((n, n + 1, 1))",
      "mutated_line": "edges.append((n, n + 0, 1))",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N + 1) for _ in range(N + 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 1):\n            for n1 in range(N + 1):\n                for n2 in range(N + 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 0, 1))\n        edges.append((n + 1, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i + 1 - c\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "edges.append((n, n + 1, 1))",
      "mutated_line": "edges.append((n, n + 0, 1))",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N + 1) for _ in range(N + 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 1):\n            for n1 in range(N + 1):\n                for n2 in range(N + 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 0, 1))\n        edges.append((n + 1, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i + 1 - c\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "edges.append((n, n + 1, 1))",
      "mutated_line": "edges.append((n, n + -1, 1))",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N + 1) for _ in range(N + 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 1):\n            for n1 in range(N + 1):\n                for n2 in range(N + 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + -1, 1))\n        edges.append((n + 1, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i + 1 - c\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "edges.append((n + 1, n, 0))",
      "mutated_line": "edges.append((n + 2, n, 0))",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N + 1) for _ in range(N + 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 1):\n            for n1 in range(N + 1):\n                for n2 in range(N + 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 2, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i + 1 - c\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "edges.append((n + 1, n, 0))",
      "mutated_line": "edges.append((n + 0, n, 0))",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N + 1) for _ in range(N + 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 1):\n            for n1 in range(N + 1):\n                for n2 in range(N + 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 0, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i + 1 - c\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "edges.append((n + 1, n, 0))",
      "mutated_line": "edges.append((n + 0, n, 0))",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N + 1) for _ in range(N + 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 1):\n            for n1 in range(N + 1):\n                for n2 in range(N + 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 0, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i + 1 - c\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "edges.append((n + 1, n, 0))",
      "mutated_line": "edges.append((n + -1, n, 0))",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N + 1) for _ in range(N + 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 1):\n            for n1 in range(N + 1):\n                for n2 in range(N + 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + -1, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i + 1 - c\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "edges.append((i - 1, j, c))",
      "mutated_line": "edges.append((i - 2, j, c))",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N + 1) for _ in range(N + 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 1):\n            for n1 in range(N + 1):\n                for n2 in range(N + 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i + 1 - c\n        edges.append((i - 2, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "edges.append((i - 1, j, c))",
      "mutated_line": "edges.append((i - 0, j, c))",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N + 1) for _ in range(N + 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 1):\n            for n1 in range(N + 1):\n                for n2 in range(N + 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i + 1 - c\n        edges.append((i - 0, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "edges.append((i - 1, j, c))",
      "mutated_line": "edges.append((i - 0, j, c))",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N + 1) for _ in range(N + 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 1):\n            for n1 in range(N + 1):\n                for n2 in range(N + 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i + 1 - c\n        edges.append((i - 0, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "edges.append((i - 1, j, c))",
      "mutated_line": "edges.append((i - -1, j, c))",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N + 1) for _ in range(N + 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 1):\n            for n1 in range(N + 1):\n                for n2 in range(N + 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i + 1 - c\n        edges.append((i - -1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "edges.append((j, i - 1, -c))",
      "mutated_line": "edges.append((j, i - 2, -c))",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N + 1) for _ in range(N + 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 1):\n            for n1 in range(N + 1):\n                for n2 in range(N + 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i + 1 - c\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 2, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "edges.append((j, i - 1, -c))",
      "mutated_line": "edges.append((j, i - 0, -c))",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N + 1) for _ in range(N + 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 1):\n            for n1 in range(N + 1):\n                for n2 in range(N + 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i + 1 - c\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 0, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "edges.append((j, i - 1, -c))",
      "mutated_line": "edges.append((j, i - 0, -c))",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N + 1) for _ in range(N + 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 1):\n            for n1 in range(N + 1):\n                for n2 in range(N + 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i + 1 - c\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 0, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "edges.append((j, i - 1, -c))",
      "mutated_line": "edges.append((j, i - -1, -c))",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N + 1) for _ in range(N + 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 1):\n            for n1 in range(N + 1):\n                for n2 in range(N + 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i + 1 - c\n        edges.append((i - 1, j, c))\n        edges.append((j, i - -1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "edges.append((n, n + 1, 1))",
      "mutated_line": "edges.append((n, n + 2, 1))",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N + 1) for _ in range(N + 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 1):\n            for n1 in range(N + 1):\n                for n2 in range(N + 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i + 1 - c\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 2, 1))\n        edges.append((n + 1, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "edges.append((n, n + 1, 1))",
      "mutated_line": "edges.append((n, n + 0, 1))",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N + 1) for _ in range(N + 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 1):\n            for n1 in range(N + 1):\n                for n2 in range(N + 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i + 1 - c\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 0, 1))\n        edges.append((n + 1, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "edges.append((n, n + 1, 1))",
      "mutated_line": "edges.append((n, n + 0, 1))",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N + 1) for _ in range(N + 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 1):\n            for n1 in range(N + 1):\n                for n2 in range(N + 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i + 1 - c\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 0, 1))\n        edges.append((n + 1, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "edges.append((n, n + 1, 1))",
      "mutated_line": "edges.append((n, n + -1, 1))",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N + 1) for _ in range(N + 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 1):\n            for n1 in range(N + 1):\n                for n2 in range(N + 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i + 1 - c\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + -1, 1))\n        edges.append((n + 1, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "edges.append((n + 1, n, 0))",
      "mutated_line": "edges.append((n + 2, n, 0))",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N + 1) for _ in range(N + 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 1):\n            for n1 in range(N + 1):\n                for n2 in range(N + 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i + 1 - c\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 2, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "edges.append((n + 1, n, 0))",
      "mutated_line": "edges.append((n + 0, n, 0))",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N + 1) for _ in range(N + 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 1):\n            for n1 in range(N + 1):\n                for n2 in range(N + 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i + 1 - c\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 0, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "edges.append((n + 1, n, 0))",
      "mutated_line": "edges.append((n + 0, n, 0))",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N + 1) for _ in range(N + 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 1):\n            for n1 in range(N + 1):\n                for n2 in range(N + 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i + 1 - c\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 0, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "edges.append((n + 1, n, 0))",
      "mutated_line": "edges.append((n + -1, n, 0))",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N + 1) for _ in range(N + 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 1):\n            for n1 in range(N + 1):\n                for n2 in range(N + 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i + 1 - c\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + -1, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "paths = [[inf] * (N + 1) for _ in range(N + 1)]",
      "mutated_line": "paths = [[inf] * (N + 1) for _ in range(N + 2)]",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N + 1) for _ in range(N + 2)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 1):\n            for n1 in range(N + 1):\n                for n2 in range(N + 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i + 1 - c\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "paths = [[inf] * (N + 1) for _ in range(N + 1)]",
      "mutated_line": "paths = [[inf] * (N + 1) for _ in range(N + 0)]",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N + 1) for _ in range(N + 0)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 1):\n            for n1 in range(N + 1):\n                for n2 in range(N + 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i + 1 - c\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "paths = [[inf] * (N + 1) for _ in range(N + 1)]",
      "mutated_line": "paths = [[inf] * (N + 1) for _ in range(N + 0)]",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N + 1) for _ in range(N + 0)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 1):\n            for n1 in range(N + 1):\n                for n2 in range(N + 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i + 1 - c\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "paths = [[inf] * (N + 1) for _ in range(N + 1)]",
      "mutated_line": "paths = [[inf] * (N + 1) for _ in range(N + -1)]",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N + 1) for _ in range(N + -1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 1):\n            for n1 in range(N + 1):\n                for n2 in range(N + 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i + 1 - c\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for n2 in range(N + 1):",
      "mutated_line": "for n2 in range(N + 2):",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N + 1) for _ in range(N + 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 1):\n            for n1 in range(N + 1):\n                for n2 in range(N + 2):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i + 1 - c\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for n2 in range(N + 1):",
      "mutated_line": "for n2 in range(N + 0):",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N + 1) for _ in range(N + 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 1):\n            for n1 in range(N + 1):\n                for n2 in range(N + 0):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i + 1 - c\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for n2 in range(N + 1):",
      "mutated_line": "for n2 in range(N + 0):",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N + 1) for _ in range(N + 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 1):\n            for n1 in range(N + 1):\n                for n2 in range(N + 0):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i + 1 - c\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for n2 in range(N + 1):",
      "mutated_line": "for n2 in range(N + -1):",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N + 1) for _ in range(N + 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 1):\n            for n1 in range(N + 1):\n                for n2 in range(N + -1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i + 1 - c\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])",
      "mutated_line": "paths[n1][n2] = min(paths[n1][n2], paths[n1][k] - paths[k][n2])",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N + 1) for _ in range(N + 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 1):\n            for n1 in range(N + 1):\n                for n2 in range(N + 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] - paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i + 1 - c\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "paths[n1][n2] = min(paths[n1][n2], paths[n1][k] + paths[k][n2])",
      "mutated_line": "paths[n1][n2] = min(paths[n1][n2], paths[n1][k] * paths[k][n2])",
      "code": "def find_min_max_liars(N, M, intervals):\n    from math import inf\n\n    def floyd_warshall(N, edges):\n        paths = [[inf] * (N + 1) for _ in range(N + 1)]\n        for (i, j, c) in edges:\n            paths[i][j] = min(paths[i][j], c)\n        for k in range(N + 1):\n            for n1 in range(N + 1):\n                for n2 in range(N + 1):\n                    paths[n1][n2] = min(paths[n1][n2], paths[n1][k] * paths[k][n2])\n        return paths[0][N]\n    edges = []\n    for (i, j, c) in intervals:\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    max_val = floyd_warshall(N, edges)\n    edges = []\n    for (i, j, c) in intervals:\n        c = j - i + 1 - c\n        edges.append((i - 1, j, c))\n        edges.append((j, i - 1, -c))\n    for n in range(N):\n        edges.append((n, n + 1, 1))\n        edges.append((n + 1, n, 0))\n    min_val = floyd_warshall(N, edges)\n    return (N - min_val, max_val)"
    }
  ]
}