{
  "task_id": "taco_2078",
  "entry_point": "min_operations_to_sort_permutation",
  "mutant_count": 106,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "if P == sorted_arr:",
      "mutated_line": "if P != sorted_arr:",
      "code": "def min_operations_to_sort_permutation(N, K, P):\n    sorted_arr = sorted(P)\n    if P != sorted_arr:\n        return 0\n    index_x = 0\n    index_y = 0\n    for i in range(N):\n        if P[i] == i + 1:\n            index_x += 1\n        else:\n            break\n    for i in reversed(range(N)):\n        if P[i] == i + 1:\n            index_y += 1\n        else:\n            break\n    if N - index_x - index_y <= K:\n        return 1\n    index_y = min(N - index_y - K, N)\n    temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]\n    arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]\n    temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]\n    arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]\n    if arr1 == sorted_arr or arr2 == sorted_arr:\n        return 2\n    else:\n        return 3"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "index_x = 0",
      "mutated_line": "index_x = 1",
      "code": "def min_operations_to_sort_permutation(N, K, P):\n    sorted_arr = sorted(P)\n    if P == sorted_arr:\n        return 0\n    index_x = 1\n    index_y = 0\n    for i in range(N):\n        if P[i] == i + 1:\n            index_x += 1\n        else:\n            break\n    for i in reversed(range(N)):\n        if P[i] == i + 1:\n            index_y += 1\n        else:\n            break\n    if N - index_x - index_y <= K:\n        return 1\n    index_y = min(N - index_y - K, N)\n    temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]\n    arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]\n    temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]\n    arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]\n    if arr1 == sorted_arr or arr2 == sorted_arr:\n        return 2\n    else:\n        return 3"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "index_x = 0",
      "mutated_line": "index_x = -1",
      "code": "def min_operations_to_sort_permutation(N, K, P):\n    sorted_arr = sorted(P)\n    if P == sorted_arr:\n        return 0\n    index_x = -1\n    index_y = 0\n    for i in range(N):\n        if P[i] == i + 1:\n            index_x += 1\n        else:\n            break\n    for i in reversed(range(N)):\n        if P[i] == i + 1:\n            index_y += 1\n        else:\n            break\n    if N - index_x - index_y <= K:\n        return 1\n    index_y = min(N - index_y - K, N)\n    temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]\n    arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]\n    temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]\n    arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]\n    if arr1 == sorted_arr or arr2 == sorted_arr:\n        return 2\n    else:\n        return 3"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "index_x = 0",
      "mutated_line": "index_x = 1",
      "code": "def min_operations_to_sort_permutation(N, K, P):\n    sorted_arr = sorted(P)\n    if P == sorted_arr:\n        return 0\n    index_x = 1\n    index_y = 0\n    for i in range(N):\n        if P[i] == i + 1:\n            index_x += 1\n        else:\n            break\n    for i in reversed(range(N)):\n        if P[i] == i + 1:\n            index_y += 1\n        else:\n            break\n    if N - index_x - index_y <= K:\n        return 1\n    index_y = min(N - index_y - K, N)\n    temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]\n    arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]\n    temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]\n    arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]\n    if arr1 == sorted_arr or arr2 == sorted_arr:\n        return 2\n    else:\n        return 3"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "index_y = 0",
      "mutated_line": "index_y = 1",
      "code": "def min_operations_to_sort_permutation(N, K, P):\n    sorted_arr = sorted(P)\n    if P == sorted_arr:\n        return 0\n    index_x = 0\n    index_y = 1\n    for i in range(N):\n        if P[i] == i + 1:\n            index_x += 1\n        else:\n            break\n    for i in reversed(range(N)):\n        if P[i] == i + 1:\n            index_y += 1\n        else:\n            break\n    if N - index_x - index_y <= K:\n        return 1\n    index_y = min(N - index_y - K, N)\n    temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]\n    arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]\n    temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]\n    arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]\n    if arr1 == sorted_arr or arr2 == sorted_arr:\n        return 2\n    else:\n        return 3"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "index_y = 0",
      "mutated_line": "index_y = -1",
      "code": "def min_operations_to_sort_permutation(N, K, P):\n    sorted_arr = sorted(P)\n    if P == sorted_arr:\n        return 0\n    index_x = 0\n    index_y = -1\n    for i in range(N):\n        if P[i] == i + 1:\n            index_x += 1\n        else:\n            break\n    for i in reversed(range(N)):\n        if P[i] == i + 1:\n            index_y += 1\n        else:\n            break\n    if N - index_x - index_y <= K:\n        return 1\n    index_y = min(N - index_y - K, N)\n    temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]\n    arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]\n    temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]\n    arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]\n    if arr1 == sorted_arr or arr2 == sorted_arr:\n        return 2\n    else:\n        return 3"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "index_y = 0",
      "mutated_line": "index_y = 1",
      "code": "def min_operations_to_sort_permutation(N, K, P):\n    sorted_arr = sorted(P)\n    if P == sorted_arr:\n        return 0\n    index_x = 0\n    index_y = 1\n    for i in range(N):\n        if P[i] == i + 1:\n            index_x += 1\n        else:\n            break\n    for i in reversed(range(N)):\n        if P[i] == i + 1:\n            index_y += 1\n        else:\n            break\n    if N - index_x - index_y <= K:\n        return 1\n    index_y = min(N - index_y - K, N)\n    temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]\n    arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]\n    temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]\n    arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]\n    if arr1 == sorted_arr or arr2 == sorted_arr:\n        return 2\n    else:\n        return 3"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if N - index_x - index_y <= K:",
      "mutated_line": "if N - index_x - index_y < K:",
      "code": "def min_operations_to_sort_permutation(N, K, P):\n    sorted_arr = sorted(P)\n    if P == sorted_arr:\n        return 0\n    index_x = 0\n    index_y = 0\n    for i in range(N):\n        if P[i] == i + 1:\n            index_x += 1\n        else:\n            break\n    for i in reversed(range(N)):\n        if P[i] == i + 1:\n            index_y += 1\n        else:\n            break\n    if N - index_x - index_y < K:\n        return 1\n    index_y = min(N - index_y - K, N)\n    temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]\n    arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]\n    temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]\n    arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]\n    if arr1 == sorted_arr or arr2 == sorted_arr:\n        return 2\n    else:\n        return 3"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if N - index_x - index_y <= K:",
      "mutated_line": "if N - index_x - index_y > K:",
      "code": "def min_operations_to_sort_permutation(N, K, P):\n    sorted_arr = sorted(P)\n    if P == sorted_arr:\n        return 0\n    index_x = 0\n    index_y = 0\n    for i in range(N):\n        if P[i] == i + 1:\n            index_x += 1\n        else:\n            break\n    for i in reversed(range(N)):\n        if P[i] == i + 1:\n            index_y += 1\n        else:\n            break\n    if N - index_x - index_y > K:\n        return 1\n    index_y = min(N - index_y - K, N)\n    temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]\n    arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]\n    temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]\n    arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]\n    if arr1 == sorted_arr or arr2 == sorted_arr:\n        return 2\n    else:\n        return 3"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if N - index_x - index_y <= K:",
      "mutated_line": "if N - index_x - index_y == K:",
      "code": "def min_operations_to_sort_permutation(N, K, P):\n    sorted_arr = sorted(P)\n    if P == sorted_arr:\n        return 0\n    index_x = 0\n    index_y = 0\n    for i in range(N):\n        if P[i] == i + 1:\n            index_x += 1\n        else:\n            break\n    for i in reversed(range(N)):\n        if P[i] == i + 1:\n            index_y += 1\n        else:\n            break\n    if N - index_x - index_y == K:\n        return 1\n    index_y = min(N - index_y - K, N)\n    temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]\n    arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]\n    temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]\n    arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]\n    if arr1 == sorted_arr or arr2 == sorted_arr:\n        return 2\n    else:\n        return 3"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]",
      "mutated_line": "temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) - P[index_x + K:N]",
      "code": "def min_operations_to_sort_permutation(N, K, P):\n    sorted_arr = sorted(P)\n    if P == sorted_arr:\n        return 0\n    index_x = 0\n    index_y = 0\n    for i in range(N):\n        if P[i] == i + 1:\n            index_x += 1\n        else:\n            break\n    for i in reversed(range(N)):\n        if P[i] == i + 1:\n            index_y += 1\n        else:\n            break\n    if N - index_x - index_y <= K:\n        return 1\n    index_y = min(N - index_y - K, N)\n    temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) - P[index_x + K:N]\n    arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]\n    temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]\n    arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]\n    if arr1 == sorted_arr or arr2 == sorted_arr:\n        return 2\n    else:\n        return 3"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]",
      "mutated_line": "temp1 = (P[0:index_x] + sorted(P[index_x:index_x + K])) * P[index_x + K:N]",
      "code": "def min_operations_to_sort_permutation(N, K, P):\n    sorted_arr = sorted(P)\n    if P == sorted_arr:\n        return 0\n    index_x = 0\n    index_y = 0\n    for i in range(N):\n        if P[i] == i + 1:\n            index_x += 1\n        else:\n            break\n    for i in reversed(range(N)):\n        if P[i] == i + 1:\n            index_y += 1\n        else:\n            break\n    if N - index_x - index_y <= K:\n        return 1\n    index_y = min(N - index_y - K, N)\n    temp1 = (P[0:index_x] + sorted(P[index_x:index_x + K])) * P[index_x + K:N]\n    arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]\n    temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]\n    arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]\n    if arr1 == sorted_arr or arr2 == sorted_arr:\n        return 2\n    else:\n        return 3"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]",
      "mutated_line": "arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) - temp1[index_y + K:N]",
      "code": "def min_operations_to_sort_permutation(N, K, P):\n    sorted_arr = sorted(P)\n    if P == sorted_arr:\n        return 0\n    index_x = 0\n    index_y = 0\n    for i in range(N):\n        if P[i] == i + 1:\n            index_x += 1\n        else:\n            break\n    for i in reversed(range(N)):\n        if P[i] == i + 1:\n            index_y += 1\n        else:\n            break\n    if N - index_x - index_y <= K:\n        return 1\n    index_y = min(N - index_y - K, N)\n    temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]\n    arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) - temp1[index_y + K:N]\n    temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]\n    arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]\n    if arr1 == sorted_arr or arr2 == sorted_arr:\n        return 2\n    else:\n        return 3"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]",
      "mutated_line": "arr1 = (temp1[0:index_y] + sorted(temp1[index_y:index_y + K])) * temp1[index_y + K:N]",
      "code": "def min_operations_to_sort_permutation(N, K, P):\n    sorted_arr = sorted(P)\n    if P == sorted_arr:\n        return 0\n    index_x = 0\n    index_y = 0\n    for i in range(N):\n        if P[i] == i + 1:\n            index_x += 1\n        else:\n            break\n    for i in reversed(range(N)):\n        if P[i] == i + 1:\n            index_y += 1\n        else:\n            break\n    if N - index_x - index_y <= K:\n        return 1\n    index_y = min(N - index_y - K, N)\n    temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]\n    arr1 = (temp1[0:index_y] + sorted(temp1[index_y:index_y + K])) * temp1[index_y + K:N]\n    temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]\n    arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]\n    if arr1 == sorted_arr or arr2 == sorted_arr:\n        return 2\n    else:\n        return 3"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]",
      "mutated_line": "temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) - P[index_y + K:N]",
      "code": "def min_operations_to_sort_permutation(N, K, P):\n    sorted_arr = sorted(P)\n    if P == sorted_arr:\n        return 0\n    index_x = 0\n    index_y = 0\n    for i in range(N):\n        if P[i] == i + 1:\n            index_x += 1\n        else:\n            break\n    for i in reversed(range(N)):\n        if P[i] == i + 1:\n            index_y += 1\n        else:\n            break\n    if N - index_x - index_y <= K:\n        return 1\n    index_y = min(N - index_y - K, N)\n    temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]\n    arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]\n    temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) - P[index_y + K:N]\n    arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]\n    if arr1 == sorted_arr or arr2 == sorted_arr:\n        return 2\n    else:\n        return 3"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]",
      "mutated_line": "temp2 = (P[0:index_y] + sorted(P[index_y:index_y + K])) * P[index_y + K:N]",
      "code": "def min_operations_to_sort_permutation(N, K, P):\n    sorted_arr = sorted(P)\n    if P == sorted_arr:\n        return 0\n    index_x = 0\n    index_y = 0\n    for i in range(N):\n        if P[i] == i + 1:\n            index_x += 1\n        else:\n            break\n    for i in reversed(range(N)):\n        if P[i] == i + 1:\n            index_y += 1\n        else:\n            break\n    if N - index_x - index_y <= K:\n        return 1\n    index_y = min(N - index_y - K, N)\n    temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]\n    arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]\n    temp2 = (P[0:index_y] + sorted(P[index_y:index_y + K])) * P[index_y + K:N]\n    arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]\n    if arr1 == sorted_arr or arr2 == sorted_arr:\n        return 2\n    else:\n        return 3"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]",
      "mutated_line": "arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) - temp2[index_x + K:N]",
      "code": "def min_operations_to_sort_permutation(N, K, P):\n    sorted_arr = sorted(P)\n    if P == sorted_arr:\n        return 0\n    index_x = 0\n    index_y = 0\n    for i in range(N):\n        if P[i] == i + 1:\n            index_x += 1\n        else:\n            break\n    for i in reversed(range(N)):\n        if P[i] == i + 1:\n            index_y += 1\n        else:\n            break\n    if N - index_x - index_y <= K:\n        return 1\n    index_y = min(N - index_y - K, N)\n    temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]\n    arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]\n    temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]\n    arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) - temp2[index_x + K:N]\n    if arr1 == sorted_arr or arr2 == sorted_arr:\n        return 2\n    else:\n        return 3"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]",
      "mutated_line": "arr2 = (temp1[0:index_x] + sorted(temp2[index_x:index_x + K])) * temp2[index_x + K:N]",
      "code": "def min_operations_to_sort_permutation(N, K, P):\n    sorted_arr = sorted(P)\n    if P == sorted_arr:\n        return 0\n    index_x = 0\n    index_y = 0\n    for i in range(N):\n        if P[i] == i + 1:\n            index_x += 1\n        else:\n            break\n    for i in reversed(range(N)):\n        if P[i] == i + 1:\n            index_y += 1\n        else:\n            break\n    if N - index_x - index_y <= K:\n        return 1\n    index_y = min(N - index_y - K, N)\n    temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]\n    arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]\n    temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]\n    arr2 = (temp1[0:index_x] + sorted(temp2[index_x:index_x + K])) * temp2[index_x + K:N]\n    if arr1 == sorted_arr or arr2 == sorted_arr:\n        return 2\n    else:\n        return 3"
    },
    {
      "operator": "LCR",
      "lineno": 30,
      "original_line": "if arr1 == sorted_arr or arr2 == sorted_arr:",
      "mutated_line": "if arr1 == sorted_arr and arr2 == sorted_arr:",
      "code": "def min_operations_to_sort_permutation(N, K, P):\n    sorted_arr = sorted(P)\n    if P == sorted_arr:\n        return 0\n    index_x = 0\n    index_y = 0\n    for i in range(N):\n        if P[i] == i + 1:\n            index_x += 1\n        else:\n            break\n    for i in reversed(range(N)):\n        if P[i] == i + 1:\n            index_y += 1\n        else:\n            break\n    if N - index_x - index_y <= K:\n        return 1\n    index_y = min(N - index_y - K, N)\n    temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]\n    arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]\n    temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]\n    arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]\n    if arr1 == sorted_arr and arr2 == sorted_arr:\n        return 2\n    else:\n        return 3"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def min_operations_to_sort_permutation(N, K, P):\n    sorted_arr = sorted(P)\n    if P == sorted_arr:\n        return 1\n    index_x = 0\n    index_y = 0\n    for i in range(N):\n        if P[i] == i + 1:\n            index_x += 1\n        else:\n            break\n    for i in reversed(range(N)):\n        if P[i] == i + 1:\n            index_y += 1\n        else:\n            break\n    if N - index_x - index_y <= K:\n        return 1\n    index_y = min(N - index_y - K, N)\n    temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]\n    arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]\n    temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]\n    arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]\n    if arr1 == sorted_arr or arr2 == sorted_arr:\n        return 2\n    else:\n        return 3"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "def min_operations_to_sort_permutation(N, K, P):\n    sorted_arr = sorted(P)\n    if P == sorted_arr:\n        return -1\n    index_x = 0\n    index_y = 0\n    for i in range(N):\n        if P[i] == i + 1:\n            index_x += 1\n        else:\n            break\n    for i in reversed(range(N)):\n        if P[i] == i + 1:\n            index_y += 1\n        else:\n            break\n    if N - index_x - index_y <= K:\n        return 1\n    index_y = min(N - index_y - K, N)\n    temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]\n    arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]\n    temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]\n    arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]\n    if arr1 == sorted_arr or arr2 == sorted_arr:\n        return 2\n    else:\n        return 3"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def min_operations_to_sort_permutation(N, K, P):\n    sorted_arr = sorted(P)\n    if P == sorted_arr:\n        return 1\n    index_x = 0\n    index_y = 0\n    for i in range(N):\n        if P[i] == i + 1:\n            index_x += 1\n        else:\n            break\n    for i in reversed(range(N)):\n        if P[i] == i + 1:\n            index_y += 1\n        else:\n            break\n    if N - index_x - index_y <= K:\n        return 1\n    index_y = min(N - index_y - K, N)\n    temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]\n    arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]\n    temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]\n    arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]\n    if arr1 == sorted_arr or arr2 == sorted_arr:\n        return 2\n    else:\n        return 3"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if P[i] == i + 1:",
      "mutated_line": "if P[i] != i + 1:",
      "code": "def min_operations_to_sort_permutation(N, K, P):\n    sorted_arr = sorted(P)\n    if P == sorted_arr:\n        return 0\n    index_x = 0\n    index_y = 0\n    for i in range(N):\n        if P[i] != i + 1:\n            index_x += 1\n        else:\n            break\n    for i in reversed(range(N)):\n        if P[i] == i + 1:\n            index_y += 1\n        else:\n            break\n    if N - index_x - index_y <= K:\n        return 1\n    index_y = min(N - index_y - K, N)\n    temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]\n    arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]\n    temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]\n    arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]\n    if arr1 == sorted_arr or arr2 == sorted_arr:\n        return 2\n    else:\n        return 3"
    },
    {
      "operator": "ASR",
      "lineno": 11,
      "original_line": "index_x += 1",
      "mutated_line": "index_x -= 1",
      "code": "def min_operations_to_sort_permutation(N, K, P):\n    sorted_arr = sorted(P)\n    if P == sorted_arr:\n        return 0\n    index_x = 0\n    index_y = 0\n    for i in range(N):\n        if P[i] == i + 1:\n            index_x -= 1\n        else:\n            break\n    for i in reversed(range(N)):\n        if P[i] == i + 1:\n            index_y += 1\n        else:\n            break\n    if N - index_x - index_y <= K:\n        return 1\n    index_y = min(N - index_y - K, N)\n    temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]\n    arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]\n    temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]\n    arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]\n    if arr1 == sorted_arr or arr2 == sorted_arr:\n        return 2\n    else:\n        return 3"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if P[i] == i + 1:",
      "mutated_line": "if P[i] != i + 1:",
      "code": "def min_operations_to_sort_permutation(N, K, P):\n    sorted_arr = sorted(P)\n    if P == sorted_arr:\n        return 0\n    index_x = 0\n    index_y = 0\n    for i in range(N):\n        if P[i] == i + 1:\n            index_x += 1\n        else:\n            break\n    for i in reversed(range(N)):\n        if P[i] != i + 1:\n            index_y += 1\n        else:\n            break\n    if N - index_x - index_y <= K:\n        return 1\n    index_y = min(N - index_y - K, N)\n    temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]\n    arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]\n    temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]\n    arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]\n    if arr1 == sorted_arr or arr2 == sorted_arr:\n        return 2\n    else:\n        return 3"
    },
    {
      "operator": "ASR",
      "lineno": 17,
      "original_line": "index_y += 1",
      "mutated_line": "index_y -= 1",
      "code": "def min_operations_to_sort_permutation(N, K, P):\n    sorted_arr = sorted(P)\n    if P == sorted_arr:\n        return 0\n    index_x = 0\n    index_y = 0\n    for i in range(N):\n        if P[i] == i + 1:\n            index_x += 1\n        else:\n            break\n    for i in reversed(range(N)):\n        if P[i] == i + 1:\n            index_y -= 1\n        else:\n            break\n    if N - index_x - index_y <= K:\n        return 1\n    index_y = min(N - index_y - K, N)\n    temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]\n    arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]\n    temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]\n    arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]\n    if arr1 == sorted_arr or arr2 == sorted_arr:\n        return 2\n    else:\n        return 3"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "if N - index_x - index_y <= K:",
      "mutated_line": "if N - index_x + index_y <= K:",
      "code": "def min_operations_to_sort_permutation(N, K, P):\n    sorted_arr = sorted(P)\n    if P == sorted_arr:\n        return 0\n    index_x = 0\n    index_y = 0\n    for i in range(N):\n        if P[i] == i + 1:\n            index_x += 1\n        else:\n            break\n    for i in reversed(range(N)):\n        if P[i] == i + 1:\n            index_y += 1\n        else:\n            break\n    if N - index_x + index_y <= K:\n        return 1\n    index_y = min(N - index_y - K, N)\n    temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]\n    arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]\n    temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]\n    arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]\n    if arr1 == sorted_arr or arr2 == sorted_arr:\n        return 2\n    else:\n        return 3"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "if N - index_x - index_y <= K:",
      "mutated_line": "if (N - index_x) * index_y <= K:",
      "code": "def min_operations_to_sort_permutation(N, K, P):\n    sorted_arr = sorted(P)\n    if P == sorted_arr:\n        return 0\n    index_x = 0\n    index_y = 0\n    for i in range(N):\n        if P[i] == i + 1:\n            index_x += 1\n        else:\n            break\n    for i in reversed(range(N)):\n        if P[i] == i + 1:\n            index_y += 1\n        else:\n            break\n    if (N - index_x) * index_y <= K:\n        return 1\n    index_y = min(N - index_y - K, N)\n    temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]\n    arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]\n    temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]\n    arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]\n    if arr1 == sorted_arr or arr2 == sorted_arr:\n        return 2\n    else:\n        return 3"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return 1",
      "mutated_line": "return 2",
      "code": "def min_operations_to_sort_permutation(N, K, P):\n    sorted_arr = sorted(P)\n    if P == sorted_arr:\n        return 0\n    index_x = 0\n    index_y = 0\n    for i in range(N):\n        if P[i] == i + 1:\n            index_x += 1\n        else:\n            break\n    for i in reversed(range(N)):\n        if P[i] == i + 1:\n            index_y += 1\n        else:\n            break\n    if N - index_x - index_y <= K:\n        return 2\n    index_y = min(N - index_y - K, N)\n    temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]\n    arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]\n    temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]\n    arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]\n    if arr1 == sorted_arr or arr2 == sorted_arr:\n        return 2\n    else:\n        return 3"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return 1",
      "mutated_line": "return 0",
      "code": "def min_operations_to_sort_permutation(N, K, P):\n    sorted_arr = sorted(P)\n    if P == sorted_arr:\n        return 0\n    index_x = 0\n    index_y = 0\n    for i in range(N):\n        if P[i] == i + 1:\n            index_x += 1\n        else:\n            break\n    for i in reversed(range(N)):\n        if P[i] == i + 1:\n            index_y += 1\n        else:\n            break\n    if N - index_x - index_y <= K:\n        return 0\n    index_y = min(N - index_y - K, N)\n    temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]\n    arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]\n    temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]\n    arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]\n    if arr1 == sorted_arr or arr2 == sorted_arr:\n        return 2\n    else:\n        return 3"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return 1",
      "mutated_line": "return 0",
      "code": "def min_operations_to_sort_permutation(N, K, P):\n    sorted_arr = sorted(P)\n    if P == sorted_arr:\n        return 0\n    index_x = 0\n    index_y = 0\n    for i in range(N):\n        if P[i] == i + 1:\n            index_x += 1\n        else:\n            break\n    for i in reversed(range(N)):\n        if P[i] == i + 1:\n            index_y += 1\n        else:\n            break\n    if N - index_x - index_y <= K:\n        return 0\n    index_y = min(N - index_y - K, N)\n    temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]\n    arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]\n    temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]\n    arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]\n    if arr1 == sorted_arr or arr2 == sorted_arr:\n        return 2\n    else:\n        return 3"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return 1",
      "mutated_line": "return -1",
      "code": "def min_operations_to_sort_permutation(N, K, P):\n    sorted_arr = sorted(P)\n    if P == sorted_arr:\n        return 0\n    index_x = 0\n    index_y = 0\n    for i in range(N):\n        if P[i] == i + 1:\n            index_x += 1\n        else:\n            break\n    for i in reversed(range(N)):\n        if P[i] == i + 1:\n            index_y += 1\n        else:\n            break\n    if N - index_x - index_y <= K:\n        return -1\n    index_y = min(N - index_y - K, N)\n    temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]\n    arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]\n    temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]\n    arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]\n    if arr1 == sorted_arr or arr2 == sorted_arr:\n        return 2\n    else:\n        return 3"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "index_y = min(N - index_y - K, N)",
      "mutated_line": "index_y = min(N - index_y + K, N)",
      "code": "def min_operations_to_sort_permutation(N, K, P):\n    sorted_arr = sorted(P)\n    if P == sorted_arr:\n        return 0\n    index_x = 0\n    index_y = 0\n    for i in range(N):\n        if P[i] == i + 1:\n            index_x += 1\n        else:\n            break\n    for i in reversed(range(N)):\n        if P[i] == i + 1:\n            index_y += 1\n        else:\n            break\n    if N - index_x - index_y <= K:\n        return 1\n    index_y = min(N - index_y + K, N)\n    temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]\n    arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]\n    temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]\n    arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]\n    if arr1 == sorted_arr or arr2 == sorted_arr:\n        return 2\n    else:\n        return 3"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "index_y = min(N - index_y - K, N)",
      "mutated_line": "index_y = min((N - index_y) * K, N)",
      "code": "def min_operations_to_sort_permutation(N, K, P):\n    sorted_arr = sorted(P)\n    if P == sorted_arr:\n        return 0\n    index_x = 0\n    index_y = 0\n    for i in range(N):\n        if P[i] == i + 1:\n            index_x += 1\n        else:\n            break\n    for i in reversed(range(N)):\n        if P[i] == i + 1:\n            index_y += 1\n        else:\n            break\n    if N - index_x - index_y <= K:\n        return 1\n    index_y = min((N - index_y) * K, N)\n    temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]\n    arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]\n    temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]\n    arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]\n    if arr1 == sorted_arr or arr2 == sorted_arr:\n        return 2\n    else:\n        return 3"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]",
      "mutated_line": "temp1 = P[0:index_x] - sorted(P[index_x:index_x + K]) + P[index_x + K:N]",
      "code": "def min_operations_to_sort_permutation(N, K, P):\n    sorted_arr = sorted(P)\n    if P == sorted_arr:\n        return 0\n    index_x = 0\n    index_y = 0\n    for i in range(N):\n        if P[i] == i + 1:\n            index_x += 1\n        else:\n            break\n    for i in reversed(range(N)):\n        if P[i] == i + 1:\n            index_y += 1\n        else:\n            break\n    if N - index_x - index_y <= K:\n        return 1\n    index_y = min(N - index_y - K, N)\n    temp1 = P[0:index_x] - sorted(P[index_x:index_x + K]) + P[index_x + K:N]\n    arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]\n    temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]\n    arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]\n    if arr1 == sorted_arr or arr2 == sorted_arr:\n        return 2\n    else:\n        return 3"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]",
      "mutated_line": "temp1 = P[0:index_x] * sorted(P[index_x:index_x + K]) + P[index_x + K:N]",
      "code": "def min_operations_to_sort_permutation(N, K, P):\n    sorted_arr = sorted(P)\n    if P == sorted_arr:\n        return 0\n    index_x = 0\n    index_y = 0\n    for i in range(N):\n        if P[i] == i + 1:\n            index_x += 1\n        else:\n            break\n    for i in reversed(range(N)):\n        if P[i] == i + 1:\n            index_y += 1\n        else:\n            break\n    if N - index_x - index_y <= K:\n        return 1\n    index_y = min(N - index_y - K, N)\n    temp1 = P[0:index_x] * sorted(P[index_x:index_x + K]) + P[index_x + K:N]\n    arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]\n    temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]\n    arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]\n    if arr1 == sorted_arr or arr2 == sorted_arr:\n        return 2\n    else:\n        return 3"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]",
      "mutated_line": "arr1 = temp1[0:index_y] - sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]",
      "code": "def min_operations_to_sort_permutation(N, K, P):\n    sorted_arr = sorted(P)\n    if P == sorted_arr:\n        return 0\n    index_x = 0\n    index_y = 0\n    for i in range(N):\n        if P[i] == i + 1:\n            index_x += 1\n        else:\n            break\n    for i in reversed(range(N)):\n        if P[i] == i + 1:\n            index_y += 1\n        else:\n            break\n    if N - index_x - index_y <= K:\n        return 1\n    index_y = min(N - index_y - K, N)\n    temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]\n    arr1 = temp1[0:index_y] - sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]\n    temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]\n    arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]\n    if arr1 == sorted_arr or arr2 == sorted_arr:\n        return 2\n    else:\n        return 3"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]",
      "mutated_line": "arr1 = temp1[0:index_y] * sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]",
      "code": "def min_operations_to_sort_permutation(N, K, P):\n    sorted_arr = sorted(P)\n    if P == sorted_arr:\n        return 0\n    index_x = 0\n    index_y = 0\n    for i in range(N):\n        if P[i] == i + 1:\n            index_x += 1\n        else:\n            break\n    for i in reversed(range(N)):\n        if P[i] == i + 1:\n            index_y += 1\n        else:\n            break\n    if N - index_x - index_y <= K:\n        return 1\n    index_y = min(N - index_y - K, N)\n    temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]\n    arr1 = temp1[0:index_y] * sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]\n    temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]\n    arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]\n    if arr1 == sorted_arr or arr2 == sorted_arr:\n        return 2\n    else:\n        return 3"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]",
      "mutated_line": "temp2 = P[0:index_y] - sorted(P[index_y:index_y + K]) + P[index_y + K:N]",
      "code": "def min_operations_to_sort_permutation(N, K, P):\n    sorted_arr = sorted(P)\n    if P == sorted_arr:\n        return 0\n    index_x = 0\n    index_y = 0\n    for i in range(N):\n        if P[i] == i + 1:\n            index_x += 1\n        else:\n            break\n    for i in reversed(range(N)):\n        if P[i] == i + 1:\n            index_y += 1\n        else:\n            break\n    if N - index_x - index_y <= K:\n        return 1\n    index_y = min(N - index_y - K, N)\n    temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]\n    arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]\n    temp2 = P[0:index_y] - sorted(P[index_y:index_y + K]) + P[index_y + K:N]\n    arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]\n    if arr1 == sorted_arr or arr2 == sorted_arr:\n        return 2\n    else:\n        return 3"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]",
      "mutated_line": "temp2 = P[0:index_y] * sorted(P[index_y:index_y + K]) + P[index_y + K:N]",
      "code": "def min_operations_to_sort_permutation(N, K, P):\n    sorted_arr = sorted(P)\n    if P == sorted_arr:\n        return 0\n    index_x = 0\n    index_y = 0\n    for i in range(N):\n        if P[i] == i + 1:\n            index_x += 1\n        else:\n            break\n    for i in reversed(range(N)):\n        if P[i] == i + 1:\n            index_y += 1\n        else:\n            break\n    if N - index_x - index_y <= K:\n        return 1\n    index_y = min(N - index_y - K, N)\n    temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]\n    arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]\n    temp2 = P[0:index_y] * sorted(P[index_y:index_y + K]) + P[index_y + K:N]\n    arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]\n    if arr1 == sorted_arr or arr2 == sorted_arr:\n        return 2\n    else:\n        return 3"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]",
      "mutated_line": "arr2 = temp1[0:index_x] - sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]",
      "code": "def min_operations_to_sort_permutation(N, K, P):\n    sorted_arr = sorted(P)\n    if P == sorted_arr:\n        return 0\n    index_x = 0\n    index_y = 0\n    for i in range(N):\n        if P[i] == i + 1:\n            index_x += 1\n        else:\n            break\n    for i in reversed(range(N)):\n        if P[i] == i + 1:\n            index_y += 1\n        else:\n            break\n    if N - index_x - index_y <= K:\n        return 1\n    index_y = min(N - index_y - K, N)\n    temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]\n    arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]\n    temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]\n    arr2 = temp1[0:index_x] - sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]\n    if arr1 == sorted_arr or arr2 == sorted_arr:\n        return 2\n    else:\n        return 3"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]",
      "mutated_line": "arr2 = temp1[0:index_x] * sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]",
      "code": "def min_operations_to_sort_permutation(N, K, P):\n    sorted_arr = sorted(P)\n    if P == sorted_arr:\n        return 0\n    index_x = 0\n    index_y = 0\n    for i in range(N):\n        if P[i] == i + 1:\n            index_x += 1\n        else:\n            break\n    for i in reversed(range(N)):\n        if P[i] == i + 1:\n            index_y += 1\n        else:\n            break\n    if N - index_x - index_y <= K:\n        return 1\n    index_y = min(N - index_y - K, N)\n    temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]\n    arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]\n    temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]\n    arr2 = temp1[0:index_x] * sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]\n    if arr1 == sorted_arr or arr2 == sorted_arr:\n        return 2\n    else:\n        return 3"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if arr1 == sorted_arr or arr2 == sorted_arr:",
      "mutated_line": "if arr1 != sorted_arr or arr2 == sorted_arr:",
      "code": "def min_operations_to_sort_permutation(N, K, P):\n    sorted_arr = sorted(P)\n    if P == sorted_arr:\n        return 0\n    index_x = 0\n    index_y = 0\n    for i in range(N):\n        if P[i] == i + 1:\n            index_x += 1\n        else:\n            break\n    for i in reversed(range(N)):\n        if P[i] == i + 1:\n            index_y += 1\n        else:\n            break\n    if N - index_x - index_y <= K:\n        return 1\n    index_y = min(N - index_y - K, N)\n    temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]\n    arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]\n    temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]\n    arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]\n    if arr1 != sorted_arr or arr2 == sorted_arr:\n        return 2\n    else:\n        return 3"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if arr1 == sorted_arr or arr2 == sorted_arr:",
      "mutated_line": "if arr1 == sorted_arr or arr2 != sorted_arr:",
      "code": "def min_operations_to_sort_permutation(N, K, P):\n    sorted_arr = sorted(P)\n    if P == sorted_arr:\n        return 0\n    index_x = 0\n    index_y = 0\n    for i in range(N):\n        if P[i] == i + 1:\n            index_x += 1\n        else:\n            break\n    for i in reversed(range(N)):\n        if P[i] == i + 1:\n            index_y += 1\n        else:\n            break\n    if N - index_x - index_y <= K:\n        return 1\n    index_y = min(N - index_y - K, N)\n    temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]\n    arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]\n    temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]\n    arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]\n    if arr1 == sorted_arr or arr2 != sorted_arr:\n        return 2\n    else:\n        return 3"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return 2",
      "mutated_line": "return 3",
      "code": "def min_operations_to_sort_permutation(N, K, P):\n    sorted_arr = sorted(P)\n    if P == sorted_arr:\n        return 0\n    index_x = 0\n    index_y = 0\n    for i in range(N):\n        if P[i] == i + 1:\n            index_x += 1\n        else:\n            break\n    for i in reversed(range(N)):\n        if P[i] == i + 1:\n            index_y += 1\n        else:\n            break\n    if N - index_x - index_y <= K:\n        return 1\n    index_y = min(N - index_y - K, N)\n    temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]\n    arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]\n    temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]\n    arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]\n    if arr1 == sorted_arr or arr2 == sorted_arr:\n        return 3\n    else:\n        return 3"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return 2",
      "mutated_line": "return 1",
      "code": "def min_operations_to_sort_permutation(N, K, P):\n    sorted_arr = sorted(P)\n    if P == sorted_arr:\n        return 0\n    index_x = 0\n    index_y = 0\n    for i in range(N):\n        if P[i] == i + 1:\n            index_x += 1\n        else:\n            break\n    for i in reversed(range(N)):\n        if P[i] == i + 1:\n            index_y += 1\n        else:\n            break\n    if N - index_x - index_y <= K:\n        return 1\n    index_y = min(N - index_y - K, N)\n    temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]\n    arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]\n    temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]\n    arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]\n    if arr1 == sorted_arr or arr2 == sorted_arr:\n        return 1\n    else:\n        return 3"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return 2",
      "mutated_line": "return 0",
      "code": "def min_operations_to_sort_permutation(N, K, P):\n    sorted_arr = sorted(P)\n    if P == sorted_arr:\n        return 0\n    index_x = 0\n    index_y = 0\n    for i in range(N):\n        if P[i] == i + 1:\n            index_x += 1\n        else:\n            break\n    for i in reversed(range(N)):\n        if P[i] == i + 1:\n            index_y += 1\n        else:\n            break\n    if N - index_x - index_y <= K:\n        return 1\n    index_y = min(N - index_y - K, N)\n    temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]\n    arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]\n    temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]\n    arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]\n    if arr1 == sorted_arr or arr2 == sorted_arr:\n        return 0\n    else:\n        return 3"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return 2",
      "mutated_line": "return 1",
      "code": "def min_operations_to_sort_permutation(N, K, P):\n    sorted_arr = sorted(P)\n    if P == sorted_arr:\n        return 0\n    index_x = 0\n    index_y = 0\n    for i in range(N):\n        if P[i] == i + 1:\n            index_x += 1\n        else:\n            break\n    for i in reversed(range(N)):\n        if P[i] == i + 1:\n            index_y += 1\n        else:\n            break\n    if N - index_x - index_y <= K:\n        return 1\n    index_y = min(N - index_y - K, N)\n    temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]\n    arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]\n    temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]\n    arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]\n    if arr1 == sorted_arr or arr2 == sorted_arr:\n        return 1\n    else:\n        return 3"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return 2",
      "mutated_line": "return -2",
      "code": "def min_operations_to_sort_permutation(N, K, P):\n    sorted_arr = sorted(P)\n    if P == sorted_arr:\n        return 0\n    index_x = 0\n    index_y = 0\n    for i in range(N):\n        if P[i] == i + 1:\n            index_x += 1\n        else:\n            break\n    for i in reversed(range(N)):\n        if P[i] == i + 1:\n            index_y += 1\n        else:\n            break\n    if N - index_x - index_y <= K:\n        return 1\n    index_y = min(N - index_y - K, N)\n    temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]\n    arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]\n    temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]\n    arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]\n    if arr1 == sorted_arr or arr2 == sorted_arr:\n        return -2\n    else:\n        return 3"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return 3",
      "mutated_line": "return 4",
      "code": "def min_operations_to_sort_permutation(N, K, P):\n    sorted_arr = sorted(P)\n    if P == sorted_arr:\n        return 0\n    index_x = 0\n    index_y = 0\n    for i in range(N):\n        if P[i] == i + 1:\n            index_x += 1\n        else:\n            break\n    for i in reversed(range(N)):\n        if P[i] == i + 1:\n            index_y += 1\n        else:\n            break\n    if N - index_x - index_y <= K:\n        return 1\n    index_y = min(N - index_y - K, N)\n    temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]\n    arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]\n    temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]\n    arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]\n    if arr1 == sorted_arr or arr2 == sorted_arr:\n        return 2\n    else:\n        return 4"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return 3",
      "mutated_line": "return 2",
      "code": "def min_operations_to_sort_permutation(N, K, P):\n    sorted_arr = sorted(P)\n    if P == sorted_arr:\n        return 0\n    index_x = 0\n    index_y = 0\n    for i in range(N):\n        if P[i] == i + 1:\n            index_x += 1\n        else:\n            break\n    for i in reversed(range(N)):\n        if P[i] == i + 1:\n            index_y += 1\n        else:\n            break\n    if N - index_x - index_y <= K:\n        return 1\n    index_y = min(N - index_y - K, N)\n    temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]\n    arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]\n    temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]\n    arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]\n    if arr1 == sorted_arr or arr2 == sorted_arr:\n        return 2\n    else:\n        return 2"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return 3",
      "mutated_line": "return 0",
      "code": "def min_operations_to_sort_permutation(N, K, P):\n    sorted_arr = sorted(P)\n    if P == sorted_arr:\n        return 0\n    index_x = 0\n    index_y = 0\n    for i in range(N):\n        if P[i] == i + 1:\n            index_x += 1\n        else:\n            break\n    for i in reversed(range(N)):\n        if P[i] == i + 1:\n            index_y += 1\n        else:\n            break\n    if N - index_x - index_y <= K:\n        return 1\n    index_y = min(N - index_y - K, N)\n    temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]\n    arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]\n    temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]\n    arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]\n    if arr1 == sorted_arr or arr2 == sorted_arr:\n        return 2\n    else:\n        return 0"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return 3",
      "mutated_line": "return 1",
      "code": "def min_operations_to_sort_permutation(N, K, P):\n    sorted_arr = sorted(P)\n    if P == sorted_arr:\n        return 0\n    index_x = 0\n    index_y = 0\n    for i in range(N):\n        if P[i] == i + 1:\n            index_x += 1\n        else:\n            break\n    for i in reversed(range(N)):\n        if P[i] == i + 1:\n            index_y += 1\n        else:\n            break\n    if N - index_x - index_y <= K:\n        return 1\n    index_y = min(N - index_y - K, N)\n    temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]\n    arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]\n    temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]\n    arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]\n    if arr1 == sorted_arr or arr2 == sorted_arr:\n        return 2\n    else:\n        return 1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return 3",
      "mutated_line": "return -3",
      "code": "def min_operations_to_sort_permutation(N, K, P):\n    sorted_arr = sorted(P)\n    if P == sorted_arr:\n        return 0\n    index_x = 0\n    index_y = 0\n    for i in range(N):\n        if P[i] == i + 1:\n            index_x += 1\n        else:\n            break\n    for i in reversed(range(N)):\n        if P[i] == i + 1:\n            index_y += 1\n        else:\n            break\n    if N - index_x - index_y <= K:\n        return 1\n    index_y = min(N - index_y - K, N)\n    temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]\n    arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]\n    temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]\n    arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]\n    if arr1 == sorted_arr or arr2 == sorted_arr:\n        return 2\n    else:\n        return -3"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "if P[i] == i + 1:",
      "mutated_line": "if P[i] == i - 1:",
      "code": "def min_operations_to_sort_permutation(N, K, P):\n    sorted_arr = sorted(P)\n    if P == sorted_arr:\n        return 0\n    index_x = 0\n    index_y = 0\n    for i in range(N):\n        if P[i] == i - 1:\n            index_x += 1\n        else:\n            break\n    for i in reversed(range(N)):\n        if P[i] == i + 1:\n            index_y += 1\n        else:\n            break\n    if N - index_x - index_y <= K:\n        return 1\n    index_y = min(N - index_y - K, N)\n    temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]\n    arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]\n    temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]\n    arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]\n    if arr1 == sorted_arr or arr2 == sorted_arr:\n        return 2\n    else:\n        return 3"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "if P[i] == i + 1:",
      "mutated_line": "if P[i] == i * 1:",
      "code": "def min_operations_to_sort_permutation(N, K, P):\n    sorted_arr = sorted(P)\n    if P == sorted_arr:\n        return 0\n    index_x = 0\n    index_y = 0\n    for i in range(N):\n        if P[i] == i * 1:\n            index_x += 1\n        else:\n            break\n    for i in reversed(range(N)):\n        if P[i] == i + 1:\n            index_y += 1\n        else:\n            break\n    if N - index_x - index_y <= K:\n        return 1\n    index_y = min(N - index_y - K, N)\n    temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]\n    arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]\n    temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]\n    arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]\n    if arr1 == sorted_arr or arr2 == sorted_arr:\n        return 2\n    else:\n        return 3"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "index_x += 1",
      "mutated_line": "index_x += 2",
      "code": "def min_operations_to_sort_permutation(N, K, P):\n    sorted_arr = sorted(P)\n    if P == sorted_arr:\n        return 0\n    index_x = 0\n    index_y = 0\n    for i in range(N):\n        if P[i] == i + 1:\n            index_x += 2\n        else:\n            break\n    for i in reversed(range(N)):\n        if P[i] == i + 1:\n            index_y += 1\n        else:\n            break\n    if N - index_x - index_y <= K:\n        return 1\n    index_y = min(N - index_y - K, N)\n    temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]\n    arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]\n    temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]\n    arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]\n    if arr1 == sorted_arr or arr2 == sorted_arr:\n        return 2\n    else:\n        return 3"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "index_x += 1",
      "mutated_line": "index_x += 0",
      "code": "def min_operations_to_sort_permutation(N, K, P):\n    sorted_arr = sorted(P)\n    if P == sorted_arr:\n        return 0\n    index_x = 0\n    index_y = 0\n    for i in range(N):\n        if P[i] == i + 1:\n            index_x += 0\n        else:\n            break\n    for i in reversed(range(N)):\n        if P[i] == i + 1:\n            index_y += 1\n        else:\n            break\n    if N - index_x - index_y <= K:\n        return 1\n    index_y = min(N - index_y - K, N)\n    temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]\n    arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]\n    temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]\n    arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]\n    if arr1 == sorted_arr or arr2 == sorted_arr:\n        return 2\n    else:\n        return 3"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "index_x += 1",
      "mutated_line": "index_x += 0",
      "code": "def min_operations_to_sort_permutation(N, K, P):\n    sorted_arr = sorted(P)\n    if P == sorted_arr:\n        return 0\n    index_x = 0\n    index_y = 0\n    for i in range(N):\n        if P[i] == i + 1:\n            index_x += 0\n        else:\n            break\n    for i in reversed(range(N)):\n        if P[i] == i + 1:\n            index_y += 1\n        else:\n            break\n    if N - index_x - index_y <= K:\n        return 1\n    index_y = min(N - index_y - K, N)\n    temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]\n    arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]\n    temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]\n    arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]\n    if arr1 == sorted_arr or arr2 == sorted_arr:\n        return 2\n    else:\n        return 3"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "index_x += 1",
      "mutated_line": "index_x += -1",
      "code": "def min_operations_to_sort_permutation(N, K, P):\n    sorted_arr = sorted(P)\n    if P == sorted_arr:\n        return 0\n    index_x = 0\n    index_y = 0\n    for i in range(N):\n        if P[i] == i + 1:\n            index_x += -1\n        else:\n            break\n    for i in reversed(range(N)):\n        if P[i] == i + 1:\n            index_y += 1\n        else:\n            break\n    if N - index_x - index_y <= K:\n        return 1\n    index_y = min(N - index_y - K, N)\n    temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]\n    arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]\n    temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]\n    arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]\n    if arr1 == sorted_arr or arr2 == sorted_arr:\n        return 2\n    else:\n        return 3"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if P[i] == i + 1:",
      "mutated_line": "if P[i] == i - 1:",
      "code": "def min_operations_to_sort_permutation(N, K, P):\n    sorted_arr = sorted(P)\n    if P == sorted_arr:\n        return 0\n    index_x = 0\n    index_y = 0\n    for i in range(N):\n        if P[i] == i + 1:\n            index_x += 1\n        else:\n            break\n    for i in reversed(range(N)):\n        if P[i] == i - 1:\n            index_y += 1\n        else:\n            break\n    if N - index_x - index_y <= K:\n        return 1\n    index_y = min(N - index_y - K, N)\n    temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]\n    arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]\n    temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]\n    arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]\n    if arr1 == sorted_arr or arr2 == sorted_arr:\n        return 2\n    else:\n        return 3"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if P[i] == i + 1:",
      "mutated_line": "if P[i] == i * 1:",
      "code": "def min_operations_to_sort_permutation(N, K, P):\n    sorted_arr = sorted(P)\n    if P == sorted_arr:\n        return 0\n    index_x = 0\n    index_y = 0\n    for i in range(N):\n        if P[i] == i + 1:\n            index_x += 1\n        else:\n            break\n    for i in reversed(range(N)):\n        if P[i] == i * 1:\n            index_y += 1\n        else:\n            break\n    if N - index_x - index_y <= K:\n        return 1\n    index_y = min(N - index_y - K, N)\n    temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]\n    arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]\n    temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]\n    arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]\n    if arr1 == sorted_arr or arr2 == sorted_arr:\n        return 2\n    else:\n        return 3"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "index_y += 1",
      "mutated_line": "index_y += 2",
      "code": "def min_operations_to_sort_permutation(N, K, P):\n    sorted_arr = sorted(P)\n    if P == sorted_arr:\n        return 0\n    index_x = 0\n    index_y = 0\n    for i in range(N):\n        if P[i] == i + 1:\n            index_x += 1\n        else:\n            break\n    for i in reversed(range(N)):\n        if P[i] == i + 1:\n            index_y += 2\n        else:\n            break\n    if N - index_x - index_y <= K:\n        return 1\n    index_y = min(N - index_y - K, N)\n    temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]\n    arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]\n    temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]\n    arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]\n    if arr1 == sorted_arr or arr2 == sorted_arr:\n        return 2\n    else:\n        return 3"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "index_y += 1",
      "mutated_line": "index_y += 0",
      "code": "def min_operations_to_sort_permutation(N, K, P):\n    sorted_arr = sorted(P)\n    if P == sorted_arr:\n        return 0\n    index_x = 0\n    index_y = 0\n    for i in range(N):\n        if P[i] == i + 1:\n            index_x += 1\n        else:\n            break\n    for i in reversed(range(N)):\n        if P[i] == i + 1:\n            index_y += 0\n        else:\n            break\n    if N - index_x - index_y <= K:\n        return 1\n    index_y = min(N - index_y - K, N)\n    temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]\n    arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]\n    temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]\n    arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]\n    if arr1 == sorted_arr or arr2 == sorted_arr:\n        return 2\n    else:\n        return 3"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "index_y += 1",
      "mutated_line": "index_y += 0",
      "code": "def min_operations_to_sort_permutation(N, K, P):\n    sorted_arr = sorted(P)\n    if P == sorted_arr:\n        return 0\n    index_x = 0\n    index_y = 0\n    for i in range(N):\n        if P[i] == i + 1:\n            index_x += 1\n        else:\n            break\n    for i in reversed(range(N)):\n        if P[i] == i + 1:\n            index_y += 0\n        else:\n            break\n    if N - index_x - index_y <= K:\n        return 1\n    index_y = min(N - index_y - K, N)\n    temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]\n    arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]\n    temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]\n    arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]\n    if arr1 == sorted_arr or arr2 == sorted_arr:\n        return 2\n    else:\n        return 3"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "index_y += 1",
      "mutated_line": "index_y += -1",
      "code": "def min_operations_to_sort_permutation(N, K, P):\n    sorted_arr = sorted(P)\n    if P == sorted_arr:\n        return 0\n    index_x = 0\n    index_y = 0\n    for i in range(N):\n        if P[i] == i + 1:\n            index_x += 1\n        else:\n            break\n    for i in reversed(range(N)):\n        if P[i] == i + 1:\n            index_y += -1\n        else:\n            break\n    if N - index_x - index_y <= K:\n        return 1\n    index_y = min(N - index_y - K, N)\n    temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]\n    arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]\n    temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]\n    arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]\n    if arr1 == sorted_arr or arr2 == sorted_arr:\n        return 2\n    else:\n        return 3"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "if N - index_x - index_y <= K:",
      "mutated_line": "if N + index_x - index_y <= K:",
      "code": "def min_operations_to_sort_permutation(N, K, P):\n    sorted_arr = sorted(P)\n    if P == sorted_arr:\n        return 0\n    index_x = 0\n    index_y = 0\n    for i in range(N):\n        if P[i] == i + 1:\n            index_x += 1\n        else:\n            break\n    for i in reversed(range(N)):\n        if P[i] == i + 1:\n            index_y += 1\n        else:\n            break\n    if N + index_x - index_y <= K:\n        return 1\n    index_y = min(N - index_y - K, N)\n    temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]\n    arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]\n    temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]\n    arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]\n    if arr1 == sorted_arr or arr2 == sorted_arr:\n        return 2\n    else:\n        return 3"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "if N - index_x - index_y <= K:",
      "mutated_line": "if N * index_x - index_y <= K:",
      "code": "def min_operations_to_sort_permutation(N, K, P):\n    sorted_arr = sorted(P)\n    if P == sorted_arr:\n        return 0\n    index_x = 0\n    index_y = 0\n    for i in range(N):\n        if P[i] == i + 1:\n            index_x += 1\n        else:\n            break\n    for i in reversed(range(N)):\n        if P[i] == i + 1:\n            index_y += 1\n        else:\n            break\n    if N * index_x - index_y <= K:\n        return 1\n    index_y = min(N - index_y - K, N)\n    temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]\n    arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]\n    temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]\n    arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]\n    if arr1 == sorted_arr or arr2 == sorted_arr:\n        return 2\n    else:\n        return 3"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "index_y = min(N - index_y - K, N)",
      "mutated_line": "index_y = min(N + index_y - K, N)",
      "code": "def min_operations_to_sort_permutation(N, K, P):\n    sorted_arr = sorted(P)\n    if P == sorted_arr:\n        return 0\n    index_x = 0\n    index_y = 0\n    for i in range(N):\n        if P[i] == i + 1:\n            index_x += 1\n        else:\n            break\n    for i in reversed(range(N)):\n        if P[i] == i + 1:\n            index_y += 1\n        else:\n            break\n    if N - index_x - index_y <= K:\n        return 1\n    index_y = min(N + index_y - K, N)\n    temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]\n    arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]\n    temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]\n    arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]\n    if arr1 == sorted_arr or arr2 == sorted_arr:\n        return 2\n    else:\n        return 3"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "index_y = min(N - index_y - K, N)",
      "mutated_line": "index_y = min(N * index_y - K, N)",
      "code": "def min_operations_to_sort_permutation(N, K, P):\n    sorted_arr = sorted(P)\n    if P == sorted_arr:\n        return 0\n    index_x = 0\n    index_y = 0\n    for i in range(N):\n        if P[i] == i + 1:\n            index_x += 1\n        else:\n            break\n    for i in reversed(range(N)):\n        if P[i] == i + 1:\n            index_y += 1\n        else:\n            break\n    if N - index_x - index_y <= K:\n        return 1\n    index_y = min(N * index_y - K, N)\n    temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]\n    arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]\n    temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]\n    arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]\n    if arr1 == sorted_arr or arr2 == sorted_arr:\n        return 2\n    else:\n        return 3"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if P[i] == i + 1:",
      "mutated_line": "if P[i] == i + 2:",
      "code": "def min_operations_to_sort_permutation(N, K, P):\n    sorted_arr = sorted(P)\n    if P == sorted_arr:\n        return 0\n    index_x = 0\n    index_y = 0\n    for i in range(N):\n        if P[i] == i + 2:\n            index_x += 1\n        else:\n            break\n    for i in reversed(range(N)):\n        if P[i] == i + 1:\n            index_y += 1\n        else:\n            break\n    if N - index_x - index_y <= K:\n        return 1\n    index_y = min(N - index_y - K, N)\n    temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]\n    arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]\n    temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]\n    arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]\n    if arr1 == sorted_arr or arr2 == sorted_arr:\n        return 2\n    else:\n        return 3"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if P[i] == i + 1:",
      "mutated_line": "if P[i] == i + 0:",
      "code": "def min_operations_to_sort_permutation(N, K, P):\n    sorted_arr = sorted(P)\n    if P == sorted_arr:\n        return 0\n    index_x = 0\n    index_y = 0\n    for i in range(N):\n        if P[i] == i + 0:\n            index_x += 1\n        else:\n            break\n    for i in reversed(range(N)):\n        if P[i] == i + 1:\n            index_y += 1\n        else:\n            break\n    if N - index_x - index_y <= K:\n        return 1\n    index_y = min(N - index_y - K, N)\n    temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]\n    arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]\n    temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]\n    arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]\n    if arr1 == sorted_arr or arr2 == sorted_arr:\n        return 2\n    else:\n        return 3"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if P[i] == i + 1:",
      "mutated_line": "if P[i] == i + 0:",
      "code": "def min_operations_to_sort_permutation(N, K, P):\n    sorted_arr = sorted(P)\n    if P == sorted_arr:\n        return 0\n    index_x = 0\n    index_y = 0\n    for i in range(N):\n        if P[i] == i + 0:\n            index_x += 1\n        else:\n            break\n    for i in reversed(range(N)):\n        if P[i] == i + 1:\n            index_y += 1\n        else:\n            break\n    if N - index_x - index_y <= K:\n        return 1\n    index_y = min(N - index_y - K, N)\n    temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]\n    arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]\n    temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]\n    arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]\n    if arr1 == sorted_arr or arr2 == sorted_arr:\n        return 2\n    else:\n        return 3"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if P[i] == i + 1:",
      "mutated_line": "if P[i] == i + -1:",
      "code": "def min_operations_to_sort_permutation(N, K, P):\n    sorted_arr = sorted(P)\n    if P == sorted_arr:\n        return 0\n    index_x = 0\n    index_y = 0\n    for i in range(N):\n        if P[i] == i + -1:\n            index_x += 1\n        else:\n            break\n    for i in reversed(range(N)):\n        if P[i] == i + 1:\n            index_y += 1\n        else:\n            break\n    if N - index_x - index_y <= K:\n        return 1\n    index_y = min(N - index_y - K, N)\n    temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]\n    arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]\n    temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]\n    arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]\n    if arr1 == sorted_arr or arr2 == sorted_arr:\n        return 2\n    else:\n        return 3"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if P[i] == i + 1:",
      "mutated_line": "if P[i] == i + 2:",
      "code": "def min_operations_to_sort_permutation(N, K, P):\n    sorted_arr = sorted(P)\n    if P == sorted_arr:\n        return 0\n    index_x = 0\n    index_y = 0\n    for i in range(N):\n        if P[i] == i + 1:\n            index_x += 1\n        else:\n            break\n    for i in reversed(range(N)):\n        if P[i] == i + 2:\n            index_y += 1\n        else:\n            break\n    if N - index_x - index_y <= K:\n        return 1\n    index_y = min(N - index_y - K, N)\n    temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]\n    arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]\n    temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]\n    arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]\n    if arr1 == sorted_arr or arr2 == sorted_arr:\n        return 2\n    else:\n        return 3"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if P[i] == i + 1:",
      "mutated_line": "if P[i] == i + 0:",
      "code": "def min_operations_to_sort_permutation(N, K, P):\n    sorted_arr = sorted(P)\n    if P == sorted_arr:\n        return 0\n    index_x = 0\n    index_y = 0\n    for i in range(N):\n        if P[i] == i + 1:\n            index_x += 1\n        else:\n            break\n    for i in reversed(range(N)):\n        if P[i] == i + 0:\n            index_y += 1\n        else:\n            break\n    if N - index_x - index_y <= K:\n        return 1\n    index_y = min(N - index_y - K, N)\n    temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]\n    arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]\n    temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]\n    arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]\n    if arr1 == sorted_arr or arr2 == sorted_arr:\n        return 2\n    else:\n        return 3"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if P[i] == i + 1:",
      "mutated_line": "if P[i] == i + 0:",
      "code": "def min_operations_to_sort_permutation(N, K, P):\n    sorted_arr = sorted(P)\n    if P == sorted_arr:\n        return 0\n    index_x = 0\n    index_y = 0\n    for i in range(N):\n        if P[i] == i + 1:\n            index_x += 1\n        else:\n            break\n    for i in reversed(range(N)):\n        if P[i] == i + 0:\n            index_y += 1\n        else:\n            break\n    if N - index_x - index_y <= K:\n        return 1\n    index_y = min(N - index_y - K, N)\n    temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]\n    arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]\n    temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]\n    arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]\n    if arr1 == sorted_arr or arr2 == sorted_arr:\n        return 2\n    else:\n        return 3"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if P[i] == i + 1:",
      "mutated_line": "if P[i] == i + -1:",
      "code": "def min_operations_to_sort_permutation(N, K, P):\n    sorted_arr = sorted(P)\n    if P == sorted_arr:\n        return 0\n    index_x = 0\n    index_y = 0\n    for i in range(N):\n        if P[i] == i + 1:\n            index_x += 1\n        else:\n            break\n    for i in reversed(range(N)):\n        if P[i] == i + -1:\n            index_y += 1\n        else:\n            break\n    if N - index_x - index_y <= K:\n        return 1\n    index_y = min(N - index_y - K, N)\n    temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]\n    arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]\n    temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]\n    arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]\n    if arr1 == sorted_arr or arr2 == sorted_arr:\n        return 2\n    else:\n        return 3"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]",
      "mutated_line": "temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x - K:N]",
      "code": "def min_operations_to_sort_permutation(N, K, P):\n    sorted_arr = sorted(P)\n    if P == sorted_arr:\n        return 0\n    index_x = 0\n    index_y = 0\n    for i in range(N):\n        if P[i] == i + 1:\n            index_x += 1\n        else:\n            break\n    for i in reversed(range(N)):\n        if P[i] == i + 1:\n            index_y += 1\n        else:\n            break\n    if N - index_x - index_y <= K:\n        return 1\n    index_y = min(N - index_y - K, N)\n    temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x - K:N]\n    arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]\n    temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]\n    arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]\n    if arr1 == sorted_arr or arr2 == sorted_arr:\n        return 2\n    else:\n        return 3"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]",
      "mutated_line": "temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x * K:N]",
      "code": "def min_operations_to_sort_permutation(N, K, P):\n    sorted_arr = sorted(P)\n    if P == sorted_arr:\n        return 0\n    index_x = 0\n    index_y = 0\n    for i in range(N):\n        if P[i] == i + 1:\n            index_x += 1\n        else:\n            break\n    for i in reversed(range(N)):\n        if P[i] == i + 1:\n            index_y += 1\n        else:\n            break\n    if N - index_x - index_y <= K:\n        return 1\n    index_y = min(N - index_y - K, N)\n    temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x * K:N]\n    arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]\n    temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]\n    arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]\n    if arr1 == sorted_arr or arr2 == sorted_arr:\n        return 2\n    else:\n        return 3"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]",
      "mutated_line": "arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y - K:N]",
      "code": "def min_operations_to_sort_permutation(N, K, P):\n    sorted_arr = sorted(P)\n    if P == sorted_arr:\n        return 0\n    index_x = 0\n    index_y = 0\n    for i in range(N):\n        if P[i] == i + 1:\n            index_x += 1\n        else:\n            break\n    for i in reversed(range(N)):\n        if P[i] == i + 1:\n            index_y += 1\n        else:\n            break\n    if N - index_x - index_y <= K:\n        return 1\n    index_y = min(N - index_y - K, N)\n    temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]\n    arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y - K:N]\n    temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]\n    arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]\n    if arr1 == sorted_arr or arr2 == sorted_arr:\n        return 2\n    else:\n        return 3"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]",
      "mutated_line": "arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y * K:N]",
      "code": "def min_operations_to_sort_permutation(N, K, P):\n    sorted_arr = sorted(P)\n    if P == sorted_arr:\n        return 0\n    index_x = 0\n    index_y = 0\n    for i in range(N):\n        if P[i] == i + 1:\n            index_x += 1\n        else:\n            break\n    for i in reversed(range(N)):\n        if P[i] == i + 1:\n            index_y += 1\n        else:\n            break\n    if N - index_x - index_y <= K:\n        return 1\n    index_y = min(N - index_y - K, N)\n    temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]\n    arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y * K:N]\n    temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]\n    arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]\n    if arr1 == sorted_arr or arr2 == sorted_arr:\n        return 2\n    else:\n        return 3"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]",
      "mutated_line": "temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y - K:N]",
      "code": "def min_operations_to_sort_permutation(N, K, P):\n    sorted_arr = sorted(P)\n    if P == sorted_arr:\n        return 0\n    index_x = 0\n    index_y = 0\n    for i in range(N):\n        if P[i] == i + 1:\n            index_x += 1\n        else:\n            break\n    for i in reversed(range(N)):\n        if P[i] == i + 1:\n            index_y += 1\n        else:\n            break\n    if N - index_x - index_y <= K:\n        return 1\n    index_y = min(N - index_y - K, N)\n    temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]\n    arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]\n    temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y - K:N]\n    arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]\n    if arr1 == sorted_arr or arr2 == sorted_arr:\n        return 2\n    else:\n        return 3"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]",
      "mutated_line": "temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y * K:N]",
      "code": "def min_operations_to_sort_permutation(N, K, P):\n    sorted_arr = sorted(P)\n    if P == sorted_arr:\n        return 0\n    index_x = 0\n    index_y = 0\n    for i in range(N):\n        if P[i] == i + 1:\n            index_x += 1\n        else:\n            break\n    for i in reversed(range(N)):\n        if P[i] == i + 1:\n            index_y += 1\n        else:\n            break\n    if N - index_x - index_y <= K:\n        return 1\n    index_y = min(N - index_y - K, N)\n    temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]\n    arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]\n    temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y * K:N]\n    arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]\n    if arr1 == sorted_arr or arr2 == sorted_arr:\n        return 2\n    else:\n        return 3"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]",
      "mutated_line": "arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x - K:N]",
      "code": "def min_operations_to_sort_permutation(N, K, P):\n    sorted_arr = sorted(P)\n    if P == sorted_arr:\n        return 0\n    index_x = 0\n    index_y = 0\n    for i in range(N):\n        if P[i] == i + 1:\n            index_x += 1\n        else:\n            break\n    for i in reversed(range(N)):\n        if P[i] == i + 1:\n            index_y += 1\n        else:\n            break\n    if N - index_x - index_y <= K:\n        return 1\n    index_y = min(N - index_y - K, N)\n    temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]\n    arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]\n    temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]\n    arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x - K:N]\n    if arr1 == sorted_arr or arr2 == sorted_arr:\n        return 2\n    else:\n        return 3"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]",
      "mutated_line": "arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x * K:N]",
      "code": "def min_operations_to_sort_permutation(N, K, P):\n    sorted_arr = sorted(P)\n    if P == sorted_arr:\n        return 0\n    index_x = 0\n    index_y = 0\n    for i in range(N):\n        if P[i] == i + 1:\n            index_x += 1\n        else:\n            break\n    for i in reversed(range(N)):\n        if P[i] == i + 1:\n            index_y += 1\n        else:\n            break\n    if N - index_x - index_y <= K:\n        return 1\n    index_y = min(N - index_y - K, N)\n    temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]\n    arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]\n    temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]\n    arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x * K:N]\n    if arr1 == sorted_arr or arr2 == sorted_arr:\n        return 2\n    else:\n        return 3"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]",
      "mutated_line": "temp1 = P[1:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]",
      "code": "def min_operations_to_sort_permutation(N, K, P):\n    sorted_arr = sorted(P)\n    if P == sorted_arr:\n        return 0\n    index_x = 0\n    index_y = 0\n    for i in range(N):\n        if P[i] == i + 1:\n            index_x += 1\n        else:\n            break\n    for i in reversed(range(N)):\n        if P[i] == i + 1:\n            index_y += 1\n        else:\n            break\n    if N - index_x - index_y <= K:\n        return 1\n    index_y = min(N - index_y - K, N)\n    temp1 = P[1:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]\n    arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]\n    temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]\n    arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]\n    if arr1 == sorted_arr or arr2 == sorted_arr:\n        return 2\n    else:\n        return 3"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]",
      "mutated_line": "temp1 = P[-1:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]",
      "code": "def min_operations_to_sort_permutation(N, K, P):\n    sorted_arr = sorted(P)\n    if P == sorted_arr:\n        return 0\n    index_x = 0\n    index_y = 0\n    for i in range(N):\n        if P[i] == i + 1:\n            index_x += 1\n        else:\n            break\n    for i in reversed(range(N)):\n        if P[i] == i + 1:\n            index_y += 1\n        else:\n            break\n    if N - index_x - index_y <= K:\n        return 1\n    index_y = min(N - index_y - K, N)\n    temp1 = P[-1:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]\n    arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]\n    temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]\n    arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]\n    if arr1 == sorted_arr or arr2 == sorted_arr:\n        return 2\n    else:\n        return 3"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]",
      "mutated_line": "temp1 = P[1:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]",
      "code": "def min_operations_to_sort_permutation(N, K, P):\n    sorted_arr = sorted(P)\n    if P == sorted_arr:\n        return 0\n    index_x = 0\n    index_y = 0\n    for i in range(N):\n        if P[i] == i + 1:\n            index_x += 1\n        else:\n            break\n    for i in reversed(range(N)):\n        if P[i] == i + 1:\n            index_y += 1\n        else:\n            break\n    if N - index_x - index_y <= K:\n        return 1\n    index_y = min(N - index_y - K, N)\n    temp1 = P[1:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]\n    arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]\n    temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]\n    arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]\n    if arr1 == sorted_arr or arr2 == sorted_arr:\n        return 2\n    else:\n        return 3"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]",
      "mutated_line": "arr1 = temp1[1:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]",
      "code": "def min_operations_to_sort_permutation(N, K, P):\n    sorted_arr = sorted(P)\n    if P == sorted_arr:\n        return 0\n    index_x = 0\n    index_y = 0\n    for i in range(N):\n        if P[i] == i + 1:\n            index_x += 1\n        else:\n            break\n    for i in reversed(range(N)):\n        if P[i] == i + 1:\n            index_y += 1\n        else:\n            break\n    if N - index_x - index_y <= K:\n        return 1\n    index_y = min(N - index_y - K, N)\n    temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]\n    arr1 = temp1[1:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]\n    temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]\n    arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]\n    if arr1 == sorted_arr or arr2 == sorted_arr:\n        return 2\n    else:\n        return 3"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]",
      "mutated_line": "arr1 = temp1[-1:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]",
      "code": "def min_operations_to_sort_permutation(N, K, P):\n    sorted_arr = sorted(P)\n    if P == sorted_arr:\n        return 0\n    index_x = 0\n    index_y = 0\n    for i in range(N):\n        if P[i] == i + 1:\n            index_x += 1\n        else:\n            break\n    for i in reversed(range(N)):\n        if P[i] == i + 1:\n            index_y += 1\n        else:\n            break\n    if N - index_x - index_y <= K:\n        return 1\n    index_y = min(N - index_y - K, N)\n    temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]\n    arr1 = temp1[-1:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]\n    temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]\n    arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]\n    if arr1 == sorted_arr or arr2 == sorted_arr:\n        return 2\n    else:\n        return 3"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]",
      "mutated_line": "arr1 = temp1[1:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]",
      "code": "def min_operations_to_sort_permutation(N, K, P):\n    sorted_arr = sorted(P)\n    if P == sorted_arr:\n        return 0\n    index_x = 0\n    index_y = 0\n    for i in range(N):\n        if P[i] == i + 1:\n            index_x += 1\n        else:\n            break\n    for i in reversed(range(N)):\n        if P[i] == i + 1:\n            index_y += 1\n        else:\n            break\n    if N - index_x - index_y <= K:\n        return 1\n    index_y = min(N - index_y - K, N)\n    temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]\n    arr1 = temp1[1:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]\n    temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]\n    arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]\n    if arr1 == sorted_arr or arr2 == sorted_arr:\n        return 2\n    else:\n        return 3"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]",
      "mutated_line": "temp2 = P[1:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]",
      "code": "def min_operations_to_sort_permutation(N, K, P):\n    sorted_arr = sorted(P)\n    if P == sorted_arr:\n        return 0\n    index_x = 0\n    index_y = 0\n    for i in range(N):\n        if P[i] == i + 1:\n            index_x += 1\n        else:\n            break\n    for i in reversed(range(N)):\n        if P[i] == i + 1:\n            index_y += 1\n        else:\n            break\n    if N - index_x - index_y <= K:\n        return 1\n    index_y = min(N - index_y - K, N)\n    temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]\n    arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]\n    temp2 = P[1:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]\n    arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]\n    if arr1 == sorted_arr or arr2 == sorted_arr:\n        return 2\n    else:\n        return 3"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]",
      "mutated_line": "temp2 = P[-1:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]",
      "code": "def min_operations_to_sort_permutation(N, K, P):\n    sorted_arr = sorted(P)\n    if P == sorted_arr:\n        return 0\n    index_x = 0\n    index_y = 0\n    for i in range(N):\n        if P[i] == i + 1:\n            index_x += 1\n        else:\n            break\n    for i in reversed(range(N)):\n        if P[i] == i + 1:\n            index_y += 1\n        else:\n            break\n    if N - index_x - index_y <= K:\n        return 1\n    index_y = min(N - index_y - K, N)\n    temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]\n    arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]\n    temp2 = P[-1:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]\n    arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]\n    if arr1 == sorted_arr or arr2 == sorted_arr:\n        return 2\n    else:\n        return 3"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]",
      "mutated_line": "temp2 = P[1:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]",
      "code": "def min_operations_to_sort_permutation(N, K, P):\n    sorted_arr = sorted(P)\n    if P == sorted_arr:\n        return 0\n    index_x = 0\n    index_y = 0\n    for i in range(N):\n        if P[i] == i + 1:\n            index_x += 1\n        else:\n            break\n    for i in reversed(range(N)):\n        if P[i] == i + 1:\n            index_y += 1\n        else:\n            break\n    if N - index_x - index_y <= K:\n        return 1\n    index_y = min(N - index_y - K, N)\n    temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]\n    arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]\n    temp2 = P[1:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]\n    arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]\n    if arr1 == sorted_arr or arr2 == sorted_arr:\n        return 2\n    else:\n        return 3"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]",
      "mutated_line": "arr2 = temp1[1:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]",
      "code": "def min_operations_to_sort_permutation(N, K, P):\n    sorted_arr = sorted(P)\n    if P == sorted_arr:\n        return 0\n    index_x = 0\n    index_y = 0\n    for i in range(N):\n        if P[i] == i + 1:\n            index_x += 1\n        else:\n            break\n    for i in reversed(range(N)):\n        if P[i] == i + 1:\n            index_y += 1\n        else:\n            break\n    if N - index_x - index_y <= K:\n        return 1\n    index_y = min(N - index_y - K, N)\n    temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]\n    arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]\n    temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]\n    arr2 = temp1[1:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]\n    if arr1 == sorted_arr or arr2 == sorted_arr:\n        return 2\n    else:\n        return 3"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]",
      "mutated_line": "arr2 = temp1[-1:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]",
      "code": "def min_operations_to_sort_permutation(N, K, P):\n    sorted_arr = sorted(P)\n    if P == sorted_arr:\n        return 0\n    index_x = 0\n    index_y = 0\n    for i in range(N):\n        if P[i] == i + 1:\n            index_x += 1\n        else:\n            break\n    for i in reversed(range(N)):\n        if P[i] == i + 1:\n            index_y += 1\n        else:\n            break\n    if N - index_x - index_y <= K:\n        return 1\n    index_y = min(N - index_y - K, N)\n    temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]\n    arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]\n    temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]\n    arr2 = temp1[-1:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]\n    if arr1 == sorted_arr or arr2 == sorted_arr:\n        return 2\n    else:\n        return 3"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]",
      "mutated_line": "arr2 = temp1[1:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]",
      "code": "def min_operations_to_sort_permutation(N, K, P):\n    sorted_arr = sorted(P)\n    if P == sorted_arr:\n        return 0\n    index_x = 0\n    index_y = 0\n    for i in range(N):\n        if P[i] == i + 1:\n            index_x += 1\n        else:\n            break\n    for i in reversed(range(N)):\n        if P[i] == i + 1:\n            index_y += 1\n        else:\n            break\n    if N - index_x - index_y <= K:\n        return 1\n    index_y = min(N - index_y - K, N)\n    temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]\n    arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]\n    temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]\n    arr2 = temp1[1:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]\n    if arr1 == sorted_arr or arr2 == sorted_arr:\n        return 2\n    else:\n        return 3"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]",
      "mutated_line": "temp1 = P[0:index_x] + sorted(P[index_x:index_x - K]) + P[index_x + K:N]",
      "code": "def min_operations_to_sort_permutation(N, K, P):\n    sorted_arr = sorted(P)\n    if P == sorted_arr:\n        return 0\n    index_x = 0\n    index_y = 0\n    for i in range(N):\n        if P[i] == i + 1:\n            index_x += 1\n        else:\n            break\n    for i in reversed(range(N)):\n        if P[i] == i + 1:\n            index_y += 1\n        else:\n            break\n    if N - index_x - index_y <= K:\n        return 1\n    index_y = min(N - index_y - K, N)\n    temp1 = P[0:index_x] + sorted(P[index_x:index_x - K]) + P[index_x + K:N]\n    arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]\n    temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]\n    arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]\n    if arr1 == sorted_arr or arr2 == sorted_arr:\n        return 2\n    else:\n        return 3"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]",
      "mutated_line": "temp1 = P[0:index_x] + sorted(P[index_x:index_x * K]) + P[index_x + K:N]",
      "code": "def min_operations_to_sort_permutation(N, K, P):\n    sorted_arr = sorted(P)\n    if P == sorted_arr:\n        return 0\n    index_x = 0\n    index_y = 0\n    for i in range(N):\n        if P[i] == i + 1:\n            index_x += 1\n        else:\n            break\n    for i in reversed(range(N)):\n        if P[i] == i + 1:\n            index_y += 1\n        else:\n            break\n    if N - index_x - index_y <= K:\n        return 1\n    index_y = min(N - index_y - K, N)\n    temp1 = P[0:index_x] + sorted(P[index_x:index_x * K]) + P[index_x + K:N]\n    arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]\n    temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]\n    arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]\n    if arr1 == sorted_arr or arr2 == sorted_arr:\n        return 2\n    else:\n        return 3"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]",
      "mutated_line": "arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y - K]) + temp1[index_y + K:N]",
      "code": "def min_operations_to_sort_permutation(N, K, P):\n    sorted_arr = sorted(P)\n    if P == sorted_arr:\n        return 0\n    index_x = 0\n    index_y = 0\n    for i in range(N):\n        if P[i] == i + 1:\n            index_x += 1\n        else:\n            break\n    for i in reversed(range(N)):\n        if P[i] == i + 1:\n            index_y += 1\n        else:\n            break\n    if N - index_x - index_y <= K:\n        return 1\n    index_y = min(N - index_y - K, N)\n    temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]\n    arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y - K]) + temp1[index_y + K:N]\n    temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]\n    arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]\n    if arr1 == sorted_arr or arr2 == sorted_arr:\n        return 2\n    else:\n        return 3"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]",
      "mutated_line": "arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y * K]) + temp1[index_y + K:N]",
      "code": "def min_operations_to_sort_permutation(N, K, P):\n    sorted_arr = sorted(P)\n    if P == sorted_arr:\n        return 0\n    index_x = 0\n    index_y = 0\n    for i in range(N):\n        if P[i] == i + 1:\n            index_x += 1\n        else:\n            break\n    for i in reversed(range(N)):\n        if P[i] == i + 1:\n            index_y += 1\n        else:\n            break\n    if N - index_x - index_y <= K:\n        return 1\n    index_y = min(N - index_y - K, N)\n    temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]\n    arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y * K]) + temp1[index_y + K:N]\n    temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]\n    arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]\n    if arr1 == sorted_arr or arr2 == sorted_arr:\n        return 2\n    else:\n        return 3"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]",
      "mutated_line": "temp2 = P[0:index_y] + sorted(P[index_y:index_y - K]) + P[index_y + K:N]",
      "code": "def min_operations_to_sort_permutation(N, K, P):\n    sorted_arr = sorted(P)\n    if P == sorted_arr:\n        return 0\n    index_x = 0\n    index_y = 0\n    for i in range(N):\n        if P[i] == i + 1:\n            index_x += 1\n        else:\n            break\n    for i in reversed(range(N)):\n        if P[i] == i + 1:\n            index_y += 1\n        else:\n            break\n    if N - index_x - index_y <= K:\n        return 1\n    index_y = min(N - index_y - K, N)\n    temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]\n    arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]\n    temp2 = P[0:index_y] + sorted(P[index_y:index_y - K]) + P[index_y + K:N]\n    arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]\n    if arr1 == sorted_arr or arr2 == sorted_arr:\n        return 2\n    else:\n        return 3"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]",
      "mutated_line": "temp2 = P[0:index_y] + sorted(P[index_y:index_y * K]) + P[index_y + K:N]",
      "code": "def min_operations_to_sort_permutation(N, K, P):\n    sorted_arr = sorted(P)\n    if P == sorted_arr:\n        return 0\n    index_x = 0\n    index_y = 0\n    for i in range(N):\n        if P[i] == i + 1:\n            index_x += 1\n        else:\n            break\n    for i in reversed(range(N)):\n        if P[i] == i + 1:\n            index_y += 1\n        else:\n            break\n    if N - index_x - index_y <= K:\n        return 1\n    index_y = min(N - index_y - K, N)\n    temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]\n    arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]\n    temp2 = P[0:index_y] + sorted(P[index_y:index_y * K]) + P[index_y + K:N]\n    arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]\n    if arr1 == sorted_arr or arr2 == sorted_arr:\n        return 2\n    else:\n        return 3"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]",
      "mutated_line": "arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x - K]) + temp2[index_x + K:N]",
      "code": "def min_operations_to_sort_permutation(N, K, P):\n    sorted_arr = sorted(P)\n    if P == sorted_arr:\n        return 0\n    index_x = 0\n    index_y = 0\n    for i in range(N):\n        if P[i] == i + 1:\n            index_x += 1\n        else:\n            break\n    for i in reversed(range(N)):\n        if P[i] == i + 1:\n            index_y += 1\n        else:\n            break\n    if N - index_x - index_y <= K:\n        return 1\n    index_y = min(N - index_y - K, N)\n    temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]\n    arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]\n    temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]\n    arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x - K]) + temp2[index_x + K:N]\n    if arr1 == sorted_arr or arr2 == sorted_arr:\n        return 2\n    else:\n        return 3"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x + K]) + temp2[index_x + K:N]",
      "mutated_line": "arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x * K]) + temp2[index_x + K:N]",
      "code": "def min_operations_to_sort_permutation(N, K, P):\n    sorted_arr = sorted(P)\n    if P == sorted_arr:\n        return 0\n    index_x = 0\n    index_y = 0\n    for i in range(N):\n        if P[i] == i + 1:\n            index_x += 1\n        else:\n            break\n    for i in reversed(range(N)):\n        if P[i] == i + 1:\n            index_y += 1\n        else:\n            break\n    if N - index_x - index_y <= K:\n        return 1\n    index_y = min(N - index_y - K, N)\n    temp1 = P[0:index_x] + sorted(P[index_x:index_x + K]) + P[index_x + K:N]\n    arr1 = temp1[0:index_y] + sorted(temp1[index_y:index_y + K]) + temp1[index_y + K:N]\n    temp2 = P[0:index_y] + sorted(P[index_y:index_y + K]) + P[index_y + K:N]\n    arr2 = temp1[0:index_x] + sorted(temp2[index_x:index_x * K]) + temp2[index_x + K:N]\n    if arr1 == sorted_arr or arr2 == sorted_arr:\n        return 2\n    else:\n        return 3"
    }
  ]
}