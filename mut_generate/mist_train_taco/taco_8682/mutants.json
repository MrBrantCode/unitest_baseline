{
  "task_id": "taco_8682",
  "entry_point": "calculate_multisets",
  "mutant_count": 195,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod_val = 1000000007",
      "mutated_line": "mod_val = 1000000008",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000008\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod_val = 1000000007",
      "mutated_line": "mod_val = 1000000006",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000006\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod_val = 1000000007",
      "mutated_line": "mod_val = 0",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 0\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod_val = 1000000007",
      "mutated_line": "mod_val = 1",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod_val = 1000000007",
      "mutated_line": "mod_val = -1000000007",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = -1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "rang = [0] * 101",
      "mutated_line": "rang = [0] / 101",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] / 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "rang = [0] * 101",
      "mutated_line": "rang = [0] + 101",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] + 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "rang = [0] * 101",
      "mutated_line": "rang = [0] ** 101",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] ** 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "pow_cache = [0] * 102",
      "mutated_line": "pow_cache = [0] / 102",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] / 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "pow_cache = [0] * 102",
      "mutated_line": "pow_cache = [0] + 102",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] + 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "pow_cache = [0] * 102",
      "mutated_line": "pow_cache = [0] ** 102",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] ** 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "rang = [0] * 101",
      "mutated_line": "rang = [0] * 102",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 102\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "rang = [0] * 101",
      "mutated_line": "rang = [0] * 100",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 100\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "rang = [0] * 101",
      "mutated_line": "rang = [0] * 0",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 0\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "rang = [0] * 101",
      "mutated_line": "rang = [0] * 1",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 1\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "rang = [0] * 101",
      "mutated_line": "rang = [0] * -101",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * -101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "pow_cache = [0] * 102",
      "mutated_line": "pow_cache = [0] * 103",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 103\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "pow_cache = [0] * 102",
      "mutated_line": "pow_cache = [0] * 101",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 101\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "pow_cache = [0] * 102",
      "mutated_line": "pow_cache = [0] * 0",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 0\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "pow_cache = [0] * 102",
      "mutated_line": "pow_cache = [0] * 1",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 1\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "pow_cache = [0] * 102",
      "mutated_line": "pow_cache = [0] * -102",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * -102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "result = 1",
      "mutated_line": "result = 2",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 2\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "result = 1",
      "mutated_line": "result = 0",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 0\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "result = 1",
      "mutated_line": "result = 0",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 0\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "result = 1",
      "mutated_line": "result = -1",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = -1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if target_sum == 0:",
      "mutated_line": "if target_sum != 0:",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum != 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if i >= target_sum:",
      "mutated_line": "if i > target_sum:",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i > target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if i >= target_sum:",
      "mutated_line": "if i < target_sum:",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i < target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if i >= target_sum:",
      "mutated_line": "if i == target_sum:",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i == target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if (i, target_sum) in multisets:",
      "mutated_line": "if (i, target_sum) not in multisets:",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) not in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "max_pos = target_sum // (i + 1)",
      "mutated_line": "max_pos = target_sum / (i + 1)",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum / (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "max_pos = target_sum // (i + 1)",
      "mutated_line": "max_pos = target_sum * (i + 1)",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum * (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "choose = rang[i + 1] % mod_val",
      "mutated_line": "choose = rang[i + 1] * mod_val",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] * mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "choose = rang[i + 1] % mod_val",
      "mutated_line": "choose = rang[i + 1] + mod_val",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] + mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "ASR",
      "lineno": 32,
      "original_line": "ans += temp",
      "mutated_line": "ans -= temp",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans -= temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "ASR",
      "lineno": 34,
      "original_line": "choose *= rang[i + 1] + j",
      "mutated_line": "choose /= rang[i + 1] + j",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose /= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "ASR",
      "lineno": 35,
      "original_line": "choose *= pow_cache[j + 1]",
      "mutated_line": "choose /= pow_cache[j + 1]",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose /= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "return cal_recurse(0, S)",
      "mutated_line": "return cal_recurse(1, S)",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(1, S)"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "return cal_recurse(0, S)",
      "mutated_line": "return cal_recurse(-1, S)",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(-1, S)"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "return cal_recurse(0, S)",
      "mutated_line": "return cal_recurse(1, S)",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(1, S)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "rang = [0] * 101",
      "mutated_line": "rang = [1] * 101",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [1] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "rang = [0] * 101",
      "mutated_line": "rang = [-1] * 101",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [-1] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "rang = [0] * 101",
      "mutated_line": "rang = [1] * 101",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [1] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "pow_cache = [0] * 102",
      "mutated_line": "pow_cache = [1] * 102",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [1] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "pow_cache = [0] * 102",
      "mutated_line": "pow_cache = [-1] * 102",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [-1] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "pow_cache = [0] * 102",
      "mutated_line": "pow_cache = [1] * 102",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [1] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "if pow & 1:",
      "mutated_line": "if pow | 1:",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow | 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "base = base * base % mod_val",
      "mutated_line": "base = base * base * mod_val",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base * mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "base = base * base % mod_val",
      "mutated_line": "base = base * base + mod_val",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base + mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(1, 102):",
      "mutated_line": "for i in range(2, 102):",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(2, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(1, 102):",
      "mutated_line": "for i in range(0, 102):",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(0, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(1, 102):",
      "mutated_line": "for i in range(0, 102):",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(0, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(1, 102):",
      "mutated_line": "for i in range(-1, 102):",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(-1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(1, 102):",
      "mutated_line": "for i in range(1, 103):",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 103):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(1, 102):",
      "mutated_line": "for i in range(1, 101):",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 101):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(1, 102):",
      "mutated_line": "for i in range(1, 0):",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 0):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(1, 102):",
      "mutated_line": "for i in range(1, 1):",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 1):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(1, 102):",
      "mutated_line": "for i in range(1, -102):",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, -102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if target_sum == 0:",
      "mutated_line": "if target_sum == 1:",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 1:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if target_sum == 0:",
      "mutated_line": "if target_sum == -1:",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == -1:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if target_sum == 0:",
      "mutated_line": "if target_sum == 1:",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 1:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return 1",
      "mutated_line": "return 2",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 2\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return 1",
      "mutated_line": "return 0",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 0\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return 1",
      "mutated_line": "return 0",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 0\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return 1",
      "mutated_line": "return -1",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return -1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 1\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return -1\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 1\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "ans = cal_recurse(i + 1, target_sum)",
      "mutated_line": "ans = cal_recurse(i - 1, target_sum)",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i - 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "ans = cal_recurse(i + 1, target_sum)",
      "mutated_line": "ans = cal_recurse(i * 1, target_sum)",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i * 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "max_pos = target_sum // (i + 1)",
      "mutated_line": "max_pos = target_sum // (i - 1)",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i - 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "max_pos = target_sum // (i + 1)",
      "mutated_line": "max_pos = target_sum // (i * 1)",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i * 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for j in range(1, max_pos + 1):",
      "mutated_line": "for j in range(2, max_pos + 1):",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(2, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for j in range(1, max_pos + 1):",
      "mutated_line": "for j in range(0, max_pos + 1):",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(0, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for j in range(1, max_pos + 1):",
      "mutated_line": "for j in range(0, max_pos + 1):",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(0, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for j in range(1, max_pos + 1):",
      "mutated_line": "for j in range(-1, max_pos + 1):",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(-1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "for j in range(1, max_pos + 1):",
      "mutated_line": "for j in range(1, max_pos - 1):",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos - 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "for j in range(1, max_pos + 1):",
      "mutated_line": "for j in range(1, max_pos * 1):",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos * 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))",
      "mutated_line": "temp = choose / cal_recurse(i + 1, target_sum - j * (i + 1))",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose / cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))",
      "mutated_line": "temp = choose + cal_recurse(i + 1, target_sum - j * (i + 1))",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose + cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))",
      "mutated_line": "temp = choose ** cal_recurse(i + 1, target_sum - j * (i + 1))",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose ** cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "choose *= rang[i + 1] + j",
      "mutated_line": "choose *= rang[i + 1] - j",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] - j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "choose *= rang[i + 1] + j",
      "mutated_line": "choose *= rang[i + 1] * j",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] * j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for i in range(1, target_sum + 1):",
      "mutated_line": "for i in range(2, target_sum + 1):",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(2, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for i in range(1, target_sum + 1):",
      "mutated_line": "for i in range(0, target_sum + 1):",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(0, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for i in range(1, target_sum + 1):",
      "mutated_line": "for i in range(0, target_sum + 1):",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(0, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for i in range(1, target_sum + 1):",
      "mutated_line": "for i in range(-1, target_sum + 1):",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(-1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "for i in range(1, target_sum + 1):",
      "mutated_line": "for i in range(1, target_sum - 1):",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum - 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "for i in range(1, target_sum + 1):",
      "mutated_line": "for i in range(1, target_sum * 1):",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum * 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i",
      "mutated_line": "rang[i] = rang_i[0] - (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] - (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i",
      "mutated_line": "rang[i] = rang_i[0] * ((rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i)",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] * ((rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i)\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if pow & 1:",
      "mutated_line": "if pow & 2:",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 2:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if pow & 1:",
      "mutated_line": "if pow & 0:",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 0:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if pow & 1:",
      "mutated_line": "if pow & 0:",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 0:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if pow & 1:",
      "mutated_line": "if pow & -1:",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & -1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "result = result * base % mod_val",
      "mutated_line": "result = result * base * mod_val",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base * mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "result = result * base % mod_val",
      "mutated_line": "result = result * base + mod_val",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base + mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "base = base * base % mod_val",
      "mutated_line": "base = base / base % mod_val",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base / base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "base = base * base % mod_val",
      "mutated_line": "base = (base + base) % mod_val",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = (base + base) % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "base = base * base % mod_val",
      "mutated_line": "base = base ** base % mod_val",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base ** base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "pow = pow >> 1",
      "mutated_line": "pow = pow >> 2",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 2\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "pow = pow >> 1",
      "mutated_line": "pow = pow >> 0",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 0\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "pow = pow >> 1",
      "mutated_line": "pow = pow >> 0",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 0\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "pow = pow >> 1",
      "mutated_line": "pow = pow >> -1",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> -1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "pow_cache[i] = mod_pow(i, mod_val - 2)",
      "mutated_line": "pow_cache[i] = mod_pow(i, mod_val + 2)",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val + 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "pow_cache[i] = mod_pow(i, mod_val - 2)",
      "mutated_line": "pow_cache[i] = mod_pow(i, mod_val * 2)",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val * 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "ans = cal_recurse(i + 1, target_sum)",
      "mutated_line": "ans = cal_recurse(i + 2, target_sum)",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 2, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "ans = cal_recurse(i + 1, target_sum)",
      "mutated_line": "ans = cal_recurse(i + 0, target_sum)",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 0, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "ans = cal_recurse(i + 1, target_sum)",
      "mutated_line": "ans = cal_recurse(i + 0, target_sum)",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 0, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "ans = cal_recurse(i + 1, target_sum)",
      "mutated_line": "ans = cal_recurse(i + -1, target_sum)",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + -1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "max_pos = target_sum // (i + 1)",
      "mutated_line": "max_pos = target_sum // (i + 2)",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 2)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "max_pos = target_sum // (i + 1)",
      "mutated_line": "max_pos = target_sum // (i + 0)",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 0)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "max_pos = target_sum // (i + 1)",
      "mutated_line": "max_pos = target_sum // (i + 0)",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 0)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "max_pos = target_sum // (i + 1)",
      "mutated_line": "max_pos = target_sum // (i + -1)",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + -1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "choose = rang[i + 1] % mod_val",
      "mutated_line": "choose = rang[i - 1] % mod_val",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i - 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "choose = rang[i + 1] % mod_val",
      "mutated_line": "choose = rang[i * 1] % mod_val",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i * 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for j in range(1, max_pos + 1):",
      "mutated_line": "for j in range(1, max_pos + 2):",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 2):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for j in range(1, max_pos + 1):",
      "mutated_line": "for j in range(1, max_pos + 0):",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 0):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for j in range(1, max_pos + 1):",
      "mutated_line": "for j in range(1, max_pos + 0):",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 0):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for j in range(1, max_pos + 1):",
      "mutated_line": "for j in range(1, max_pos + -1):",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + -1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "choose *= pow_cache[j + 1]",
      "mutated_line": "choose *= pow_cache[j - 1]",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j - 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "choose *= pow_cache[j + 1]",
      "mutated_line": "choose *= pow_cache[j * 1]",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j * 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for i in range(1, target_sum + 1):",
      "mutated_line": "for i in range(1, target_sum + 2):",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 2):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for i in range(1, target_sum + 1):",
      "mutated_line": "for i in range(1, target_sum + 0):",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 0):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for i in range(1, target_sum + 1):",
      "mutated_line": "for i in range(1, target_sum + 0):",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 0):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for i in range(1, target_sum + 1):",
      "mutated_line": "for i in range(1, target_sum + -1):",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + -1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i",
      "mutated_line": "rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) / i",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) / i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i",
      "mutated_line": "rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i + i)",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i + i)\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i",
      "mutated_line": "rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) ** i",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) ** i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "result = result * base % mod_val",
      "mutated_line": "result = result / base % mod_val",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result / base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "result = result * base % mod_val",
      "mutated_line": "result = (result + base) % mod_val",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = (result + base) % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "result = result * base % mod_val",
      "mutated_line": "result = result ** base % mod_val",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result ** base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "pow_cache[i] = mod_pow(i, mod_val - 2)",
      "mutated_line": "pow_cache[i] = mod_pow(i, mod_val - 3)",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 3)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "pow_cache[i] = mod_pow(i, mod_val - 2)",
      "mutated_line": "pow_cache[i] = mod_pow(i, mod_val - 1)",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 1)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "pow_cache[i] = mod_pow(i, mod_val - 2)",
      "mutated_line": "pow_cache[i] = mod_pow(i, mod_val - 0)",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 0)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "pow_cache[i] = mod_pow(i, mod_val - 2)",
      "mutated_line": "pow_cache[i] = mod_pow(i, mod_val - 1)",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 1)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "pow_cache[i] = mod_pow(i, mod_val - 2)",
      "mutated_line": "pow_cache[i] = mod_pow(i, mod_val - -2)",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - -2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "choose = rang[i + 1] % mod_val",
      "mutated_line": "choose = rang[i + 2] % mod_val",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 2] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "choose = rang[i + 1] % mod_val",
      "mutated_line": "choose = rang[i + 0] % mod_val",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 0] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "choose = rang[i + 1] % mod_val",
      "mutated_line": "choose = rang[i + 0] % mod_val",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 0] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "choose = rang[i + 1] % mod_val",
      "mutated_line": "choose = rang[i + -1] % mod_val",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + -1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))",
      "mutated_line": "temp = choose * cal_recurse(i - 1, target_sum - j * (i + 1))",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i - 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))",
      "mutated_line": "temp = choose * cal_recurse(i * 1, target_sum - j * (i + 1))",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i * 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))",
      "mutated_line": "temp = choose * cal_recurse(i + 1, target_sum + j * (i + 1))",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum + j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))",
      "mutated_line": "temp = choose * cal_recurse(i + 1, target_sum * (j * (i + 1)))",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum * (j * (i + 1)))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "choose *= rang[i + 1] + j",
      "mutated_line": "choose *= rang[i - 1] + j",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i - 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "choose *= rang[i + 1] + j",
      "mutated_line": "choose *= rang[i * 1] + j",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i * 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "choose *= pow_cache[j + 1]",
      "mutated_line": "choose *= pow_cache[j + 2]",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 2]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "choose *= pow_cache[j + 1]",
      "mutated_line": "choose *= pow_cache[j + 0]",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 0]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "choose *= pow_cache[j + 1]",
      "mutated_line": "choose *= pow_cache[j + 0]",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 0]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "choose *= pow_cache[j + 1]",
      "mutated_line": "choose *= pow_cache[j + -1]",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + -1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i",
      "mutated_line": "rang[i] = rang_i[1] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[1] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i",
      "mutated_line": "rang[i] = rang_i[-1] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[-1] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i",
      "mutated_line": "rang[i] = rang_i[1] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[1] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i",
      "mutated_line": "rang[i] = rang_i[0] + (rang_i[1] - (rang_i[2] + rang_i[3] * i) * i) * i",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] - (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i",
      "mutated_line": "rang[i] = rang_i[0] + rang_i[1] * ((rang_i[2] + rang_i[3] * i) * i) * i",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + rang_i[1] * ((rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))",
      "mutated_line": "temp = choose * cal_recurse(i + 2, target_sum - j * (i + 1))",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 2, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))",
      "mutated_line": "temp = choose * cal_recurse(i + 0, target_sum - j * (i + 1))",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 0, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))",
      "mutated_line": "temp = choose * cal_recurse(i + 0, target_sum - j * (i + 1))",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 0, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))",
      "mutated_line": "temp = choose * cal_recurse(i + -1, target_sum - j * (i + 1))",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + -1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))",
      "mutated_line": "temp = choose * cal_recurse(i + 1, target_sum - j / (i + 1))",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j / (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))",
      "mutated_line": "temp = choose * cal_recurse(i + 1, target_sum - (j + (i + 1)))",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - (j + (i + 1)))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))",
      "mutated_line": "temp = choose * cal_recurse(i + 1, target_sum - j ** (i + 1))",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j ** (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "choose *= rang[i + 1] + j",
      "mutated_line": "choose *= rang[i + 2] + j",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 2] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "choose *= rang[i + 1] + j",
      "mutated_line": "choose *= rang[i + 0] + j",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 0] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "choose *= rang[i + 1] + j",
      "mutated_line": "choose *= rang[i + 0] + j",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 0] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "choose *= rang[i + 1] + j",
      "mutated_line": "choose *= rang[i + -1] + j",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + -1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i",
      "mutated_line": "rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) / i) * i",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) / i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i",
      "mutated_line": "rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i + i)) * i",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i + i)) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i",
      "mutated_line": "rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) ** i) * i",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) ** i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))",
      "mutated_line": "temp = choose * cal_recurse(i + 1, target_sum - j * (i - 1))",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i - 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))",
      "mutated_line": "temp = choose * cal_recurse(i + 1, target_sum - j * (i * 1))",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i * 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i",
      "mutated_line": "rang[i] = rang_i[0] + (rang_i[2] + (rang_i[2] + rang_i[3] * i) * i) * i",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[2] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i",
      "mutated_line": "rang[i] = rang_i[0] + (rang_i[0] + (rang_i[2] + rang_i[3] * i) * i) * i",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[0] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i",
      "mutated_line": "rang[i] = rang_i[0] + (rang_i[0] + (rang_i[2] + rang_i[3] * i) * i) * i",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[0] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i",
      "mutated_line": "rang[i] = rang_i[0] + (rang_i[-1] + (rang_i[2] + rang_i[3] * i) * i) * i",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[-1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i",
      "mutated_line": "rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] - rang_i[3] * i) * i) * i",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] - rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i",
      "mutated_line": "rang[i] = rang_i[0] + (rang_i[1] + rang_i[2] * (rang_i[3] * i) * i) * i",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + rang_i[2] * (rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))",
      "mutated_line": "temp = choose * cal_recurse(i + 1, target_sum - j * (i + 2))",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 2))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))",
      "mutated_line": "temp = choose * cal_recurse(i + 1, target_sum - j * (i + 0))",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 0))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))",
      "mutated_line": "temp = choose * cal_recurse(i + 1, target_sum - j * (i + 0))",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 0))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))",
      "mutated_line": "temp = choose * cal_recurse(i + 1, target_sum - j * (i + -1))",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + -1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i",
      "mutated_line": "rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] / i) * i) * i",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] / i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i",
      "mutated_line": "rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + (rang_i[3] + i)) * i) * i",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + (rang_i[3] + i)) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i",
      "mutated_line": "rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] ** i) * i) * i",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] ** i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i",
      "mutated_line": "rang[i] = rang_i[0] + (rang_i[1] + (rang_i[3] + rang_i[3] * i) * i) * i",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[3] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i",
      "mutated_line": "rang[i] = rang_i[0] + (rang_i[1] + (rang_i[1] + rang_i[3] * i) * i) * i",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[1] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i",
      "mutated_line": "rang[i] = rang_i[0] + (rang_i[1] + (rang_i[0] + rang_i[3] * i) * i) * i",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[0] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i",
      "mutated_line": "rang[i] = rang_i[0] + (rang_i[1] + (rang_i[1] + rang_i[3] * i) * i) * i",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[1] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i",
      "mutated_line": "rang[i] = rang_i[0] + (rang_i[1] + (rang_i[-2] + rang_i[3] * i) * i) * i",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[-2] + rang_i[3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i",
      "mutated_line": "rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[4] * i) * i) * i",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[4] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i",
      "mutated_line": "rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[2] * i) * i) * i",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[2] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i",
      "mutated_line": "rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[0] * i) * i) * i",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[0] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i",
      "mutated_line": "rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[1] * i) * i) * i",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[1] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[3] * i) * i) * i",
      "mutated_line": "rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[-3] * i) * i) * i",
      "code": "def calculate_multisets(A0, A1, A2, A3, S):\n    mod_val = 1000000007\n    rang = [0] * 101\n    pow_cache = [0] * 102\n    multisets = {}\n\n    def mod_pow(base, pow):\n        result = 1\n        while pow:\n            if pow & 1:\n                result = result * base % mod_val\n            base = base * base % mod_val\n            pow = pow >> 1\n        return result\n\n    def precalculate():\n        for i in range(1, 102):\n            pow_cache[i] = mod_pow(i, mod_val - 2)\n\n    def cal_recurse(i, target_sum):\n        if target_sum == 0:\n            return 1\n        if i >= target_sum:\n            return 0\n        if (i, target_sum) in multisets:\n            return multisets[i, target_sum]\n        ans = cal_recurse(i + 1, target_sum)\n        max_pos = target_sum // (i + 1)\n        choose = rang[i + 1] % mod_val\n        for j in range(1, max_pos + 1):\n            temp = choose * cal_recurse(i + 1, target_sum - j * (i + 1))\n            ans += temp\n            ans %= mod_val\n            choose *= rang[i + 1] + j\n            choose *= pow_cache[j + 1]\n            choose %= mod_val\n        multisets[i, target_sum] = ans\n        return ans\n\n    def populate(target_sum, rang_i):\n        for i in range(1, target_sum + 1):\n            rang[i] = rang_i[0] + (rang_i[1] + (rang_i[2] + rang_i[-3] * i) * i) * i\n    precalculate()\n    populate(S, [A0, A1, A2, A3])\n    return cal_recurse(0, S)"
    }
  ]
}