{
  "task_id": "taco_17548",
  "entry_point": "count_set_bits",
  "mutant_count": 78,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "count = 0",
      "mutated_line": "count = 1",
      "code": "import math\n\ndef count_set_bits(n: int) -> int:\n    digits = math.ceil(math.log(n + 1, 2))\n    count = 1\n    for i in range(digits):\n        div = 2 ** (i + 1)\n        divi = (n + 1) // div\n        rem = (n + 1) % div\n        mul = 2 ** i\n        if rem <= div // 2:\n            rem = 0\n        else:\n            rem = rem - div // 2\n        count += mul * divi + rem\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "count = 0",
      "mutated_line": "count = -1",
      "code": "import math\n\ndef count_set_bits(n: int) -> int:\n    digits = math.ceil(math.log(n + 1, 2))\n    count = -1\n    for i in range(digits):\n        div = 2 ** (i + 1)\n        divi = (n + 1) // div\n        rem = (n + 1) % div\n        mul = 2 ** i\n        if rem <= div // 2:\n            rem = 0\n        else:\n            rem = rem - div // 2\n        count += mul * divi + rem\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "count = 0",
      "mutated_line": "count = 1",
      "code": "import math\n\ndef count_set_bits(n: int) -> int:\n    digits = math.ceil(math.log(n + 1, 2))\n    count = 1\n    for i in range(digits):\n        div = 2 ** (i + 1)\n        divi = (n + 1) // div\n        rem = (n + 1) % div\n        mul = 2 ** i\n        if rem <= div // 2:\n            rem = 0\n        else:\n            rem = rem - div // 2\n        count += mul * divi + rem\n    return count"
    },
    {
      "operator": "ASR",
      "lineno": 15,
      "original_line": "count += mul * divi + rem",
      "mutated_line": "count -= mul * divi + rem",
      "code": "import math\n\ndef count_set_bits(n: int) -> int:\n    digits = math.ceil(math.log(n + 1, 2))\n    count = 0\n    for i in range(digits):\n        div = 2 ** (i + 1)\n        divi = (n + 1) // div\n        rem = (n + 1) % div\n        mul = 2 ** i\n        if rem <= div // 2:\n            rem = 0\n        else:\n            rem = rem - div // 2\n        count -= mul * divi + rem\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "div = 2 ** (i + 1)",
      "mutated_line": "div = 2 * (i + 1)",
      "code": "import math\n\ndef count_set_bits(n: int) -> int:\n    digits = math.ceil(math.log(n + 1, 2))\n    count = 0\n    for i in range(digits):\n        div = 2 * (i + 1)\n        divi = (n + 1) // div\n        rem = (n + 1) % div\n        mul = 2 ** i\n        if rem <= div // 2:\n            rem = 0\n        else:\n            rem = rem - div // 2\n        count += mul * divi + rem\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "div = 2 ** (i + 1)",
      "mutated_line": "div = 2 + (i + 1)",
      "code": "import math\n\ndef count_set_bits(n: int) -> int:\n    digits = math.ceil(math.log(n + 1, 2))\n    count = 0\n    for i in range(digits):\n        div = 2 + (i + 1)\n        divi = (n + 1) // div\n        rem = (n + 1) % div\n        mul = 2 ** i\n        if rem <= div // 2:\n            rem = 0\n        else:\n            rem = rem - div // 2\n        count += mul * divi + rem\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "divi = (n + 1) // div",
      "mutated_line": "divi = (n + 1) / div",
      "code": "import math\n\ndef count_set_bits(n: int) -> int:\n    digits = math.ceil(math.log(n + 1, 2))\n    count = 0\n    for i in range(digits):\n        div = 2 ** (i + 1)\n        divi = (n + 1) / div\n        rem = (n + 1) % div\n        mul = 2 ** i\n        if rem <= div // 2:\n            rem = 0\n        else:\n            rem = rem - div // 2\n        count += mul * divi + rem\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "divi = (n + 1) // div",
      "mutated_line": "divi = (n + 1) * div",
      "code": "import math\n\ndef count_set_bits(n: int) -> int:\n    digits = math.ceil(math.log(n + 1, 2))\n    count = 0\n    for i in range(digits):\n        div = 2 ** (i + 1)\n        divi = (n + 1) * div\n        rem = (n + 1) % div\n        mul = 2 ** i\n        if rem <= div // 2:\n            rem = 0\n        else:\n            rem = rem - div // 2\n        count += mul * divi + rem\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "rem = (n + 1) % div",
      "mutated_line": "rem = (n + 1) * div",
      "code": "import math\n\ndef count_set_bits(n: int) -> int:\n    digits = math.ceil(math.log(n + 1, 2))\n    count = 0\n    for i in range(digits):\n        div = 2 ** (i + 1)\n        divi = (n + 1) // div\n        rem = (n + 1) * div\n        mul = 2 ** i\n        if rem <= div // 2:\n            rem = 0\n        else:\n            rem = rem - div // 2\n        count += mul * divi + rem\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "rem = (n + 1) % div",
      "mutated_line": "rem = n + 1 + div",
      "code": "import math\n\ndef count_set_bits(n: int) -> int:\n    digits = math.ceil(math.log(n + 1, 2))\n    count = 0\n    for i in range(digits):\n        div = 2 ** (i + 1)\n        divi = (n + 1) // div\n        rem = n + 1 + div\n        mul = 2 ** i\n        if rem <= div // 2:\n            rem = 0\n        else:\n            rem = rem - div // 2\n        count += mul * divi + rem\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "mul = 2 ** i",
      "mutated_line": "mul = 2 * i",
      "code": "import math\n\ndef count_set_bits(n: int) -> int:\n    digits = math.ceil(math.log(n + 1, 2))\n    count = 0\n    for i in range(digits):\n        div = 2 ** (i + 1)\n        divi = (n + 1) // div\n        rem = (n + 1) % div\n        mul = 2 * i\n        if rem <= div // 2:\n            rem = 0\n        else:\n            rem = rem - div // 2\n        count += mul * divi + rem\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "mul = 2 ** i",
      "mutated_line": "mul = 2 + i",
      "code": "import math\n\ndef count_set_bits(n: int) -> int:\n    digits = math.ceil(math.log(n + 1, 2))\n    count = 0\n    for i in range(digits):\n        div = 2 ** (i + 1)\n        divi = (n + 1) // div\n        rem = (n + 1) % div\n        mul = 2 + i\n        if rem <= div // 2:\n            rem = 0\n        else:\n            rem = rem - div // 2\n        count += mul * divi + rem\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if rem <= div // 2:",
      "mutated_line": "if rem < div // 2:",
      "code": "import math\n\ndef count_set_bits(n: int) -> int:\n    digits = math.ceil(math.log(n + 1, 2))\n    count = 0\n    for i in range(digits):\n        div = 2 ** (i + 1)\n        divi = (n + 1) // div\n        rem = (n + 1) % div\n        mul = 2 ** i\n        if rem < div // 2:\n            rem = 0\n        else:\n            rem = rem - div // 2\n        count += mul * divi + rem\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if rem <= div // 2:",
      "mutated_line": "if rem > div // 2:",
      "code": "import math\n\ndef count_set_bits(n: int) -> int:\n    digits = math.ceil(math.log(n + 1, 2))\n    count = 0\n    for i in range(digits):\n        div = 2 ** (i + 1)\n        divi = (n + 1) // div\n        rem = (n + 1) % div\n        mul = 2 ** i\n        if rem > div // 2:\n            rem = 0\n        else:\n            rem = rem - div // 2\n        count += mul * divi + rem\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if rem <= div // 2:",
      "mutated_line": "if rem == div // 2:",
      "code": "import math\n\ndef count_set_bits(n: int) -> int:\n    digits = math.ceil(math.log(n + 1, 2))\n    count = 0\n    for i in range(digits):\n        div = 2 ** (i + 1)\n        divi = (n + 1) // div\n        rem = (n + 1) % div\n        mul = 2 ** i\n        if rem == div // 2:\n            rem = 0\n        else:\n            rem = rem - div // 2\n        count += mul * divi + rem\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "count += mul * divi + rem",
      "mutated_line": "count += mul * divi - rem",
      "code": "import math\n\ndef count_set_bits(n: int) -> int:\n    digits = math.ceil(math.log(n + 1, 2))\n    count = 0\n    for i in range(digits):\n        div = 2 ** (i + 1)\n        divi = (n + 1) // div\n        rem = (n + 1) % div\n        mul = 2 ** i\n        if rem <= div // 2:\n            rem = 0\n        else:\n            rem = rem - div // 2\n        count += mul * divi - rem\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "count += mul * divi + rem",
      "mutated_line": "count += mul * divi * rem",
      "code": "import math\n\ndef count_set_bits(n: int) -> int:\n    digits = math.ceil(math.log(n + 1, 2))\n    count = 0\n    for i in range(digits):\n        div = 2 ** (i + 1)\n        divi = (n + 1) // div\n        rem = (n + 1) % div\n        mul = 2 ** i\n        if rem <= div // 2:\n            rem = 0\n        else:\n            rem = rem - div // 2\n        count += mul * divi * rem\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "digits = math.ceil(math.log(n + 1, 2))",
      "mutated_line": "digits = math.ceil(math.log(n - 1, 2))",
      "code": "import math\n\ndef count_set_bits(n: int) -> int:\n    digits = math.ceil(math.log(n - 1, 2))\n    count = 0\n    for i in range(digits):\n        div = 2 ** (i + 1)\n        divi = (n + 1) // div\n        rem = (n + 1) % div\n        mul = 2 ** i\n        if rem <= div // 2:\n            rem = 0\n        else:\n            rem = rem - div // 2\n        count += mul * divi + rem\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "digits = math.ceil(math.log(n + 1, 2))",
      "mutated_line": "digits = math.ceil(math.log(n * 1, 2))",
      "code": "import math\n\ndef count_set_bits(n: int) -> int:\n    digits = math.ceil(math.log(n * 1, 2))\n    count = 0\n    for i in range(digits):\n        div = 2 ** (i + 1)\n        divi = (n + 1) // div\n        rem = (n + 1) % div\n        mul = 2 ** i\n        if rem <= div // 2:\n            rem = 0\n        else:\n            rem = rem - div // 2\n        count += mul * divi + rem\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "digits = math.ceil(math.log(n + 1, 2))",
      "mutated_line": "digits = math.ceil(math.log(n + 1, 3))",
      "code": "import math\n\ndef count_set_bits(n: int) -> int:\n    digits = math.ceil(math.log(n + 1, 3))\n    count = 0\n    for i in range(digits):\n        div = 2 ** (i + 1)\n        divi = (n + 1) // div\n        rem = (n + 1) % div\n        mul = 2 ** i\n        if rem <= div // 2:\n            rem = 0\n        else:\n            rem = rem - div // 2\n        count += mul * divi + rem\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "digits = math.ceil(math.log(n + 1, 2))",
      "mutated_line": "digits = math.ceil(math.log(n + 1, 1))",
      "code": "import math\n\ndef count_set_bits(n: int) -> int:\n    digits = math.ceil(math.log(n + 1, 1))\n    count = 0\n    for i in range(digits):\n        div = 2 ** (i + 1)\n        divi = (n + 1) // div\n        rem = (n + 1) % div\n        mul = 2 ** i\n        if rem <= div // 2:\n            rem = 0\n        else:\n            rem = rem - div // 2\n        count += mul * divi + rem\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "digits = math.ceil(math.log(n + 1, 2))",
      "mutated_line": "digits = math.ceil(math.log(n + 1, 0))",
      "code": "import math\n\ndef count_set_bits(n: int) -> int:\n    digits = math.ceil(math.log(n + 1, 0))\n    count = 0\n    for i in range(digits):\n        div = 2 ** (i + 1)\n        divi = (n + 1) // div\n        rem = (n + 1) % div\n        mul = 2 ** i\n        if rem <= div // 2:\n            rem = 0\n        else:\n            rem = rem - div // 2\n        count += mul * divi + rem\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "digits = math.ceil(math.log(n + 1, 2))",
      "mutated_line": "digits = math.ceil(math.log(n + 1, 1))",
      "code": "import math\n\ndef count_set_bits(n: int) -> int:\n    digits = math.ceil(math.log(n + 1, 1))\n    count = 0\n    for i in range(digits):\n        div = 2 ** (i + 1)\n        divi = (n + 1) // div\n        rem = (n + 1) % div\n        mul = 2 ** i\n        if rem <= div // 2:\n            rem = 0\n        else:\n            rem = rem - div // 2\n        count += mul * divi + rem\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "digits = math.ceil(math.log(n + 1, 2))",
      "mutated_line": "digits = math.ceil(math.log(n + 1, -2))",
      "code": "import math\n\ndef count_set_bits(n: int) -> int:\n    digits = math.ceil(math.log(n + 1, -2))\n    count = 0\n    for i in range(digits):\n        div = 2 ** (i + 1)\n        divi = (n + 1) // div\n        rem = (n + 1) % div\n        mul = 2 ** i\n        if rem <= div // 2:\n            rem = 0\n        else:\n            rem = rem - div // 2\n        count += mul * divi + rem\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "div = 2 ** (i + 1)",
      "mutated_line": "div = 3 ** (i + 1)",
      "code": "import math\n\ndef count_set_bits(n: int) -> int:\n    digits = math.ceil(math.log(n + 1, 2))\n    count = 0\n    for i in range(digits):\n        div = 3 ** (i + 1)\n        divi = (n + 1) // div\n        rem = (n + 1) % div\n        mul = 2 ** i\n        if rem <= div // 2:\n            rem = 0\n        else:\n            rem = rem - div // 2\n        count += mul * divi + rem\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "div = 2 ** (i + 1)",
      "mutated_line": "div = 1 ** (i + 1)",
      "code": "import math\n\ndef count_set_bits(n: int) -> int:\n    digits = math.ceil(math.log(n + 1, 2))\n    count = 0\n    for i in range(digits):\n        div = 1 ** (i + 1)\n        divi = (n + 1) // div\n        rem = (n + 1) % div\n        mul = 2 ** i\n        if rem <= div // 2:\n            rem = 0\n        else:\n            rem = rem - div // 2\n        count += mul * divi + rem\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "div = 2 ** (i + 1)",
      "mutated_line": "div = 0 ** (i + 1)",
      "code": "import math\n\ndef count_set_bits(n: int) -> int:\n    digits = math.ceil(math.log(n + 1, 2))\n    count = 0\n    for i in range(digits):\n        div = 0 ** (i + 1)\n        divi = (n + 1) // div\n        rem = (n + 1) % div\n        mul = 2 ** i\n        if rem <= div // 2:\n            rem = 0\n        else:\n            rem = rem - div // 2\n        count += mul * divi + rem\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "div = 2 ** (i + 1)",
      "mutated_line": "div = 1 ** (i + 1)",
      "code": "import math\n\ndef count_set_bits(n: int) -> int:\n    digits = math.ceil(math.log(n + 1, 2))\n    count = 0\n    for i in range(digits):\n        div = 1 ** (i + 1)\n        divi = (n + 1) // div\n        rem = (n + 1) % div\n        mul = 2 ** i\n        if rem <= div // 2:\n            rem = 0\n        else:\n            rem = rem - div // 2\n        count += mul * divi + rem\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "div = 2 ** (i + 1)",
      "mutated_line": "div = -2 ** (i + 1)",
      "code": "import math\n\ndef count_set_bits(n: int) -> int:\n    digits = math.ceil(math.log(n + 1, 2))\n    count = 0\n    for i in range(digits):\n        div = -2 ** (i + 1)\n        divi = (n + 1) // div\n        rem = (n + 1) % div\n        mul = 2 ** i\n        if rem <= div // 2:\n            rem = 0\n        else:\n            rem = rem - div // 2\n        count += mul * divi + rem\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "div = 2 ** (i + 1)",
      "mutated_line": "div = 2 ** (i - 1)",
      "code": "import math\n\ndef count_set_bits(n: int) -> int:\n    digits = math.ceil(math.log(n + 1, 2))\n    count = 0\n    for i in range(digits):\n        div = 2 ** (i - 1)\n        divi = (n + 1) // div\n        rem = (n + 1) % div\n        mul = 2 ** i\n        if rem <= div // 2:\n            rem = 0\n        else:\n            rem = rem - div // 2\n        count += mul * divi + rem\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "div = 2 ** (i + 1)",
      "mutated_line": "div = 2 ** (i * 1)",
      "code": "import math\n\ndef count_set_bits(n: int) -> int:\n    digits = math.ceil(math.log(n + 1, 2))\n    count = 0\n    for i in range(digits):\n        div = 2 ** (i * 1)\n        divi = (n + 1) // div\n        rem = (n + 1) % div\n        mul = 2 ** i\n        if rem <= div // 2:\n            rem = 0\n        else:\n            rem = rem - div // 2\n        count += mul * divi + rem\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "divi = (n + 1) // div",
      "mutated_line": "divi = (n - 1) // div",
      "code": "import math\n\ndef count_set_bits(n: int) -> int:\n    digits = math.ceil(math.log(n + 1, 2))\n    count = 0\n    for i in range(digits):\n        div = 2 ** (i + 1)\n        divi = (n - 1) // div\n        rem = (n + 1) % div\n        mul = 2 ** i\n        if rem <= div // 2:\n            rem = 0\n        else:\n            rem = rem - div // 2\n        count += mul * divi + rem\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "divi = (n + 1) // div",
      "mutated_line": "divi = n * 1 // div",
      "code": "import math\n\ndef count_set_bits(n: int) -> int:\n    digits = math.ceil(math.log(n + 1, 2))\n    count = 0\n    for i in range(digits):\n        div = 2 ** (i + 1)\n        divi = n * 1 // div\n        rem = (n + 1) % div\n        mul = 2 ** i\n        if rem <= div // 2:\n            rem = 0\n        else:\n            rem = rem - div // 2\n        count += mul * divi + rem\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "rem = (n + 1) % div",
      "mutated_line": "rem = (n - 1) % div",
      "code": "import math\n\ndef count_set_bits(n: int) -> int:\n    digits = math.ceil(math.log(n + 1, 2))\n    count = 0\n    for i in range(digits):\n        div = 2 ** (i + 1)\n        divi = (n + 1) // div\n        rem = (n - 1) % div\n        mul = 2 ** i\n        if rem <= div // 2:\n            rem = 0\n        else:\n            rem = rem - div // 2\n        count += mul * divi + rem\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "rem = (n + 1) % div",
      "mutated_line": "rem = n * 1 % div",
      "code": "import math\n\ndef count_set_bits(n: int) -> int:\n    digits = math.ceil(math.log(n + 1, 2))\n    count = 0\n    for i in range(digits):\n        div = 2 ** (i + 1)\n        divi = (n + 1) // div\n        rem = n * 1 % div\n        mul = 2 ** i\n        if rem <= div // 2:\n            rem = 0\n        else:\n            rem = rem - div // 2\n        count += mul * divi + rem\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "mul = 2 ** i",
      "mutated_line": "mul = 3 ** i",
      "code": "import math\n\ndef count_set_bits(n: int) -> int:\n    digits = math.ceil(math.log(n + 1, 2))\n    count = 0\n    for i in range(digits):\n        div = 2 ** (i + 1)\n        divi = (n + 1) // div\n        rem = (n + 1) % div\n        mul = 3 ** i\n        if rem <= div // 2:\n            rem = 0\n        else:\n            rem = rem - div // 2\n        count += mul * divi + rem\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "mul = 2 ** i",
      "mutated_line": "mul = 1 ** i",
      "code": "import math\n\ndef count_set_bits(n: int) -> int:\n    digits = math.ceil(math.log(n + 1, 2))\n    count = 0\n    for i in range(digits):\n        div = 2 ** (i + 1)\n        divi = (n + 1) // div\n        rem = (n + 1) % div\n        mul = 1 ** i\n        if rem <= div // 2:\n            rem = 0\n        else:\n            rem = rem - div // 2\n        count += mul * divi + rem\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "mul = 2 ** i",
      "mutated_line": "mul = 0 ** i",
      "code": "import math\n\ndef count_set_bits(n: int) -> int:\n    digits = math.ceil(math.log(n + 1, 2))\n    count = 0\n    for i in range(digits):\n        div = 2 ** (i + 1)\n        divi = (n + 1) // div\n        rem = (n + 1) % div\n        mul = 0 ** i\n        if rem <= div // 2:\n            rem = 0\n        else:\n            rem = rem - div // 2\n        count += mul * divi + rem\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "mul = 2 ** i",
      "mutated_line": "mul = 1 ** i",
      "code": "import math\n\ndef count_set_bits(n: int) -> int:\n    digits = math.ceil(math.log(n + 1, 2))\n    count = 0\n    for i in range(digits):\n        div = 2 ** (i + 1)\n        divi = (n + 1) // div\n        rem = (n + 1) % div\n        mul = 1 ** i\n        if rem <= div // 2:\n            rem = 0\n        else:\n            rem = rem - div // 2\n        count += mul * divi + rem\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "mul = 2 ** i",
      "mutated_line": "mul = -2 ** i",
      "code": "import math\n\ndef count_set_bits(n: int) -> int:\n    digits = math.ceil(math.log(n + 1, 2))\n    count = 0\n    for i in range(digits):\n        div = 2 ** (i + 1)\n        divi = (n + 1) // div\n        rem = (n + 1) % div\n        mul = -2 ** i\n        if rem <= div // 2:\n            rem = 0\n        else:\n            rem = rem - div // 2\n        count += mul * divi + rem\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "if rem <= div // 2:",
      "mutated_line": "if rem <= div / 2:",
      "code": "import math\n\ndef count_set_bits(n: int) -> int:\n    digits = math.ceil(math.log(n + 1, 2))\n    count = 0\n    for i in range(digits):\n        div = 2 ** (i + 1)\n        divi = (n + 1) // div\n        rem = (n + 1) % div\n        mul = 2 ** i\n        if rem <= div / 2:\n            rem = 0\n        else:\n            rem = rem - div // 2\n        count += mul * divi + rem\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "if rem <= div // 2:",
      "mutated_line": "if rem <= div * 2:",
      "code": "import math\n\ndef count_set_bits(n: int) -> int:\n    digits = math.ceil(math.log(n + 1, 2))\n    count = 0\n    for i in range(digits):\n        div = 2 ** (i + 1)\n        divi = (n + 1) // div\n        rem = (n + 1) % div\n        mul = 2 ** i\n        if rem <= div * 2:\n            rem = 0\n        else:\n            rem = rem - div // 2\n        count += mul * divi + rem\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "rem = 0",
      "mutated_line": "rem = 1",
      "code": "import math\n\ndef count_set_bits(n: int) -> int:\n    digits = math.ceil(math.log(n + 1, 2))\n    count = 0\n    for i in range(digits):\n        div = 2 ** (i + 1)\n        divi = (n + 1) // div\n        rem = (n + 1) % div\n        mul = 2 ** i\n        if rem <= div // 2:\n            rem = 1\n        else:\n            rem = rem - div // 2\n        count += mul * divi + rem\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "rem = 0",
      "mutated_line": "rem = -1",
      "code": "import math\n\ndef count_set_bits(n: int) -> int:\n    digits = math.ceil(math.log(n + 1, 2))\n    count = 0\n    for i in range(digits):\n        div = 2 ** (i + 1)\n        divi = (n + 1) // div\n        rem = (n + 1) % div\n        mul = 2 ** i\n        if rem <= div // 2:\n            rem = -1\n        else:\n            rem = rem - div // 2\n        count += mul * divi + rem\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "rem = 0",
      "mutated_line": "rem = 1",
      "code": "import math\n\ndef count_set_bits(n: int) -> int:\n    digits = math.ceil(math.log(n + 1, 2))\n    count = 0\n    for i in range(digits):\n        div = 2 ** (i + 1)\n        divi = (n + 1) // div\n        rem = (n + 1) % div\n        mul = 2 ** i\n        if rem <= div // 2:\n            rem = 1\n        else:\n            rem = rem - div // 2\n        count += mul * divi + rem\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "rem = rem - div // 2",
      "mutated_line": "rem = rem + div // 2",
      "code": "import math\n\ndef count_set_bits(n: int) -> int:\n    digits = math.ceil(math.log(n + 1, 2))\n    count = 0\n    for i in range(digits):\n        div = 2 ** (i + 1)\n        divi = (n + 1) // div\n        rem = (n + 1) % div\n        mul = 2 ** i\n        if rem <= div // 2:\n            rem = 0\n        else:\n            rem = rem + div // 2\n        count += mul * divi + rem\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "rem = rem - div // 2",
      "mutated_line": "rem = rem * (div // 2)",
      "code": "import math\n\ndef count_set_bits(n: int) -> int:\n    digits = math.ceil(math.log(n + 1, 2))\n    count = 0\n    for i in range(digits):\n        div = 2 ** (i + 1)\n        divi = (n + 1) // div\n        rem = (n + 1) % div\n        mul = 2 ** i\n        if rem <= div // 2:\n            rem = 0\n        else:\n            rem = rem * (div // 2)\n        count += mul * divi + rem\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "count += mul * divi + rem",
      "mutated_line": "count += mul / divi + rem",
      "code": "import math\n\ndef count_set_bits(n: int) -> int:\n    digits = math.ceil(math.log(n + 1, 2))\n    count = 0\n    for i in range(digits):\n        div = 2 ** (i + 1)\n        divi = (n + 1) // div\n        rem = (n + 1) % div\n        mul = 2 ** i\n        if rem <= div // 2:\n            rem = 0\n        else:\n            rem = rem - div // 2\n        count += mul / divi + rem\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "count += mul * divi + rem",
      "mutated_line": "count += mul + divi + rem",
      "code": "import math\n\ndef count_set_bits(n: int) -> int:\n    digits = math.ceil(math.log(n + 1, 2))\n    count = 0\n    for i in range(digits):\n        div = 2 ** (i + 1)\n        divi = (n + 1) // div\n        rem = (n + 1) % div\n        mul = 2 ** i\n        if rem <= div // 2:\n            rem = 0\n        else:\n            rem = rem - div // 2\n        count += mul + divi + rem\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "count += mul * divi + rem",
      "mutated_line": "count += mul ** divi + rem",
      "code": "import math\n\ndef count_set_bits(n: int) -> int:\n    digits = math.ceil(math.log(n + 1, 2))\n    count = 0\n    for i in range(digits):\n        div = 2 ** (i + 1)\n        divi = (n + 1) // div\n        rem = (n + 1) % div\n        mul = 2 ** i\n        if rem <= div // 2:\n            rem = 0\n        else:\n            rem = rem - div // 2\n        count += mul ** divi + rem\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "digits = math.ceil(math.log(n + 1, 2))",
      "mutated_line": "digits = math.ceil(math.log(n + 2, 2))",
      "code": "import math\n\ndef count_set_bits(n: int) -> int:\n    digits = math.ceil(math.log(n + 2, 2))\n    count = 0\n    for i in range(digits):\n        div = 2 ** (i + 1)\n        divi = (n + 1) // div\n        rem = (n + 1) % div\n        mul = 2 ** i\n        if rem <= div // 2:\n            rem = 0\n        else:\n            rem = rem - div // 2\n        count += mul * divi + rem\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "digits = math.ceil(math.log(n + 1, 2))",
      "mutated_line": "digits = math.ceil(math.log(n + 0, 2))",
      "code": "import math\n\ndef count_set_bits(n: int) -> int:\n    digits = math.ceil(math.log(n + 0, 2))\n    count = 0\n    for i in range(digits):\n        div = 2 ** (i + 1)\n        divi = (n + 1) // div\n        rem = (n + 1) % div\n        mul = 2 ** i\n        if rem <= div // 2:\n            rem = 0\n        else:\n            rem = rem - div // 2\n        count += mul * divi + rem\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "digits = math.ceil(math.log(n + 1, 2))",
      "mutated_line": "digits = math.ceil(math.log(n + 0, 2))",
      "code": "import math\n\ndef count_set_bits(n: int) -> int:\n    digits = math.ceil(math.log(n + 0, 2))\n    count = 0\n    for i in range(digits):\n        div = 2 ** (i + 1)\n        divi = (n + 1) // div\n        rem = (n + 1) % div\n        mul = 2 ** i\n        if rem <= div // 2:\n            rem = 0\n        else:\n            rem = rem - div // 2\n        count += mul * divi + rem\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "digits = math.ceil(math.log(n + 1, 2))",
      "mutated_line": "digits = math.ceil(math.log(n + -1, 2))",
      "code": "import math\n\ndef count_set_bits(n: int) -> int:\n    digits = math.ceil(math.log(n + -1, 2))\n    count = 0\n    for i in range(digits):\n        div = 2 ** (i + 1)\n        divi = (n + 1) // div\n        rem = (n + 1) % div\n        mul = 2 ** i\n        if rem <= div // 2:\n            rem = 0\n        else:\n            rem = rem - div // 2\n        count += mul * divi + rem\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "div = 2 ** (i + 1)",
      "mutated_line": "div = 2 ** (i + 2)",
      "code": "import math\n\ndef count_set_bits(n: int) -> int:\n    digits = math.ceil(math.log(n + 1, 2))\n    count = 0\n    for i in range(digits):\n        div = 2 ** (i + 2)\n        divi = (n + 1) // div\n        rem = (n + 1) % div\n        mul = 2 ** i\n        if rem <= div // 2:\n            rem = 0\n        else:\n            rem = rem - div // 2\n        count += mul * divi + rem\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "div = 2 ** (i + 1)",
      "mutated_line": "div = 2 ** (i + 0)",
      "code": "import math\n\ndef count_set_bits(n: int) -> int:\n    digits = math.ceil(math.log(n + 1, 2))\n    count = 0\n    for i in range(digits):\n        div = 2 ** (i + 0)\n        divi = (n + 1) // div\n        rem = (n + 1) % div\n        mul = 2 ** i\n        if rem <= div // 2:\n            rem = 0\n        else:\n            rem = rem - div // 2\n        count += mul * divi + rem\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "div = 2 ** (i + 1)",
      "mutated_line": "div = 2 ** (i + 0)",
      "code": "import math\n\ndef count_set_bits(n: int) -> int:\n    digits = math.ceil(math.log(n + 1, 2))\n    count = 0\n    for i in range(digits):\n        div = 2 ** (i + 0)\n        divi = (n + 1) // div\n        rem = (n + 1) % div\n        mul = 2 ** i\n        if rem <= div // 2:\n            rem = 0\n        else:\n            rem = rem - div // 2\n        count += mul * divi + rem\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "div = 2 ** (i + 1)",
      "mutated_line": "div = 2 ** (i + -1)",
      "code": "import math\n\ndef count_set_bits(n: int) -> int:\n    digits = math.ceil(math.log(n + 1, 2))\n    count = 0\n    for i in range(digits):\n        div = 2 ** (i + -1)\n        divi = (n + 1) // div\n        rem = (n + 1) % div\n        mul = 2 ** i\n        if rem <= div // 2:\n            rem = 0\n        else:\n            rem = rem - div // 2\n        count += mul * divi + rem\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "divi = (n + 1) // div",
      "mutated_line": "divi = (n + 2) // div",
      "code": "import math\n\ndef count_set_bits(n: int) -> int:\n    digits = math.ceil(math.log(n + 1, 2))\n    count = 0\n    for i in range(digits):\n        div = 2 ** (i + 1)\n        divi = (n + 2) // div\n        rem = (n + 1) % div\n        mul = 2 ** i\n        if rem <= div // 2:\n            rem = 0\n        else:\n            rem = rem - div // 2\n        count += mul * divi + rem\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "divi = (n + 1) // div",
      "mutated_line": "divi = (n + 0) // div",
      "code": "import math\n\ndef count_set_bits(n: int) -> int:\n    digits = math.ceil(math.log(n + 1, 2))\n    count = 0\n    for i in range(digits):\n        div = 2 ** (i + 1)\n        divi = (n + 0) // div\n        rem = (n + 1) % div\n        mul = 2 ** i\n        if rem <= div // 2:\n            rem = 0\n        else:\n            rem = rem - div // 2\n        count += mul * divi + rem\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "divi = (n + 1) // div",
      "mutated_line": "divi = (n + 0) // div",
      "code": "import math\n\ndef count_set_bits(n: int) -> int:\n    digits = math.ceil(math.log(n + 1, 2))\n    count = 0\n    for i in range(digits):\n        div = 2 ** (i + 1)\n        divi = (n + 0) // div\n        rem = (n + 1) % div\n        mul = 2 ** i\n        if rem <= div // 2:\n            rem = 0\n        else:\n            rem = rem - div // 2\n        count += mul * divi + rem\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "divi = (n + 1) // div",
      "mutated_line": "divi = (n + -1) // div",
      "code": "import math\n\ndef count_set_bits(n: int) -> int:\n    digits = math.ceil(math.log(n + 1, 2))\n    count = 0\n    for i in range(digits):\n        div = 2 ** (i + 1)\n        divi = (n + -1) // div\n        rem = (n + 1) % div\n        mul = 2 ** i\n        if rem <= div // 2:\n            rem = 0\n        else:\n            rem = rem - div // 2\n        count += mul * divi + rem\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "rem = (n + 1) % div",
      "mutated_line": "rem = (n + 2) % div",
      "code": "import math\n\ndef count_set_bits(n: int) -> int:\n    digits = math.ceil(math.log(n + 1, 2))\n    count = 0\n    for i in range(digits):\n        div = 2 ** (i + 1)\n        divi = (n + 1) // div\n        rem = (n + 2) % div\n        mul = 2 ** i\n        if rem <= div // 2:\n            rem = 0\n        else:\n            rem = rem - div // 2\n        count += mul * divi + rem\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "rem = (n + 1) % div",
      "mutated_line": "rem = (n + 0) % div",
      "code": "import math\n\ndef count_set_bits(n: int) -> int:\n    digits = math.ceil(math.log(n + 1, 2))\n    count = 0\n    for i in range(digits):\n        div = 2 ** (i + 1)\n        divi = (n + 1) // div\n        rem = (n + 0) % div\n        mul = 2 ** i\n        if rem <= div // 2:\n            rem = 0\n        else:\n            rem = rem - div // 2\n        count += mul * divi + rem\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "rem = (n + 1) % div",
      "mutated_line": "rem = (n + 0) % div",
      "code": "import math\n\ndef count_set_bits(n: int) -> int:\n    digits = math.ceil(math.log(n + 1, 2))\n    count = 0\n    for i in range(digits):\n        div = 2 ** (i + 1)\n        divi = (n + 1) // div\n        rem = (n + 0) % div\n        mul = 2 ** i\n        if rem <= div // 2:\n            rem = 0\n        else:\n            rem = rem - div // 2\n        count += mul * divi + rem\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "rem = (n + 1) % div",
      "mutated_line": "rem = (n + -1) % div",
      "code": "import math\n\ndef count_set_bits(n: int) -> int:\n    digits = math.ceil(math.log(n + 1, 2))\n    count = 0\n    for i in range(digits):\n        div = 2 ** (i + 1)\n        divi = (n + 1) // div\n        rem = (n + -1) % div\n        mul = 2 ** i\n        if rem <= div // 2:\n            rem = 0\n        else:\n            rem = rem - div // 2\n        count += mul * divi + rem\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if rem <= div // 2:",
      "mutated_line": "if rem <= div // 3:",
      "code": "import math\n\ndef count_set_bits(n: int) -> int:\n    digits = math.ceil(math.log(n + 1, 2))\n    count = 0\n    for i in range(digits):\n        div = 2 ** (i + 1)\n        divi = (n + 1) // div\n        rem = (n + 1) % div\n        mul = 2 ** i\n        if rem <= div // 3:\n            rem = 0\n        else:\n            rem = rem - div // 2\n        count += mul * divi + rem\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if rem <= div // 2:",
      "mutated_line": "if rem <= div // 1:",
      "code": "import math\n\ndef count_set_bits(n: int) -> int:\n    digits = math.ceil(math.log(n + 1, 2))\n    count = 0\n    for i in range(digits):\n        div = 2 ** (i + 1)\n        divi = (n + 1) // div\n        rem = (n + 1) % div\n        mul = 2 ** i\n        if rem <= div // 1:\n            rem = 0\n        else:\n            rem = rem - div // 2\n        count += mul * divi + rem\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if rem <= div // 2:",
      "mutated_line": "if rem <= div // 0:",
      "code": "import math\n\ndef count_set_bits(n: int) -> int:\n    digits = math.ceil(math.log(n + 1, 2))\n    count = 0\n    for i in range(digits):\n        div = 2 ** (i + 1)\n        divi = (n + 1) // div\n        rem = (n + 1) % div\n        mul = 2 ** i\n        if rem <= div // 0:\n            rem = 0\n        else:\n            rem = rem - div // 2\n        count += mul * divi + rem\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if rem <= div // 2:",
      "mutated_line": "if rem <= div // 1:",
      "code": "import math\n\ndef count_set_bits(n: int) -> int:\n    digits = math.ceil(math.log(n + 1, 2))\n    count = 0\n    for i in range(digits):\n        div = 2 ** (i + 1)\n        divi = (n + 1) // div\n        rem = (n + 1) % div\n        mul = 2 ** i\n        if rem <= div // 1:\n            rem = 0\n        else:\n            rem = rem - div // 2\n        count += mul * divi + rem\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if rem <= div // 2:",
      "mutated_line": "if rem <= div // -2:",
      "code": "import math\n\ndef count_set_bits(n: int) -> int:\n    digits = math.ceil(math.log(n + 1, 2))\n    count = 0\n    for i in range(digits):\n        div = 2 ** (i + 1)\n        divi = (n + 1) // div\n        rem = (n + 1) % div\n        mul = 2 ** i\n        if rem <= div // -2:\n            rem = 0\n        else:\n            rem = rem - div // 2\n        count += mul * divi + rem\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "rem = rem - div // 2",
      "mutated_line": "rem = rem - div / 2",
      "code": "import math\n\ndef count_set_bits(n: int) -> int:\n    digits = math.ceil(math.log(n + 1, 2))\n    count = 0\n    for i in range(digits):\n        div = 2 ** (i + 1)\n        divi = (n + 1) // div\n        rem = (n + 1) % div\n        mul = 2 ** i\n        if rem <= div // 2:\n            rem = 0\n        else:\n            rem = rem - div / 2\n        count += mul * divi + rem\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "rem = rem - div // 2",
      "mutated_line": "rem = rem - div * 2",
      "code": "import math\n\ndef count_set_bits(n: int) -> int:\n    digits = math.ceil(math.log(n + 1, 2))\n    count = 0\n    for i in range(digits):\n        div = 2 ** (i + 1)\n        divi = (n + 1) // div\n        rem = (n + 1) % div\n        mul = 2 ** i\n        if rem <= div // 2:\n            rem = 0\n        else:\n            rem = rem - div * 2\n        count += mul * divi + rem\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "rem = rem - div // 2",
      "mutated_line": "rem = rem - div // 3",
      "code": "import math\n\ndef count_set_bits(n: int) -> int:\n    digits = math.ceil(math.log(n + 1, 2))\n    count = 0\n    for i in range(digits):\n        div = 2 ** (i + 1)\n        divi = (n + 1) // div\n        rem = (n + 1) % div\n        mul = 2 ** i\n        if rem <= div // 2:\n            rem = 0\n        else:\n            rem = rem - div // 3\n        count += mul * divi + rem\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "rem = rem - div // 2",
      "mutated_line": "rem = rem - div // 1",
      "code": "import math\n\ndef count_set_bits(n: int) -> int:\n    digits = math.ceil(math.log(n + 1, 2))\n    count = 0\n    for i in range(digits):\n        div = 2 ** (i + 1)\n        divi = (n + 1) // div\n        rem = (n + 1) % div\n        mul = 2 ** i\n        if rem <= div // 2:\n            rem = 0\n        else:\n            rem = rem - div // 1\n        count += mul * divi + rem\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "rem = rem - div // 2",
      "mutated_line": "rem = rem - div // 0",
      "code": "import math\n\ndef count_set_bits(n: int) -> int:\n    digits = math.ceil(math.log(n + 1, 2))\n    count = 0\n    for i in range(digits):\n        div = 2 ** (i + 1)\n        divi = (n + 1) // div\n        rem = (n + 1) % div\n        mul = 2 ** i\n        if rem <= div // 2:\n            rem = 0\n        else:\n            rem = rem - div // 0\n        count += mul * divi + rem\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "rem = rem - div // 2",
      "mutated_line": "rem = rem - div // 1",
      "code": "import math\n\ndef count_set_bits(n: int) -> int:\n    digits = math.ceil(math.log(n + 1, 2))\n    count = 0\n    for i in range(digits):\n        div = 2 ** (i + 1)\n        divi = (n + 1) // div\n        rem = (n + 1) % div\n        mul = 2 ** i\n        if rem <= div // 2:\n            rem = 0\n        else:\n            rem = rem - div // 1\n        count += mul * divi + rem\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "rem = rem - div // 2",
      "mutated_line": "rem = rem - div // -2",
      "code": "import math\n\ndef count_set_bits(n: int) -> int:\n    digits = math.ceil(math.log(n + 1, 2))\n    count = 0\n    for i in range(digits):\n        div = 2 ** (i + 1)\n        divi = (n + 1) // div\n        rem = (n + 1) % div\n        mul = 2 ** i\n        if rem <= div // 2:\n            rem = 0\n        else:\n            rem = rem - div // -2\n        count += mul * divi + rem\n    return count"
    }
  ]
}