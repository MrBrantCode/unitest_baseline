{
  "task_id": "taco_10817",
  "entry_point": "max_combinations",
  "mutant_count": 84,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if i > 0:",
      "mutated_line": "if i >= 0:",
      "code": "def max_combinations(N, K, A, B):\n    import heapq\n    A.sort()\n    B.sort()\n    pq = []\n    heapq.heapify(pq)\n    heapq.heappush(pq, (-(A[N - 1] + B[N - 1]), (N - 1, N - 1)))\n    visited = set()\n    visited.add((N - 1, N - 1))\n    result = []\n    for _ in range(K):\n        (current_sum, (i, j)) = heapq.heappop(pq)\n        result.append(-current_sum)\n        if i >= 0:\n            next_sum = A[i - 1] + B[j]\n            next_indices = (i - 1, j)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n        if j > 0:\n            next_sum = A[i] + B[j - 1]\n            next_indices = (i, j - 1)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if i > 0:",
      "mutated_line": "if i <= 0:",
      "code": "def max_combinations(N, K, A, B):\n    import heapq\n    A.sort()\n    B.sort()\n    pq = []\n    heapq.heapify(pq)\n    heapq.heappush(pq, (-(A[N - 1] + B[N - 1]), (N - 1, N - 1)))\n    visited = set()\n    visited.add((N - 1, N - 1))\n    result = []\n    for _ in range(K):\n        (current_sum, (i, j)) = heapq.heappop(pq)\n        result.append(-current_sum)\n        if i <= 0:\n            next_sum = A[i - 1] + B[j]\n            next_indices = (i - 1, j)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n        if j > 0:\n            next_sum = A[i] + B[j - 1]\n            next_indices = (i, j - 1)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if i > 0:",
      "mutated_line": "if i != 0:",
      "code": "def max_combinations(N, K, A, B):\n    import heapq\n    A.sort()\n    B.sort()\n    pq = []\n    heapq.heapify(pq)\n    heapq.heappush(pq, (-(A[N - 1] + B[N - 1]), (N - 1, N - 1)))\n    visited = set()\n    visited.add((N - 1, N - 1))\n    result = []\n    for _ in range(K):\n        (current_sum, (i, j)) = heapq.heappop(pq)\n        result.append(-current_sum)\n        if i != 0:\n            next_sum = A[i - 1] + B[j]\n            next_indices = (i - 1, j)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n        if j > 0:\n            next_sum = A[i] + B[j - 1]\n            next_indices = (i, j - 1)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if j > 0:",
      "mutated_line": "if j >= 0:",
      "code": "def max_combinations(N, K, A, B):\n    import heapq\n    A.sort()\n    B.sort()\n    pq = []\n    heapq.heapify(pq)\n    heapq.heappush(pq, (-(A[N - 1] + B[N - 1]), (N - 1, N - 1)))\n    visited = set()\n    visited.add((N - 1, N - 1))\n    result = []\n    for _ in range(K):\n        (current_sum, (i, j)) = heapq.heappop(pq)\n        result.append(-current_sum)\n        if i > 0:\n            next_sum = A[i - 1] + B[j]\n            next_indices = (i - 1, j)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n        if j >= 0:\n            next_sum = A[i] + B[j - 1]\n            next_indices = (i, j - 1)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if j > 0:",
      "mutated_line": "if j <= 0:",
      "code": "def max_combinations(N, K, A, B):\n    import heapq\n    A.sort()\n    B.sort()\n    pq = []\n    heapq.heapify(pq)\n    heapq.heappush(pq, (-(A[N - 1] + B[N - 1]), (N - 1, N - 1)))\n    visited = set()\n    visited.add((N - 1, N - 1))\n    result = []\n    for _ in range(K):\n        (current_sum, (i, j)) = heapq.heappop(pq)\n        result.append(-current_sum)\n        if i > 0:\n            next_sum = A[i - 1] + B[j]\n            next_indices = (i - 1, j)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n        if j <= 0:\n            next_sum = A[i] + B[j - 1]\n            next_indices = (i, j - 1)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if j > 0:",
      "mutated_line": "if j != 0:",
      "code": "def max_combinations(N, K, A, B):\n    import heapq\n    A.sort()\n    B.sort()\n    pq = []\n    heapq.heapify(pq)\n    heapq.heappush(pq, (-(A[N - 1] + B[N - 1]), (N - 1, N - 1)))\n    visited = set()\n    visited.add((N - 1, N - 1))\n    result = []\n    for _ in range(K):\n        (current_sum, (i, j)) = heapq.heappop(pq)\n        result.append(-current_sum)\n        if i > 0:\n            next_sum = A[i - 1] + B[j]\n            next_indices = (i - 1, j)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n        if j != 0:\n            next_sum = A[i] + B[j - 1]\n            next_indices = (i, j - 1)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n    return result"
    },
    {
      "operator": "UOI",
      "lineno": 13,
      "original_line": "heapq.heappush(pq, (-(A[N - 1] + B[N - 1]), (N - 1, N - 1)))",
      "mutated_line": "heapq.heappush(pq, (+(A[N - 1] + B[N - 1]), (N - 1, N - 1)))",
      "code": "def max_combinations(N, K, A, B):\n    import heapq\n    A.sort()\n    B.sort()\n    pq = []\n    heapq.heapify(pq)\n    heapq.heappush(pq, (+(A[N - 1] + B[N - 1]), (N - 1, N - 1)))\n    visited = set()\n    visited.add((N - 1, N - 1))\n    result = []\n    for _ in range(K):\n        (current_sum, (i, j)) = heapq.heappop(pq)\n        result.append(-current_sum)\n        if i > 0:\n            next_sum = A[i - 1] + B[j]\n            next_indices = (i - 1, j)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n        if j > 0:\n            next_sum = A[i] + B[j - 1]\n            next_indices = (i, j - 1)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "visited.add((N - 1, N - 1))",
      "mutated_line": "visited.add((N + 1, N - 1))",
      "code": "def max_combinations(N, K, A, B):\n    import heapq\n    A.sort()\n    B.sort()\n    pq = []\n    heapq.heapify(pq)\n    heapq.heappush(pq, (-(A[N - 1] + B[N - 1]), (N - 1, N - 1)))\n    visited = set()\n    visited.add((N + 1, N - 1))\n    result = []\n    for _ in range(K):\n        (current_sum, (i, j)) = heapq.heappop(pq)\n        result.append(-current_sum)\n        if i > 0:\n            next_sum = A[i - 1] + B[j]\n            next_indices = (i - 1, j)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n        if j > 0:\n            next_sum = A[i] + B[j - 1]\n            next_indices = (i, j - 1)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "visited.add((N - 1, N - 1))",
      "mutated_line": "visited.add((N * 1, N - 1))",
      "code": "def max_combinations(N, K, A, B):\n    import heapq\n    A.sort()\n    B.sort()\n    pq = []\n    heapq.heapify(pq)\n    heapq.heappush(pq, (-(A[N - 1] + B[N - 1]), (N - 1, N - 1)))\n    visited = set()\n    visited.add((N * 1, N - 1))\n    result = []\n    for _ in range(K):\n        (current_sum, (i, j)) = heapq.heappop(pq)\n        result.append(-current_sum)\n        if i > 0:\n            next_sum = A[i - 1] + B[j]\n            next_indices = (i - 1, j)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n        if j > 0:\n            next_sum = A[i] + B[j - 1]\n            next_indices = (i, j - 1)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "visited.add((N - 1, N - 1))",
      "mutated_line": "visited.add((N - 1, N + 1))",
      "code": "def max_combinations(N, K, A, B):\n    import heapq\n    A.sort()\n    B.sort()\n    pq = []\n    heapq.heapify(pq)\n    heapq.heappush(pq, (-(A[N - 1] + B[N - 1]), (N - 1, N - 1)))\n    visited = set()\n    visited.add((N - 1, N + 1))\n    result = []\n    for _ in range(K):\n        (current_sum, (i, j)) = heapq.heappop(pq)\n        result.append(-current_sum)\n        if i > 0:\n            next_sum = A[i - 1] + B[j]\n            next_indices = (i - 1, j)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n        if j > 0:\n            next_sum = A[i] + B[j - 1]\n            next_indices = (i, j - 1)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "visited.add((N - 1, N - 1))",
      "mutated_line": "visited.add((N - 1, N * 1))",
      "code": "def max_combinations(N, K, A, B):\n    import heapq\n    A.sort()\n    B.sort()\n    pq = []\n    heapq.heapify(pq)\n    heapq.heappush(pq, (-(A[N - 1] + B[N - 1]), (N - 1, N - 1)))\n    visited = set()\n    visited.add((N - 1, N * 1))\n    result = []\n    for _ in range(K):\n        (current_sum, (i, j)) = heapq.heappop(pq)\n        result.append(-current_sum)\n        if i > 0:\n            next_sum = A[i - 1] + B[j]\n            next_indices = (i - 1, j)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n        if j > 0:\n            next_sum = A[i] + B[j - 1]\n            next_indices = (i, j - 1)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n    return result"
    },
    {
      "operator": "UOI",
      "lineno": 24,
      "original_line": "result.append(-current_sum)",
      "mutated_line": "result.append(+current_sum)",
      "code": "def max_combinations(N, K, A, B):\n    import heapq\n    A.sort()\n    B.sort()\n    pq = []\n    heapq.heapify(pq)\n    heapq.heappush(pq, (-(A[N - 1] + B[N - 1]), (N - 1, N - 1)))\n    visited = set()\n    visited.add((N - 1, N - 1))\n    result = []\n    for _ in range(K):\n        (current_sum, (i, j)) = heapq.heappop(pq)\n        result.append(+current_sum)\n        if i > 0:\n            next_sum = A[i - 1] + B[j]\n            next_indices = (i - 1, j)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n        if j > 0:\n            next_sum = A[i] + B[j - 1]\n            next_indices = (i, j - 1)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if i > 0:",
      "mutated_line": "if i > 1:",
      "code": "def max_combinations(N, K, A, B):\n    import heapq\n    A.sort()\n    B.sort()\n    pq = []\n    heapq.heapify(pq)\n    heapq.heappush(pq, (-(A[N - 1] + B[N - 1]), (N - 1, N - 1)))\n    visited = set()\n    visited.add((N - 1, N - 1))\n    result = []\n    for _ in range(K):\n        (current_sum, (i, j)) = heapq.heappop(pq)\n        result.append(-current_sum)\n        if i > 1:\n            next_sum = A[i - 1] + B[j]\n            next_indices = (i - 1, j)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n        if j > 0:\n            next_sum = A[i] + B[j - 1]\n            next_indices = (i, j - 1)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if i > 0:",
      "mutated_line": "if i > -1:",
      "code": "def max_combinations(N, K, A, B):\n    import heapq\n    A.sort()\n    B.sort()\n    pq = []\n    heapq.heapify(pq)\n    heapq.heappush(pq, (-(A[N - 1] + B[N - 1]), (N - 1, N - 1)))\n    visited = set()\n    visited.add((N - 1, N - 1))\n    result = []\n    for _ in range(K):\n        (current_sum, (i, j)) = heapq.heappop(pq)\n        result.append(-current_sum)\n        if i > -1:\n            next_sum = A[i - 1] + B[j]\n            next_indices = (i - 1, j)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n        if j > 0:\n            next_sum = A[i] + B[j - 1]\n            next_indices = (i, j - 1)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if i > 0:",
      "mutated_line": "if i > 1:",
      "code": "def max_combinations(N, K, A, B):\n    import heapq\n    A.sort()\n    B.sort()\n    pq = []\n    heapq.heapify(pq)\n    heapq.heappush(pq, (-(A[N - 1] + B[N - 1]), (N - 1, N - 1)))\n    visited = set()\n    visited.add((N - 1, N - 1))\n    result = []\n    for _ in range(K):\n        (current_sum, (i, j)) = heapq.heappop(pq)\n        result.append(-current_sum)\n        if i > 1:\n            next_sum = A[i - 1] + B[j]\n            next_indices = (i - 1, j)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n        if j > 0:\n            next_sum = A[i] + B[j - 1]\n            next_indices = (i, j - 1)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "next_sum = A[i - 1] + B[j]",
      "mutated_line": "next_sum = A[i - 1] - B[j]",
      "code": "def max_combinations(N, K, A, B):\n    import heapq\n    A.sort()\n    B.sort()\n    pq = []\n    heapq.heapify(pq)\n    heapq.heappush(pq, (-(A[N - 1] + B[N - 1]), (N - 1, N - 1)))\n    visited = set()\n    visited.add((N - 1, N - 1))\n    result = []\n    for _ in range(K):\n        (current_sum, (i, j)) = heapq.heappop(pq)\n        result.append(-current_sum)\n        if i > 0:\n            next_sum = A[i - 1] - B[j]\n            next_indices = (i - 1, j)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n        if j > 0:\n            next_sum = A[i] + B[j - 1]\n            next_indices = (i, j - 1)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "next_sum = A[i - 1] + B[j]",
      "mutated_line": "next_sum = A[i - 1] * B[j]",
      "code": "def max_combinations(N, K, A, B):\n    import heapq\n    A.sort()\n    B.sort()\n    pq = []\n    heapq.heapify(pq)\n    heapq.heappush(pq, (-(A[N - 1] + B[N - 1]), (N - 1, N - 1)))\n    visited = set()\n    visited.add((N - 1, N - 1))\n    result = []\n    for _ in range(K):\n        (current_sum, (i, j)) = heapq.heappop(pq)\n        result.append(-current_sum)\n        if i > 0:\n            next_sum = A[i - 1] * B[j]\n            next_indices = (i - 1, j)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n        if j > 0:\n            next_sum = A[i] + B[j - 1]\n            next_indices = (i, j - 1)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if next_indices not in visited:",
      "mutated_line": "if next_indices in visited:",
      "code": "def max_combinations(N, K, A, B):\n    import heapq\n    A.sort()\n    B.sort()\n    pq = []\n    heapq.heapify(pq)\n    heapq.heappush(pq, (-(A[N - 1] + B[N - 1]), (N - 1, N - 1)))\n    visited = set()\n    visited.add((N - 1, N - 1))\n    result = []\n    for _ in range(K):\n        (current_sum, (i, j)) = heapq.heappop(pq)\n        result.append(-current_sum)\n        if i > 0:\n            next_sum = A[i - 1] + B[j]\n            next_indices = (i - 1, j)\n            if next_indices in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n        if j > 0:\n            next_sum = A[i] + B[j - 1]\n            next_indices = (i, j - 1)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if j > 0:",
      "mutated_line": "if j > 1:",
      "code": "def max_combinations(N, K, A, B):\n    import heapq\n    A.sort()\n    B.sort()\n    pq = []\n    heapq.heapify(pq)\n    heapq.heappush(pq, (-(A[N - 1] + B[N - 1]), (N - 1, N - 1)))\n    visited = set()\n    visited.add((N - 1, N - 1))\n    result = []\n    for _ in range(K):\n        (current_sum, (i, j)) = heapq.heappop(pq)\n        result.append(-current_sum)\n        if i > 0:\n            next_sum = A[i - 1] + B[j]\n            next_indices = (i - 1, j)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n        if j > 1:\n            next_sum = A[i] + B[j - 1]\n            next_indices = (i, j - 1)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if j > 0:",
      "mutated_line": "if j > -1:",
      "code": "def max_combinations(N, K, A, B):\n    import heapq\n    A.sort()\n    B.sort()\n    pq = []\n    heapq.heapify(pq)\n    heapq.heappush(pq, (-(A[N - 1] + B[N - 1]), (N - 1, N - 1)))\n    visited = set()\n    visited.add((N - 1, N - 1))\n    result = []\n    for _ in range(K):\n        (current_sum, (i, j)) = heapq.heappop(pq)\n        result.append(-current_sum)\n        if i > 0:\n            next_sum = A[i - 1] + B[j]\n            next_indices = (i - 1, j)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n        if j > -1:\n            next_sum = A[i] + B[j - 1]\n            next_indices = (i, j - 1)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if j > 0:",
      "mutated_line": "if j > 1:",
      "code": "def max_combinations(N, K, A, B):\n    import heapq\n    A.sort()\n    B.sort()\n    pq = []\n    heapq.heapify(pq)\n    heapq.heappush(pq, (-(A[N - 1] + B[N - 1]), (N - 1, N - 1)))\n    visited = set()\n    visited.add((N - 1, N - 1))\n    result = []\n    for _ in range(K):\n        (current_sum, (i, j)) = heapq.heappop(pq)\n        result.append(-current_sum)\n        if i > 0:\n            next_sum = A[i - 1] + B[j]\n            next_indices = (i - 1, j)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n        if j > 1:\n            next_sum = A[i] + B[j - 1]\n            next_indices = (i, j - 1)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "next_sum = A[i] + B[j - 1]",
      "mutated_line": "next_sum = A[i] - B[j - 1]",
      "code": "def max_combinations(N, K, A, B):\n    import heapq\n    A.sort()\n    B.sort()\n    pq = []\n    heapq.heapify(pq)\n    heapq.heappush(pq, (-(A[N - 1] + B[N - 1]), (N - 1, N - 1)))\n    visited = set()\n    visited.add((N - 1, N - 1))\n    result = []\n    for _ in range(K):\n        (current_sum, (i, j)) = heapq.heappop(pq)\n        result.append(-current_sum)\n        if i > 0:\n            next_sum = A[i - 1] + B[j]\n            next_indices = (i - 1, j)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n        if j > 0:\n            next_sum = A[i] - B[j - 1]\n            next_indices = (i, j - 1)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "next_sum = A[i] + B[j - 1]",
      "mutated_line": "next_sum = A[i] * B[j - 1]",
      "code": "def max_combinations(N, K, A, B):\n    import heapq\n    A.sort()\n    B.sort()\n    pq = []\n    heapq.heapify(pq)\n    heapq.heappush(pq, (-(A[N - 1] + B[N - 1]), (N - 1, N - 1)))\n    visited = set()\n    visited.add((N - 1, N - 1))\n    result = []\n    for _ in range(K):\n        (current_sum, (i, j)) = heapq.heappop(pq)\n        result.append(-current_sum)\n        if i > 0:\n            next_sum = A[i - 1] + B[j]\n            next_indices = (i - 1, j)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n        if j > 0:\n            next_sum = A[i] * B[j - 1]\n            next_indices = (i, j - 1)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if next_indices not in visited:",
      "mutated_line": "if next_indices in visited:",
      "code": "def max_combinations(N, K, A, B):\n    import heapq\n    A.sort()\n    B.sort()\n    pq = []\n    heapq.heapify(pq)\n    heapq.heappush(pq, (-(A[N - 1] + B[N - 1]), (N - 1, N - 1)))\n    visited = set()\n    visited.add((N - 1, N - 1))\n    result = []\n    for _ in range(K):\n        (current_sum, (i, j)) = heapq.heappop(pq)\n        result.append(-current_sum)\n        if i > 0:\n            next_sum = A[i - 1] + B[j]\n            next_indices = (i - 1, j)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n        if j > 0:\n            next_sum = A[i] + B[j - 1]\n            next_indices = (i, j - 1)\n            if next_indices in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "heapq.heappush(pq, (-(A[N - 1] + B[N - 1]), (N - 1, N - 1)))",
      "mutated_line": "heapq.heappush(pq, (-(A[N - 1] - B[N - 1]), (N - 1, N - 1)))",
      "code": "def max_combinations(N, K, A, B):\n    import heapq\n    A.sort()\n    B.sort()\n    pq = []\n    heapq.heapify(pq)\n    heapq.heappush(pq, (-(A[N - 1] - B[N - 1]), (N - 1, N - 1)))\n    visited = set()\n    visited.add((N - 1, N - 1))\n    result = []\n    for _ in range(K):\n        (current_sum, (i, j)) = heapq.heappop(pq)\n        result.append(-current_sum)\n        if i > 0:\n            next_sum = A[i - 1] + B[j]\n            next_indices = (i - 1, j)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n        if j > 0:\n            next_sum = A[i] + B[j - 1]\n            next_indices = (i, j - 1)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "heapq.heappush(pq, (-(A[N - 1] + B[N - 1]), (N - 1, N - 1)))",
      "mutated_line": "heapq.heappush(pq, (-(A[N - 1] * B[N - 1]), (N - 1, N - 1)))",
      "code": "def max_combinations(N, K, A, B):\n    import heapq\n    A.sort()\n    B.sort()\n    pq = []\n    heapq.heapify(pq)\n    heapq.heappush(pq, (-(A[N - 1] * B[N - 1]), (N - 1, N - 1)))\n    visited = set()\n    visited.add((N - 1, N - 1))\n    result = []\n    for _ in range(K):\n        (current_sum, (i, j)) = heapq.heappop(pq)\n        result.append(-current_sum)\n        if i > 0:\n            next_sum = A[i - 1] + B[j]\n            next_indices = (i - 1, j)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n        if j > 0:\n            next_sum = A[i] + B[j - 1]\n            next_indices = (i, j - 1)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "heapq.heappush(pq, (-(A[N - 1] + B[N - 1]), (N - 1, N - 1)))",
      "mutated_line": "heapq.heappush(pq, (-(A[N - 1] + B[N - 1]), (N + 1, N - 1)))",
      "code": "def max_combinations(N, K, A, B):\n    import heapq\n    A.sort()\n    B.sort()\n    pq = []\n    heapq.heapify(pq)\n    heapq.heappush(pq, (-(A[N - 1] + B[N - 1]), (N + 1, N - 1)))\n    visited = set()\n    visited.add((N - 1, N - 1))\n    result = []\n    for _ in range(K):\n        (current_sum, (i, j)) = heapq.heappop(pq)\n        result.append(-current_sum)\n        if i > 0:\n            next_sum = A[i - 1] + B[j]\n            next_indices = (i - 1, j)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n        if j > 0:\n            next_sum = A[i] + B[j - 1]\n            next_indices = (i, j - 1)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "heapq.heappush(pq, (-(A[N - 1] + B[N - 1]), (N - 1, N - 1)))",
      "mutated_line": "heapq.heappush(pq, (-(A[N - 1] + B[N - 1]), (N * 1, N - 1)))",
      "code": "def max_combinations(N, K, A, B):\n    import heapq\n    A.sort()\n    B.sort()\n    pq = []\n    heapq.heapify(pq)\n    heapq.heappush(pq, (-(A[N - 1] + B[N - 1]), (N * 1, N - 1)))\n    visited = set()\n    visited.add((N - 1, N - 1))\n    result = []\n    for _ in range(K):\n        (current_sum, (i, j)) = heapq.heappop(pq)\n        result.append(-current_sum)\n        if i > 0:\n            next_sum = A[i - 1] + B[j]\n            next_indices = (i - 1, j)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n        if j > 0:\n            next_sum = A[i] + B[j - 1]\n            next_indices = (i, j - 1)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "heapq.heappush(pq, (-(A[N - 1] + B[N - 1]), (N - 1, N - 1)))",
      "mutated_line": "heapq.heappush(pq, (-(A[N - 1] + B[N - 1]), (N - 1, N + 1)))",
      "code": "def max_combinations(N, K, A, B):\n    import heapq\n    A.sort()\n    B.sort()\n    pq = []\n    heapq.heapify(pq)\n    heapq.heappush(pq, (-(A[N - 1] + B[N - 1]), (N - 1, N + 1)))\n    visited = set()\n    visited.add((N - 1, N - 1))\n    result = []\n    for _ in range(K):\n        (current_sum, (i, j)) = heapq.heappop(pq)\n        result.append(-current_sum)\n        if i > 0:\n            next_sum = A[i - 1] + B[j]\n            next_indices = (i - 1, j)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n        if j > 0:\n            next_sum = A[i] + B[j - 1]\n            next_indices = (i, j - 1)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "heapq.heappush(pq, (-(A[N - 1] + B[N - 1]), (N - 1, N - 1)))",
      "mutated_line": "heapq.heappush(pq, (-(A[N - 1] + B[N - 1]), (N - 1, N * 1)))",
      "code": "def max_combinations(N, K, A, B):\n    import heapq\n    A.sort()\n    B.sort()\n    pq = []\n    heapq.heapify(pq)\n    heapq.heappush(pq, (-(A[N - 1] + B[N - 1]), (N - 1, N * 1)))\n    visited = set()\n    visited.add((N - 1, N - 1))\n    result = []\n    for _ in range(K):\n        (current_sum, (i, j)) = heapq.heappop(pq)\n        result.append(-current_sum)\n        if i > 0:\n            next_sum = A[i - 1] + B[j]\n            next_indices = (i - 1, j)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n        if j > 0:\n            next_sum = A[i] + B[j - 1]\n            next_indices = (i, j - 1)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "visited.add((N - 1, N - 1))",
      "mutated_line": "visited.add((N - 2, N - 1))",
      "code": "def max_combinations(N, K, A, B):\n    import heapq\n    A.sort()\n    B.sort()\n    pq = []\n    heapq.heapify(pq)\n    heapq.heappush(pq, (-(A[N - 1] + B[N - 1]), (N - 1, N - 1)))\n    visited = set()\n    visited.add((N - 2, N - 1))\n    result = []\n    for _ in range(K):\n        (current_sum, (i, j)) = heapq.heappop(pq)\n        result.append(-current_sum)\n        if i > 0:\n            next_sum = A[i - 1] + B[j]\n            next_indices = (i - 1, j)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n        if j > 0:\n            next_sum = A[i] + B[j - 1]\n            next_indices = (i, j - 1)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "visited.add((N - 1, N - 1))",
      "mutated_line": "visited.add((N - 0, N - 1))",
      "code": "def max_combinations(N, K, A, B):\n    import heapq\n    A.sort()\n    B.sort()\n    pq = []\n    heapq.heapify(pq)\n    heapq.heappush(pq, (-(A[N - 1] + B[N - 1]), (N - 1, N - 1)))\n    visited = set()\n    visited.add((N - 0, N - 1))\n    result = []\n    for _ in range(K):\n        (current_sum, (i, j)) = heapq.heappop(pq)\n        result.append(-current_sum)\n        if i > 0:\n            next_sum = A[i - 1] + B[j]\n            next_indices = (i - 1, j)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n        if j > 0:\n            next_sum = A[i] + B[j - 1]\n            next_indices = (i, j - 1)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "visited.add((N - 1, N - 1))",
      "mutated_line": "visited.add((N - 0, N - 1))",
      "code": "def max_combinations(N, K, A, B):\n    import heapq\n    A.sort()\n    B.sort()\n    pq = []\n    heapq.heapify(pq)\n    heapq.heappush(pq, (-(A[N - 1] + B[N - 1]), (N - 1, N - 1)))\n    visited = set()\n    visited.add((N - 0, N - 1))\n    result = []\n    for _ in range(K):\n        (current_sum, (i, j)) = heapq.heappop(pq)\n        result.append(-current_sum)\n        if i > 0:\n            next_sum = A[i - 1] + B[j]\n            next_indices = (i - 1, j)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n        if j > 0:\n            next_sum = A[i] + B[j - 1]\n            next_indices = (i, j - 1)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "visited.add((N - 1, N - 1))",
      "mutated_line": "visited.add((N - -1, N - 1))",
      "code": "def max_combinations(N, K, A, B):\n    import heapq\n    A.sort()\n    B.sort()\n    pq = []\n    heapq.heapify(pq)\n    heapq.heappush(pq, (-(A[N - 1] + B[N - 1]), (N - 1, N - 1)))\n    visited = set()\n    visited.add((N - -1, N - 1))\n    result = []\n    for _ in range(K):\n        (current_sum, (i, j)) = heapq.heappop(pq)\n        result.append(-current_sum)\n        if i > 0:\n            next_sum = A[i - 1] + B[j]\n            next_indices = (i - 1, j)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n        if j > 0:\n            next_sum = A[i] + B[j - 1]\n            next_indices = (i, j - 1)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "visited.add((N - 1, N - 1))",
      "mutated_line": "visited.add((N - 1, N - 2))",
      "code": "def max_combinations(N, K, A, B):\n    import heapq\n    A.sort()\n    B.sort()\n    pq = []\n    heapq.heapify(pq)\n    heapq.heappush(pq, (-(A[N - 1] + B[N - 1]), (N - 1, N - 1)))\n    visited = set()\n    visited.add((N - 1, N - 2))\n    result = []\n    for _ in range(K):\n        (current_sum, (i, j)) = heapq.heappop(pq)\n        result.append(-current_sum)\n        if i > 0:\n            next_sum = A[i - 1] + B[j]\n            next_indices = (i - 1, j)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n        if j > 0:\n            next_sum = A[i] + B[j - 1]\n            next_indices = (i, j - 1)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "visited.add((N - 1, N - 1))",
      "mutated_line": "visited.add((N - 1, N - 0))",
      "code": "def max_combinations(N, K, A, B):\n    import heapq\n    A.sort()\n    B.sort()\n    pq = []\n    heapq.heapify(pq)\n    heapq.heappush(pq, (-(A[N - 1] + B[N - 1]), (N - 1, N - 1)))\n    visited = set()\n    visited.add((N - 1, N - 0))\n    result = []\n    for _ in range(K):\n        (current_sum, (i, j)) = heapq.heappop(pq)\n        result.append(-current_sum)\n        if i > 0:\n            next_sum = A[i - 1] + B[j]\n            next_indices = (i - 1, j)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n        if j > 0:\n            next_sum = A[i] + B[j - 1]\n            next_indices = (i, j - 1)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "visited.add((N - 1, N - 1))",
      "mutated_line": "visited.add((N - 1, N - 0))",
      "code": "def max_combinations(N, K, A, B):\n    import heapq\n    A.sort()\n    B.sort()\n    pq = []\n    heapq.heapify(pq)\n    heapq.heappush(pq, (-(A[N - 1] + B[N - 1]), (N - 1, N - 1)))\n    visited = set()\n    visited.add((N - 1, N - 0))\n    result = []\n    for _ in range(K):\n        (current_sum, (i, j)) = heapq.heappop(pq)\n        result.append(-current_sum)\n        if i > 0:\n            next_sum = A[i - 1] + B[j]\n            next_indices = (i - 1, j)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n        if j > 0:\n            next_sum = A[i] + B[j - 1]\n            next_indices = (i, j - 1)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "visited.add((N - 1, N - 1))",
      "mutated_line": "visited.add((N - 1, N - -1))",
      "code": "def max_combinations(N, K, A, B):\n    import heapq\n    A.sort()\n    B.sort()\n    pq = []\n    heapq.heapify(pq)\n    heapq.heappush(pq, (-(A[N - 1] + B[N - 1]), (N - 1, N - 1)))\n    visited = set()\n    visited.add((N - 1, N - -1))\n    result = []\n    for _ in range(K):\n        (current_sum, (i, j)) = heapq.heappop(pq)\n        result.append(-current_sum)\n        if i > 0:\n            next_sum = A[i - 1] + B[j]\n            next_indices = (i - 1, j)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n        if j > 0:\n            next_sum = A[i] + B[j - 1]\n            next_indices = (i, j - 1)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "next_indices = (i - 1, j)",
      "mutated_line": "next_indices = (i + 1, j)",
      "code": "def max_combinations(N, K, A, B):\n    import heapq\n    A.sort()\n    B.sort()\n    pq = []\n    heapq.heapify(pq)\n    heapq.heappush(pq, (-(A[N - 1] + B[N - 1]), (N - 1, N - 1)))\n    visited = set()\n    visited.add((N - 1, N - 1))\n    result = []\n    for _ in range(K):\n        (current_sum, (i, j)) = heapq.heappop(pq)\n        result.append(-current_sum)\n        if i > 0:\n            next_sum = A[i - 1] + B[j]\n            next_indices = (i + 1, j)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n        if j > 0:\n            next_sum = A[i] + B[j - 1]\n            next_indices = (i, j - 1)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "next_indices = (i - 1, j)",
      "mutated_line": "next_indices = (i * 1, j)",
      "code": "def max_combinations(N, K, A, B):\n    import heapq\n    A.sort()\n    B.sort()\n    pq = []\n    heapq.heapify(pq)\n    heapq.heappush(pq, (-(A[N - 1] + B[N - 1]), (N - 1, N - 1)))\n    visited = set()\n    visited.add((N - 1, N - 1))\n    result = []\n    for _ in range(K):\n        (current_sum, (i, j)) = heapq.heappop(pq)\n        result.append(-current_sum)\n        if i > 0:\n            next_sum = A[i - 1] + B[j]\n            next_indices = (i * 1, j)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n        if j > 0:\n            next_sum = A[i] + B[j - 1]\n            next_indices = (i, j - 1)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "next_indices = (i, j - 1)",
      "mutated_line": "next_indices = (i, j + 1)",
      "code": "def max_combinations(N, K, A, B):\n    import heapq\n    A.sort()\n    B.sort()\n    pq = []\n    heapq.heapify(pq)\n    heapq.heappush(pq, (-(A[N - 1] + B[N - 1]), (N - 1, N - 1)))\n    visited = set()\n    visited.add((N - 1, N - 1))\n    result = []\n    for _ in range(K):\n        (current_sum, (i, j)) = heapq.heappop(pq)\n        result.append(-current_sum)\n        if i > 0:\n            next_sum = A[i - 1] + B[j]\n            next_indices = (i - 1, j)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n        if j > 0:\n            next_sum = A[i] + B[j - 1]\n            next_indices = (i, j + 1)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "next_indices = (i, j - 1)",
      "mutated_line": "next_indices = (i, j * 1)",
      "code": "def max_combinations(N, K, A, B):\n    import heapq\n    A.sort()\n    B.sort()\n    pq = []\n    heapq.heapify(pq)\n    heapq.heappush(pq, (-(A[N - 1] + B[N - 1]), (N - 1, N - 1)))\n    visited = set()\n    visited.add((N - 1, N - 1))\n    result = []\n    for _ in range(K):\n        (current_sum, (i, j)) = heapq.heappop(pq)\n        result.append(-current_sum)\n        if i > 0:\n            next_sum = A[i - 1] + B[j]\n            next_indices = (i - 1, j)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n        if j > 0:\n            next_sum = A[i] + B[j - 1]\n            next_indices = (i, j * 1)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "heapq.heappush(pq, (-(A[N - 1] + B[N - 1]), (N - 1, N - 1)))",
      "mutated_line": "heapq.heappush(pq, (-(A[N - 1] + B[N - 1]), (N - 2, N - 1)))",
      "code": "def max_combinations(N, K, A, B):\n    import heapq\n    A.sort()\n    B.sort()\n    pq = []\n    heapq.heapify(pq)\n    heapq.heappush(pq, (-(A[N - 1] + B[N - 1]), (N - 2, N - 1)))\n    visited = set()\n    visited.add((N - 1, N - 1))\n    result = []\n    for _ in range(K):\n        (current_sum, (i, j)) = heapq.heappop(pq)\n        result.append(-current_sum)\n        if i > 0:\n            next_sum = A[i - 1] + B[j]\n            next_indices = (i - 1, j)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n        if j > 0:\n            next_sum = A[i] + B[j - 1]\n            next_indices = (i, j - 1)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "heapq.heappush(pq, (-(A[N - 1] + B[N - 1]), (N - 1, N - 1)))",
      "mutated_line": "heapq.heappush(pq, (-(A[N - 1] + B[N - 1]), (N - 0, N - 1)))",
      "code": "def max_combinations(N, K, A, B):\n    import heapq\n    A.sort()\n    B.sort()\n    pq = []\n    heapq.heapify(pq)\n    heapq.heappush(pq, (-(A[N - 1] + B[N - 1]), (N - 0, N - 1)))\n    visited = set()\n    visited.add((N - 1, N - 1))\n    result = []\n    for _ in range(K):\n        (current_sum, (i, j)) = heapq.heappop(pq)\n        result.append(-current_sum)\n        if i > 0:\n            next_sum = A[i - 1] + B[j]\n            next_indices = (i - 1, j)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n        if j > 0:\n            next_sum = A[i] + B[j - 1]\n            next_indices = (i, j - 1)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "heapq.heappush(pq, (-(A[N - 1] + B[N - 1]), (N - 1, N - 1)))",
      "mutated_line": "heapq.heappush(pq, (-(A[N - 1] + B[N - 1]), (N - 0, N - 1)))",
      "code": "def max_combinations(N, K, A, B):\n    import heapq\n    A.sort()\n    B.sort()\n    pq = []\n    heapq.heapify(pq)\n    heapq.heappush(pq, (-(A[N - 1] + B[N - 1]), (N - 0, N - 1)))\n    visited = set()\n    visited.add((N - 1, N - 1))\n    result = []\n    for _ in range(K):\n        (current_sum, (i, j)) = heapq.heappop(pq)\n        result.append(-current_sum)\n        if i > 0:\n            next_sum = A[i - 1] + B[j]\n            next_indices = (i - 1, j)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n        if j > 0:\n            next_sum = A[i] + B[j - 1]\n            next_indices = (i, j - 1)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "heapq.heappush(pq, (-(A[N - 1] + B[N - 1]), (N - 1, N - 1)))",
      "mutated_line": "heapq.heappush(pq, (-(A[N - 1] + B[N - 1]), (N - -1, N - 1)))",
      "code": "def max_combinations(N, K, A, B):\n    import heapq\n    A.sort()\n    B.sort()\n    pq = []\n    heapq.heapify(pq)\n    heapq.heappush(pq, (-(A[N - 1] + B[N - 1]), (N - -1, N - 1)))\n    visited = set()\n    visited.add((N - 1, N - 1))\n    result = []\n    for _ in range(K):\n        (current_sum, (i, j)) = heapq.heappop(pq)\n        result.append(-current_sum)\n        if i > 0:\n            next_sum = A[i - 1] + B[j]\n            next_indices = (i - 1, j)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n        if j > 0:\n            next_sum = A[i] + B[j - 1]\n            next_indices = (i, j - 1)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "heapq.heappush(pq, (-(A[N - 1] + B[N - 1]), (N - 1, N - 1)))",
      "mutated_line": "heapq.heappush(pq, (-(A[N - 1] + B[N - 1]), (N - 1, N - 2)))",
      "code": "def max_combinations(N, K, A, B):\n    import heapq\n    A.sort()\n    B.sort()\n    pq = []\n    heapq.heapify(pq)\n    heapq.heappush(pq, (-(A[N - 1] + B[N - 1]), (N - 1, N - 2)))\n    visited = set()\n    visited.add((N - 1, N - 1))\n    result = []\n    for _ in range(K):\n        (current_sum, (i, j)) = heapq.heappop(pq)\n        result.append(-current_sum)\n        if i > 0:\n            next_sum = A[i - 1] + B[j]\n            next_indices = (i - 1, j)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n        if j > 0:\n            next_sum = A[i] + B[j - 1]\n            next_indices = (i, j - 1)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "heapq.heappush(pq, (-(A[N - 1] + B[N - 1]), (N - 1, N - 1)))",
      "mutated_line": "heapq.heappush(pq, (-(A[N - 1] + B[N - 1]), (N - 1, N - 0)))",
      "code": "def max_combinations(N, K, A, B):\n    import heapq\n    A.sort()\n    B.sort()\n    pq = []\n    heapq.heapify(pq)\n    heapq.heappush(pq, (-(A[N - 1] + B[N - 1]), (N - 1, N - 0)))\n    visited = set()\n    visited.add((N - 1, N - 1))\n    result = []\n    for _ in range(K):\n        (current_sum, (i, j)) = heapq.heappop(pq)\n        result.append(-current_sum)\n        if i > 0:\n            next_sum = A[i - 1] + B[j]\n            next_indices = (i - 1, j)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n        if j > 0:\n            next_sum = A[i] + B[j - 1]\n            next_indices = (i, j - 1)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "heapq.heappush(pq, (-(A[N - 1] + B[N - 1]), (N - 1, N - 1)))",
      "mutated_line": "heapq.heappush(pq, (-(A[N - 1] + B[N - 1]), (N - 1, N - 0)))",
      "code": "def max_combinations(N, K, A, B):\n    import heapq\n    A.sort()\n    B.sort()\n    pq = []\n    heapq.heapify(pq)\n    heapq.heappush(pq, (-(A[N - 1] + B[N - 1]), (N - 1, N - 0)))\n    visited = set()\n    visited.add((N - 1, N - 1))\n    result = []\n    for _ in range(K):\n        (current_sum, (i, j)) = heapq.heappop(pq)\n        result.append(-current_sum)\n        if i > 0:\n            next_sum = A[i - 1] + B[j]\n            next_indices = (i - 1, j)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n        if j > 0:\n            next_sum = A[i] + B[j - 1]\n            next_indices = (i, j - 1)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "heapq.heappush(pq, (-(A[N - 1] + B[N - 1]), (N - 1, N - 1)))",
      "mutated_line": "heapq.heappush(pq, (-(A[N - 1] + B[N - 1]), (N - 1, N - -1)))",
      "code": "def max_combinations(N, K, A, B):\n    import heapq\n    A.sort()\n    B.sort()\n    pq = []\n    heapq.heapify(pq)\n    heapq.heappush(pq, (-(A[N - 1] + B[N - 1]), (N - 1, N - -1)))\n    visited = set()\n    visited.add((N - 1, N - 1))\n    result = []\n    for _ in range(K):\n        (current_sum, (i, j)) = heapq.heappop(pq)\n        result.append(-current_sum)\n        if i > 0:\n            next_sum = A[i - 1] + B[j]\n            next_indices = (i - 1, j)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n        if j > 0:\n            next_sum = A[i] + B[j - 1]\n            next_indices = (i, j - 1)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "next_sum = A[i - 1] + B[j]",
      "mutated_line": "next_sum = A[i + 1] + B[j]",
      "code": "def max_combinations(N, K, A, B):\n    import heapq\n    A.sort()\n    B.sort()\n    pq = []\n    heapq.heapify(pq)\n    heapq.heappush(pq, (-(A[N - 1] + B[N - 1]), (N - 1, N - 1)))\n    visited = set()\n    visited.add((N - 1, N - 1))\n    result = []\n    for _ in range(K):\n        (current_sum, (i, j)) = heapq.heappop(pq)\n        result.append(-current_sum)\n        if i > 0:\n            next_sum = A[i + 1] + B[j]\n            next_indices = (i - 1, j)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n        if j > 0:\n            next_sum = A[i] + B[j - 1]\n            next_indices = (i, j - 1)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "next_sum = A[i - 1] + B[j]",
      "mutated_line": "next_sum = A[i * 1] + B[j]",
      "code": "def max_combinations(N, K, A, B):\n    import heapq\n    A.sort()\n    B.sort()\n    pq = []\n    heapq.heapify(pq)\n    heapq.heappush(pq, (-(A[N - 1] + B[N - 1]), (N - 1, N - 1)))\n    visited = set()\n    visited.add((N - 1, N - 1))\n    result = []\n    for _ in range(K):\n        (current_sum, (i, j)) = heapq.heappop(pq)\n        result.append(-current_sum)\n        if i > 0:\n            next_sum = A[i * 1] + B[j]\n            next_indices = (i - 1, j)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n        if j > 0:\n            next_sum = A[i] + B[j - 1]\n            next_indices = (i, j - 1)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "next_indices = (i - 1, j)",
      "mutated_line": "next_indices = (i - 2, j)",
      "code": "def max_combinations(N, K, A, B):\n    import heapq\n    A.sort()\n    B.sort()\n    pq = []\n    heapq.heapify(pq)\n    heapq.heappush(pq, (-(A[N - 1] + B[N - 1]), (N - 1, N - 1)))\n    visited = set()\n    visited.add((N - 1, N - 1))\n    result = []\n    for _ in range(K):\n        (current_sum, (i, j)) = heapq.heappop(pq)\n        result.append(-current_sum)\n        if i > 0:\n            next_sum = A[i - 1] + B[j]\n            next_indices = (i - 2, j)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n        if j > 0:\n            next_sum = A[i] + B[j - 1]\n            next_indices = (i, j - 1)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "next_indices = (i - 1, j)",
      "mutated_line": "next_indices = (i - 0, j)",
      "code": "def max_combinations(N, K, A, B):\n    import heapq\n    A.sort()\n    B.sort()\n    pq = []\n    heapq.heapify(pq)\n    heapq.heappush(pq, (-(A[N - 1] + B[N - 1]), (N - 1, N - 1)))\n    visited = set()\n    visited.add((N - 1, N - 1))\n    result = []\n    for _ in range(K):\n        (current_sum, (i, j)) = heapq.heappop(pq)\n        result.append(-current_sum)\n        if i > 0:\n            next_sum = A[i - 1] + B[j]\n            next_indices = (i - 0, j)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n        if j > 0:\n            next_sum = A[i] + B[j - 1]\n            next_indices = (i, j - 1)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "next_indices = (i - 1, j)",
      "mutated_line": "next_indices = (i - 0, j)",
      "code": "def max_combinations(N, K, A, B):\n    import heapq\n    A.sort()\n    B.sort()\n    pq = []\n    heapq.heapify(pq)\n    heapq.heappush(pq, (-(A[N - 1] + B[N - 1]), (N - 1, N - 1)))\n    visited = set()\n    visited.add((N - 1, N - 1))\n    result = []\n    for _ in range(K):\n        (current_sum, (i, j)) = heapq.heappop(pq)\n        result.append(-current_sum)\n        if i > 0:\n            next_sum = A[i - 1] + B[j]\n            next_indices = (i - 0, j)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n        if j > 0:\n            next_sum = A[i] + B[j - 1]\n            next_indices = (i, j - 1)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "next_indices = (i - 1, j)",
      "mutated_line": "next_indices = (i - -1, j)",
      "code": "def max_combinations(N, K, A, B):\n    import heapq\n    A.sort()\n    B.sort()\n    pq = []\n    heapq.heapify(pq)\n    heapq.heappush(pq, (-(A[N - 1] + B[N - 1]), (N - 1, N - 1)))\n    visited = set()\n    visited.add((N - 1, N - 1))\n    result = []\n    for _ in range(K):\n        (current_sum, (i, j)) = heapq.heappop(pq)\n        result.append(-current_sum)\n        if i > 0:\n            next_sum = A[i - 1] + B[j]\n            next_indices = (i - -1, j)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n        if j > 0:\n            next_sum = A[i] + B[j - 1]\n            next_indices = (i, j - 1)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "next_sum = A[i] + B[j - 1]",
      "mutated_line": "next_sum = A[i] + B[j + 1]",
      "code": "def max_combinations(N, K, A, B):\n    import heapq\n    A.sort()\n    B.sort()\n    pq = []\n    heapq.heapify(pq)\n    heapq.heappush(pq, (-(A[N - 1] + B[N - 1]), (N - 1, N - 1)))\n    visited = set()\n    visited.add((N - 1, N - 1))\n    result = []\n    for _ in range(K):\n        (current_sum, (i, j)) = heapq.heappop(pq)\n        result.append(-current_sum)\n        if i > 0:\n            next_sum = A[i - 1] + B[j]\n            next_indices = (i - 1, j)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n        if j > 0:\n            next_sum = A[i] + B[j + 1]\n            next_indices = (i, j - 1)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "next_sum = A[i] + B[j - 1]",
      "mutated_line": "next_sum = A[i] + B[j * 1]",
      "code": "def max_combinations(N, K, A, B):\n    import heapq\n    A.sort()\n    B.sort()\n    pq = []\n    heapq.heapify(pq)\n    heapq.heappush(pq, (-(A[N - 1] + B[N - 1]), (N - 1, N - 1)))\n    visited = set()\n    visited.add((N - 1, N - 1))\n    result = []\n    for _ in range(K):\n        (current_sum, (i, j)) = heapq.heappop(pq)\n        result.append(-current_sum)\n        if i > 0:\n            next_sum = A[i - 1] + B[j]\n            next_indices = (i - 1, j)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n        if j > 0:\n            next_sum = A[i] + B[j * 1]\n            next_indices = (i, j - 1)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "next_indices = (i, j - 1)",
      "mutated_line": "next_indices = (i, j - 2)",
      "code": "def max_combinations(N, K, A, B):\n    import heapq\n    A.sort()\n    B.sort()\n    pq = []\n    heapq.heapify(pq)\n    heapq.heappush(pq, (-(A[N - 1] + B[N - 1]), (N - 1, N - 1)))\n    visited = set()\n    visited.add((N - 1, N - 1))\n    result = []\n    for _ in range(K):\n        (current_sum, (i, j)) = heapq.heappop(pq)\n        result.append(-current_sum)\n        if i > 0:\n            next_sum = A[i - 1] + B[j]\n            next_indices = (i - 1, j)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n        if j > 0:\n            next_sum = A[i] + B[j - 1]\n            next_indices = (i, j - 2)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "next_indices = (i, j - 1)",
      "mutated_line": "next_indices = (i, j - 0)",
      "code": "def max_combinations(N, K, A, B):\n    import heapq\n    A.sort()\n    B.sort()\n    pq = []\n    heapq.heapify(pq)\n    heapq.heappush(pq, (-(A[N - 1] + B[N - 1]), (N - 1, N - 1)))\n    visited = set()\n    visited.add((N - 1, N - 1))\n    result = []\n    for _ in range(K):\n        (current_sum, (i, j)) = heapq.heappop(pq)\n        result.append(-current_sum)\n        if i > 0:\n            next_sum = A[i - 1] + B[j]\n            next_indices = (i - 1, j)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n        if j > 0:\n            next_sum = A[i] + B[j - 1]\n            next_indices = (i, j - 0)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "next_indices = (i, j - 1)",
      "mutated_line": "next_indices = (i, j - 0)",
      "code": "def max_combinations(N, K, A, B):\n    import heapq\n    A.sort()\n    B.sort()\n    pq = []\n    heapq.heapify(pq)\n    heapq.heappush(pq, (-(A[N - 1] + B[N - 1]), (N - 1, N - 1)))\n    visited = set()\n    visited.add((N - 1, N - 1))\n    result = []\n    for _ in range(K):\n        (current_sum, (i, j)) = heapq.heappop(pq)\n        result.append(-current_sum)\n        if i > 0:\n            next_sum = A[i - 1] + B[j]\n            next_indices = (i - 1, j)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n        if j > 0:\n            next_sum = A[i] + B[j - 1]\n            next_indices = (i, j - 0)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "next_indices = (i, j - 1)",
      "mutated_line": "next_indices = (i, j - -1)",
      "code": "def max_combinations(N, K, A, B):\n    import heapq\n    A.sort()\n    B.sort()\n    pq = []\n    heapq.heapify(pq)\n    heapq.heappush(pq, (-(A[N - 1] + B[N - 1]), (N - 1, N - 1)))\n    visited = set()\n    visited.add((N - 1, N - 1))\n    result = []\n    for _ in range(K):\n        (current_sum, (i, j)) = heapq.heappop(pq)\n        result.append(-current_sum)\n        if i > 0:\n            next_sum = A[i - 1] + B[j]\n            next_indices = (i - 1, j)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n        if j > 0:\n            next_sum = A[i] + B[j - 1]\n            next_indices = (i, j - -1)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "heapq.heappush(pq, (-(A[N - 1] + B[N - 1]), (N - 1, N - 1)))",
      "mutated_line": "heapq.heappush(pq, (-(A[N + 1] + B[N - 1]), (N - 1, N - 1)))",
      "code": "def max_combinations(N, K, A, B):\n    import heapq\n    A.sort()\n    B.sort()\n    pq = []\n    heapq.heapify(pq)\n    heapq.heappush(pq, (-(A[N + 1] + B[N - 1]), (N - 1, N - 1)))\n    visited = set()\n    visited.add((N - 1, N - 1))\n    result = []\n    for _ in range(K):\n        (current_sum, (i, j)) = heapq.heappop(pq)\n        result.append(-current_sum)\n        if i > 0:\n            next_sum = A[i - 1] + B[j]\n            next_indices = (i - 1, j)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n        if j > 0:\n            next_sum = A[i] + B[j - 1]\n            next_indices = (i, j - 1)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "heapq.heappush(pq, (-(A[N - 1] + B[N - 1]), (N - 1, N - 1)))",
      "mutated_line": "heapq.heappush(pq, (-(A[N * 1] + B[N - 1]), (N - 1, N - 1)))",
      "code": "def max_combinations(N, K, A, B):\n    import heapq\n    A.sort()\n    B.sort()\n    pq = []\n    heapq.heapify(pq)\n    heapq.heappush(pq, (-(A[N * 1] + B[N - 1]), (N - 1, N - 1)))\n    visited = set()\n    visited.add((N - 1, N - 1))\n    result = []\n    for _ in range(K):\n        (current_sum, (i, j)) = heapq.heappop(pq)\n        result.append(-current_sum)\n        if i > 0:\n            next_sum = A[i - 1] + B[j]\n            next_indices = (i - 1, j)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n        if j > 0:\n            next_sum = A[i] + B[j - 1]\n            next_indices = (i, j - 1)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "heapq.heappush(pq, (-(A[N - 1] + B[N - 1]), (N - 1, N - 1)))",
      "mutated_line": "heapq.heappush(pq, (-(A[N - 1] + B[N + 1]), (N - 1, N - 1)))",
      "code": "def max_combinations(N, K, A, B):\n    import heapq\n    A.sort()\n    B.sort()\n    pq = []\n    heapq.heapify(pq)\n    heapq.heappush(pq, (-(A[N - 1] + B[N + 1]), (N - 1, N - 1)))\n    visited = set()\n    visited.add((N - 1, N - 1))\n    result = []\n    for _ in range(K):\n        (current_sum, (i, j)) = heapq.heappop(pq)\n        result.append(-current_sum)\n        if i > 0:\n            next_sum = A[i - 1] + B[j]\n            next_indices = (i - 1, j)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n        if j > 0:\n            next_sum = A[i] + B[j - 1]\n            next_indices = (i, j - 1)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "heapq.heappush(pq, (-(A[N - 1] + B[N - 1]), (N - 1, N - 1)))",
      "mutated_line": "heapq.heappush(pq, (-(A[N - 1] + B[N * 1]), (N - 1, N - 1)))",
      "code": "def max_combinations(N, K, A, B):\n    import heapq\n    A.sort()\n    B.sort()\n    pq = []\n    heapq.heapify(pq)\n    heapq.heappush(pq, (-(A[N - 1] + B[N * 1]), (N - 1, N - 1)))\n    visited = set()\n    visited.add((N - 1, N - 1))\n    result = []\n    for _ in range(K):\n        (current_sum, (i, j)) = heapq.heappop(pq)\n        result.append(-current_sum)\n        if i > 0:\n            next_sum = A[i - 1] + B[j]\n            next_indices = (i - 1, j)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n        if j > 0:\n            next_sum = A[i] + B[j - 1]\n            next_indices = (i, j - 1)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "next_sum = A[i - 1] + B[j]",
      "mutated_line": "next_sum = A[i - 2] + B[j]",
      "code": "def max_combinations(N, K, A, B):\n    import heapq\n    A.sort()\n    B.sort()\n    pq = []\n    heapq.heapify(pq)\n    heapq.heappush(pq, (-(A[N - 1] + B[N - 1]), (N - 1, N - 1)))\n    visited = set()\n    visited.add((N - 1, N - 1))\n    result = []\n    for _ in range(K):\n        (current_sum, (i, j)) = heapq.heappop(pq)\n        result.append(-current_sum)\n        if i > 0:\n            next_sum = A[i - 2] + B[j]\n            next_indices = (i - 1, j)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n        if j > 0:\n            next_sum = A[i] + B[j - 1]\n            next_indices = (i, j - 1)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "next_sum = A[i - 1] + B[j]",
      "mutated_line": "next_sum = A[i - 0] + B[j]",
      "code": "def max_combinations(N, K, A, B):\n    import heapq\n    A.sort()\n    B.sort()\n    pq = []\n    heapq.heapify(pq)\n    heapq.heappush(pq, (-(A[N - 1] + B[N - 1]), (N - 1, N - 1)))\n    visited = set()\n    visited.add((N - 1, N - 1))\n    result = []\n    for _ in range(K):\n        (current_sum, (i, j)) = heapq.heappop(pq)\n        result.append(-current_sum)\n        if i > 0:\n            next_sum = A[i - 0] + B[j]\n            next_indices = (i - 1, j)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n        if j > 0:\n            next_sum = A[i] + B[j - 1]\n            next_indices = (i, j - 1)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "next_sum = A[i - 1] + B[j]",
      "mutated_line": "next_sum = A[i - 0] + B[j]",
      "code": "def max_combinations(N, K, A, B):\n    import heapq\n    A.sort()\n    B.sort()\n    pq = []\n    heapq.heapify(pq)\n    heapq.heappush(pq, (-(A[N - 1] + B[N - 1]), (N - 1, N - 1)))\n    visited = set()\n    visited.add((N - 1, N - 1))\n    result = []\n    for _ in range(K):\n        (current_sum, (i, j)) = heapq.heappop(pq)\n        result.append(-current_sum)\n        if i > 0:\n            next_sum = A[i - 0] + B[j]\n            next_indices = (i - 1, j)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n        if j > 0:\n            next_sum = A[i] + B[j - 1]\n            next_indices = (i, j - 1)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "next_sum = A[i - 1] + B[j]",
      "mutated_line": "next_sum = A[i - -1] + B[j]",
      "code": "def max_combinations(N, K, A, B):\n    import heapq\n    A.sort()\n    B.sort()\n    pq = []\n    heapq.heapify(pq)\n    heapq.heappush(pq, (-(A[N - 1] + B[N - 1]), (N - 1, N - 1)))\n    visited = set()\n    visited.add((N - 1, N - 1))\n    result = []\n    for _ in range(K):\n        (current_sum, (i, j)) = heapq.heappop(pq)\n        result.append(-current_sum)\n        if i > 0:\n            next_sum = A[i - -1] + B[j]\n            next_indices = (i - 1, j)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n        if j > 0:\n            next_sum = A[i] + B[j - 1]\n            next_indices = (i, j - 1)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n    return result"
    },
    {
      "operator": "UOI",
      "lineno": 31,
      "original_line": "heapq.heappush(pq, (-next_sum, next_indices))",
      "mutated_line": "heapq.heappush(pq, (+next_sum, next_indices))",
      "code": "def max_combinations(N, K, A, B):\n    import heapq\n    A.sort()\n    B.sort()\n    pq = []\n    heapq.heapify(pq)\n    heapq.heappush(pq, (-(A[N - 1] + B[N - 1]), (N - 1, N - 1)))\n    visited = set()\n    visited.add((N - 1, N - 1))\n    result = []\n    for _ in range(K):\n        (current_sum, (i, j)) = heapq.heappop(pq)\n        result.append(-current_sum)\n        if i > 0:\n            next_sum = A[i - 1] + B[j]\n            next_indices = (i - 1, j)\n            if next_indices not in visited:\n                heapq.heappush(pq, (+next_sum, next_indices))\n                visited.add(next_indices)\n        if j > 0:\n            next_sum = A[i] + B[j - 1]\n            next_indices = (i, j - 1)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "next_sum = A[i] + B[j - 1]",
      "mutated_line": "next_sum = A[i] + B[j - 2]",
      "code": "def max_combinations(N, K, A, B):\n    import heapq\n    A.sort()\n    B.sort()\n    pq = []\n    heapq.heapify(pq)\n    heapq.heappush(pq, (-(A[N - 1] + B[N - 1]), (N - 1, N - 1)))\n    visited = set()\n    visited.add((N - 1, N - 1))\n    result = []\n    for _ in range(K):\n        (current_sum, (i, j)) = heapq.heappop(pq)\n        result.append(-current_sum)\n        if i > 0:\n            next_sum = A[i - 1] + B[j]\n            next_indices = (i - 1, j)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n        if j > 0:\n            next_sum = A[i] + B[j - 2]\n            next_indices = (i, j - 1)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "next_sum = A[i] + B[j - 1]",
      "mutated_line": "next_sum = A[i] + B[j - 0]",
      "code": "def max_combinations(N, K, A, B):\n    import heapq\n    A.sort()\n    B.sort()\n    pq = []\n    heapq.heapify(pq)\n    heapq.heappush(pq, (-(A[N - 1] + B[N - 1]), (N - 1, N - 1)))\n    visited = set()\n    visited.add((N - 1, N - 1))\n    result = []\n    for _ in range(K):\n        (current_sum, (i, j)) = heapq.heappop(pq)\n        result.append(-current_sum)\n        if i > 0:\n            next_sum = A[i - 1] + B[j]\n            next_indices = (i - 1, j)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n        if j > 0:\n            next_sum = A[i] + B[j - 0]\n            next_indices = (i, j - 1)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "next_sum = A[i] + B[j - 1]",
      "mutated_line": "next_sum = A[i] + B[j - 0]",
      "code": "def max_combinations(N, K, A, B):\n    import heapq\n    A.sort()\n    B.sort()\n    pq = []\n    heapq.heapify(pq)\n    heapq.heappush(pq, (-(A[N - 1] + B[N - 1]), (N - 1, N - 1)))\n    visited = set()\n    visited.add((N - 1, N - 1))\n    result = []\n    for _ in range(K):\n        (current_sum, (i, j)) = heapq.heappop(pq)\n        result.append(-current_sum)\n        if i > 0:\n            next_sum = A[i - 1] + B[j]\n            next_indices = (i - 1, j)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n        if j > 0:\n            next_sum = A[i] + B[j - 0]\n            next_indices = (i, j - 1)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "next_sum = A[i] + B[j - 1]",
      "mutated_line": "next_sum = A[i] + B[j - -1]",
      "code": "def max_combinations(N, K, A, B):\n    import heapq\n    A.sort()\n    B.sort()\n    pq = []\n    heapq.heapify(pq)\n    heapq.heappush(pq, (-(A[N - 1] + B[N - 1]), (N - 1, N - 1)))\n    visited = set()\n    visited.add((N - 1, N - 1))\n    result = []\n    for _ in range(K):\n        (current_sum, (i, j)) = heapq.heappop(pq)\n        result.append(-current_sum)\n        if i > 0:\n            next_sum = A[i - 1] + B[j]\n            next_indices = (i - 1, j)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n        if j > 0:\n            next_sum = A[i] + B[j - -1]\n            next_indices = (i, j - 1)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n    return result"
    },
    {
      "operator": "UOI",
      "lineno": 38,
      "original_line": "heapq.heappush(pq, (-next_sum, next_indices))",
      "mutated_line": "heapq.heappush(pq, (+next_sum, next_indices))",
      "code": "def max_combinations(N, K, A, B):\n    import heapq\n    A.sort()\n    B.sort()\n    pq = []\n    heapq.heapify(pq)\n    heapq.heappush(pq, (-(A[N - 1] + B[N - 1]), (N - 1, N - 1)))\n    visited = set()\n    visited.add((N - 1, N - 1))\n    result = []\n    for _ in range(K):\n        (current_sum, (i, j)) = heapq.heappop(pq)\n        result.append(-current_sum)\n        if i > 0:\n            next_sum = A[i - 1] + B[j]\n            next_indices = (i - 1, j)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n        if j > 0:\n            next_sum = A[i] + B[j - 1]\n            next_indices = (i, j - 1)\n            if next_indices not in visited:\n                heapq.heappush(pq, (+next_sum, next_indices))\n                visited.add(next_indices)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "heapq.heappush(pq, (-(A[N - 1] + B[N - 1]), (N - 1, N - 1)))",
      "mutated_line": "heapq.heappush(pq, (-(A[N - 2] + B[N - 1]), (N - 1, N - 1)))",
      "code": "def max_combinations(N, K, A, B):\n    import heapq\n    A.sort()\n    B.sort()\n    pq = []\n    heapq.heapify(pq)\n    heapq.heappush(pq, (-(A[N - 2] + B[N - 1]), (N - 1, N - 1)))\n    visited = set()\n    visited.add((N - 1, N - 1))\n    result = []\n    for _ in range(K):\n        (current_sum, (i, j)) = heapq.heappop(pq)\n        result.append(-current_sum)\n        if i > 0:\n            next_sum = A[i - 1] + B[j]\n            next_indices = (i - 1, j)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n        if j > 0:\n            next_sum = A[i] + B[j - 1]\n            next_indices = (i, j - 1)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "heapq.heappush(pq, (-(A[N - 1] + B[N - 1]), (N - 1, N - 1)))",
      "mutated_line": "heapq.heappush(pq, (-(A[N - 0] + B[N - 1]), (N - 1, N - 1)))",
      "code": "def max_combinations(N, K, A, B):\n    import heapq\n    A.sort()\n    B.sort()\n    pq = []\n    heapq.heapify(pq)\n    heapq.heappush(pq, (-(A[N - 0] + B[N - 1]), (N - 1, N - 1)))\n    visited = set()\n    visited.add((N - 1, N - 1))\n    result = []\n    for _ in range(K):\n        (current_sum, (i, j)) = heapq.heappop(pq)\n        result.append(-current_sum)\n        if i > 0:\n            next_sum = A[i - 1] + B[j]\n            next_indices = (i - 1, j)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n        if j > 0:\n            next_sum = A[i] + B[j - 1]\n            next_indices = (i, j - 1)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "heapq.heappush(pq, (-(A[N - 1] + B[N - 1]), (N - 1, N - 1)))",
      "mutated_line": "heapq.heappush(pq, (-(A[N - 0] + B[N - 1]), (N - 1, N - 1)))",
      "code": "def max_combinations(N, K, A, B):\n    import heapq\n    A.sort()\n    B.sort()\n    pq = []\n    heapq.heapify(pq)\n    heapq.heappush(pq, (-(A[N - 0] + B[N - 1]), (N - 1, N - 1)))\n    visited = set()\n    visited.add((N - 1, N - 1))\n    result = []\n    for _ in range(K):\n        (current_sum, (i, j)) = heapq.heappop(pq)\n        result.append(-current_sum)\n        if i > 0:\n            next_sum = A[i - 1] + B[j]\n            next_indices = (i - 1, j)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n        if j > 0:\n            next_sum = A[i] + B[j - 1]\n            next_indices = (i, j - 1)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "heapq.heappush(pq, (-(A[N - 1] + B[N - 1]), (N - 1, N - 1)))",
      "mutated_line": "heapq.heappush(pq, (-(A[N - -1] + B[N - 1]), (N - 1, N - 1)))",
      "code": "def max_combinations(N, K, A, B):\n    import heapq\n    A.sort()\n    B.sort()\n    pq = []\n    heapq.heapify(pq)\n    heapq.heappush(pq, (-(A[N - -1] + B[N - 1]), (N - 1, N - 1)))\n    visited = set()\n    visited.add((N - 1, N - 1))\n    result = []\n    for _ in range(K):\n        (current_sum, (i, j)) = heapq.heappop(pq)\n        result.append(-current_sum)\n        if i > 0:\n            next_sum = A[i - 1] + B[j]\n            next_indices = (i - 1, j)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n        if j > 0:\n            next_sum = A[i] + B[j - 1]\n            next_indices = (i, j - 1)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "heapq.heappush(pq, (-(A[N - 1] + B[N - 1]), (N - 1, N - 1)))",
      "mutated_line": "heapq.heappush(pq, (-(A[N - 1] + B[N - 2]), (N - 1, N - 1)))",
      "code": "def max_combinations(N, K, A, B):\n    import heapq\n    A.sort()\n    B.sort()\n    pq = []\n    heapq.heapify(pq)\n    heapq.heappush(pq, (-(A[N - 1] + B[N - 2]), (N - 1, N - 1)))\n    visited = set()\n    visited.add((N - 1, N - 1))\n    result = []\n    for _ in range(K):\n        (current_sum, (i, j)) = heapq.heappop(pq)\n        result.append(-current_sum)\n        if i > 0:\n            next_sum = A[i - 1] + B[j]\n            next_indices = (i - 1, j)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n        if j > 0:\n            next_sum = A[i] + B[j - 1]\n            next_indices = (i, j - 1)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "heapq.heappush(pq, (-(A[N - 1] + B[N - 1]), (N - 1, N - 1)))",
      "mutated_line": "heapq.heappush(pq, (-(A[N - 1] + B[N - 0]), (N - 1, N - 1)))",
      "code": "def max_combinations(N, K, A, B):\n    import heapq\n    A.sort()\n    B.sort()\n    pq = []\n    heapq.heapify(pq)\n    heapq.heappush(pq, (-(A[N - 1] + B[N - 0]), (N - 1, N - 1)))\n    visited = set()\n    visited.add((N - 1, N - 1))\n    result = []\n    for _ in range(K):\n        (current_sum, (i, j)) = heapq.heappop(pq)\n        result.append(-current_sum)\n        if i > 0:\n            next_sum = A[i - 1] + B[j]\n            next_indices = (i - 1, j)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n        if j > 0:\n            next_sum = A[i] + B[j - 1]\n            next_indices = (i, j - 1)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "heapq.heappush(pq, (-(A[N - 1] + B[N - 1]), (N - 1, N - 1)))",
      "mutated_line": "heapq.heappush(pq, (-(A[N - 1] + B[N - 0]), (N - 1, N - 1)))",
      "code": "def max_combinations(N, K, A, B):\n    import heapq\n    A.sort()\n    B.sort()\n    pq = []\n    heapq.heapify(pq)\n    heapq.heappush(pq, (-(A[N - 1] + B[N - 0]), (N - 1, N - 1)))\n    visited = set()\n    visited.add((N - 1, N - 1))\n    result = []\n    for _ in range(K):\n        (current_sum, (i, j)) = heapq.heappop(pq)\n        result.append(-current_sum)\n        if i > 0:\n            next_sum = A[i - 1] + B[j]\n            next_indices = (i - 1, j)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n        if j > 0:\n            next_sum = A[i] + B[j - 1]\n            next_indices = (i, j - 1)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "heapq.heappush(pq, (-(A[N - 1] + B[N - 1]), (N - 1, N - 1)))",
      "mutated_line": "heapq.heappush(pq, (-(A[N - 1] + B[N - -1]), (N - 1, N - 1)))",
      "code": "def max_combinations(N, K, A, B):\n    import heapq\n    A.sort()\n    B.sort()\n    pq = []\n    heapq.heapify(pq)\n    heapq.heappush(pq, (-(A[N - 1] + B[N - -1]), (N - 1, N - 1)))\n    visited = set()\n    visited.add((N - 1, N - 1))\n    result = []\n    for _ in range(K):\n        (current_sum, (i, j)) = heapq.heappop(pq)\n        result.append(-current_sum)\n        if i > 0:\n            next_sum = A[i - 1] + B[j]\n            next_indices = (i - 1, j)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n        if j > 0:\n            next_sum = A[i] + B[j - 1]\n            next_indices = (i, j - 1)\n            if next_indices not in visited:\n                heapq.heappush(pq, (-next_sum, next_indices))\n                visited.add(next_indices)\n    return result"
    }
  ]
}