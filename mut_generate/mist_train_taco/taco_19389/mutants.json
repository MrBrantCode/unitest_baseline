{
  "task_id": "taco_19389",
  "entry_point": "largest_component_size",
  "mutant_count": 80,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "MAXPRIME = 100001",
      "mutated_line": "MAXPRIME = 100002",
      "code": "from collections import defaultdict\nMAXPRIME = 100002\nisPrime = [0 for _ in range(MAXPRIME + 1)]\nisPrime[0] = -1\nisPrime[1] = -1\nfor i in range(2, MAXPRIME):\n    if isPrime[i] == 0:\n        for multiple in range(i * i, MAXPRIME + 1, i):\n            if isPrime[multiple] == 0:\n                isPrime[multiple] = i\n        isPrime[i] = i\n\ndef largest_component_size(A):\n    label = defaultdict(int)\n\n    def findRoot(key):\n        if label[key] > 0:\n            label[key] = findRoot(label[key])\n            return label[key]\n        else:\n            return key\n\n    def mergeRoot(k1, k2):\n        (r1, r2) = (findRoot(k1), findRoot(k2))\n        if r1 != r2:\n            (r1, r2) = (min(r1, r2), max(r1, r2))\n            label[r1] += label[r2]\n            label[r2] = r1\n        return r1\n    for x in A:\n        root_id = 0\n        prime_factors = set()\n        while isPrime[x] != -1:\n            p = isPrime[x]\n            root_id = findRoot(p) if root_id == 0 else mergeRoot(root_id, p)\n            x //= p\n        label[root_id] -= 1\n    return -min(label.values())"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "MAXPRIME = 100001",
      "mutated_line": "MAXPRIME = 100000",
      "code": "from collections import defaultdict\nMAXPRIME = 100000\nisPrime = [0 for _ in range(MAXPRIME + 1)]\nisPrime[0] = -1\nisPrime[1] = -1\nfor i in range(2, MAXPRIME):\n    if isPrime[i] == 0:\n        for multiple in range(i * i, MAXPRIME + 1, i):\n            if isPrime[multiple] == 0:\n                isPrime[multiple] = i\n        isPrime[i] = i\n\ndef largest_component_size(A):\n    label = defaultdict(int)\n\n    def findRoot(key):\n        if label[key] > 0:\n            label[key] = findRoot(label[key])\n            return label[key]\n        else:\n            return key\n\n    def mergeRoot(k1, k2):\n        (r1, r2) = (findRoot(k1), findRoot(k2))\n        if r1 != r2:\n            (r1, r2) = (min(r1, r2), max(r1, r2))\n            label[r1] += label[r2]\n            label[r2] = r1\n        return r1\n    for x in A:\n        root_id = 0\n        prime_factors = set()\n        while isPrime[x] != -1:\n            p = isPrime[x]\n            root_id = findRoot(p) if root_id == 0 else mergeRoot(root_id, p)\n            x //= p\n        label[root_id] -= 1\n    return -min(label.values())"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "MAXPRIME = 100001",
      "mutated_line": "MAXPRIME = 0",
      "code": "from collections import defaultdict\nMAXPRIME = 0\nisPrime = [0 for _ in range(MAXPRIME + 1)]\nisPrime[0] = -1\nisPrime[1] = -1\nfor i in range(2, MAXPRIME):\n    if isPrime[i] == 0:\n        for multiple in range(i * i, MAXPRIME + 1, i):\n            if isPrime[multiple] == 0:\n                isPrime[multiple] = i\n        isPrime[i] = i\n\ndef largest_component_size(A):\n    label = defaultdict(int)\n\n    def findRoot(key):\n        if label[key] > 0:\n            label[key] = findRoot(label[key])\n            return label[key]\n        else:\n            return key\n\n    def mergeRoot(k1, k2):\n        (r1, r2) = (findRoot(k1), findRoot(k2))\n        if r1 != r2:\n            (r1, r2) = (min(r1, r2), max(r1, r2))\n            label[r1] += label[r2]\n            label[r2] = r1\n        return r1\n    for x in A:\n        root_id = 0\n        prime_factors = set()\n        while isPrime[x] != -1:\n            p = isPrime[x]\n            root_id = findRoot(p) if root_id == 0 else mergeRoot(root_id, p)\n            x //= p\n        label[root_id] -= 1\n    return -min(label.values())"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "MAXPRIME = 100001",
      "mutated_line": "MAXPRIME = 1",
      "code": "from collections import defaultdict\nMAXPRIME = 1\nisPrime = [0 for _ in range(MAXPRIME + 1)]\nisPrime[0] = -1\nisPrime[1] = -1\nfor i in range(2, MAXPRIME):\n    if isPrime[i] == 0:\n        for multiple in range(i * i, MAXPRIME + 1, i):\n            if isPrime[multiple] == 0:\n                isPrime[multiple] = i\n        isPrime[i] = i\n\ndef largest_component_size(A):\n    label = defaultdict(int)\n\n    def findRoot(key):\n        if label[key] > 0:\n            label[key] = findRoot(label[key])\n            return label[key]\n        else:\n            return key\n\n    def mergeRoot(k1, k2):\n        (r1, r2) = (findRoot(k1), findRoot(k2))\n        if r1 != r2:\n            (r1, r2) = (min(r1, r2), max(r1, r2))\n            label[r1] += label[r2]\n            label[r2] = r1\n        return r1\n    for x in A:\n        root_id = 0\n        prime_factors = set()\n        while isPrime[x] != -1:\n            p = isPrime[x]\n            root_id = findRoot(p) if root_id == 0 else mergeRoot(root_id, p)\n            x //= p\n        label[root_id] -= 1\n    return -min(label.values())"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "MAXPRIME = 100001",
      "mutated_line": "MAXPRIME = -100001",
      "code": "from collections import defaultdict\nMAXPRIME = -100001\nisPrime = [0 for _ in range(MAXPRIME + 1)]\nisPrime[0] = -1\nisPrime[1] = -1\nfor i in range(2, MAXPRIME):\n    if isPrime[i] == 0:\n        for multiple in range(i * i, MAXPRIME + 1, i):\n            if isPrime[multiple] == 0:\n                isPrime[multiple] = i\n        isPrime[i] = i\n\ndef largest_component_size(A):\n    label = defaultdict(int)\n\n    def findRoot(key):\n        if label[key] > 0:\n            label[key] = findRoot(label[key])\n            return label[key]\n        else:\n            return key\n\n    def mergeRoot(k1, k2):\n        (r1, r2) = (findRoot(k1), findRoot(k2))\n        if r1 != r2:\n            (r1, r2) = (min(r1, r2), max(r1, r2))\n            label[r1] += label[r2]\n            label[r2] = r1\n        return r1\n    for x in A:\n        root_id = 0\n        prime_factors = set()\n        while isPrime[x] != -1:\n            p = isPrime[x]\n            root_id = findRoot(p) if root_id == 0 else mergeRoot(root_id, p)\n            x //= p\n        label[root_id] -= 1\n    return -min(label.values())"
    },
    {
      "operator": "UOI",
      "lineno": 6,
      "original_line": "isPrime[0] = -1",
      "mutated_line": "isPrime[0] = +1",
      "code": "from collections import defaultdict\nMAXPRIME = 100001\nisPrime = [0 for _ in range(MAXPRIME + 1)]\nisPrime[0] = +1\nisPrime[1] = -1\nfor i in range(2, MAXPRIME):\n    if isPrime[i] == 0:\n        for multiple in range(i * i, MAXPRIME + 1, i):\n            if isPrime[multiple] == 0:\n                isPrime[multiple] = i\n        isPrime[i] = i\n\ndef largest_component_size(A):\n    label = defaultdict(int)\n\n    def findRoot(key):\n        if label[key] > 0:\n            label[key] = findRoot(label[key])\n            return label[key]\n        else:\n            return key\n\n    def mergeRoot(k1, k2):\n        (r1, r2) = (findRoot(k1), findRoot(k2))\n        if r1 != r2:\n            (r1, r2) = (min(r1, r2), max(r1, r2))\n            label[r1] += label[r2]\n            label[r2] = r1\n        return r1\n    for x in A:\n        root_id = 0\n        prime_factors = set()\n        while isPrime[x] != -1:\n            p = isPrime[x]\n            root_id = findRoot(p) if root_id == 0 else mergeRoot(root_id, p)\n            x //= p\n        label[root_id] -= 1\n    return -min(label.values())"
    },
    {
      "operator": "UOI",
      "lineno": 7,
      "original_line": "isPrime[1] = -1",
      "mutated_line": "isPrime[1] = +1",
      "code": "from collections import defaultdict\nMAXPRIME = 100001\nisPrime = [0 for _ in range(MAXPRIME + 1)]\nisPrime[0] = -1\nisPrime[1] = +1\nfor i in range(2, MAXPRIME):\n    if isPrime[i] == 0:\n        for multiple in range(i * i, MAXPRIME + 1, i):\n            if isPrime[multiple] == 0:\n                isPrime[multiple] = i\n        isPrime[i] = i\n\ndef largest_component_size(A):\n    label = defaultdict(int)\n\n    def findRoot(key):\n        if label[key] > 0:\n            label[key] = findRoot(label[key])\n            return label[key]\n        else:\n            return key\n\n    def mergeRoot(k1, k2):\n        (r1, r2) = (findRoot(k1), findRoot(k2))\n        if r1 != r2:\n            (r1, r2) = (min(r1, r2), max(r1, r2))\n            label[r1] += label[r2]\n            label[r2] = r1\n        return r1\n    for x in A:\n        root_id = 0\n        prime_factors = set()\n        while isPrime[x] != -1:\n            p = isPrime[x]\n            root_id = findRoot(p) if root_id == 0 else mergeRoot(root_id, p)\n            x //= p\n        label[root_id] -= 1\n    return -min(label.values())"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "isPrime = [0 for _ in range(MAXPRIME + 1)]",
      "mutated_line": "isPrime = [1 for _ in range(MAXPRIME + 1)]",
      "code": "from collections import defaultdict\nMAXPRIME = 100001\nisPrime = [1 for _ in range(MAXPRIME + 1)]\nisPrime[0] = -1\nisPrime[1] = -1\nfor i in range(2, MAXPRIME):\n    if isPrime[i] == 0:\n        for multiple in range(i * i, MAXPRIME + 1, i):\n            if isPrime[multiple] == 0:\n                isPrime[multiple] = i\n        isPrime[i] = i\n\ndef largest_component_size(A):\n    label = defaultdict(int)\n\n    def findRoot(key):\n        if label[key] > 0:\n            label[key] = findRoot(label[key])\n            return label[key]\n        else:\n            return key\n\n    def mergeRoot(k1, k2):\n        (r1, r2) = (findRoot(k1), findRoot(k2))\n        if r1 != r2:\n            (r1, r2) = (min(r1, r2), max(r1, r2))\n            label[r1] += label[r2]\n            label[r2] = r1\n        return r1\n    for x in A:\n        root_id = 0\n        prime_factors = set()\n        while isPrime[x] != -1:\n            p = isPrime[x]\n            root_id = findRoot(p) if root_id == 0 else mergeRoot(root_id, p)\n            x //= p\n        label[root_id] -= 1\n    return -min(label.values())"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "isPrime = [0 for _ in range(MAXPRIME + 1)]",
      "mutated_line": "isPrime = [-1 for _ in range(MAXPRIME + 1)]",
      "code": "from collections import defaultdict\nMAXPRIME = 100001\nisPrime = [-1 for _ in range(MAXPRIME + 1)]\nisPrime[0] = -1\nisPrime[1] = -1\nfor i in range(2, MAXPRIME):\n    if isPrime[i] == 0:\n        for multiple in range(i * i, MAXPRIME + 1, i):\n            if isPrime[multiple] == 0:\n                isPrime[multiple] = i\n        isPrime[i] = i\n\ndef largest_component_size(A):\n    label = defaultdict(int)\n\n    def findRoot(key):\n        if label[key] > 0:\n            label[key] = findRoot(label[key])\n            return label[key]\n        else:\n            return key\n\n    def mergeRoot(k1, k2):\n        (r1, r2) = (findRoot(k1), findRoot(k2))\n        if r1 != r2:\n            (r1, r2) = (min(r1, r2), max(r1, r2))\n            label[r1] += label[r2]\n            label[r2] = r1\n        return r1\n    for x in A:\n        root_id = 0\n        prime_factors = set()\n        while isPrime[x] != -1:\n            p = isPrime[x]\n            root_id = findRoot(p) if root_id == 0 else mergeRoot(root_id, p)\n            x //= p\n        label[root_id] -= 1\n    return -min(label.values())"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "isPrime = [0 for _ in range(MAXPRIME + 1)]",
      "mutated_line": "isPrime = [1 for _ in range(MAXPRIME + 1)]",
      "code": "from collections import defaultdict\nMAXPRIME = 100001\nisPrime = [1 for _ in range(MAXPRIME + 1)]\nisPrime[0] = -1\nisPrime[1] = -1\nfor i in range(2, MAXPRIME):\n    if isPrime[i] == 0:\n        for multiple in range(i * i, MAXPRIME + 1, i):\n            if isPrime[multiple] == 0:\n                isPrime[multiple] = i\n        isPrime[i] = i\n\ndef largest_component_size(A):\n    label = defaultdict(int)\n\n    def findRoot(key):\n        if label[key] > 0:\n            label[key] = findRoot(label[key])\n            return label[key]\n        else:\n            return key\n\n    def mergeRoot(k1, k2):\n        (r1, r2) = (findRoot(k1), findRoot(k2))\n        if r1 != r2:\n            (r1, r2) = (min(r1, r2), max(r1, r2))\n            label[r1] += label[r2]\n            label[r2] = r1\n        return r1\n    for x in A:\n        root_id = 0\n        prime_factors = set()\n        while isPrime[x] != -1:\n            p = isPrime[x]\n            root_id = findRoot(p) if root_id == 0 else mergeRoot(root_id, p)\n            x //= p\n        label[root_id] -= 1\n    return -min(label.values())"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "isPrime[0] = -1",
      "mutated_line": "isPrime[1] = -1",
      "code": "from collections import defaultdict\nMAXPRIME = 100001\nisPrime = [0 for _ in range(MAXPRIME + 1)]\nisPrime[1] = -1\nisPrime[1] = -1\nfor i in range(2, MAXPRIME):\n    if isPrime[i] == 0:\n        for multiple in range(i * i, MAXPRIME + 1, i):\n            if isPrime[multiple] == 0:\n                isPrime[multiple] = i\n        isPrime[i] = i\n\ndef largest_component_size(A):\n    label = defaultdict(int)\n\n    def findRoot(key):\n        if label[key] > 0:\n            label[key] = findRoot(label[key])\n            return label[key]\n        else:\n            return key\n\n    def mergeRoot(k1, k2):\n        (r1, r2) = (findRoot(k1), findRoot(k2))\n        if r1 != r2:\n            (r1, r2) = (min(r1, r2), max(r1, r2))\n            label[r1] += label[r2]\n            label[r2] = r1\n        return r1\n    for x in A:\n        root_id = 0\n        prime_factors = set()\n        while isPrime[x] != -1:\n            p = isPrime[x]\n            root_id = findRoot(p) if root_id == 0 else mergeRoot(root_id, p)\n            x //= p\n        label[root_id] -= 1\n    return -min(label.values())"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "isPrime[0] = -1",
      "mutated_line": "isPrime[-1] = -1",
      "code": "from collections import defaultdict\nMAXPRIME = 100001\nisPrime = [0 for _ in range(MAXPRIME + 1)]\nisPrime[-1] = -1\nisPrime[1] = -1\nfor i in range(2, MAXPRIME):\n    if isPrime[i] == 0:\n        for multiple in range(i * i, MAXPRIME + 1, i):\n            if isPrime[multiple] == 0:\n                isPrime[multiple] = i\n        isPrime[i] = i\n\ndef largest_component_size(A):\n    label = defaultdict(int)\n\n    def findRoot(key):\n        if label[key] > 0:\n            label[key] = findRoot(label[key])\n            return label[key]\n        else:\n            return key\n\n    def mergeRoot(k1, k2):\n        (r1, r2) = (findRoot(k1), findRoot(k2))\n        if r1 != r2:\n            (r1, r2) = (min(r1, r2), max(r1, r2))\n            label[r1] += label[r2]\n            label[r2] = r1\n        return r1\n    for x in A:\n        root_id = 0\n        prime_factors = set()\n        while isPrime[x] != -1:\n            p = isPrime[x]\n            root_id = findRoot(p) if root_id == 0 else mergeRoot(root_id, p)\n            x //= p\n        label[root_id] -= 1\n    return -min(label.values())"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "isPrime[0] = -1",
      "mutated_line": "isPrime[1] = -1",
      "code": "from collections import defaultdict\nMAXPRIME = 100001\nisPrime = [0 for _ in range(MAXPRIME + 1)]\nisPrime[1] = -1\nisPrime[1] = -1\nfor i in range(2, MAXPRIME):\n    if isPrime[i] == 0:\n        for multiple in range(i * i, MAXPRIME + 1, i):\n            if isPrime[multiple] == 0:\n                isPrime[multiple] = i\n        isPrime[i] = i\n\ndef largest_component_size(A):\n    label = defaultdict(int)\n\n    def findRoot(key):\n        if label[key] > 0:\n            label[key] = findRoot(label[key])\n            return label[key]\n        else:\n            return key\n\n    def mergeRoot(k1, k2):\n        (r1, r2) = (findRoot(k1), findRoot(k2))\n        if r1 != r2:\n            (r1, r2) = (min(r1, r2), max(r1, r2))\n            label[r1] += label[r2]\n            label[r2] = r1\n        return r1\n    for x in A:\n        root_id = 0\n        prime_factors = set()\n        while isPrime[x] != -1:\n            p = isPrime[x]\n            root_id = findRoot(p) if root_id == 0 else mergeRoot(root_id, p)\n            x //= p\n        label[root_id] -= 1\n    return -min(label.values())"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "isPrime[0] = -1",
      "mutated_line": "isPrime[0] = -2",
      "code": "from collections import defaultdict\nMAXPRIME = 100001\nisPrime = [0 for _ in range(MAXPRIME + 1)]\nisPrime[0] = -2\nisPrime[1] = -1\nfor i in range(2, MAXPRIME):\n    if isPrime[i] == 0:\n        for multiple in range(i * i, MAXPRIME + 1, i):\n            if isPrime[multiple] == 0:\n                isPrime[multiple] = i\n        isPrime[i] = i\n\ndef largest_component_size(A):\n    label = defaultdict(int)\n\n    def findRoot(key):\n        if label[key] > 0:\n            label[key] = findRoot(label[key])\n            return label[key]\n        else:\n            return key\n\n    def mergeRoot(k1, k2):\n        (r1, r2) = (findRoot(k1), findRoot(k2))\n        if r1 != r2:\n            (r1, r2) = (min(r1, r2), max(r1, r2))\n            label[r1] += label[r2]\n            label[r2] = r1\n        return r1\n    for x in A:\n        root_id = 0\n        prime_factors = set()\n        while isPrime[x] != -1:\n            p = isPrime[x]\n            root_id = findRoot(p) if root_id == 0 else mergeRoot(root_id, p)\n            x //= p\n        label[root_id] -= 1\n    return -min(label.values())"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "isPrime[0] = -1",
      "mutated_line": "isPrime[0] = -0",
      "code": "from collections import defaultdict\nMAXPRIME = 100001\nisPrime = [0 for _ in range(MAXPRIME + 1)]\nisPrime[0] = -0\nisPrime[1] = -1\nfor i in range(2, MAXPRIME):\n    if isPrime[i] == 0:\n        for multiple in range(i * i, MAXPRIME + 1, i):\n            if isPrime[multiple] == 0:\n                isPrime[multiple] = i\n        isPrime[i] = i\n\ndef largest_component_size(A):\n    label = defaultdict(int)\n\n    def findRoot(key):\n        if label[key] > 0:\n            label[key] = findRoot(label[key])\n            return label[key]\n        else:\n            return key\n\n    def mergeRoot(k1, k2):\n        (r1, r2) = (findRoot(k1), findRoot(k2))\n        if r1 != r2:\n            (r1, r2) = (min(r1, r2), max(r1, r2))\n            label[r1] += label[r2]\n            label[r2] = r1\n        return r1\n    for x in A:\n        root_id = 0\n        prime_factors = set()\n        while isPrime[x] != -1:\n            p = isPrime[x]\n            root_id = findRoot(p) if root_id == 0 else mergeRoot(root_id, p)\n            x //= p\n        label[root_id] -= 1\n    return -min(label.values())"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "isPrime[0] = -1",
      "mutated_line": "isPrime[0] = -0",
      "code": "from collections import defaultdict\nMAXPRIME = 100001\nisPrime = [0 for _ in range(MAXPRIME + 1)]\nisPrime[0] = -0\nisPrime[1] = -1\nfor i in range(2, MAXPRIME):\n    if isPrime[i] == 0:\n        for multiple in range(i * i, MAXPRIME + 1, i):\n            if isPrime[multiple] == 0:\n                isPrime[multiple] = i\n        isPrime[i] = i\n\ndef largest_component_size(A):\n    label = defaultdict(int)\n\n    def findRoot(key):\n        if label[key] > 0:\n            label[key] = findRoot(label[key])\n            return label[key]\n        else:\n            return key\n\n    def mergeRoot(k1, k2):\n        (r1, r2) = (findRoot(k1), findRoot(k2))\n        if r1 != r2:\n            (r1, r2) = (min(r1, r2), max(r1, r2))\n            label[r1] += label[r2]\n            label[r2] = r1\n        return r1\n    for x in A:\n        root_id = 0\n        prime_factors = set()\n        while isPrime[x] != -1:\n            p = isPrime[x]\n            root_id = findRoot(p) if root_id == 0 else mergeRoot(root_id, p)\n            x //= p\n        label[root_id] -= 1\n    return -min(label.values())"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "isPrime[0] = -1",
      "mutated_line": "isPrime[0] = --1",
      "code": "from collections import defaultdict\nMAXPRIME = 100001\nisPrime = [0 for _ in range(MAXPRIME + 1)]\nisPrime[0] = --1\nisPrime[1] = -1\nfor i in range(2, MAXPRIME):\n    if isPrime[i] == 0:\n        for multiple in range(i * i, MAXPRIME + 1, i):\n            if isPrime[multiple] == 0:\n                isPrime[multiple] = i\n        isPrime[i] = i\n\ndef largest_component_size(A):\n    label = defaultdict(int)\n\n    def findRoot(key):\n        if label[key] > 0:\n            label[key] = findRoot(label[key])\n            return label[key]\n        else:\n            return key\n\n    def mergeRoot(k1, k2):\n        (r1, r2) = (findRoot(k1), findRoot(k2))\n        if r1 != r2:\n            (r1, r2) = (min(r1, r2), max(r1, r2))\n            label[r1] += label[r2]\n            label[r2] = r1\n        return r1\n    for x in A:\n        root_id = 0\n        prime_factors = set()\n        while isPrime[x] != -1:\n            p = isPrime[x]\n            root_id = findRoot(p) if root_id == 0 else mergeRoot(root_id, p)\n            x //= p\n        label[root_id] -= 1\n    return -min(label.values())"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "isPrime[1] = -1",
      "mutated_line": "isPrime[2] = -1",
      "code": "from collections import defaultdict\nMAXPRIME = 100001\nisPrime = [0 for _ in range(MAXPRIME + 1)]\nisPrime[0] = -1\nisPrime[2] = -1\nfor i in range(2, MAXPRIME):\n    if isPrime[i] == 0:\n        for multiple in range(i * i, MAXPRIME + 1, i):\n            if isPrime[multiple] == 0:\n                isPrime[multiple] = i\n        isPrime[i] = i\n\ndef largest_component_size(A):\n    label = defaultdict(int)\n\n    def findRoot(key):\n        if label[key] > 0:\n            label[key] = findRoot(label[key])\n            return label[key]\n        else:\n            return key\n\n    def mergeRoot(k1, k2):\n        (r1, r2) = (findRoot(k1), findRoot(k2))\n        if r1 != r2:\n            (r1, r2) = (min(r1, r2), max(r1, r2))\n            label[r1] += label[r2]\n            label[r2] = r1\n        return r1\n    for x in A:\n        root_id = 0\n        prime_factors = set()\n        while isPrime[x] != -1:\n            p = isPrime[x]\n            root_id = findRoot(p) if root_id == 0 else mergeRoot(root_id, p)\n            x //= p\n        label[root_id] -= 1\n    return -min(label.values())"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "isPrime[1] = -1",
      "mutated_line": "isPrime[0] = -1",
      "code": "from collections import defaultdict\nMAXPRIME = 100001\nisPrime = [0 for _ in range(MAXPRIME + 1)]\nisPrime[0] = -1\nisPrime[0] = -1\nfor i in range(2, MAXPRIME):\n    if isPrime[i] == 0:\n        for multiple in range(i * i, MAXPRIME + 1, i):\n            if isPrime[multiple] == 0:\n                isPrime[multiple] = i\n        isPrime[i] = i\n\ndef largest_component_size(A):\n    label = defaultdict(int)\n\n    def findRoot(key):\n        if label[key] > 0:\n            label[key] = findRoot(label[key])\n            return label[key]\n        else:\n            return key\n\n    def mergeRoot(k1, k2):\n        (r1, r2) = (findRoot(k1), findRoot(k2))\n        if r1 != r2:\n            (r1, r2) = (min(r1, r2), max(r1, r2))\n            label[r1] += label[r2]\n            label[r2] = r1\n        return r1\n    for x in A:\n        root_id = 0\n        prime_factors = set()\n        while isPrime[x] != -1:\n            p = isPrime[x]\n            root_id = findRoot(p) if root_id == 0 else mergeRoot(root_id, p)\n            x //= p\n        label[root_id] -= 1\n    return -min(label.values())"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "isPrime[1] = -1",
      "mutated_line": "isPrime[0] = -1",
      "code": "from collections import defaultdict\nMAXPRIME = 100001\nisPrime = [0 for _ in range(MAXPRIME + 1)]\nisPrime[0] = -1\nisPrime[0] = -1\nfor i in range(2, MAXPRIME):\n    if isPrime[i] == 0:\n        for multiple in range(i * i, MAXPRIME + 1, i):\n            if isPrime[multiple] == 0:\n                isPrime[multiple] = i\n        isPrime[i] = i\n\ndef largest_component_size(A):\n    label = defaultdict(int)\n\n    def findRoot(key):\n        if label[key] > 0:\n            label[key] = findRoot(label[key])\n            return label[key]\n        else:\n            return key\n\n    def mergeRoot(k1, k2):\n        (r1, r2) = (findRoot(k1), findRoot(k2))\n        if r1 != r2:\n            (r1, r2) = (min(r1, r2), max(r1, r2))\n            label[r1] += label[r2]\n            label[r2] = r1\n        return r1\n    for x in A:\n        root_id = 0\n        prime_factors = set()\n        while isPrime[x] != -1:\n            p = isPrime[x]\n            root_id = findRoot(p) if root_id == 0 else mergeRoot(root_id, p)\n            x //= p\n        label[root_id] -= 1\n    return -min(label.values())"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "isPrime[1] = -1",
      "mutated_line": "isPrime[-1] = -1",
      "code": "from collections import defaultdict\nMAXPRIME = 100001\nisPrime = [0 for _ in range(MAXPRIME + 1)]\nisPrime[0] = -1\nisPrime[-1] = -1\nfor i in range(2, MAXPRIME):\n    if isPrime[i] == 0:\n        for multiple in range(i * i, MAXPRIME + 1, i):\n            if isPrime[multiple] == 0:\n                isPrime[multiple] = i\n        isPrime[i] = i\n\ndef largest_component_size(A):\n    label = defaultdict(int)\n\n    def findRoot(key):\n        if label[key] > 0:\n            label[key] = findRoot(label[key])\n            return label[key]\n        else:\n            return key\n\n    def mergeRoot(k1, k2):\n        (r1, r2) = (findRoot(k1), findRoot(k2))\n        if r1 != r2:\n            (r1, r2) = (min(r1, r2), max(r1, r2))\n            label[r1] += label[r2]\n            label[r2] = r1\n        return r1\n    for x in A:\n        root_id = 0\n        prime_factors = set()\n        while isPrime[x] != -1:\n            p = isPrime[x]\n            root_id = findRoot(p) if root_id == 0 else mergeRoot(root_id, p)\n            x //= p\n        label[root_id] -= 1\n    return -min(label.values())"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "isPrime[1] = -1",
      "mutated_line": "isPrime[1] = -2",
      "code": "from collections import defaultdict\nMAXPRIME = 100001\nisPrime = [0 for _ in range(MAXPRIME + 1)]\nisPrime[0] = -1\nisPrime[1] = -2\nfor i in range(2, MAXPRIME):\n    if isPrime[i] == 0:\n        for multiple in range(i * i, MAXPRIME + 1, i):\n            if isPrime[multiple] == 0:\n                isPrime[multiple] = i\n        isPrime[i] = i\n\ndef largest_component_size(A):\n    label = defaultdict(int)\n\n    def findRoot(key):\n        if label[key] > 0:\n            label[key] = findRoot(label[key])\n            return label[key]\n        else:\n            return key\n\n    def mergeRoot(k1, k2):\n        (r1, r2) = (findRoot(k1), findRoot(k2))\n        if r1 != r2:\n            (r1, r2) = (min(r1, r2), max(r1, r2))\n            label[r1] += label[r2]\n            label[r2] = r1\n        return r1\n    for x in A:\n        root_id = 0\n        prime_factors = set()\n        while isPrime[x] != -1:\n            p = isPrime[x]\n            root_id = findRoot(p) if root_id == 0 else mergeRoot(root_id, p)\n            x //= p\n        label[root_id] -= 1\n    return -min(label.values())"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "isPrime[1] = -1",
      "mutated_line": "isPrime[1] = -0",
      "code": "from collections import defaultdict\nMAXPRIME = 100001\nisPrime = [0 for _ in range(MAXPRIME + 1)]\nisPrime[0] = -1\nisPrime[1] = -0\nfor i in range(2, MAXPRIME):\n    if isPrime[i] == 0:\n        for multiple in range(i * i, MAXPRIME + 1, i):\n            if isPrime[multiple] == 0:\n                isPrime[multiple] = i\n        isPrime[i] = i\n\ndef largest_component_size(A):\n    label = defaultdict(int)\n\n    def findRoot(key):\n        if label[key] > 0:\n            label[key] = findRoot(label[key])\n            return label[key]\n        else:\n            return key\n\n    def mergeRoot(k1, k2):\n        (r1, r2) = (findRoot(k1), findRoot(k2))\n        if r1 != r2:\n            (r1, r2) = (min(r1, r2), max(r1, r2))\n            label[r1] += label[r2]\n            label[r2] = r1\n        return r1\n    for x in A:\n        root_id = 0\n        prime_factors = set()\n        while isPrime[x] != -1:\n            p = isPrime[x]\n            root_id = findRoot(p) if root_id == 0 else mergeRoot(root_id, p)\n            x //= p\n        label[root_id] -= 1\n    return -min(label.values())"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "isPrime[1] = -1",
      "mutated_line": "isPrime[1] = -0",
      "code": "from collections import defaultdict\nMAXPRIME = 100001\nisPrime = [0 for _ in range(MAXPRIME + 1)]\nisPrime[0] = -1\nisPrime[1] = -0\nfor i in range(2, MAXPRIME):\n    if isPrime[i] == 0:\n        for multiple in range(i * i, MAXPRIME + 1, i):\n            if isPrime[multiple] == 0:\n                isPrime[multiple] = i\n        isPrime[i] = i\n\ndef largest_component_size(A):\n    label = defaultdict(int)\n\n    def findRoot(key):\n        if label[key] > 0:\n            label[key] = findRoot(label[key])\n            return label[key]\n        else:\n            return key\n\n    def mergeRoot(k1, k2):\n        (r1, r2) = (findRoot(k1), findRoot(k2))\n        if r1 != r2:\n            (r1, r2) = (min(r1, r2), max(r1, r2))\n            label[r1] += label[r2]\n            label[r2] = r1\n        return r1\n    for x in A:\n        root_id = 0\n        prime_factors = set()\n        while isPrime[x] != -1:\n            p = isPrime[x]\n            root_id = findRoot(p) if root_id == 0 else mergeRoot(root_id, p)\n            x //= p\n        label[root_id] -= 1\n    return -min(label.values())"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "isPrime[1] = -1",
      "mutated_line": "isPrime[1] = --1",
      "code": "from collections import defaultdict\nMAXPRIME = 100001\nisPrime = [0 for _ in range(MAXPRIME + 1)]\nisPrime[0] = -1\nisPrime[1] = --1\nfor i in range(2, MAXPRIME):\n    if isPrime[i] == 0:\n        for multiple in range(i * i, MAXPRIME + 1, i):\n            if isPrime[multiple] == 0:\n                isPrime[multiple] = i\n        isPrime[i] = i\n\ndef largest_component_size(A):\n    label = defaultdict(int)\n\n    def findRoot(key):\n        if label[key] > 0:\n            label[key] = findRoot(label[key])\n            return label[key]\n        else:\n            return key\n\n    def mergeRoot(k1, k2):\n        (r1, r2) = (findRoot(k1), findRoot(k2))\n        if r1 != r2:\n            (r1, r2) = (min(r1, r2), max(r1, r2))\n            label[r1] += label[r2]\n            label[r2] = r1\n        return r1\n    for x in A:\n        root_id = 0\n        prime_factors = set()\n        while isPrime[x] != -1:\n            p = isPrime[x]\n            root_id = findRoot(p) if root_id == 0 else mergeRoot(root_id, p)\n            x //= p\n        label[root_id] -= 1\n    return -min(label.values())"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(2, MAXPRIME):",
      "mutated_line": "for i in range(3, MAXPRIME):",
      "code": "from collections import defaultdict\nMAXPRIME = 100001\nisPrime = [0 for _ in range(MAXPRIME + 1)]\nisPrime[0] = -1\nisPrime[1] = -1\nfor i in range(3, MAXPRIME):\n    if isPrime[i] == 0:\n        for multiple in range(i * i, MAXPRIME + 1, i):\n            if isPrime[multiple] == 0:\n                isPrime[multiple] = i\n        isPrime[i] = i\n\ndef largest_component_size(A):\n    label = defaultdict(int)\n\n    def findRoot(key):\n        if label[key] > 0:\n            label[key] = findRoot(label[key])\n            return label[key]\n        else:\n            return key\n\n    def mergeRoot(k1, k2):\n        (r1, r2) = (findRoot(k1), findRoot(k2))\n        if r1 != r2:\n            (r1, r2) = (min(r1, r2), max(r1, r2))\n            label[r1] += label[r2]\n            label[r2] = r1\n        return r1\n    for x in A:\n        root_id = 0\n        prime_factors = set()\n        while isPrime[x] != -1:\n            p = isPrime[x]\n            root_id = findRoot(p) if root_id == 0 else mergeRoot(root_id, p)\n            x //= p\n        label[root_id] -= 1\n    return -min(label.values())"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(2, MAXPRIME):",
      "mutated_line": "for i in range(1, MAXPRIME):",
      "code": "from collections import defaultdict\nMAXPRIME = 100001\nisPrime = [0 for _ in range(MAXPRIME + 1)]\nisPrime[0] = -1\nisPrime[1] = -1\nfor i in range(1, MAXPRIME):\n    if isPrime[i] == 0:\n        for multiple in range(i * i, MAXPRIME + 1, i):\n            if isPrime[multiple] == 0:\n                isPrime[multiple] = i\n        isPrime[i] = i\n\ndef largest_component_size(A):\n    label = defaultdict(int)\n\n    def findRoot(key):\n        if label[key] > 0:\n            label[key] = findRoot(label[key])\n            return label[key]\n        else:\n            return key\n\n    def mergeRoot(k1, k2):\n        (r1, r2) = (findRoot(k1), findRoot(k2))\n        if r1 != r2:\n            (r1, r2) = (min(r1, r2), max(r1, r2))\n            label[r1] += label[r2]\n            label[r2] = r1\n        return r1\n    for x in A:\n        root_id = 0\n        prime_factors = set()\n        while isPrime[x] != -1:\n            p = isPrime[x]\n            root_id = findRoot(p) if root_id == 0 else mergeRoot(root_id, p)\n            x //= p\n        label[root_id] -= 1\n    return -min(label.values())"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(2, MAXPRIME):",
      "mutated_line": "for i in range(0, MAXPRIME):",
      "code": "from collections import defaultdict\nMAXPRIME = 100001\nisPrime = [0 for _ in range(MAXPRIME + 1)]\nisPrime[0] = -1\nisPrime[1] = -1\nfor i in range(0, MAXPRIME):\n    if isPrime[i] == 0:\n        for multiple in range(i * i, MAXPRIME + 1, i):\n            if isPrime[multiple] == 0:\n                isPrime[multiple] = i\n        isPrime[i] = i\n\ndef largest_component_size(A):\n    label = defaultdict(int)\n\n    def findRoot(key):\n        if label[key] > 0:\n            label[key] = findRoot(label[key])\n            return label[key]\n        else:\n            return key\n\n    def mergeRoot(k1, k2):\n        (r1, r2) = (findRoot(k1), findRoot(k2))\n        if r1 != r2:\n            (r1, r2) = (min(r1, r2), max(r1, r2))\n            label[r1] += label[r2]\n            label[r2] = r1\n        return r1\n    for x in A:\n        root_id = 0\n        prime_factors = set()\n        while isPrime[x] != -1:\n            p = isPrime[x]\n            root_id = findRoot(p) if root_id == 0 else mergeRoot(root_id, p)\n            x //= p\n        label[root_id] -= 1\n    return -min(label.values())"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(2, MAXPRIME):",
      "mutated_line": "for i in range(1, MAXPRIME):",
      "code": "from collections import defaultdict\nMAXPRIME = 100001\nisPrime = [0 for _ in range(MAXPRIME + 1)]\nisPrime[0] = -1\nisPrime[1] = -1\nfor i in range(1, MAXPRIME):\n    if isPrime[i] == 0:\n        for multiple in range(i * i, MAXPRIME + 1, i):\n            if isPrime[multiple] == 0:\n                isPrime[multiple] = i\n        isPrime[i] = i\n\ndef largest_component_size(A):\n    label = defaultdict(int)\n\n    def findRoot(key):\n        if label[key] > 0:\n            label[key] = findRoot(label[key])\n            return label[key]\n        else:\n            return key\n\n    def mergeRoot(k1, k2):\n        (r1, r2) = (findRoot(k1), findRoot(k2))\n        if r1 != r2:\n            (r1, r2) = (min(r1, r2), max(r1, r2))\n            label[r1] += label[r2]\n            label[r2] = r1\n        return r1\n    for x in A:\n        root_id = 0\n        prime_factors = set()\n        while isPrime[x] != -1:\n            p = isPrime[x]\n            root_id = findRoot(p) if root_id == 0 else mergeRoot(root_id, p)\n            x //= p\n        label[root_id] -= 1\n    return -min(label.values())"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(2, MAXPRIME):",
      "mutated_line": "for i in range(-2, MAXPRIME):",
      "code": "from collections import defaultdict\nMAXPRIME = 100001\nisPrime = [0 for _ in range(MAXPRIME + 1)]\nisPrime[0] = -1\nisPrime[1] = -1\nfor i in range(-2, MAXPRIME):\n    if isPrime[i] == 0:\n        for multiple in range(i * i, MAXPRIME + 1, i):\n            if isPrime[multiple] == 0:\n                isPrime[multiple] = i\n        isPrime[i] = i\n\ndef largest_component_size(A):\n    label = defaultdict(int)\n\n    def findRoot(key):\n        if label[key] > 0:\n            label[key] = findRoot(label[key])\n            return label[key]\n        else:\n            return key\n\n    def mergeRoot(k1, k2):\n        (r1, r2) = (findRoot(k1), findRoot(k2))\n        if r1 != r2:\n            (r1, r2) = (min(r1, r2), max(r1, r2))\n            label[r1] += label[r2]\n            label[r2] = r1\n        return r1\n    for x in A:\n        root_id = 0\n        prime_factors = set()\n        while isPrime[x] != -1:\n            p = isPrime[x]\n            root_id = findRoot(p) if root_id == 0 else mergeRoot(root_id, p)\n            x //= p\n        label[root_id] -= 1\n    return -min(label.values())"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if isPrime[i] == 0:",
      "mutated_line": "if isPrime[i] != 0:",
      "code": "from collections import defaultdict\nMAXPRIME = 100001\nisPrime = [0 for _ in range(MAXPRIME + 1)]\nisPrime[0] = -1\nisPrime[1] = -1\nfor i in range(2, MAXPRIME):\n    if isPrime[i] != 0:\n        for multiple in range(i * i, MAXPRIME + 1, i):\n            if isPrime[multiple] == 0:\n                isPrime[multiple] = i\n        isPrime[i] = i\n\ndef largest_component_size(A):\n    label = defaultdict(int)\n\n    def findRoot(key):\n        if label[key] > 0:\n            label[key] = findRoot(label[key])\n            return label[key]\n        else:\n            return key\n\n    def mergeRoot(k1, k2):\n        (r1, r2) = (findRoot(k1), findRoot(k2))\n        if r1 != r2:\n            (r1, r2) = (min(r1, r2), max(r1, r2))\n            label[r1] += label[r2]\n            label[r2] = r1\n        return r1\n    for x in A:\n        root_id = 0\n        prime_factors = set()\n        while isPrime[x] != -1:\n            p = isPrime[x]\n            root_id = findRoot(p) if root_id == 0 else mergeRoot(root_id, p)\n            x //= p\n        label[root_id] -= 1\n    return -min(label.values())"
    },
    {
      "operator": "ASR",
      "lineno": 40,
      "original_line": "label[root_id] -= 1",
      "mutated_line": "label[root_id] += 1",
      "code": "from collections import defaultdict\nMAXPRIME = 100001\nisPrime = [0 for _ in range(MAXPRIME + 1)]\nisPrime[0] = -1\nisPrime[1] = -1\nfor i in range(2, MAXPRIME):\n    if isPrime[i] == 0:\n        for multiple in range(i * i, MAXPRIME + 1, i):\n            if isPrime[multiple] == 0:\n                isPrime[multiple] = i\n        isPrime[i] = i\n\ndef largest_component_size(A):\n    label = defaultdict(int)\n\n    def findRoot(key):\n        if label[key] > 0:\n            label[key] = findRoot(label[key])\n            return label[key]\n        else:\n            return key\n\n    def mergeRoot(k1, k2):\n        (r1, r2) = (findRoot(k1), findRoot(k2))\n        if r1 != r2:\n            (r1, r2) = (min(r1, r2), max(r1, r2))\n            label[r1] += label[r2]\n            label[r2] = r1\n        return r1\n    for x in A:\n        root_id = 0\n        prime_factors = set()\n        while isPrime[x] != -1:\n            p = isPrime[x]\n            root_id = findRoot(p) if root_id == 0 else mergeRoot(root_id, p)\n            x //= p\n        label[root_id] += 1\n    return -min(label.values())"
    },
    {
      "operator": "UOI",
      "lineno": 42,
      "original_line": "return -min(label.values())",
      "mutated_line": "return +min(label.values())",
      "code": "from collections import defaultdict\nMAXPRIME = 100001\nisPrime = [0 for _ in range(MAXPRIME + 1)]\nisPrime[0] = -1\nisPrime[1] = -1\nfor i in range(2, MAXPRIME):\n    if isPrime[i] == 0:\n        for multiple in range(i * i, MAXPRIME + 1, i):\n            if isPrime[multiple] == 0:\n                isPrime[multiple] = i\n        isPrime[i] = i\n\ndef largest_component_size(A):\n    label = defaultdict(int)\n\n    def findRoot(key):\n        if label[key] > 0:\n            label[key] = findRoot(label[key])\n            return label[key]\n        else:\n            return key\n\n    def mergeRoot(k1, k2):\n        (r1, r2) = (findRoot(k1), findRoot(k2))\n        if r1 != r2:\n            (r1, r2) = (min(r1, r2), max(r1, r2))\n            label[r1] += label[r2]\n            label[r2] = r1\n        return r1\n    for x in A:\n        root_id = 0\n        prime_factors = set()\n        while isPrime[x] != -1:\n            p = isPrime[x]\n            root_id = findRoot(p) if root_id == 0 else mergeRoot(root_id, p)\n            x //= p\n        label[root_id] -= 1\n    return +min(label.values())"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if isPrime[i] == 0:",
      "mutated_line": "if isPrime[i] == 1:",
      "code": "from collections import defaultdict\nMAXPRIME = 100001\nisPrime = [0 for _ in range(MAXPRIME + 1)]\nisPrime[0] = -1\nisPrime[1] = -1\nfor i in range(2, MAXPRIME):\n    if isPrime[i] == 1:\n        for multiple in range(i * i, MAXPRIME + 1, i):\n            if isPrime[multiple] == 0:\n                isPrime[multiple] = i\n        isPrime[i] = i\n\ndef largest_component_size(A):\n    label = defaultdict(int)\n\n    def findRoot(key):\n        if label[key] > 0:\n            label[key] = findRoot(label[key])\n            return label[key]\n        else:\n            return key\n\n    def mergeRoot(k1, k2):\n        (r1, r2) = (findRoot(k1), findRoot(k2))\n        if r1 != r2:\n            (r1, r2) = (min(r1, r2), max(r1, r2))\n            label[r1] += label[r2]\n            label[r2] = r1\n        return r1\n    for x in A:\n        root_id = 0\n        prime_factors = set()\n        while isPrime[x] != -1:\n            p = isPrime[x]\n            root_id = findRoot(p) if root_id == 0 else mergeRoot(root_id, p)\n            x //= p\n        label[root_id] -= 1\n    return -min(label.values())"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if isPrime[i] == 0:",
      "mutated_line": "if isPrime[i] == -1:",
      "code": "from collections import defaultdict\nMAXPRIME = 100001\nisPrime = [0 for _ in range(MAXPRIME + 1)]\nisPrime[0] = -1\nisPrime[1] = -1\nfor i in range(2, MAXPRIME):\n    if isPrime[i] == -1:\n        for multiple in range(i * i, MAXPRIME + 1, i):\n            if isPrime[multiple] == 0:\n                isPrime[multiple] = i\n        isPrime[i] = i\n\ndef largest_component_size(A):\n    label = defaultdict(int)\n\n    def findRoot(key):\n        if label[key] > 0:\n            label[key] = findRoot(label[key])\n            return label[key]\n        else:\n            return key\n\n    def mergeRoot(k1, k2):\n        (r1, r2) = (findRoot(k1), findRoot(k2))\n        if r1 != r2:\n            (r1, r2) = (min(r1, r2), max(r1, r2))\n            label[r1] += label[r2]\n            label[r2] = r1\n        return r1\n    for x in A:\n        root_id = 0\n        prime_factors = set()\n        while isPrime[x] != -1:\n            p = isPrime[x]\n            root_id = findRoot(p) if root_id == 0 else mergeRoot(root_id, p)\n            x //= p\n        label[root_id] -= 1\n    return -min(label.values())"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if isPrime[i] == 0:",
      "mutated_line": "if isPrime[i] == 1:",
      "code": "from collections import defaultdict\nMAXPRIME = 100001\nisPrime = [0 for _ in range(MAXPRIME + 1)]\nisPrime[0] = -1\nisPrime[1] = -1\nfor i in range(2, MAXPRIME):\n    if isPrime[i] == 1:\n        for multiple in range(i * i, MAXPRIME + 1, i):\n            if isPrime[multiple] == 0:\n                isPrime[multiple] = i\n        isPrime[i] = i\n\ndef largest_component_size(A):\n    label = defaultdict(int)\n\n    def findRoot(key):\n        if label[key] > 0:\n            label[key] = findRoot(label[key])\n            return label[key]\n        else:\n            return key\n\n    def mergeRoot(k1, k2):\n        (r1, r2) = (findRoot(k1), findRoot(k2))\n        if r1 != r2:\n            (r1, r2) = (min(r1, r2), max(r1, r2))\n            label[r1] += label[r2]\n            label[r2] = r1\n        return r1\n    for x in A:\n        root_id = 0\n        prime_factors = set()\n        while isPrime[x] != -1:\n            p = isPrime[x]\n            root_id = findRoot(p) if root_id == 0 else mergeRoot(root_id, p)\n            x //= p\n        label[root_id] -= 1\n    return -min(label.values())"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if label[key] > 0:",
      "mutated_line": "if label[key] >= 0:",
      "code": "from collections import defaultdict\nMAXPRIME = 100001\nisPrime = [0 for _ in range(MAXPRIME + 1)]\nisPrime[0] = -1\nisPrime[1] = -1\nfor i in range(2, MAXPRIME):\n    if isPrime[i] == 0:\n        for multiple in range(i * i, MAXPRIME + 1, i):\n            if isPrime[multiple] == 0:\n                isPrime[multiple] = i\n        isPrime[i] = i\n\ndef largest_component_size(A):\n    label = defaultdict(int)\n\n    def findRoot(key):\n        if label[key] >= 0:\n            label[key] = findRoot(label[key])\n            return label[key]\n        else:\n            return key\n\n    def mergeRoot(k1, k2):\n        (r1, r2) = (findRoot(k1), findRoot(k2))\n        if r1 != r2:\n            (r1, r2) = (min(r1, r2), max(r1, r2))\n            label[r1] += label[r2]\n            label[r2] = r1\n        return r1\n    for x in A:\n        root_id = 0\n        prime_factors = set()\n        while isPrime[x] != -1:\n            p = isPrime[x]\n            root_id = findRoot(p) if root_id == 0 else mergeRoot(root_id, p)\n            x //= p\n        label[root_id] -= 1\n    return -min(label.values())"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if label[key] > 0:",
      "mutated_line": "if label[key] <= 0:",
      "code": "from collections import defaultdict\nMAXPRIME = 100001\nisPrime = [0 for _ in range(MAXPRIME + 1)]\nisPrime[0] = -1\nisPrime[1] = -1\nfor i in range(2, MAXPRIME):\n    if isPrime[i] == 0:\n        for multiple in range(i * i, MAXPRIME + 1, i):\n            if isPrime[multiple] == 0:\n                isPrime[multiple] = i\n        isPrime[i] = i\n\ndef largest_component_size(A):\n    label = defaultdict(int)\n\n    def findRoot(key):\n        if label[key] <= 0:\n            label[key] = findRoot(label[key])\n            return label[key]\n        else:\n            return key\n\n    def mergeRoot(k1, k2):\n        (r1, r2) = (findRoot(k1), findRoot(k2))\n        if r1 != r2:\n            (r1, r2) = (min(r1, r2), max(r1, r2))\n            label[r1] += label[r2]\n            label[r2] = r1\n        return r1\n    for x in A:\n        root_id = 0\n        prime_factors = set()\n        while isPrime[x] != -1:\n            p = isPrime[x]\n            root_id = findRoot(p) if root_id == 0 else mergeRoot(root_id, p)\n            x //= p\n        label[root_id] -= 1\n    return -min(label.values())"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if label[key] > 0:",
      "mutated_line": "if label[key] != 0:",
      "code": "from collections import defaultdict\nMAXPRIME = 100001\nisPrime = [0 for _ in range(MAXPRIME + 1)]\nisPrime[0] = -1\nisPrime[1] = -1\nfor i in range(2, MAXPRIME):\n    if isPrime[i] == 0:\n        for multiple in range(i * i, MAXPRIME + 1, i):\n            if isPrime[multiple] == 0:\n                isPrime[multiple] = i\n        isPrime[i] = i\n\ndef largest_component_size(A):\n    label = defaultdict(int)\n\n    def findRoot(key):\n        if label[key] != 0:\n            label[key] = findRoot(label[key])\n            return label[key]\n        else:\n            return key\n\n    def mergeRoot(k1, k2):\n        (r1, r2) = (findRoot(k1), findRoot(k2))\n        if r1 != r2:\n            (r1, r2) = (min(r1, r2), max(r1, r2))\n            label[r1] += label[r2]\n            label[r2] = r1\n        return r1\n    for x in A:\n        root_id = 0\n        prime_factors = set()\n        while isPrime[x] != -1:\n            p = isPrime[x]\n            root_id = findRoot(p) if root_id == 0 else mergeRoot(root_id, p)\n            x //= p\n        label[root_id] -= 1\n    return -min(label.values())"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if r1 != r2:",
      "mutated_line": "if r1 == r2:",
      "code": "from collections import defaultdict\nMAXPRIME = 100001\nisPrime = [0 for _ in range(MAXPRIME + 1)]\nisPrime[0] = -1\nisPrime[1] = -1\nfor i in range(2, MAXPRIME):\n    if isPrime[i] == 0:\n        for multiple in range(i * i, MAXPRIME + 1, i):\n            if isPrime[multiple] == 0:\n                isPrime[multiple] = i\n        isPrime[i] = i\n\ndef largest_component_size(A):\n    label = defaultdict(int)\n\n    def findRoot(key):\n        if label[key] > 0:\n            label[key] = findRoot(label[key])\n            return label[key]\n        else:\n            return key\n\n    def mergeRoot(k1, k2):\n        (r1, r2) = (findRoot(k1), findRoot(k2))\n        if r1 == r2:\n            (r1, r2) = (min(r1, r2), max(r1, r2))\n            label[r1] += label[r2]\n            label[r2] = r1\n        return r1\n    for x in A:\n        root_id = 0\n        prime_factors = set()\n        while isPrime[x] != -1:\n            p = isPrime[x]\n            root_id = findRoot(p) if root_id == 0 else mergeRoot(root_id, p)\n            x //= p\n        label[root_id] -= 1\n    return -min(label.values())"
    },
    {
      "operator": "ASR",
      "lineno": 29,
      "original_line": "label[r1] += label[r2]",
      "mutated_line": "label[r1] -= label[r2]",
      "code": "from collections import defaultdict\nMAXPRIME = 100001\nisPrime = [0 for _ in range(MAXPRIME + 1)]\nisPrime[0] = -1\nisPrime[1] = -1\nfor i in range(2, MAXPRIME):\n    if isPrime[i] == 0:\n        for multiple in range(i * i, MAXPRIME + 1, i):\n            if isPrime[multiple] == 0:\n                isPrime[multiple] = i\n        isPrime[i] = i\n\ndef largest_component_size(A):\n    label = defaultdict(int)\n\n    def findRoot(key):\n        if label[key] > 0:\n            label[key] = findRoot(label[key])\n            return label[key]\n        else:\n            return key\n\n    def mergeRoot(k1, k2):\n        (r1, r2) = (findRoot(k1), findRoot(k2))\n        if r1 != r2:\n            (r1, r2) = (min(r1, r2), max(r1, r2))\n            label[r1] -= label[r2]\n            label[r2] = r1\n        return r1\n    for x in A:\n        root_id = 0\n        prime_factors = set()\n        while isPrime[x] != -1:\n            p = isPrime[x]\n            root_id = findRoot(p) if root_id == 0 else mergeRoot(root_id, p)\n            x //= p\n        label[root_id] -= 1\n    return -min(label.values())"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "root_id = 0",
      "mutated_line": "root_id = 1",
      "code": "from collections import defaultdict\nMAXPRIME = 100001\nisPrime = [0 for _ in range(MAXPRIME + 1)]\nisPrime[0] = -1\nisPrime[1] = -1\nfor i in range(2, MAXPRIME):\n    if isPrime[i] == 0:\n        for multiple in range(i * i, MAXPRIME + 1, i):\n            if isPrime[multiple] == 0:\n                isPrime[multiple] = i\n        isPrime[i] = i\n\ndef largest_component_size(A):\n    label = defaultdict(int)\n\n    def findRoot(key):\n        if label[key] > 0:\n            label[key] = findRoot(label[key])\n            return label[key]\n        else:\n            return key\n\n    def mergeRoot(k1, k2):\n        (r1, r2) = (findRoot(k1), findRoot(k2))\n        if r1 != r2:\n            (r1, r2) = (min(r1, r2), max(r1, r2))\n            label[r1] += label[r2]\n            label[r2] = r1\n        return r1\n    for x in A:\n        root_id = 1\n        prime_factors = set()\n        while isPrime[x] != -1:\n            p = isPrime[x]\n            root_id = findRoot(p) if root_id == 0 else mergeRoot(root_id, p)\n            x //= p\n        label[root_id] -= 1\n    return -min(label.values())"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "root_id = 0",
      "mutated_line": "root_id = -1",
      "code": "from collections import defaultdict\nMAXPRIME = 100001\nisPrime = [0 for _ in range(MAXPRIME + 1)]\nisPrime[0] = -1\nisPrime[1] = -1\nfor i in range(2, MAXPRIME):\n    if isPrime[i] == 0:\n        for multiple in range(i * i, MAXPRIME + 1, i):\n            if isPrime[multiple] == 0:\n                isPrime[multiple] = i\n        isPrime[i] = i\n\ndef largest_component_size(A):\n    label = defaultdict(int)\n\n    def findRoot(key):\n        if label[key] > 0:\n            label[key] = findRoot(label[key])\n            return label[key]\n        else:\n            return key\n\n    def mergeRoot(k1, k2):\n        (r1, r2) = (findRoot(k1), findRoot(k2))\n        if r1 != r2:\n            (r1, r2) = (min(r1, r2), max(r1, r2))\n            label[r1] += label[r2]\n            label[r2] = r1\n        return r1\n    for x in A:\n        root_id = -1\n        prime_factors = set()\n        while isPrime[x] != -1:\n            p = isPrime[x]\n            root_id = findRoot(p) if root_id == 0 else mergeRoot(root_id, p)\n            x //= p\n        label[root_id] -= 1\n    return -min(label.values())"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "root_id = 0",
      "mutated_line": "root_id = 1",
      "code": "from collections import defaultdict\nMAXPRIME = 100001\nisPrime = [0 for _ in range(MAXPRIME + 1)]\nisPrime[0] = -1\nisPrime[1] = -1\nfor i in range(2, MAXPRIME):\n    if isPrime[i] == 0:\n        for multiple in range(i * i, MAXPRIME + 1, i):\n            if isPrime[multiple] == 0:\n                isPrime[multiple] = i\n        isPrime[i] = i\n\ndef largest_component_size(A):\n    label = defaultdict(int)\n\n    def findRoot(key):\n        if label[key] > 0:\n            label[key] = findRoot(label[key])\n            return label[key]\n        else:\n            return key\n\n    def mergeRoot(k1, k2):\n        (r1, r2) = (findRoot(k1), findRoot(k2))\n        if r1 != r2:\n            (r1, r2) = (min(r1, r2), max(r1, r2))\n            label[r1] += label[r2]\n            label[r2] = r1\n        return r1\n    for x in A:\n        root_id = 1\n        prime_factors = set()\n        while isPrime[x] != -1:\n            p = isPrime[x]\n            root_id = findRoot(p) if root_id == 0 else mergeRoot(root_id, p)\n            x //= p\n        label[root_id] -= 1\n    return -min(label.values())"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "while isPrime[x] != -1:",
      "mutated_line": "while isPrime[x] == -1:",
      "code": "from collections import defaultdict\nMAXPRIME = 100001\nisPrime = [0 for _ in range(MAXPRIME + 1)]\nisPrime[0] = -1\nisPrime[1] = -1\nfor i in range(2, MAXPRIME):\n    if isPrime[i] == 0:\n        for multiple in range(i * i, MAXPRIME + 1, i):\n            if isPrime[multiple] == 0:\n                isPrime[multiple] = i\n        isPrime[i] = i\n\ndef largest_component_size(A):\n    label = defaultdict(int)\n\n    def findRoot(key):\n        if label[key] > 0:\n            label[key] = findRoot(label[key])\n            return label[key]\n        else:\n            return key\n\n    def mergeRoot(k1, k2):\n        (r1, r2) = (findRoot(k1), findRoot(k2))\n        if r1 != r2:\n            (r1, r2) = (min(r1, r2), max(r1, r2))\n            label[r1] += label[r2]\n            label[r2] = r1\n        return r1\n    for x in A:\n        root_id = 0\n        prime_factors = set()\n        while isPrime[x] == -1:\n            p = isPrime[x]\n            root_id = findRoot(p) if root_id == 0 else mergeRoot(root_id, p)\n            x //= p\n        label[root_id] -= 1\n    return -min(label.values())"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "label[root_id] -= 1",
      "mutated_line": "label[root_id] -= 2",
      "code": "from collections import defaultdict\nMAXPRIME = 100001\nisPrime = [0 for _ in range(MAXPRIME + 1)]\nisPrime[0] = -1\nisPrime[1] = -1\nfor i in range(2, MAXPRIME):\n    if isPrime[i] == 0:\n        for multiple in range(i * i, MAXPRIME + 1, i):\n            if isPrime[multiple] == 0:\n                isPrime[multiple] = i\n        isPrime[i] = i\n\ndef largest_component_size(A):\n    label = defaultdict(int)\n\n    def findRoot(key):\n        if label[key] > 0:\n            label[key] = findRoot(label[key])\n            return label[key]\n        else:\n            return key\n\n    def mergeRoot(k1, k2):\n        (r1, r2) = (findRoot(k1), findRoot(k2))\n        if r1 != r2:\n            (r1, r2) = (min(r1, r2), max(r1, r2))\n            label[r1] += label[r2]\n            label[r2] = r1\n        return r1\n    for x in A:\n        root_id = 0\n        prime_factors = set()\n        while isPrime[x] != -1:\n            p = isPrime[x]\n            root_id = findRoot(p) if root_id == 0 else mergeRoot(root_id, p)\n            x //= p\n        label[root_id] -= 2\n    return -min(label.values())"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "label[root_id] -= 1",
      "mutated_line": "label[root_id] -= 0",
      "code": "from collections import defaultdict\nMAXPRIME = 100001\nisPrime = [0 for _ in range(MAXPRIME + 1)]\nisPrime[0] = -1\nisPrime[1] = -1\nfor i in range(2, MAXPRIME):\n    if isPrime[i] == 0:\n        for multiple in range(i * i, MAXPRIME + 1, i):\n            if isPrime[multiple] == 0:\n                isPrime[multiple] = i\n        isPrime[i] = i\n\ndef largest_component_size(A):\n    label = defaultdict(int)\n\n    def findRoot(key):\n        if label[key] > 0:\n            label[key] = findRoot(label[key])\n            return label[key]\n        else:\n            return key\n\n    def mergeRoot(k1, k2):\n        (r1, r2) = (findRoot(k1), findRoot(k2))\n        if r1 != r2:\n            (r1, r2) = (min(r1, r2), max(r1, r2))\n            label[r1] += label[r2]\n            label[r2] = r1\n        return r1\n    for x in A:\n        root_id = 0\n        prime_factors = set()\n        while isPrime[x] != -1:\n            p = isPrime[x]\n            root_id = findRoot(p) if root_id == 0 else mergeRoot(root_id, p)\n            x //= p\n        label[root_id] -= 0\n    return -min(label.values())"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "label[root_id] -= 1",
      "mutated_line": "label[root_id] -= 0",
      "code": "from collections import defaultdict\nMAXPRIME = 100001\nisPrime = [0 for _ in range(MAXPRIME + 1)]\nisPrime[0] = -1\nisPrime[1] = -1\nfor i in range(2, MAXPRIME):\n    if isPrime[i] == 0:\n        for multiple in range(i * i, MAXPRIME + 1, i):\n            if isPrime[multiple] == 0:\n                isPrime[multiple] = i\n        isPrime[i] = i\n\ndef largest_component_size(A):\n    label = defaultdict(int)\n\n    def findRoot(key):\n        if label[key] > 0:\n            label[key] = findRoot(label[key])\n            return label[key]\n        else:\n            return key\n\n    def mergeRoot(k1, k2):\n        (r1, r2) = (findRoot(k1), findRoot(k2))\n        if r1 != r2:\n            (r1, r2) = (min(r1, r2), max(r1, r2))\n            label[r1] += label[r2]\n            label[r2] = r1\n        return r1\n    for x in A:\n        root_id = 0\n        prime_factors = set()\n        while isPrime[x] != -1:\n            p = isPrime[x]\n            root_id = findRoot(p) if root_id == 0 else mergeRoot(root_id, p)\n            x //= p\n        label[root_id] -= 0\n    return -min(label.values())"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "label[root_id] -= 1",
      "mutated_line": "label[root_id] -= -1",
      "code": "from collections import defaultdict\nMAXPRIME = 100001\nisPrime = [0 for _ in range(MAXPRIME + 1)]\nisPrime[0] = -1\nisPrime[1] = -1\nfor i in range(2, MAXPRIME):\n    if isPrime[i] == 0:\n        for multiple in range(i * i, MAXPRIME + 1, i):\n            if isPrime[multiple] == 0:\n                isPrime[multiple] = i\n        isPrime[i] = i\n\ndef largest_component_size(A):\n    label = defaultdict(int)\n\n    def findRoot(key):\n        if label[key] > 0:\n            label[key] = findRoot(label[key])\n            return label[key]\n        else:\n            return key\n\n    def mergeRoot(k1, k2):\n        (r1, r2) = (findRoot(k1), findRoot(k2))\n        if r1 != r2:\n            (r1, r2) = (min(r1, r2), max(r1, r2))\n            label[r1] += label[r2]\n            label[r2] = r1\n        return r1\n    for x in A:\n        root_id = 0\n        prime_factors = set()\n        while isPrime[x] != -1:\n            p = isPrime[x]\n            root_id = findRoot(p) if root_id == 0 else mergeRoot(root_id, p)\n            x //= p\n        label[root_id] -= -1\n    return -min(label.values())"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "isPrime = [0 for _ in range(MAXPRIME + 1)]",
      "mutated_line": "isPrime = [0 for _ in range(MAXPRIME - 1)]",
      "code": "from collections import defaultdict\nMAXPRIME = 100001\nisPrime = [0 for _ in range(MAXPRIME - 1)]\nisPrime[0] = -1\nisPrime[1] = -1\nfor i in range(2, MAXPRIME):\n    if isPrime[i] == 0:\n        for multiple in range(i * i, MAXPRIME + 1, i):\n            if isPrime[multiple] == 0:\n                isPrime[multiple] = i\n        isPrime[i] = i\n\ndef largest_component_size(A):\n    label = defaultdict(int)\n\n    def findRoot(key):\n        if label[key] > 0:\n            label[key] = findRoot(label[key])\n            return label[key]\n        else:\n            return key\n\n    def mergeRoot(k1, k2):\n        (r1, r2) = (findRoot(k1), findRoot(k2))\n        if r1 != r2:\n            (r1, r2) = (min(r1, r2), max(r1, r2))\n            label[r1] += label[r2]\n            label[r2] = r1\n        return r1\n    for x in A:\n        root_id = 0\n        prime_factors = set()\n        while isPrime[x] != -1:\n            p = isPrime[x]\n            root_id = findRoot(p) if root_id == 0 else mergeRoot(root_id, p)\n            x //= p\n        label[root_id] -= 1\n    return -min(label.values())"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "isPrime = [0 for _ in range(MAXPRIME + 1)]",
      "mutated_line": "isPrime = [0 for _ in range(MAXPRIME * 1)]",
      "code": "from collections import defaultdict\nMAXPRIME = 100001\nisPrime = [0 for _ in range(MAXPRIME * 1)]\nisPrime[0] = -1\nisPrime[1] = -1\nfor i in range(2, MAXPRIME):\n    if isPrime[i] == 0:\n        for multiple in range(i * i, MAXPRIME + 1, i):\n            if isPrime[multiple] == 0:\n                isPrime[multiple] = i\n        isPrime[i] = i\n\ndef largest_component_size(A):\n    label = defaultdict(int)\n\n    def findRoot(key):\n        if label[key] > 0:\n            label[key] = findRoot(label[key])\n            return label[key]\n        else:\n            return key\n\n    def mergeRoot(k1, k2):\n        (r1, r2) = (findRoot(k1), findRoot(k2))\n        if r1 != r2:\n            (r1, r2) = (min(r1, r2), max(r1, r2))\n            label[r1] += label[r2]\n            label[r2] = r1\n        return r1\n    for x in A:\n        root_id = 0\n        prime_factors = set()\n        while isPrime[x] != -1:\n            p = isPrime[x]\n            root_id = findRoot(p) if root_id == 0 else mergeRoot(root_id, p)\n            x //= p\n        label[root_id] -= 1\n    return -min(label.values())"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "for multiple in range(i * i, MAXPRIME + 1, i):",
      "mutated_line": "for multiple in range(i / i, MAXPRIME + 1, i):",
      "code": "from collections import defaultdict\nMAXPRIME = 100001\nisPrime = [0 for _ in range(MAXPRIME + 1)]\nisPrime[0] = -1\nisPrime[1] = -1\nfor i in range(2, MAXPRIME):\n    if isPrime[i] == 0:\n        for multiple in range(i / i, MAXPRIME + 1, i):\n            if isPrime[multiple] == 0:\n                isPrime[multiple] = i\n        isPrime[i] = i\n\ndef largest_component_size(A):\n    label = defaultdict(int)\n\n    def findRoot(key):\n        if label[key] > 0:\n            label[key] = findRoot(label[key])\n            return label[key]\n        else:\n            return key\n\n    def mergeRoot(k1, k2):\n        (r1, r2) = (findRoot(k1), findRoot(k2))\n        if r1 != r2:\n            (r1, r2) = (min(r1, r2), max(r1, r2))\n            label[r1] += label[r2]\n            label[r2] = r1\n        return r1\n    for x in A:\n        root_id = 0\n        prime_factors = set()\n        while isPrime[x] != -1:\n            p = isPrime[x]\n            root_id = findRoot(p) if root_id == 0 else mergeRoot(root_id, p)\n            x //= p\n        label[root_id] -= 1\n    return -min(label.values())"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "for multiple in range(i * i, MAXPRIME + 1, i):",
      "mutated_line": "for multiple in range(i + i, MAXPRIME + 1, i):",
      "code": "from collections import defaultdict\nMAXPRIME = 100001\nisPrime = [0 for _ in range(MAXPRIME + 1)]\nisPrime[0] = -1\nisPrime[1] = -1\nfor i in range(2, MAXPRIME):\n    if isPrime[i] == 0:\n        for multiple in range(i + i, MAXPRIME + 1, i):\n            if isPrime[multiple] == 0:\n                isPrime[multiple] = i\n        isPrime[i] = i\n\ndef largest_component_size(A):\n    label = defaultdict(int)\n\n    def findRoot(key):\n        if label[key] > 0:\n            label[key] = findRoot(label[key])\n            return label[key]\n        else:\n            return key\n\n    def mergeRoot(k1, k2):\n        (r1, r2) = (findRoot(k1), findRoot(k2))\n        if r1 != r2:\n            (r1, r2) = (min(r1, r2), max(r1, r2))\n            label[r1] += label[r2]\n            label[r2] = r1\n        return r1\n    for x in A:\n        root_id = 0\n        prime_factors = set()\n        while isPrime[x] != -1:\n            p = isPrime[x]\n            root_id = findRoot(p) if root_id == 0 else mergeRoot(root_id, p)\n            x //= p\n        label[root_id] -= 1\n    return -min(label.values())"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "for multiple in range(i * i, MAXPRIME + 1, i):",
      "mutated_line": "for multiple in range(i ** i, MAXPRIME + 1, i):",
      "code": "from collections import defaultdict\nMAXPRIME = 100001\nisPrime = [0 for _ in range(MAXPRIME + 1)]\nisPrime[0] = -1\nisPrime[1] = -1\nfor i in range(2, MAXPRIME):\n    if isPrime[i] == 0:\n        for multiple in range(i ** i, MAXPRIME + 1, i):\n            if isPrime[multiple] == 0:\n                isPrime[multiple] = i\n        isPrime[i] = i\n\ndef largest_component_size(A):\n    label = defaultdict(int)\n\n    def findRoot(key):\n        if label[key] > 0:\n            label[key] = findRoot(label[key])\n            return label[key]\n        else:\n            return key\n\n    def mergeRoot(k1, k2):\n        (r1, r2) = (findRoot(k1), findRoot(k2))\n        if r1 != r2:\n            (r1, r2) = (min(r1, r2), max(r1, r2))\n            label[r1] += label[r2]\n            label[r2] = r1\n        return r1\n    for x in A:\n        root_id = 0\n        prime_factors = set()\n        while isPrime[x] != -1:\n            p = isPrime[x]\n            root_id = findRoot(p) if root_id == 0 else mergeRoot(root_id, p)\n            x //= p\n        label[root_id] -= 1\n    return -min(label.values())"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "for multiple in range(i * i, MAXPRIME + 1, i):",
      "mutated_line": "for multiple in range(i * i, MAXPRIME - 1, i):",
      "code": "from collections import defaultdict\nMAXPRIME = 100001\nisPrime = [0 for _ in range(MAXPRIME + 1)]\nisPrime[0] = -1\nisPrime[1] = -1\nfor i in range(2, MAXPRIME):\n    if isPrime[i] == 0:\n        for multiple in range(i * i, MAXPRIME - 1, i):\n            if isPrime[multiple] == 0:\n                isPrime[multiple] = i\n        isPrime[i] = i\n\ndef largest_component_size(A):\n    label = defaultdict(int)\n\n    def findRoot(key):\n        if label[key] > 0:\n            label[key] = findRoot(label[key])\n            return label[key]\n        else:\n            return key\n\n    def mergeRoot(k1, k2):\n        (r1, r2) = (findRoot(k1), findRoot(k2))\n        if r1 != r2:\n            (r1, r2) = (min(r1, r2), max(r1, r2))\n            label[r1] += label[r2]\n            label[r2] = r1\n        return r1\n    for x in A:\n        root_id = 0\n        prime_factors = set()\n        while isPrime[x] != -1:\n            p = isPrime[x]\n            root_id = findRoot(p) if root_id == 0 else mergeRoot(root_id, p)\n            x //= p\n        label[root_id] -= 1\n    return -min(label.values())"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "for multiple in range(i * i, MAXPRIME + 1, i):",
      "mutated_line": "for multiple in range(i * i, MAXPRIME * 1, i):",
      "code": "from collections import defaultdict\nMAXPRIME = 100001\nisPrime = [0 for _ in range(MAXPRIME + 1)]\nisPrime[0] = -1\nisPrime[1] = -1\nfor i in range(2, MAXPRIME):\n    if isPrime[i] == 0:\n        for multiple in range(i * i, MAXPRIME * 1, i):\n            if isPrime[multiple] == 0:\n                isPrime[multiple] = i\n        isPrime[i] = i\n\ndef largest_component_size(A):\n    label = defaultdict(int)\n\n    def findRoot(key):\n        if label[key] > 0:\n            label[key] = findRoot(label[key])\n            return label[key]\n        else:\n            return key\n\n    def mergeRoot(k1, k2):\n        (r1, r2) = (findRoot(k1), findRoot(k2))\n        if r1 != r2:\n            (r1, r2) = (min(r1, r2), max(r1, r2))\n            label[r1] += label[r2]\n            label[r2] = r1\n        return r1\n    for x in A:\n        root_id = 0\n        prime_factors = set()\n        while isPrime[x] != -1:\n            p = isPrime[x]\n            root_id = findRoot(p) if root_id == 0 else mergeRoot(root_id, p)\n            x //= p\n        label[root_id] -= 1\n    return -min(label.values())"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if isPrime[multiple] == 0:",
      "mutated_line": "if isPrime[multiple] != 0:",
      "code": "from collections import defaultdict\nMAXPRIME = 100001\nisPrime = [0 for _ in range(MAXPRIME + 1)]\nisPrime[0] = -1\nisPrime[1] = -1\nfor i in range(2, MAXPRIME):\n    if isPrime[i] == 0:\n        for multiple in range(i * i, MAXPRIME + 1, i):\n            if isPrime[multiple] != 0:\n                isPrime[multiple] = i\n        isPrime[i] = i\n\ndef largest_component_size(A):\n    label = defaultdict(int)\n\n    def findRoot(key):\n        if label[key] > 0:\n            label[key] = findRoot(label[key])\n            return label[key]\n        else:\n            return key\n\n    def mergeRoot(k1, k2):\n        (r1, r2) = (findRoot(k1), findRoot(k2))\n        if r1 != r2:\n            (r1, r2) = (min(r1, r2), max(r1, r2))\n            label[r1] += label[r2]\n            label[r2] = r1\n        return r1\n    for x in A:\n        root_id = 0\n        prime_factors = set()\n        while isPrime[x] != -1:\n            p = isPrime[x]\n            root_id = findRoot(p) if root_id == 0 else mergeRoot(root_id, p)\n            x //= p\n        label[root_id] -= 1\n    return -min(label.values())"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if label[key] > 0:",
      "mutated_line": "if label[key] > 1:",
      "code": "from collections import defaultdict\nMAXPRIME = 100001\nisPrime = [0 for _ in range(MAXPRIME + 1)]\nisPrime[0] = -1\nisPrime[1] = -1\nfor i in range(2, MAXPRIME):\n    if isPrime[i] == 0:\n        for multiple in range(i * i, MAXPRIME + 1, i):\n            if isPrime[multiple] == 0:\n                isPrime[multiple] = i\n        isPrime[i] = i\n\ndef largest_component_size(A):\n    label = defaultdict(int)\n\n    def findRoot(key):\n        if label[key] > 1:\n            label[key] = findRoot(label[key])\n            return label[key]\n        else:\n            return key\n\n    def mergeRoot(k1, k2):\n        (r1, r2) = (findRoot(k1), findRoot(k2))\n        if r1 != r2:\n            (r1, r2) = (min(r1, r2), max(r1, r2))\n            label[r1] += label[r2]\n            label[r2] = r1\n        return r1\n    for x in A:\n        root_id = 0\n        prime_factors = set()\n        while isPrime[x] != -1:\n            p = isPrime[x]\n            root_id = findRoot(p) if root_id == 0 else mergeRoot(root_id, p)\n            x //= p\n        label[root_id] -= 1\n    return -min(label.values())"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if label[key] > 0:",
      "mutated_line": "if label[key] > -1:",
      "code": "from collections import defaultdict\nMAXPRIME = 100001\nisPrime = [0 for _ in range(MAXPRIME + 1)]\nisPrime[0] = -1\nisPrime[1] = -1\nfor i in range(2, MAXPRIME):\n    if isPrime[i] == 0:\n        for multiple in range(i * i, MAXPRIME + 1, i):\n            if isPrime[multiple] == 0:\n                isPrime[multiple] = i\n        isPrime[i] = i\n\ndef largest_component_size(A):\n    label = defaultdict(int)\n\n    def findRoot(key):\n        if label[key] > -1:\n            label[key] = findRoot(label[key])\n            return label[key]\n        else:\n            return key\n\n    def mergeRoot(k1, k2):\n        (r1, r2) = (findRoot(k1), findRoot(k2))\n        if r1 != r2:\n            (r1, r2) = (min(r1, r2), max(r1, r2))\n            label[r1] += label[r2]\n            label[r2] = r1\n        return r1\n    for x in A:\n        root_id = 0\n        prime_factors = set()\n        while isPrime[x] != -1:\n            p = isPrime[x]\n            root_id = findRoot(p) if root_id == 0 else mergeRoot(root_id, p)\n            x //= p\n        label[root_id] -= 1\n    return -min(label.values())"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if label[key] > 0:",
      "mutated_line": "if label[key] > 1:",
      "code": "from collections import defaultdict\nMAXPRIME = 100001\nisPrime = [0 for _ in range(MAXPRIME + 1)]\nisPrime[0] = -1\nisPrime[1] = -1\nfor i in range(2, MAXPRIME):\n    if isPrime[i] == 0:\n        for multiple in range(i * i, MAXPRIME + 1, i):\n            if isPrime[multiple] == 0:\n                isPrime[multiple] = i\n        isPrime[i] = i\n\ndef largest_component_size(A):\n    label = defaultdict(int)\n\n    def findRoot(key):\n        if label[key] > 1:\n            label[key] = findRoot(label[key])\n            return label[key]\n        else:\n            return key\n\n    def mergeRoot(k1, k2):\n        (r1, r2) = (findRoot(k1), findRoot(k2))\n        if r1 != r2:\n            (r1, r2) = (min(r1, r2), max(r1, r2))\n            label[r1] += label[r2]\n            label[r2] = r1\n        return r1\n    for x in A:\n        root_id = 0\n        prime_factors = set()\n        while isPrime[x] != -1:\n            p = isPrime[x]\n            root_id = findRoot(p) if root_id == 0 else mergeRoot(root_id, p)\n            x //= p\n        label[root_id] -= 1\n    return -min(label.values())"
    },
    {
      "operator": "UOI",
      "lineno": 36,
      "original_line": "while isPrime[x] != -1:",
      "mutated_line": "while isPrime[x] != +1:",
      "code": "from collections import defaultdict\nMAXPRIME = 100001\nisPrime = [0 for _ in range(MAXPRIME + 1)]\nisPrime[0] = -1\nisPrime[1] = -1\nfor i in range(2, MAXPRIME):\n    if isPrime[i] == 0:\n        for multiple in range(i * i, MAXPRIME + 1, i):\n            if isPrime[multiple] == 0:\n                isPrime[multiple] = i\n        isPrime[i] = i\n\ndef largest_component_size(A):\n    label = defaultdict(int)\n\n    def findRoot(key):\n        if label[key] > 0:\n            label[key] = findRoot(label[key])\n            return label[key]\n        else:\n            return key\n\n    def mergeRoot(k1, k2):\n        (r1, r2) = (findRoot(k1), findRoot(k2))\n        if r1 != r2:\n            (r1, r2) = (min(r1, r2), max(r1, r2))\n            label[r1] += label[r2]\n            label[r2] = r1\n        return r1\n    for x in A:\n        root_id = 0\n        prime_factors = set()\n        while isPrime[x] != +1:\n            p = isPrime[x]\n            root_id = findRoot(p) if root_id == 0 else mergeRoot(root_id, p)\n            x //= p\n        label[root_id] -= 1\n    return -min(label.values())"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "isPrime = [0 for _ in range(MAXPRIME + 1)]",
      "mutated_line": "isPrime = [0 for _ in range(MAXPRIME + 2)]",
      "code": "from collections import defaultdict\nMAXPRIME = 100001\nisPrime = [0 for _ in range(MAXPRIME + 2)]\nisPrime[0] = -1\nisPrime[1] = -1\nfor i in range(2, MAXPRIME):\n    if isPrime[i] == 0:\n        for multiple in range(i * i, MAXPRIME + 1, i):\n            if isPrime[multiple] == 0:\n                isPrime[multiple] = i\n        isPrime[i] = i\n\ndef largest_component_size(A):\n    label = defaultdict(int)\n\n    def findRoot(key):\n        if label[key] > 0:\n            label[key] = findRoot(label[key])\n            return label[key]\n        else:\n            return key\n\n    def mergeRoot(k1, k2):\n        (r1, r2) = (findRoot(k1), findRoot(k2))\n        if r1 != r2:\n            (r1, r2) = (min(r1, r2), max(r1, r2))\n            label[r1] += label[r2]\n            label[r2] = r1\n        return r1\n    for x in A:\n        root_id = 0\n        prime_factors = set()\n        while isPrime[x] != -1:\n            p = isPrime[x]\n            root_id = findRoot(p) if root_id == 0 else mergeRoot(root_id, p)\n            x //= p\n        label[root_id] -= 1\n    return -min(label.values())"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "isPrime = [0 for _ in range(MAXPRIME + 1)]",
      "mutated_line": "isPrime = [0 for _ in range(MAXPRIME + 0)]",
      "code": "from collections import defaultdict\nMAXPRIME = 100001\nisPrime = [0 for _ in range(MAXPRIME + 0)]\nisPrime[0] = -1\nisPrime[1] = -1\nfor i in range(2, MAXPRIME):\n    if isPrime[i] == 0:\n        for multiple in range(i * i, MAXPRIME + 1, i):\n            if isPrime[multiple] == 0:\n                isPrime[multiple] = i\n        isPrime[i] = i\n\ndef largest_component_size(A):\n    label = defaultdict(int)\n\n    def findRoot(key):\n        if label[key] > 0:\n            label[key] = findRoot(label[key])\n            return label[key]\n        else:\n            return key\n\n    def mergeRoot(k1, k2):\n        (r1, r2) = (findRoot(k1), findRoot(k2))\n        if r1 != r2:\n            (r1, r2) = (min(r1, r2), max(r1, r2))\n            label[r1] += label[r2]\n            label[r2] = r1\n        return r1\n    for x in A:\n        root_id = 0\n        prime_factors = set()\n        while isPrime[x] != -1:\n            p = isPrime[x]\n            root_id = findRoot(p) if root_id == 0 else mergeRoot(root_id, p)\n            x //= p\n        label[root_id] -= 1\n    return -min(label.values())"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "isPrime = [0 for _ in range(MAXPRIME + 1)]",
      "mutated_line": "isPrime = [0 for _ in range(MAXPRIME + 0)]",
      "code": "from collections import defaultdict\nMAXPRIME = 100001\nisPrime = [0 for _ in range(MAXPRIME + 0)]\nisPrime[0] = -1\nisPrime[1] = -1\nfor i in range(2, MAXPRIME):\n    if isPrime[i] == 0:\n        for multiple in range(i * i, MAXPRIME + 1, i):\n            if isPrime[multiple] == 0:\n                isPrime[multiple] = i\n        isPrime[i] = i\n\ndef largest_component_size(A):\n    label = defaultdict(int)\n\n    def findRoot(key):\n        if label[key] > 0:\n            label[key] = findRoot(label[key])\n            return label[key]\n        else:\n            return key\n\n    def mergeRoot(k1, k2):\n        (r1, r2) = (findRoot(k1), findRoot(k2))\n        if r1 != r2:\n            (r1, r2) = (min(r1, r2), max(r1, r2))\n            label[r1] += label[r2]\n            label[r2] = r1\n        return r1\n    for x in A:\n        root_id = 0\n        prime_factors = set()\n        while isPrime[x] != -1:\n            p = isPrime[x]\n            root_id = findRoot(p) if root_id == 0 else mergeRoot(root_id, p)\n            x //= p\n        label[root_id] -= 1\n    return -min(label.values())"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "isPrime = [0 for _ in range(MAXPRIME + 1)]",
      "mutated_line": "isPrime = [0 for _ in range(MAXPRIME + -1)]",
      "code": "from collections import defaultdict\nMAXPRIME = 100001\nisPrime = [0 for _ in range(MAXPRIME + -1)]\nisPrime[0] = -1\nisPrime[1] = -1\nfor i in range(2, MAXPRIME):\n    if isPrime[i] == 0:\n        for multiple in range(i * i, MAXPRIME + 1, i):\n            if isPrime[multiple] == 0:\n                isPrime[multiple] = i\n        isPrime[i] = i\n\ndef largest_component_size(A):\n    label = defaultdict(int)\n\n    def findRoot(key):\n        if label[key] > 0:\n            label[key] = findRoot(label[key])\n            return label[key]\n        else:\n            return key\n\n    def mergeRoot(k1, k2):\n        (r1, r2) = (findRoot(k1), findRoot(k2))\n        if r1 != r2:\n            (r1, r2) = (min(r1, r2), max(r1, r2))\n            label[r1] += label[r2]\n            label[r2] = r1\n        return r1\n    for x in A:\n        root_id = 0\n        prime_factors = set()\n        while isPrime[x] != -1:\n            p = isPrime[x]\n            root_id = findRoot(p) if root_id == 0 else mergeRoot(root_id, p)\n            x //= p\n        label[root_id] -= 1\n    return -min(label.values())"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for multiple in range(i * i, MAXPRIME + 1, i):",
      "mutated_line": "for multiple in range(i * i, MAXPRIME + 2, i):",
      "code": "from collections import defaultdict\nMAXPRIME = 100001\nisPrime = [0 for _ in range(MAXPRIME + 1)]\nisPrime[0] = -1\nisPrime[1] = -1\nfor i in range(2, MAXPRIME):\n    if isPrime[i] == 0:\n        for multiple in range(i * i, MAXPRIME + 2, i):\n            if isPrime[multiple] == 0:\n                isPrime[multiple] = i\n        isPrime[i] = i\n\ndef largest_component_size(A):\n    label = defaultdict(int)\n\n    def findRoot(key):\n        if label[key] > 0:\n            label[key] = findRoot(label[key])\n            return label[key]\n        else:\n            return key\n\n    def mergeRoot(k1, k2):\n        (r1, r2) = (findRoot(k1), findRoot(k2))\n        if r1 != r2:\n            (r1, r2) = (min(r1, r2), max(r1, r2))\n            label[r1] += label[r2]\n            label[r2] = r1\n        return r1\n    for x in A:\n        root_id = 0\n        prime_factors = set()\n        while isPrime[x] != -1:\n            p = isPrime[x]\n            root_id = findRoot(p) if root_id == 0 else mergeRoot(root_id, p)\n            x //= p\n        label[root_id] -= 1\n    return -min(label.values())"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for multiple in range(i * i, MAXPRIME + 1, i):",
      "mutated_line": "for multiple in range(i * i, MAXPRIME + 0, i):",
      "code": "from collections import defaultdict\nMAXPRIME = 100001\nisPrime = [0 for _ in range(MAXPRIME + 1)]\nisPrime[0] = -1\nisPrime[1] = -1\nfor i in range(2, MAXPRIME):\n    if isPrime[i] == 0:\n        for multiple in range(i * i, MAXPRIME + 0, i):\n            if isPrime[multiple] == 0:\n                isPrime[multiple] = i\n        isPrime[i] = i\n\ndef largest_component_size(A):\n    label = defaultdict(int)\n\n    def findRoot(key):\n        if label[key] > 0:\n            label[key] = findRoot(label[key])\n            return label[key]\n        else:\n            return key\n\n    def mergeRoot(k1, k2):\n        (r1, r2) = (findRoot(k1), findRoot(k2))\n        if r1 != r2:\n            (r1, r2) = (min(r1, r2), max(r1, r2))\n            label[r1] += label[r2]\n            label[r2] = r1\n        return r1\n    for x in A:\n        root_id = 0\n        prime_factors = set()\n        while isPrime[x] != -1:\n            p = isPrime[x]\n            root_id = findRoot(p) if root_id == 0 else mergeRoot(root_id, p)\n            x //= p\n        label[root_id] -= 1\n    return -min(label.values())"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for multiple in range(i * i, MAXPRIME + 1, i):",
      "mutated_line": "for multiple in range(i * i, MAXPRIME + 0, i):",
      "code": "from collections import defaultdict\nMAXPRIME = 100001\nisPrime = [0 for _ in range(MAXPRIME + 1)]\nisPrime[0] = -1\nisPrime[1] = -1\nfor i in range(2, MAXPRIME):\n    if isPrime[i] == 0:\n        for multiple in range(i * i, MAXPRIME + 0, i):\n            if isPrime[multiple] == 0:\n                isPrime[multiple] = i\n        isPrime[i] = i\n\ndef largest_component_size(A):\n    label = defaultdict(int)\n\n    def findRoot(key):\n        if label[key] > 0:\n            label[key] = findRoot(label[key])\n            return label[key]\n        else:\n            return key\n\n    def mergeRoot(k1, k2):\n        (r1, r2) = (findRoot(k1), findRoot(k2))\n        if r1 != r2:\n            (r1, r2) = (min(r1, r2), max(r1, r2))\n            label[r1] += label[r2]\n            label[r2] = r1\n        return r1\n    for x in A:\n        root_id = 0\n        prime_factors = set()\n        while isPrime[x] != -1:\n            p = isPrime[x]\n            root_id = findRoot(p) if root_id == 0 else mergeRoot(root_id, p)\n            x //= p\n        label[root_id] -= 1\n    return -min(label.values())"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for multiple in range(i * i, MAXPRIME + 1, i):",
      "mutated_line": "for multiple in range(i * i, MAXPRIME + -1, i):",
      "code": "from collections import defaultdict\nMAXPRIME = 100001\nisPrime = [0 for _ in range(MAXPRIME + 1)]\nisPrime[0] = -1\nisPrime[1] = -1\nfor i in range(2, MAXPRIME):\n    if isPrime[i] == 0:\n        for multiple in range(i * i, MAXPRIME + -1, i):\n            if isPrime[multiple] == 0:\n                isPrime[multiple] = i\n        isPrime[i] = i\n\ndef largest_component_size(A):\n    label = defaultdict(int)\n\n    def findRoot(key):\n        if label[key] > 0:\n            label[key] = findRoot(label[key])\n            return label[key]\n        else:\n            return key\n\n    def mergeRoot(k1, k2):\n        (r1, r2) = (findRoot(k1), findRoot(k2))\n        if r1 != r2:\n            (r1, r2) = (min(r1, r2), max(r1, r2))\n            label[r1] += label[r2]\n            label[r2] = r1\n        return r1\n    for x in A:\n        root_id = 0\n        prime_factors = set()\n        while isPrime[x] != -1:\n            p = isPrime[x]\n            root_id = findRoot(p) if root_id == 0 else mergeRoot(root_id, p)\n            x //= p\n        label[root_id] -= 1\n    return -min(label.values())"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if isPrime[multiple] == 0:",
      "mutated_line": "if isPrime[multiple] == 1:",
      "code": "from collections import defaultdict\nMAXPRIME = 100001\nisPrime = [0 for _ in range(MAXPRIME + 1)]\nisPrime[0] = -1\nisPrime[1] = -1\nfor i in range(2, MAXPRIME):\n    if isPrime[i] == 0:\n        for multiple in range(i * i, MAXPRIME + 1, i):\n            if isPrime[multiple] == 1:\n                isPrime[multiple] = i\n        isPrime[i] = i\n\ndef largest_component_size(A):\n    label = defaultdict(int)\n\n    def findRoot(key):\n        if label[key] > 0:\n            label[key] = findRoot(label[key])\n            return label[key]\n        else:\n            return key\n\n    def mergeRoot(k1, k2):\n        (r1, r2) = (findRoot(k1), findRoot(k2))\n        if r1 != r2:\n            (r1, r2) = (min(r1, r2), max(r1, r2))\n            label[r1] += label[r2]\n            label[r2] = r1\n        return r1\n    for x in A:\n        root_id = 0\n        prime_factors = set()\n        while isPrime[x] != -1:\n            p = isPrime[x]\n            root_id = findRoot(p) if root_id == 0 else mergeRoot(root_id, p)\n            x //= p\n        label[root_id] -= 1\n    return -min(label.values())"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if isPrime[multiple] == 0:",
      "mutated_line": "if isPrime[multiple] == -1:",
      "code": "from collections import defaultdict\nMAXPRIME = 100001\nisPrime = [0 for _ in range(MAXPRIME + 1)]\nisPrime[0] = -1\nisPrime[1] = -1\nfor i in range(2, MAXPRIME):\n    if isPrime[i] == 0:\n        for multiple in range(i * i, MAXPRIME + 1, i):\n            if isPrime[multiple] == -1:\n                isPrime[multiple] = i\n        isPrime[i] = i\n\ndef largest_component_size(A):\n    label = defaultdict(int)\n\n    def findRoot(key):\n        if label[key] > 0:\n            label[key] = findRoot(label[key])\n            return label[key]\n        else:\n            return key\n\n    def mergeRoot(k1, k2):\n        (r1, r2) = (findRoot(k1), findRoot(k2))\n        if r1 != r2:\n            (r1, r2) = (min(r1, r2), max(r1, r2))\n            label[r1] += label[r2]\n            label[r2] = r1\n        return r1\n    for x in A:\n        root_id = 0\n        prime_factors = set()\n        while isPrime[x] != -1:\n            p = isPrime[x]\n            root_id = findRoot(p) if root_id == 0 else mergeRoot(root_id, p)\n            x //= p\n        label[root_id] -= 1\n    return -min(label.values())"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if isPrime[multiple] == 0:",
      "mutated_line": "if isPrime[multiple] == 1:",
      "code": "from collections import defaultdict\nMAXPRIME = 100001\nisPrime = [0 for _ in range(MAXPRIME + 1)]\nisPrime[0] = -1\nisPrime[1] = -1\nfor i in range(2, MAXPRIME):\n    if isPrime[i] == 0:\n        for multiple in range(i * i, MAXPRIME + 1, i):\n            if isPrime[multiple] == 1:\n                isPrime[multiple] = i\n        isPrime[i] = i\n\ndef largest_component_size(A):\n    label = defaultdict(int)\n\n    def findRoot(key):\n        if label[key] > 0:\n            label[key] = findRoot(label[key])\n            return label[key]\n        else:\n            return key\n\n    def mergeRoot(k1, k2):\n        (r1, r2) = (findRoot(k1), findRoot(k2))\n        if r1 != r2:\n            (r1, r2) = (min(r1, r2), max(r1, r2))\n            label[r1] += label[r2]\n            label[r2] = r1\n        return r1\n    for x in A:\n        root_id = 0\n        prime_factors = set()\n        while isPrime[x] != -1:\n            p = isPrime[x]\n            root_id = findRoot(p) if root_id == 0 else mergeRoot(root_id, p)\n            x //= p\n        label[root_id] -= 1\n    return -min(label.values())"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "while isPrime[x] != -1:",
      "mutated_line": "while isPrime[x] != -2:",
      "code": "from collections import defaultdict\nMAXPRIME = 100001\nisPrime = [0 for _ in range(MAXPRIME + 1)]\nisPrime[0] = -1\nisPrime[1] = -1\nfor i in range(2, MAXPRIME):\n    if isPrime[i] == 0:\n        for multiple in range(i * i, MAXPRIME + 1, i):\n            if isPrime[multiple] == 0:\n                isPrime[multiple] = i\n        isPrime[i] = i\n\ndef largest_component_size(A):\n    label = defaultdict(int)\n\n    def findRoot(key):\n        if label[key] > 0:\n            label[key] = findRoot(label[key])\n            return label[key]\n        else:\n            return key\n\n    def mergeRoot(k1, k2):\n        (r1, r2) = (findRoot(k1), findRoot(k2))\n        if r1 != r2:\n            (r1, r2) = (min(r1, r2), max(r1, r2))\n            label[r1] += label[r2]\n            label[r2] = r1\n        return r1\n    for x in A:\n        root_id = 0\n        prime_factors = set()\n        while isPrime[x] != -2:\n            p = isPrime[x]\n            root_id = findRoot(p) if root_id == 0 else mergeRoot(root_id, p)\n            x //= p\n        label[root_id] -= 1\n    return -min(label.values())"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "while isPrime[x] != -1:",
      "mutated_line": "while isPrime[x] != -0:",
      "code": "from collections import defaultdict\nMAXPRIME = 100001\nisPrime = [0 for _ in range(MAXPRIME + 1)]\nisPrime[0] = -1\nisPrime[1] = -1\nfor i in range(2, MAXPRIME):\n    if isPrime[i] == 0:\n        for multiple in range(i * i, MAXPRIME + 1, i):\n            if isPrime[multiple] == 0:\n                isPrime[multiple] = i\n        isPrime[i] = i\n\ndef largest_component_size(A):\n    label = defaultdict(int)\n\n    def findRoot(key):\n        if label[key] > 0:\n            label[key] = findRoot(label[key])\n            return label[key]\n        else:\n            return key\n\n    def mergeRoot(k1, k2):\n        (r1, r2) = (findRoot(k1), findRoot(k2))\n        if r1 != r2:\n            (r1, r2) = (min(r1, r2), max(r1, r2))\n            label[r1] += label[r2]\n            label[r2] = r1\n        return r1\n    for x in A:\n        root_id = 0\n        prime_factors = set()\n        while isPrime[x] != -0:\n            p = isPrime[x]\n            root_id = findRoot(p) if root_id == 0 else mergeRoot(root_id, p)\n            x //= p\n        label[root_id] -= 1\n    return -min(label.values())"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "while isPrime[x] != -1:",
      "mutated_line": "while isPrime[x] != -0:",
      "code": "from collections import defaultdict\nMAXPRIME = 100001\nisPrime = [0 for _ in range(MAXPRIME + 1)]\nisPrime[0] = -1\nisPrime[1] = -1\nfor i in range(2, MAXPRIME):\n    if isPrime[i] == 0:\n        for multiple in range(i * i, MAXPRIME + 1, i):\n            if isPrime[multiple] == 0:\n                isPrime[multiple] = i\n        isPrime[i] = i\n\ndef largest_component_size(A):\n    label = defaultdict(int)\n\n    def findRoot(key):\n        if label[key] > 0:\n            label[key] = findRoot(label[key])\n            return label[key]\n        else:\n            return key\n\n    def mergeRoot(k1, k2):\n        (r1, r2) = (findRoot(k1), findRoot(k2))\n        if r1 != r2:\n            (r1, r2) = (min(r1, r2), max(r1, r2))\n            label[r1] += label[r2]\n            label[r2] = r1\n        return r1\n    for x in A:\n        root_id = 0\n        prime_factors = set()\n        while isPrime[x] != -0:\n            p = isPrime[x]\n            root_id = findRoot(p) if root_id == 0 else mergeRoot(root_id, p)\n            x //= p\n        label[root_id] -= 1\n    return -min(label.values())"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "while isPrime[x] != -1:",
      "mutated_line": "while isPrime[x] != --1:",
      "code": "from collections import defaultdict\nMAXPRIME = 100001\nisPrime = [0 for _ in range(MAXPRIME + 1)]\nisPrime[0] = -1\nisPrime[1] = -1\nfor i in range(2, MAXPRIME):\n    if isPrime[i] == 0:\n        for multiple in range(i * i, MAXPRIME + 1, i):\n            if isPrime[multiple] == 0:\n                isPrime[multiple] = i\n        isPrime[i] = i\n\ndef largest_component_size(A):\n    label = defaultdict(int)\n\n    def findRoot(key):\n        if label[key] > 0:\n            label[key] = findRoot(label[key])\n            return label[key]\n        else:\n            return key\n\n    def mergeRoot(k1, k2):\n        (r1, r2) = (findRoot(k1), findRoot(k2))\n        if r1 != r2:\n            (r1, r2) = (min(r1, r2), max(r1, r2))\n            label[r1] += label[r2]\n            label[r2] = r1\n        return r1\n    for x in A:\n        root_id = 0\n        prime_factors = set()\n        while isPrime[x] != --1:\n            p = isPrime[x]\n            root_id = findRoot(p) if root_id == 0 else mergeRoot(root_id, p)\n            x //= p\n        label[root_id] -= 1\n    return -min(label.values())"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "root_id = findRoot(p) if root_id == 0 else mergeRoot(root_id, p)",
      "mutated_line": "root_id = findRoot(p) if root_id != 0 else mergeRoot(root_id, p)",
      "code": "from collections import defaultdict\nMAXPRIME = 100001\nisPrime = [0 for _ in range(MAXPRIME + 1)]\nisPrime[0] = -1\nisPrime[1] = -1\nfor i in range(2, MAXPRIME):\n    if isPrime[i] == 0:\n        for multiple in range(i * i, MAXPRIME + 1, i):\n            if isPrime[multiple] == 0:\n                isPrime[multiple] = i\n        isPrime[i] = i\n\ndef largest_component_size(A):\n    label = defaultdict(int)\n\n    def findRoot(key):\n        if label[key] > 0:\n            label[key] = findRoot(label[key])\n            return label[key]\n        else:\n            return key\n\n    def mergeRoot(k1, k2):\n        (r1, r2) = (findRoot(k1), findRoot(k2))\n        if r1 != r2:\n            (r1, r2) = (min(r1, r2), max(r1, r2))\n            label[r1] += label[r2]\n            label[r2] = r1\n        return r1\n    for x in A:\n        root_id = 0\n        prime_factors = set()\n        while isPrime[x] != -1:\n            p = isPrime[x]\n            root_id = findRoot(p) if root_id != 0 else mergeRoot(root_id, p)\n            x //= p\n        label[root_id] -= 1\n    return -min(label.values())"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "root_id = findRoot(p) if root_id == 0 else mergeRoot(root_id, p)",
      "mutated_line": "root_id = findRoot(p) if root_id == 1 else mergeRoot(root_id, p)",
      "code": "from collections import defaultdict\nMAXPRIME = 100001\nisPrime = [0 for _ in range(MAXPRIME + 1)]\nisPrime[0] = -1\nisPrime[1] = -1\nfor i in range(2, MAXPRIME):\n    if isPrime[i] == 0:\n        for multiple in range(i * i, MAXPRIME + 1, i):\n            if isPrime[multiple] == 0:\n                isPrime[multiple] = i\n        isPrime[i] = i\n\ndef largest_component_size(A):\n    label = defaultdict(int)\n\n    def findRoot(key):\n        if label[key] > 0:\n            label[key] = findRoot(label[key])\n            return label[key]\n        else:\n            return key\n\n    def mergeRoot(k1, k2):\n        (r1, r2) = (findRoot(k1), findRoot(k2))\n        if r1 != r2:\n            (r1, r2) = (min(r1, r2), max(r1, r2))\n            label[r1] += label[r2]\n            label[r2] = r1\n        return r1\n    for x in A:\n        root_id = 0\n        prime_factors = set()\n        while isPrime[x] != -1:\n            p = isPrime[x]\n            root_id = findRoot(p) if root_id == 1 else mergeRoot(root_id, p)\n            x //= p\n        label[root_id] -= 1\n    return -min(label.values())"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "root_id = findRoot(p) if root_id == 0 else mergeRoot(root_id, p)",
      "mutated_line": "root_id = findRoot(p) if root_id == -1 else mergeRoot(root_id, p)",
      "code": "from collections import defaultdict\nMAXPRIME = 100001\nisPrime = [0 for _ in range(MAXPRIME + 1)]\nisPrime[0] = -1\nisPrime[1] = -1\nfor i in range(2, MAXPRIME):\n    if isPrime[i] == 0:\n        for multiple in range(i * i, MAXPRIME + 1, i):\n            if isPrime[multiple] == 0:\n                isPrime[multiple] = i\n        isPrime[i] = i\n\ndef largest_component_size(A):\n    label = defaultdict(int)\n\n    def findRoot(key):\n        if label[key] > 0:\n            label[key] = findRoot(label[key])\n            return label[key]\n        else:\n            return key\n\n    def mergeRoot(k1, k2):\n        (r1, r2) = (findRoot(k1), findRoot(k2))\n        if r1 != r2:\n            (r1, r2) = (min(r1, r2), max(r1, r2))\n            label[r1] += label[r2]\n            label[r2] = r1\n        return r1\n    for x in A:\n        root_id = 0\n        prime_factors = set()\n        while isPrime[x] != -1:\n            p = isPrime[x]\n            root_id = findRoot(p) if root_id == -1 else mergeRoot(root_id, p)\n            x //= p\n        label[root_id] -= 1\n    return -min(label.values())"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "root_id = findRoot(p) if root_id == 0 else mergeRoot(root_id, p)",
      "mutated_line": "root_id = findRoot(p) if root_id == 1 else mergeRoot(root_id, p)",
      "code": "from collections import defaultdict\nMAXPRIME = 100001\nisPrime = [0 for _ in range(MAXPRIME + 1)]\nisPrime[0] = -1\nisPrime[1] = -1\nfor i in range(2, MAXPRIME):\n    if isPrime[i] == 0:\n        for multiple in range(i * i, MAXPRIME + 1, i):\n            if isPrime[multiple] == 0:\n                isPrime[multiple] = i\n        isPrime[i] = i\n\ndef largest_component_size(A):\n    label = defaultdict(int)\n\n    def findRoot(key):\n        if label[key] > 0:\n            label[key] = findRoot(label[key])\n            return label[key]\n        else:\n            return key\n\n    def mergeRoot(k1, k2):\n        (r1, r2) = (findRoot(k1), findRoot(k2))\n        if r1 != r2:\n            (r1, r2) = (min(r1, r2), max(r1, r2))\n            label[r1] += label[r2]\n            label[r2] = r1\n        return r1\n    for x in A:\n        root_id = 0\n        prime_factors = set()\n        while isPrime[x] != -1:\n            p = isPrime[x]\n            root_id = findRoot(p) if root_id == 1 else mergeRoot(root_id, p)\n            x //= p\n        label[root_id] -= 1\n    return -min(label.values())"
    }
  ]
}