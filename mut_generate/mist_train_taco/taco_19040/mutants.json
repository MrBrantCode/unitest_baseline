{
  "task_id": "taco_19040",
  "entry_point": "count_paths_in_cost_range",
  "mutant_count": 29,
  "mutants": [
    {
      "operator": "ASR",
      "lineno": 22,
      "original_line": "counts[W] += u.size * v.size",
      "mutated_line": "counts[W] -= u.size * v.size",
      "code": "from collections import defaultdict\nimport bisect\n\ndef count_paths_in_cost_range(N, Q, edges, queries):\n    weights = sorted(edges)\n\n    class Node:\n\n        def __init__(self, size, parent=None):\n            self.size = size\n            self.parent = parent\n    clusters = {n: Node(1) for n in range(1, N + 1)}\n    counts = defaultdict(int)\n    for (W, U, V) in weights:\n        u = clusters[U]\n        v = clusters[V]\n        while u.parent:\n            u = u.parent\n        while v.parent:\n            v = v.parent\n        counts[W] -= u.size * v.size\n        n = Node(u.size + v.size)\n        u.parent = n\n        v.parent = n\n        clusters[U] = n\n        clusters[V] = n\n    K = sorted(counts)\n    V = [counts[k] for k in K]\n    Z = [0]\n    t = 0\n    for v in V:\n        t += v\n        Z.append(t)\n    results = []\n    for (L, R) in queries:\n        x = bisect.bisect_left(K, L)\n        y = bisect.bisect_right(K, R)\n        results.append(Z[y] - Z[x])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "t = 0",
      "mutated_line": "t = 1",
      "code": "from collections import defaultdict\nimport bisect\n\ndef count_paths_in_cost_range(N, Q, edges, queries):\n    weights = sorted(edges)\n\n    class Node:\n\n        def __init__(self, size, parent=None):\n            self.size = size\n            self.parent = parent\n    clusters = {n: Node(1) for n in range(1, N + 1)}\n    counts = defaultdict(int)\n    for (W, U, V) in weights:\n        u = clusters[U]\n        v = clusters[V]\n        while u.parent:\n            u = u.parent\n        while v.parent:\n            v = v.parent\n        counts[W] += u.size * v.size\n        n = Node(u.size + v.size)\n        u.parent = n\n        v.parent = n\n        clusters[U] = n\n        clusters[V] = n\n    K = sorted(counts)\n    V = [counts[k] for k in K]\n    Z = [0]\n    t = 1\n    for v in V:\n        t += v\n        Z.append(t)\n    results = []\n    for (L, R) in queries:\n        x = bisect.bisect_left(K, L)\n        y = bisect.bisect_right(K, R)\n        results.append(Z[y] - Z[x])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "t = 0",
      "mutated_line": "t = -1",
      "code": "from collections import defaultdict\nimport bisect\n\ndef count_paths_in_cost_range(N, Q, edges, queries):\n    weights = sorted(edges)\n\n    class Node:\n\n        def __init__(self, size, parent=None):\n            self.size = size\n            self.parent = parent\n    clusters = {n: Node(1) for n in range(1, N + 1)}\n    counts = defaultdict(int)\n    for (W, U, V) in weights:\n        u = clusters[U]\n        v = clusters[V]\n        while u.parent:\n            u = u.parent\n        while v.parent:\n            v = v.parent\n        counts[W] += u.size * v.size\n        n = Node(u.size + v.size)\n        u.parent = n\n        v.parent = n\n        clusters[U] = n\n        clusters[V] = n\n    K = sorted(counts)\n    V = [counts[k] for k in K]\n    Z = [0]\n    t = -1\n    for v in V:\n        t += v\n        Z.append(t)\n    results = []\n    for (L, R) in queries:\n        x = bisect.bisect_left(K, L)\n        y = bisect.bisect_right(K, R)\n        results.append(Z[y] - Z[x])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "t = 0",
      "mutated_line": "t = 1",
      "code": "from collections import defaultdict\nimport bisect\n\ndef count_paths_in_cost_range(N, Q, edges, queries):\n    weights = sorted(edges)\n\n    class Node:\n\n        def __init__(self, size, parent=None):\n            self.size = size\n            self.parent = parent\n    clusters = {n: Node(1) for n in range(1, N + 1)}\n    counts = defaultdict(int)\n    for (W, U, V) in weights:\n        u = clusters[U]\n        v = clusters[V]\n        while u.parent:\n            u = u.parent\n        while v.parent:\n            v = v.parent\n        counts[W] += u.size * v.size\n        n = Node(u.size + v.size)\n        u.parent = n\n        v.parent = n\n        clusters[U] = n\n        clusters[V] = n\n    K = sorted(counts)\n    V = [counts[k] for k in K]\n    Z = [0]\n    t = 1\n    for v in V:\n        t += v\n        Z.append(t)\n    results = []\n    for (L, R) in queries:\n        x = bisect.bisect_left(K, L)\n        y = bisect.bisect_right(K, R)\n        results.append(Z[y] - Z[x])\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 34,
      "original_line": "t += v",
      "mutated_line": "t -= v",
      "code": "from collections import defaultdict\nimport bisect\n\ndef count_paths_in_cost_range(N, Q, edges, queries):\n    weights = sorted(edges)\n\n    class Node:\n\n        def __init__(self, size, parent=None):\n            self.size = size\n            self.parent = parent\n    clusters = {n: Node(1) for n in range(1, N + 1)}\n    counts = defaultdict(int)\n    for (W, U, V) in weights:\n        u = clusters[U]\n        v = clusters[V]\n        while u.parent:\n            u = u.parent\n        while v.parent:\n            v = v.parent\n        counts[W] += u.size * v.size\n        n = Node(u.size + v.size)\n        u.parent = n\n        v.parent = n\n        clusters[U] = n\n        clusters[V] = n\n    K = sorted(counts)\n    V = [counts[k] for k in K]\n    Z = [0]\n    t = 0\n    for v in V:\n        t -= v\n        Z.append(t)\n    results = []\n    for (L, R) in queries:\n        x = bisect.bisect_left(K, L)\n        y = bisect.bisect_right(K, R)\n        results.append(Z[y] - Z[x])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "counts[W] += u.size * v.size",
      "mutated_line": "counts[W] += u.size / v.size",
      "code": "from collections import defaultdict\nimport bisect\n\ndef count_paths_in_cost_range(N, Q, edges, queries):\n    weights = sorted(edges)\n\n    class Node:\n\n        def __init__(self, size, parent=None):\n            self.size = size\n            self.parent = parent\n    clusters = {n: Node(1) for n in range(1, N + 1)}\n    counts = defaultdict(int)\n    for (W, U, V) in weights:\n        u = clusters[U]\n        v = clusters[V]\n        while u.parent:\n            u = u.parent\n        while v.parent:\n            v = v.parent\n        counts[W] += u.size / v.size\n        n = Node(u.size + v.size)\n        u.parent = n\n        v.parent = n\n        clusters[U] = n\n        clusters[V] = n\n    K = sorted(counts)\n    V = [counts[k] for k in K]\n    Z = [0]\n    t = 0\n    for v in V:\n        t += v\n        Z.append(t)\n    results = []\n    for (L, R) in queries:\n        x = bisect.bisect_left(K, L)\n        y = bisect.bisect_right(K, R)\n        results.append(Z[y] - Z[x])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "counts[W] += u.size * v.size",
      "mutated_line": "counts[W] += u.size + v.size",
      "code": "from collections import defaultdict\nimport bisect\n\ndef count_paths_in_cost_range(N, Q, edges, queries):\n    weights = sorted(edges)\n\n    class Node:\n\n        def __init__(self, size, parent=None):\n            self.size = size\n            self.parent = parent\n    clusters = {n: Node(1) for n in range(1, N + 1)}\n    counts = defaultdict(int)\n    for (W, U, V) in weights:\n        u = clusters[U]\n        v = clusters[V]\n        while u.parent:\n            u = u.parent\n        while v.parent:\n            v = v.parent\n        counts[W] += u.size + v.size\n        n = Node(u.size + v.size)\n        u.parent = n\n        v.parent = n\n        clusters[U] = n\n        clusters[V] = n\n    K = sorted(counts)\n    V = [counts[k] for k in K]\n    Z = [0]\n    t = 0\n    for v in V:\n        t += v\n        Z.append(t)\n    results = []\n    for (L, R) in queries:\n        x = bisect.bisect_left(K, L)\n        y = bisect.bisect_right(K, R)\n        results.append(Z[y] - Z[x])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "counts[W] += u.size * v.size",
      "mutated_line": "counts[W] += u.size ** v.size",
      "code": "from collections import defaultdict\nimport bisect\n\ndef count_paths_in_cost_range(N, Q, edges, queries):\n    weights = sorted(edges)\n\n    class Node:\n\n        def __init__(self, size, parent=None):\n            self.size = size\n            self.parent = parent\n    clusters = {n: Node(1) for n in range(1, N + 1)}\n    counts = defaultdict(int)\n    for (W, U, V) in weights:\n        u = clusters[U]\n        v = clusters[V]\n        while u.parent:\n            u = u.parent\n        while v.parent:\n            v = v.parent\n        counts[W] += u.size ** v.size\n        n = Node(u.size + v.size)\n        u.parent = n\n        v.parent = n\n        clusters[U] = n\n        clusters[V] = n\n    K = sorted(counts)\n    V = [counts[k] for k in K]\n    Z = [0]\n    t = 0\n    for v in V:\n        t += v\n        Z.append(t)\n    results = []\n    for (L, R) in queries:\n        x = bisect.bisect_left(K, L)\n        y = bisect.bisect_right(K, R)\n        results.append(Z[y] - Z[x])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "Z = [0]",
      "mutated_line": "Z = [1]",
      "code": "from collections import defaultdict\nimport bisect\n\ndef count_paths_in_cost_range(N, Q, edges, queries):\n    weights = sorted(edges)\n\n    class Node:\n\n        def __init__(self, size, parent=None):\n            self.size = size\n            self.parent = parent\n    clusters = {n: Node(1) for n in range(1, N + 1)}\n    counts = defaultdict(int)\n    for (W, U, V) in weights:\n        u = clusters[U]\n        v = clusters[V]\n        while u.parent:\n            u = u.parent\n        while v.parent:\n            v = v.parent\n        counts[W] += u.size * v.size\n        n = Node(u.size + v.size)\n        u.parent = n\n        v.parent = n\n        clusters[U] = n\n        clusters[V] = n\n    K = sorted(counts)\n    V = [counts[k] for k in K]\n    Z = [1]\n    t = 0\n    for v in V:\n        t += v\n        Z.append(t)\n    results = []\n    for (L, R) in queries:\n        x = bisect.bisect_left(K, L)\n        y = bisect.bisect_right(K, R)\n        results.append(Z[y] - Z[x])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "Z = [0]",
      "mutated_line": "Z = [-1]",
      "code": "from collections import defaultdict\nimport bisect\n\ndef count_paths_in_cost_range(N, Q, edges, queries):\n    weights = sorted(edges)\n\n    class Node:\n\n        def __init__(self, size, parent=None):\n            self.size = size\n            self.parent = parent\n    clusters = {n: Node(1) for n in range(1, N + 1)}\n    counts = defaultdict(int)\n    for (W, U, V) in weights:\n        u = clusters[U]\n        v = clusters[V]\n        while u.parent:\n            u = u.parent\n        while v.parent:\n            v = v.parent\n        counts[W] += u.size * v.size\n        n = Node(u.size + v.size)\n        u.parent = n\n        v.parent = n\n        clusters[U] = n\n        clusters[V] = n\n    K = sorted(counts)\n    V = [counts[k] for k in K]\n    Z = [-1]\n    t = 0\n    for v in V:\n        t += v\n        Z.append(t)\n    results = []\n    for (L, R) in queries:\n        x = bisect.bisect_left(K, L)\n        y = bisect.bisect_right(K, R)\n        results.append(Z[y] - Z[x])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "Z = [0]",
      "mutated_line": "Z = [1]",
      "code": "from collections import defaultdict\nimport bisect\n\ndef count_paths_in_cost_range(N, Q, edges, queries):\n    weights = sorted(edges)\n\n    class Node:\n\n        def __init__(self, size, parent=None):\n            self.size = size\n            self.parent = parent\n    clusters = {n: Node(1) for n in range(1, N + 1)}\n    counts = defaultdict(int)\n    for (W, U, V) in weights:\n        u = clusters[U]\n        v = clusters[V]\n        while u.parent:\n            u = u.parent\n        while v.parent:\n            v = v.parent\n        counts[W] += u.size * v.size\n        n = Node(u.size + v.size)\n        u.parent = n\n        v.parent = n\n        clusters[U] = n\n        clusters[V] = n\n    K = sorted(counts)\n    V = [counts[k] for k in K]\n    Z = [1]\n    t = 0\n    for v in V:\n        t += v\n        Z.append(t)\n    results = []\n    for (L, R) in queries:\n        x = bisect.bisect_left(K, L)\n        y = bisect.bisect_right(K, R)\n        results.append(Z[y] - Z[x])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "clusters = {n: Node(1) for n in range(1, N + 1)}",
      "mutated_line": "clusters = {n: Node(2) for n in range(1, N + 1)}",
      "code": "from collections import defaultdict\nimport bisect\n\ndef count_paths_in_cost_range(N, Q, edges, queries):\n    weights = sorted(edges)\n\n    class Node:\n\n        def __init__(self, size, parent=None):\n            self.size = size\n            self.parent = parent\n    clusters = {n: Node(2) for n in range(1, N + 1)}\n    counts = defaultdict(int)\n    for (W, U, V) in weights:\n        u = clusters[U]\n        v = clusters[V]\n        while u.parent:\n            u = u.parent\n        while v.parent:\n            v = v.parent\n        counts[W] += u.size * v.size\n        n = Node(u.size + v.size)\n        u.parent = n\n        v.parent = n\n        clusters[U] = n\n        clusters[V] = n\n    K = sorted(counts)\n    V = [counts[k] for k in K]\n    Z = [0]\n    t = 0\n    for v in V:\n        t += v\n        Z.append(t)\n    results = []\n    for (L, R) in queries:\n        x = bisect.bisect_left(K, L)\n        y = bisect.bisect_right(K, R)\n        results.append(Z[y] - Z[x])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "clusters = {n: Node(1) for n in range(1, N + 1)}",
      "mutated_line": "clusters = {n: Node(0) for n in range(1, N + 1)}",
      "code": "from collections import defaultdict\nimport bisect\n\ndef count_paths_in_cost_range(N, Q, edges, queries):\n    weights = sorted(edges)\n\n    class Node:\n\n        def __init__(self, size, parent=None):\n            self.size = size\n            self.parent = parent\n    clusters = {n: Node(0) for n in range(1, N + 1)}\n    counts = defaultdict(int)\n    for (W, U, V) in weights:\n        u = clusters[U]\n        v = clusters[V]\n        while u.parent:\n            u = u.parent\n        while v.parent:\n            v = v.parent\n        counts[W] += u.size * v.size\n        n = Node(u.size + v.size)\n        u.parent = n\n        v.parent = n\n        clusters[U] = n\n        clusters[V] = n\n    K = sorted(counts)\n    V = [counts[k] for k in K]\n    Z = [0]\n    t = 0\n    for v in V:\n        t += v\n        Z.append(t)\n    results = []\n    for (L, R) in queries:\n        x = bisect.bisect_left(K, L)\n        y = bisect.bisect_right(K, R)\n        results.append(Z[y] - Z[x])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "clusters = {n: Node(1) for n in range(1, N + 1)}",
      "mutated_line": "clusters = {n: Node(0) for n in range(1, N + 1)}",
      "code": "from collections import defaultdict\nimport bisect\n\ndef count_paths_in_cost_range(N, Q, edges, queries):\n    weights = sorted(edges)\n\n    class Node:\n\n        def __init__(self, size, parent=None):\n            self.size = size\n            self.parent = parent\n    clusters = {n: Node(0) for n in range(1, N + 1)}\n    counts = defaultdict(int)\n    for (W, U, V) in weights:\n        u = clusters[U]\n        v = clusters[V]\n        while u.parent:\n            u = u.parent\n        while v.parent:\n            v = v.parent\n        counts[W] += u.size * v.size\n        n = Node(u.size + v.size)\n        u.parent = n\n        v.parent = n\n        clusters[U] = n\n        clusters[V] = n\n    K = sorted(counts)\n    V = [counts[k] for k in K]\n    Z = [0]\n    t = 0\n    for v in V:\n        t += v\n        Z.append(t)\n    results = []\n    for (L, R) in queries:\n        x = bisect.bisect_left(K, L)\n        y = bisect.bisect_right(K, R)\n        results.append(Z[y] - Z[x])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "clusters = {n: Node(1) for n in range(1, N + 1)}",
      "mutated_line": "clusters = {n: Node(-1) for n in range(1, N + 1)}",
      "code": "from collections import defaultdict\nimport bisect\n\ndef count_paths_in_cost_range(N, Q, edges, queries):\n    weights = sorted(edges)\n\n    class Node:\n\n        def __init__(self, size, parent=None):\n            self.size = size\n            self.parent = parent\n    clusters = {n: Node(-1) for n in range(1, N + 1)}\n    counts = defaultdict(int)\n    for (W, U, V) in weights:\n        u = clusters[U]\n        v = clusters[V]\n        while u.parent:\n            u = u.parent\n        while v.parent:\n            v = v.parent\n        counts[W] += u.size * v.size\n        n = Node(u.size + v.size)\n        u.parent = n\n        v.parent = n\n        clusters[U] = n\n        clusters[V] = n\n    K = sorted(counts)\n    V = [counts[k] for k in K]\n    Z = [0]\n    t = 0\n    for v in V:\n        t += v\n        Z.append(t)\n    results = []\n    for (L, R) in queries:\n        x = bisect.bisect_left(K, L)\n        y = bisect.bisect_right(K, R)\n        results.append(Z[y] - Z[x])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "n = Node(u.size + v.size)",
      "mutated_line": "n = Node(u.size - v.size)",
      "code": "from collections import defaultdict\nimport bisect\n\ndef count_paths_in_cost_range(N, Q, edges, queries):\n    weights = sorted(edges)\n\n    class Node:\n\n        def __init__(self, size, parent=None):\n            self.size = size\n            self.parent = parent\n    clusters = {n: Node(1) for n in range(1, N + 1)}\n    counts = defaultdict(int)\n    for (W, U, V) in weights:\n        u = clusters[U]\n        v = clusters[V]\n        while u.parent:\n            u = u.parent\n        while v.parent:\n            v = v.parent\n        counts[W] += u.size * v.size\n        n = Node(u.size - v.size)\n        u.parent = n\n        v.parent = n\n        clusters[U] = n\n        clusters[V] = n\n    K = sorted(counts)\n    V = [counts[k] for k in K]\n    Z = [0]\n    t = 0\n    for v in V:\n        t += v\n        Z.append(t)\n    results = []\n    for (L, R) in queries:\n        x = bisect.bisect_left(K, L)\n        y = bisect.bisect_right(K, R)\n        results.append(Z[y] - Z[x])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "n = Node(u.size + v.size)",
      "mutated_line": "n = Node(u.size * v.size)",
      "code": "from collections import defaultdict\nimport bisect\n\ndef count_paths_in_cost_range(N, Q, edges, queries):\n    weights = sorted(edges)\n\n    class Node:\n\n        def __init__(self, size, parent=None):\n            self.size = size\n            self.parent = parent\n    clusters = {n: Node(1) for n in range(1, N + 1)}\n    counts = defaultdict(int)\n    for (W, U, V) in weights:\n        u = clusters[U]\n        v = clusters[V]\n        while u.parent:\n            u = u.parent\n        while v.parent:\n            v = v.parent\n        counts[W] += u.size * v.size\n        n = Node(u.size * v.size)\n        u.parent = n\n        v.parent = n\n        clusters[U] = n\n        clusters[V] = n\n    K = sorted(counts)\n    V = [counts[k] for k in K]\n    Z = [0]\n    t = 0\n    for v in V:\n        t += v\n        Z.append(t)\n    results = []\n    for (L, R) in queries:\n        x = bisect.bisect_left(K, L)\n        y = bisect.bisect_right(K, R)\n        results.append(Z[y] - Z[x])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "results.append(Z[y] - Z[x])",
      "mutated_line": "results.append(Z[y] + Z[x])",
      "code": "from collections import defaultdict\nimport bisect\n\ndef count_paths_in_cost_range(N, Q, edges, queries):\n    weights = sorted(edges)\n\n    class Node:\n\n        def __init__(self, size, parent=None):\n            self.size = size\n            self.parent = parent\n    clusters = {n: Node(1) for n in range(1, N + 1)}\n    counts = defaultdict(int)\n    for (W, U, V) in weights:\n        u = clusters[U]\n        v = clusters[V]\n        while u.parent:\n            u = u.parent\n        while v.parent:\n            v = v.parent\n        counts[W] += u.size * v.size\n        n = Node(u.size + v.size)\n        u.parent = n\n        v.parent = n\n        clusters[U] = n\n        clusters[V] = n\n    K = sorted(counts)\n    V = [counts[k] for k in K]\n    Z = [0]\n    t = 0\n    for v in V:\n        t += v\n        Z.append(t)\n    results = []\n    for (L, R) in queries:\n        x = bisect.bisect_left(K, L)\n        y = bisect.bisect_right(K, R)\n        results.append(Z[y] + Z[x])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "results.append(Z[y] - Z[x])",
      "mutated_line": "results.append(Z[y] * Z[x])",
      "code": "from collections import defaultdict\nimport bisect\n\ndef count_paths_in_cost_range(N, Q, edges, queries):\n    weights = sorted(edges)\n\n    class Node:\n\n        def __init__(self, size, parent=None):\n            self.size = size\n            self.parent = parent\n    clusters = {n: Node(1) for n in range(1, N + 1)}\n    counts = defaultdict(int)\n    for (W, U, V) in weights:\n        u = clusters[U]\n        v = clusters[V]\n        while u.parent:\n            u = u.parent\n        while v.parent:\n            v = v.parent\n        counts[W] += u.size * v.size\n        n = Node(u.size + v.size)\n        u.parent = n\n        v.parent = n\n        clusters[U] = n\n        clusters[V] = n\n    K = sorted(counts)\n    V = [counts[k] for k in K]\n    Z = [0]\n    t = 0\n    for v in V:\n        t += v\n        Z.append(t)\n    results = []\n    for (L, R) in queries:\n        x = bisect.bisect_left(K, L)\n        y = bisect.bisect_right(K, R)\n        results.append(Z[y] * Z[x])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "clusters = {n: Node(1) for n in range(1, N + 1)}",
      "mutated_line": "clusters = {n: Node(1) for n in range(2, N + 1)}",
      "code": "from collections import defaultdict\nimport bisect\n\ndef count_paths_in_cost_range(N, Q, edges, queries):\n    weights = sorted(edges)\n\n    class Node:\n\n        def __init__(self, size, parent=None):\n            self.size = size\n            self.parent = parent\n    clusters = {n: Node(1) for n in range(2, N + 1)}\n    counts = defaultdict(int)\n    for (W, U, V) in weights:\n        u = clusters[U]\n        v = clusters[V]\n        while u.parent:\n            u = u.parent\n        while v.parent:\n            v = v.parent\n        counts[W] += u.size * v.size\n        n = Node(u.size + v.size)\n        u.parent = n\n        v.parent = n\n        clusters[U] = n\n        clusters[V] = n\n    K = sorted(counts)\n    V = [counts[k] for k in K]\n    Z = [0]\n    t = 0\n    for v in V:\n        t += v\n        Z.append(t)\n    results = []\n    for (L, R) in queries:\n        x = bisect.bisect_left(K, L)\n        y = bisect.bisect_right(K, R)\n        results.append(Z[y] - Z[x])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "clusters = {n: Node(1) for n in range(1, N + 1)}",
      "mutated_line": "clusters = {n: Node(1) for n in range(0, N + 1)}",
      "code": "from collections import defaultdict\nimport bisect\n\ndef count_paths_in_cost_range(N, Q, edges, queries):\n    weights = sorted(edges)\n\n    class Node:\n\n        def __init__(self, size, parent=None):\n            self.size = size\n            self.parent = parent\n    clusters = {n: Node(1) for n in range(0, N + 1)}\n    counts = defaultdict(int)\n    for (W, U, V) in weights:\n        u = clusters[U]\n        v = clusters[V]\n        while u.parent:\n            u = u.parent\n        while v.parent:\n            v = v.parent\n        counts[W] += u.size * v.size\n        n = Node(u.size + v.size)\n        u.parent = n\n        v.parent = n\n        clusters[U] = n\n        clusters[V] = n\n    K = sorted(counts)\n    V = [counts[k] for k in K]\n    Z = [0]\n    t = 0\n    for v in V:\n        t += v\n        Z.append(t)\n    results = []\n    for (L, R) in queries:\n        x = bisect.bisect_left(K, L)\n        y = bisect.bisect_right(K, R)\n        results.append(Z[y] - Z[x])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "clusters = {n: Node(1) for n in range(1, N + 1)}",
      "mutated_line": "clusters = {n: Node(1) for n in range(0, N + 1)}",
      "code": "from collections import defaultdict\nimport bisect\n\ndef count_paths_in_cost_range(N, Q, edges, queries):\n    weights = sorted(edges)\n\n    class Node:\n\n        def __init__(self, size, parent=None):\n            self.size = size\n            self.parent = parent\n    clusters = {n: Node(1) for n in range(0, N + 1)}\n    counts = defaultdict(int)\n    for (W, U, V) in weights:\n        u = clusters[U]\n        v = clusters[V]\n        while u.parent:\n            u = u.parent\n        while v.parent:\n            v = v.parent\n        counts[W] += u.size * v.size\n        n = Node(u.size + v.size)\n        u.parent = n\n        v.parent = n\n        clusters[U] = n\n        clusters[V] = n\n    K = sorted(counts)\n    V = [counts[k] for k in K]\n    Z = [0]\n    t = 0\n    for v in V:\n        t += v\n        Z.append(t)\n    results = []\n    for (L, R) in queries:\n        x = bisect.bisect_left(K, L)\n        y = bisect.bisect_right(K, R)\n        results.append(Z[y] - Z[x])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "clusters = {n: Node(1) for n in range(1, N + 1)}",
      "mutated_line": "clusters = {n: Node(1) for n in range(-1, N + 1)}",
      "code": "from collections import defaultdict\nimport bisect\n\ndef count_paths_in_cost_range(N, Q, edges, queries):\n    weights = sorted(edges)\n\n    class Node:\n\n        def __init__(self, size, parent=None):\n            self.size = size\n            self.parent = parent\n    clusters = {n: Node(1) for n in range(-1, N + 1)}\n    counts = defaultdict(int)\n    for (W, U, V) in weights:\n        u = clusters[U]\n        v = clusters[V]\n        while u.parent:\n            u = u.parent\n        while v.parent:\n            v = v.parent\n        counts[W] += u.size * v.size\n        n = Node(u.size + v.size)\n        u.parent = n\n        v.parent = n\n        clusters[U] = n\n        clusters[V] = n\n    K = sorted(counts)\n    V = [counts[k] for k in K]\n    Z = [0]\n    t = 0\n    for v in V:\n        t += v\n        Z.append(t)\n    results = []\n    for (L, R) in queries:\n        x = bisect.bisect_left(K, L)\n        y = bisect.bisect_right(K, R)\n        results.append(Z[y] - Z[x])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "clusters = {n: Node(1) for n in range(1, N + 1)}",
      "mutated_line": "clusters = {n: Node(1) for n in range(1, N - 1)}",
      "code": "from collections import defaultdict\nimport bisect\n\ndef count_paths_in_cost_range(N, Q, edges, queries):\n    weights = sorted(edges)\n\n    class Node:\n\n        def __init__(self, size, parent=None):\n            self.size = size\n            self.parent = parent\n    clusters = {n: Node(1) for n in range(1, N - 1)}\n    counts = defaultdict(int)\n    for (W, U, V) in weights:\n        u = clusters[U]\n        v = clusters[V]\n        while u.parent:\n            u = u.parent\n        while v.parent:\n            v = v.parent\n        counts[W] += u.size * v.size\n        n = Node(u.size + v.size)\n        u.parent = n\n        v.parent = n\n        clusters[U] = n\n        clusters[V] = n\n    K = sorted(counts)\n    V = [counts[k] for k in K]\n    Z = [0]\n    t = 0\n    for v in V:\n        t += v\n        Z.append(t)\n    results = []\n    for (L, R) in queries:\n        x = bisect.bisect_left(K, L)\n        y = bisect.bisect_right(K, R)\n        results.append(Z[y] - Z[x])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "clusters = {n: Node(1) for n in range(1, N + 1)}",
      "mutated_line": "clusters = {n: Node(1) for n in range(1, N * 1)}",
      "code": "from collections import defaultdict\nimport bisect\n\ndef count_paths_in_cost_range(N, Q, edges, queries):\n    weights = sorted(edges)\n\n    class Node:\n\n        def __init__(self, size, parent=None):\n            self.size = size\n            self.parent = parent\n    clusters = {n: Node(1) for n in range(1, N * 1)}\n    counts = defaultdict(int)\n    for (W, U, V) in weights:\n        u = clusters[U]\n        v = clusters[V]\n        while u.parent:\n            u = u.parent\n        while v.parent:\n            v = v.parent\n        counts[W] += u.size * v.size\n        n = Node(u.size + v.size)\n        u.parent = n\n        v.parent = n\n        clusters[U] = n\n        clusters[V] = n\n    K = sorted(counts)\n    V = [counts[k] for k in K]\n    Z = [0]\n    t = 0\n    for v in V:\n        t += v\n        Z.append(t)\n    results = []\n    for (L, R) in queries:\n        x = bisect.bisect_left(K, L)\n        y = bisect.bisect_right(K, R)\n        results.append(Z[y] - Z[x])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "clusters = {n: Node(1) for n in range(1, N + 1)}",
      "mutated_line": "clusters = {n: Node(1) for n in range(1, N + 2)}",
      "code": "from collections import defaultdict\nimport bisect\n\ndef count_paths_in_cost_range(N, Q, edges, queries):\n    weights = sorted(edges)\n\n    class Node:\n\n        def __init__(self, size, parent=None):\n            self.size = size\n            self.parent = parent\n    clusters = {n: Node(1) for n in range(1, N + 2)}\n    counts = defaultdict(int)\n    for (W, U, V) in weights:\n        u = clusters[U]\n        v = clusters[V]\n        while u.parent:\n            u = u.parent\n        while v.parent:\n            v = v.parent\n        counts[W] += u.size * v.size\n        n = Node(u.size + v.size)\n        u.parent = n\n        v.parent = n\n        clusters[U] = n\n        clusters[V] = n\n    K = sorted(counts)\n    V = [counts[k] for k in K]\n    Z = [0]\n    t = 0\n    for v in V:\n        t += v\n        Z.append(t)\n    results = []\n    for (L, R) in queries:\n        x = bisect.bisect_left(K, L)\n        y = bisect.bisect_right(K, R)\n        results.append(Z[y] - Z[x])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "clusters = {n: Node(1) for n in range(1, N + 1)}",
      "mutated_line": "clusters = {n: Node(1) for n in range(1, N + 0)}",
      "code": "from collections import defaultdict\nimport bisect\n\ndef count_paths_in_cost_range(N, Q, edges, queries):\n    weights = sorted(edges)\n\n    class Node:\n\n        def __init__(self, size, parent=None):\n            self.size = size\n            self.parent = parent\n    clusters = {n: Node(1) for n in range(1, N + 0)}\n    counts = defaultdict(int)\n    for (W, U, V) in weights:\n        u = clusters[U]\n        v = clusters[V]\n        while u.parent:\n            u = u.parent\n        while v.parent:\n            v = v.parent\n        counts[W] += u.size * v.size\n        n = Node(u.size + v.size)\n        u.parent = n\n        v.parent = n\n        clusters[U] = n\n        clusters[V] = n\n    K = sorted(counts)\n    V = [counts[k] for k in K]\n    Z = [0]\n    t = 0\n    for v in V:\n        t += v\n        Z.append(t)\n    results = []\n    for (L, R) in queries:\n        x = bisect.bisect_left(K, L)\n        y = bisect.bisect_right(K, R)\n        results.append(Z[y] - Z[x])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "clusters = {n: Node(1) for n in range(1, N + 1)}",
      "mutated_line": "clusters = {n: Node(1) for n in range(1, N + 0)}",
      "code": "from collections import defaultdict\nimport bisect\n\ndef count_paths_in_cost_range(N, Q, edges, queries):\n    weights = sorted(edges)\n\n    class Node:\n\n        def __init__(self, size, parent=None):\n            self.size = size\n            self.parent = parent\n    clusters = {n: Node(1) for n in range(1, N + 0)}\n    counts = defaultdict(int)\n    for (W, U, V) in weights:\n        u = clusters[U]\n        v = clusters[V]\n        while u.parent:\n            u = u.parent\n        while v.parent:\n            v = v.parent\n        counts[W] += u.size * v.size\n        n = Node(u.size + v.size)\n        u.parent = n\n        v.parent = n\n        clusters[U] = n\n        clusters[V] = n\n    K = sorted(counts)\n    V = [counts[k] for k in K]\n    Z = [0]\n    t = 0\n    for v in V:\n        t += v\n        Z.append(t)\n    results = []\n    for (L, R) in queries:\n        x = bisect.bisect_left(K, L)\n        y = bisect.bisect_right(K, R)\n        results.append(Z[y] - Z[x])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "clusters = {n: Node(1) for n in range(1, N + 1)}",
      "mutated_line": "clusters = {n: Node(1) for n in range(1, N + -1)}",
      "code": "from collections import defaultdict\nimport bisect\n\ndef count_paths_in_cost_range(N, Q, edges, queries):\n    weights = sorted(edges)\n\n    class Node:\n\n        def __init__(self, size, parent=None):\n            self.size = size\n            self.parent = parent\n    clusters = {n: Node(1) for n in range(1, N + -1)}\n    counts = defaultdict(int)\n    for (W, U, V) in weights:\n        u = clusters[U]\n        v = clusters[V]\n        while u.parent:\n            u = u.parent\n        while v.parent:\n            v = v.parent\n        counts[W] += u.size * v.size\n        n = Node(u.size + v.size)\n        u.parent = n\n        v.parent = n\n        clusters[U] = n\n        clusters[V] = n\n    K = sorted(counts)\n    V = [counts[k] for k in K]\n    Z = [0]\n    t = 0\n    for v in V:\n        t += v\n        Z.append(t)\n    results = []\n    for (L, R) in queries:\n        x = bisect.bisect_left(K, L)\n        y = bisect.bisect_right(K, R)\n        results.append(Z[y] - Z[x])\n    return results"
    }
  ]
}