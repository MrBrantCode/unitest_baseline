{
  "task_id": "taco_8095",
  "entry_point": "max_parallel_line_pairs",
  "mutant_count": 107,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if (state, dx, dy) in memo:",
      "mutated_line": "if (state, dx, dy) not in memo:",
      "code": "def max_parallel_line_pairs(points):\n    m = len(points)\n    s = set()\n    for i in range(m):\n        (xi, yi) = points[i]\n        for j in range(i + 1, m):\n            (xj, yj) = points[j]\n            u = xj - xi\n            v = yj - yi\n            for (x, y) in s:\n                if x * v == y * u:\n                    break\n            else:\n                s.add((u, v))\n    memo = {}\n\n    def dfs(state, dx, dy):\n        if (state, dx, dy) not in memo:\n            return memo[state, dx, dy]\n        pstate = state\n        update = 1\n        cnt = -1\n        while update:\n            update = 0\n            cnt += 1\n            for i in range(m):\n                if state >> i & 1:\n                    continue\n                (xi, yi) = points[i]\n                for j in range(i + 1, m):\n                    if state >> j & 1:\n                        continue\n                    (xj, yj) = points[j]\n                    u = xj - xi\n                    v = yj - yi\n                    if dx * v == dy * u:\n                        update = 1\n                        state |= 1 << i | 1 << j\n                        break\n                if update:\n                    break\n        if cnt <= 1:\n            res = 0\n        else:\n            res = cnt * (cnt - 1) // 2 + max((dfs(state, *e) for e in s))\n        memo[pstate, dx, dy] = res\n        return res\n    return max((dfs(0, *e) for e in s))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "update = 1",
      "mutated_line": "update = 2",
      "code": "def max_parallel_line_pairs(points):\n    m = len(points)\n    s = set()\n    for i in range(m):\n        (xi, yi) = points[i]\n        for j in range(i + 1, m):\n            (xj, yj) = points[j]\n            u = xj - xi\n            v = yj - yi\n            for (x, y) in s:\n                if x * v == y * u:\n                    break\n            else:\n                s.add((u, v))\n    memo = {}\n\n    def dfs(state, dx, dy):\n        if (state, dx, dy) in memo:\n            return memo[state, dx, dy]\n        pstate = state\n        update = 2\n        cnt = -1\n        while update:\n            update = 0\n            cnt += 1\n            for i in range(m):\n                if state >> i & 1:\n                    continue\n                (xi, yi) = points[i]\n                for j in range(i + 1, m):\n                    if state >> j & 1:\n                        continue\n                    (xj, yj) = points[j]\n                    u = xj - xi\n                    v = yj - yi\n                    if dx * v == dy * u:\n                        update = 1\n                        state |= 1 << i | 1 << j\n                        break\n                if update:\n                    break\n        if cnt <= 1:\n            res = 0\n        else:\n            res = cnt * (cnt - 1) // 2 + max((dfs(state, *e) for e in s))\n        memo[pstate, dx, dy] = res\n        return res\n    return max((dfs(0, *e) for e in s))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "update = 1",
      "mutated_line": "update = 0",
      "code": "def max_parallel_line_pairs(points):\n    m = len(points)\n    s = set()\n    for i in range(m):\n        (xi, yi) = points[i]\n        for j in range(i + 1, m):\n            (xj, yj) = points[j]\n            u = xj - xi\n            v = yj - yi\n            for (x, y) in s:\n                if x * v == y * u:\n                    break\n            else:\n                s.add((u, v))\n    memo = {}\n\n    def dfs(state, dx, dy):\n        if (state, dx, dy) in memo:\n            return memo[state, dx, dy]\n        pstate = state\n        update = 0\n        cnt = -1\n        while update:\n            update = 0\n            cnt += 1\n            for i in range(m):\n                if state >> i & 1:\n                    continue\n                (xi, yi) = points[i]\n                for j in range(i + 1, m):\n                    if state >> j & 1:\n                        continue\n                    (xj, yj) = points[j]\n                    u = xj - xi\n                    v = yj - yi\n                    if dx * v == dy * u:\n                        update = 1\n                        state |= 1 << i | 1 << j\n                        break\n                if update:\n                    break\n        if cnt <= 1:\n            res = 0\n        else:\n            res = cnt * (cnt - 1) // 2 + max((dfs(state, *e) for e in s))\n        memo[pstate, dx, dy] = res\n        return res\n    return max((dfs(0, *e) for e in s))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "update = 1",
      "mutated_line": "update = 0",
      "code": "def max_parallel_line_pairs(points):\n    m = len(points)\n    s = set()\n    for i in range(m):\n        (xi, yi) = points[i]\n        for j in range(i + 1, m):\n            (xj, yj) = points[j]\n            u = xj - xi\n            v = yj - yi\n            for (x, y) in s:\n                if x * v == y * u:\n                    break\n            else:\n                s.add((u, v))\n    memo = {}\n\n    def dfs(state, dx, dy):\n        if (state, dx, dy) in memo:\n            return memo[state, dx, dy]\n        pstate = state\n        update = 0\n        cnt = -1\n        while update:\n            update = 0\n            cnt += 1\n            for i in range(m):\n                if state >> i & 1:\n                    continue\n                (xi, yi) = points[i]\n                for j in range(i + 1, m):\n                    if state >> j & 1:\n                        continue\n                    (xj, yj) = points[j]\n                    u = xj - xi\n                    v = yj - yi\n                    if dx * v == dy * u:\n                        update = 1\n                        state |= 1 << i | 1 << j\n                        break\n                if update:\n                    break\n        if cnt <= 1:\n            res = 0\n        else:\n            res = cnt * (cnt - 1) // 2 + max((dfs(state, *e) for e in s))\n        memo[pstate, dx, dy] = res\n        return res\n    return max((dfs(0, *e) for e in s))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "update = 1",
      "mutated_line": "update = -1",
      "code": "def max_parallel_line_pairs(points):\n    m = len(points)\n    s = set()\n    for i in range(m):\n        (xi, yi) = points[i]\n        for j in range(i + 1, m):\n            (xj, yj) = points[j]\n            u = xj - xi\n            v = yj - yi\n            for (x, y) in s:\n                if x * v == y * u:\n                    break\n            else:\n                s.add((u, v))\n    memo = {}\n\n    def dfs(state, dx, dy):\n        if (state, dx, dy) in memo:\n            return memo[state, dx, dy]\n        pstate = state\n        update = -1\n        cnt = -1\n        while update:\n            update = 0\n            cnt += 1\n            for i in range(m):\n                if state >> i & 1:\n                    continue\n                (xi, yi) = points[i]\n                for j in range(i + 1, m):\n                    if state >> j & 1:\n                        continue\n                    (xj, yj) = points[j]\n                    u = xj - xi\n                    v = yj - yi\n                    if dx * v == dy * u:\n                        update = 1\n                        state |= 1 << i | 1 << j\n                        break\n                if update:\n                    break\n        if cnt <= 1:\n            res = 0\n        else:\n            res = cnt * (cnt - 1) // 2 + max((dfs(state, *e) for e in s))\n        memo[pstate, dx, dy] = res\n        return res\n    return max((dfs(0, *e) for e in s))"
    },
    {
      "operator": "UOI",
      "lineno": 24,
      "original_line": "cnt = -1",
      "mutated_line": "cnt = +1",
      "code": "def max_parallel_line_pairs(points):\n    m = len(points)\n    s = set()\n    for i in range(m):\n        (xi, yi) = points[i]\n        for j in range(i + 1, m):\n            (xj, yj) = points[j]\n            u = xj - xi\n            v = yj - yi\n            for (x, y) in s:\n                if x * v == y * u:\n                    break\n            else:\n                s.add((u, v))\n    memo = {}\n\n    def dfs(state, dx, dy):\n        if (state, dx, dy) in memo:\n            return memo[state, dx, dy]\n        pstate = state\n        update = 1\n        cnt = +1\n        while update:\n            update = 0\n            cnt += 1\n            for i in range(m):\n                if state >> i & 1:\n                    continue\n                (xi, yi) = points[i]\n                for j in range(i + 1, m):\n                    if state >> j & 1:\n                        continue\n                    (xj, yj) = points[j]\n                    u = xj - xi\n                    v = yj - yi\n                    if dx * v == dy * u:\n                        update = 1\n                        state |= 1 << i | 1 << j\n                        break\n                if update:\n                    break\n        if cnt <= 1:\n            res = 0\n        else:\n            res = cnt * (cnt - 1) // 2 + max((dfs(state, *e) for e in s))\n        memo[pstate, dx, dy] = res\n        return res\n    return max((dfs(0, *e) for e in s))"
    },
    {
      "operator": "ASR",
      "lineno": 27,
      "original_line": "cnt += 1",
      "mutated_line": "cnt -= 1",
      "code": "def max_parallel_line_pairs(points):\n    m = len(points)\n    s = set()\n    for i in range(m):\n        (xi, yi) = points[i]\n        for j in range(i + 1, m):\n            (xj, yj) = points[j]\n            u = xj - xi\n            v = yj - yi\n            for (x, y) in s:\n                if x * v == y * u:\n                    break\n            else:\n                s.add((u, v))\n    memo = {}\n\n    def dfs(state, dx, dy):\n        if (state, dx, dy) in memo:\n            return memo[state, dx, dy]\n        pstate = state\n        update = 1\n        cnt = -1\n        while update:\n            update = 0\n            cnt -= 1\n            for i in range(m):\n                if state >> i & 1:\n                    continue\n                (xi, yi) = points[i]\n                for j in range(i + 1, m):\n                    if state >> j & 1:\n                        continue\n                    (xj, yj) = points[j]\n                    u = xj - xi\n                    v = yj - yi\n                    if dx * v == dy * u:\n                        update = 1\n                        state |= 1 << i | 1 << j\n                        break\n                if update:\n                    break\n        if cnt <= 1:\n            res = 0\n        else:\n            res = cnt * (cnt - 1) // 2 + max((dfs(state, *e) for e in s))\n        memo[pstate, dx, dy] = res\n        return res\n    return max((dfs(0, *e) for e in s))"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "if cnt <= 1:",
      "mutated_line": "if cnt < 1:",
      "code": "def max_parallel_line_pairs(points):\n    m = len(points)\n    s = set()\n    for i in range(m):\n        (xi, yi) = points[i]\n        for j in range(i + 1, m):\n            (xj, yj) = points[j]\n            u = xj - xi\n            v = yj - yi\n            for (x, y) in s:\n                if x * v == y * u:\n                    break\n            else:\n                s.add((u, v))\n    memo = {}\n\n    def dfs(state, dx, dy):\n        if (state, dx, dy) in memo:\n            return memo[state, dx, dy]\n        pstate = state\n        update = 1\n        cnt = -1\n        while update:\n            update = 0\n            cnt += 1\n            for i in range(m):\n                if state >> i & 1:\n                    continue\n                (xi, yi) = points[i]\n                for j in range(i + 1, m):\n                    if state >> j & 1:\n                        continue\n                    (xj, yj) = points[j]\n                    u = xj - xi\n                    v = yj - yi\n                    if dx * v == dy * u:\n                        update = 1\n                        state |= 1 << i | 1 << j\n                        break\n                if update:\n                    break\n        if cnt < 1:\n            res = 0\n        else:\n            res = cnt * (cnt - 1) // 2 + max((dfs(state, *e) for e in s))\n        memo[pstate, dx, dy] = res\n        return res\n    return max((dfs(0, *e) for e in s))"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "if cnt <= 1:",
      "mutated_line": "if cnt > 1:",
      "code": "def max_parallel_line_pairs(points):\n    m = len(points)\n    s = set()\n    for i in range(m):\n        (xi, yi) = points[i]\n        for j in range(i + 1, m):\n            (xj, yj) = points[j]\n            u = xj - xi\n            v = yj - yi\n            for (x, y) in s:\n                if x * v == y * u:\n                    break\n            else:\n                s.add((u, v))\n    memo = {}\n\n    def dfs(state, dx, dy):\n        if (state, dx, dy) in memo:\n            return memo[state, dx, dy]\n        pstate = state\n        update = 1\n        cnt = -1\n        while update:\n            update = 0\n            cnt += 1\n            for i in range(m):\n                if state >> i & 1:\n                    continue\n                (xi, yi) = points[i]\n                for j in range(i + 1, m):\n                    if state >> j & 1:\n                        continue\n                    (xj, yj) = points[j]\n                    u = xj - xi\n                    v = yj - yi\n                    if dx * v == dy * u:\n                        update = 1\n                        state |= 1 << i | 1 << j\n                        break\n                if update:\n                    break\n        if cnt > 1:\n            res = 0\n        else:\n            res = cnt * (cnt - 1) // 2 + max((dfs(state, *e) for e in s))\n        memo[pstate, dx, dy] = res\n        return res\n    return max((dfs(0, *e) for e in s))"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "if cnt <= 1:",
      "mutated_line": "if cnt == 1:",
      "code": "def max_parallel_line_pairs(points):\n    m = len(points)\n    s = set()\n    for i in range(m):\n        (xi, yi) = points[i]\n        for j in range(i + 1, m):\n            (xj, yj) = points[j]\n            u = xj - xi\n            v = yj - yi\n            for (x, y) in s:\n                if x * v == y * u:\n                    break\n            else:\n                s.add((u, v))\n    memo = {}\n\n    def dfs(state, dx, dy):\n        if (state, dx, dy) in memo:\n            return memo[state, dx, dy]\n        pstate = state\n        update = 1\n        cnt = -1\n        while update:\n            update = 0\n            cnt += 1\n            for i in range(m):\n                if state >> i & 1:\n                    continue\n                (xi, yi) = points[i]\n                for j in range(i + 1, m):\n                    if state >> j & 1:\n                        continue\n                    (xj, yj) = points[j]\n                    u = xj - xi\n                    v = yj - yi\n                    if dx * v == dy * u:\n                        update = 1\n                        state |= 1 << i | 1 << j\n                        break\n                if update:\n                    break\n        if cnt == 1:\n            res = 0\n        else:\n            res = cnt * (cnt - 1) // 2 + max((dfs(state, *e) for e in s))\n        memo[pstate, dx, dy] = res\n        return res\n    return max((dfs(0, *e) for e in s))"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "for j in range(i + 1, m):",
      "mutated_line": "for j in range(i - 1, m):",
      "code": "def max_parallel_line_pairs(points):\n    m = len(points)\n    s = set()\n    for i in range(m):\n        (xi, yi) = points[i]\n        for j in range(i - 1, m):\n            (xj, yj) = points[j]\n            u = xj - xi\n            v = yj - yi\n            for (x, y) in s:\n                if x * v == y * u:\n                    break\n            else:\n                s.add((u, v))\n    memo = {}\n\n    def dfs(state, dx, dy):\n        if (state, dx, dy) in memo:\n            return memo[state, dx, dy]\n        pstate = state\n        update = 1\n        cnt = -1\n        while update:\n            update = 0\n            cnt += 1\n            for i in range(m):\n                if state >> i & 1:\n                    continue\n                (xi, yi) = points[i]\n                for j in range(i + 1, m):\n                    if state >> j & 1:\n                        continue\n                    (xj, yj) = points[j]\n                    u = xj - xi\n                    v = yj - yi\n                    if dx * v == dy * u:\n                        update = 1\n                        state |= 1 << i | 1 << j\n                        break\n                if update:\n                    break\n        if cnt <= 1:\n            res = 0\n        else:\n            res = cnt * (cnt - 1) // 2 + max((dfs(state, *e) for e in s))\n        memo[pstate, dx, dy] = res\n        return res\n    return max((dfs(0, *e) for e in s))"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "for j in range(i + 1, m):",
      "mutated_line": "for j in range(i * 1, m):",
      "code": "def max_parallel_line_pairs(points):\n    m = len(points)\n    s = set()\n    for i in range(m):\n        (xi, yi) = points[i]\n        for j in range(i * 1, m):\n            (xj, yj) = points[j]\n            u = xj - xi\n            v = yj - yi\n            for (x, y) in s:\n                if x * v == y * u:\n                    break\n            else:\n                s.add((u, v))\n    memo = {}\n\n    def dfs(state, dx, dy):\n        if (state, dx, dy) in memo:\n            return memo[state, dx, dy]\n        pstate = state\n        update = 1\n        cnt = -1\n        while update:\n            update = 0\n            cnt += 1\n            for i in range(m):\n                if state >> i & 1:\n                    continue\n                (xi, yi) = points[i]\n                for j in range(i + 1, m):\n                    if state >> j & 1:\n                        continue\n                    (xj, yj) = points[j]\n                    u = xj - xi\n                    v = yj - yi\n                    if dx * v == dy * u:\n                        update = 1\n                        state |= 1 << i | 1 << j\n                        break\n                if update:\n                    break\n        if cnt <= 1:\n            res = 0\n        else:\n            res = cnt * (cnt - 1) // 2 + max((dfs(state, *e) for e in s))\n        memo[pstate, dx, dy] = res\n        return res\n    return max((dfs(0, *e) for e in s))"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "u = xj - xi",
      "mutated_line": "u = xj + xi",
      "code": "def max_parallel_line_pairs(points):\n    m = len(points)\n    s = set()\n    for i in range(m):\n        (xi, yi) = points[i]\n        for j in range(i + 1, m):\n            (xj, yj) = points[j]\n            u = xj + xi\n            v = yj - yi\n            for (x, y) in s:\n                if x * v == y * u:\n                    break\n            else:\n                s.add((u, v))\n    memo = {}\n\n    def dfs(state, dx, dy):\n        if (state, dx, dy) in memo:\n            return memo[state, dx, dy]\n        pstate = state\n        update = 1\n        cnt = -1\n        while update:\n            update = 0\n            cnt += 1\n            for i in range(m):\n                if state >> i & 1:\n                    continue\n                (xi, yi) = points[i]\n                for j in range(i + 1, m):\n                    if state >> j & 1:\n                        continue\n                    (xj, yj) = points[j]\n                    u = xj - xi\n                    v = yj - yi\n                    if dx * v == dy * u:\n                        update = 1\n                        state |= 1 << i | 1 << j\n                        break\n                if update:\n                    break\n        if cnt <= 1:\n            res = 0\n        else:\n            res = cnt * (cnt - 1) // 2 + max((dfs(state, *e) for e in s))\n        memo[pstate, dx, dy] = res\n        return res\n    return max((dfs(0, *e) for e in s))"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "u = xj - xi",
      "mutated_line": "u = xj * xi",
      "code": "def max_parallel_line_pairs(points):\n    m = len(points)\n    s = set()\n    for i in range(m):\n        (xi, yi) = points[i]\n        for j in range(i + 1, m):\n            (xj, yj) = points[j]\n            u = xj * xi\n            v = yj - yi\n            for (x, y) in s:\n                if x * v == y * u:\n                    break\n            else:\n                s.add((u, v))\n    memo = {}\n\n    def dfs(state, dx, dy):\n        if (state, dx, dy) in memo:\n            return memo[state, dx, dy]\n        pstate = state\n        update = 1\n        cnt = -1\n        while update:\n            update = 0\n            cnt += 1\n            for i in range(m):\n                if state >> i & 1:\n                    continue\n                (xi, yi) = points[i]\n                for j in range(i + 1, m):\n                    if state >> j & 1:\n                        continue\n                    (xj, yj) = points[j]\n                    u = xj - xi\n                    v = yj - yi\n                    if dx * v == dy * u:\n                        update = 1\n                        state |= 1 << i | 1 << j\n                        break\n                if update:\n                    break\n        if cnt <= 1:\n            res = 0\n        else:\n            res = cnt * (cnt - 1) // 2 + max((dfs(state, *e) for e in s))\n        memo[pstate, dx, dy] = res\n        return res\n    return max((dfs(0, *e) for e in s))"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "v = yj - yi",
      "mutated_line": "v = yj + yi",
      "code": "def max_parallel_line_pairs(points):\n    m = len(points)\n    s = set()\n    for i in range(m):\n        (xi, yi) = points[i]\n        for j in range(i + 1, m):\n            (xj, yj) = points[j]\n            u = xj - xi\n            v = yj + yi\n            for (x, y) in s:\n                if x * v == y * u:\n                    break\n            else:\n                s.add((u, v))\n    memo = {}\n\n    def dfs(state, dx, dy):\n        if (state, dx, dy) in memo:\n            return memo[state, dx, dy]\n        pstate = state\n        update = 1\n        cnt = -1\n        while update:\n            update = 0\n            cnt += 1\n            for i in range(m):\n                if state >> i & 1:\n                    continue\n                (xi, yi) = points[i]\n                for j in range(i + 1, m):\n                    if state >> j & 1:\n                        continue\n                    (xj, yj) = points[j]\n                    u = xj - xi\n                    v = yj - yi\n                    if dx * v == dy * u:\n                        update = 1\n                        state |= 1 << i | 1 << j\n                        break\n                if update:\n                    break\n        if cnt <= 1:\n            res = 0\n        else:\n            res = cnt * (cnt - 1) // 2 + max((dfs(state, *e) for e in s))\n        memo[pstate, dx, dy] = res\n        return res\n    return max((dfs(0, *e) for e in s))"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "v = yj - yi",
      "mutated_line": "v = yj * yi",
      "code": "def max_parallel_line_pairs(points):\n    m = len(points)\n    s = set()\n    for i in range(m):\n        (xi, yi) = points[i]\n        for j in range(i + 1, m):\n            (xj, yj) = points[j]\n            u = xj - xi\n            v = yj * yi\n            for (x, y) in s:\n                if x * v == y * u:\n                    break\n            else:\n                s.add((u, v))\n    memo = {}\n\n    def dfs(state, dx, dy):\n        if (state, dx, dy) in memo:\n            return memo[state, dx, dy]\n        pstate = state\n        update = 1\n        cnt = -1\n        while update:\n            update = 0\n            cnt += 1\n            for i in range(m):\n                if state >> i & 1:\n                    continue\n                (xi, yi) = points[i]\n                for j in range(i + 1, m):\n                    if state >> j & 1:\n                        continue\n                    (xj, yj) = points[j]\n                    u = xj - xi\n                    v = yj - yi\n                    if dx * v == dy * u:\n                        update = 1\n                        state |= 1 << i | 1 << j\n                        break\n                if update:\n                    break\n        if cnt <= 1:\n            res = 0\n        else:\n            res = cnt * (cnt - 1) // 2 + max((dfs(state, *e) for e in s))\n        memo[pstate, dx, dy] = res\n        return res\n    return max((dfs(0, *e) for e in s))"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "cnt = -1",
      "mutated_line": "cnt = -2",
      "code": "def max_parallel_line_pairs(points):\n    m = len(points)\n    s = set()\n    for i in range(m):\n        (xi, yi) = points[i]\n        for j in range(i + 1, m):\n            (xj, yj) = points[j]\n            u = xj - xi\n            v = yj - yi\n            for (x, y) in s:\n                if x * v == y * u:\n                    break\n            else:\n                s.add((u, v))\n    memo = {}\n\n    def dfs(state, dx, dy):\n        if (state, dx, dy) in memo:\n            return memo[state, dx, dy]\n        pstate = state\n        update = 1\n        cnt = -2\n        while update:\n            update = 0\n            cnt += 1\n            for i in range(m):\n                if state >> i & 1:\n                    continue\n                (xi, yi) = points[i]\n                for j in range(i + 1, m):\n                    if state >> j & 1:\n                        continue\n                    (xj, yj) = points[j]\n                    u = xj - xi\n                    v = yj - yi\n                    if dx * v == dy * u:\n                        update = 1\n                        state |= 1 << i | 1 << j\n                        break\n                if update:\n                    break\n        if cnt <= 1:\n            res = 0\n        else:\n            res = cnt * (cnt - 1) // 2 + max((dfs(state, *e) for e in s))\n        memo[pstate, dx, dy] = res\n        return res\n    return max((dfs(0, *e) for e in s))"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "cnt = -1",
      "mutated_line": "cnt = -0",
      "code": "def max_parallel_line_pairs(points):\n    m = len(points)\n    s = set()\n    for i in range(m):\n        (xi, yi) = points[i]\n        for j in range(i + 1, m):\n            (xj, yj) = points[j]\n            u = xj - xi\n            v = yj - yi\n            for (x, y) in s:\n                if x * v == y * u:\n                    break\n            else:\n                s.add((u, v))\n    memo = {}\n\n    def dfs(state, dx, dy):\n        if (state, dx, dy) in memo:\n            return memo[state, dx, dy]\n        pstate = state\n        update = 1\n        cnt = -0\n        while update:\n            update = 0\n            cnt += 1\n            for i in range(m):\n                if state >> i & 1:\n                    continue\n                (xi, yi) = points[i]\n                for j in range(i + 1, m):\n                    if state >> j & 1:\n                        continue\n                    (xj, yj) = points[j]\n                    u = xj - xi\n                    v = yj - yi\n                    if dx * v == dy * u:\n                        update = 1\n                        state |= 1 << i | 1 << j\n                        break\n                if update:\n                    break\n        if cnt <= 1:\n            res = 0\n        else:\n            res = cnt * (cnt - 1) // 2 + max((dfs(state, *e) for e in s))\n        memo[pstate, dx, dy] = res\n        return res\n    return max((dfs(0, *e) for e in s))"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "cnt = -1",
      "mutated_line": "cnt = -0",
      "code": "def max_parallel_line_pairs(points):\n    m = len(points)\n    s = set()\n    for i in range(m):\n        (xi, yi) = points[i]\n        for j in range(i + 1, m):\n            (xj, yj) = points[j]\n            u = xj - xi\n            v = yj - yi\n            for (x, y) in s:\n                if x * v == y * u:\n                    break\n            else:\n                s.add((u, v))\n    memo = {}\n\n    def dfs(state, dx, dy):\n        if (state, dx, dy) in memo:\n            return memo[state, dx, dy]\n        pstate = state\n        update = 1\n        cnt = -0\n        while update:\n            update = 0\n            cnt += 1\n            for i in range(m):\n                if state >> i & 1:\n                    continue\n                (xi, yi) = points[i]\n                for j in range(i + 1, m):\n                    if state >> j & 1:\n                        continue\n                    (xj, yj) = points[j]\n                    u = xj - xi\n                    v = yj - yi\n                    if dx * v == dy * u:\n                        update = 1\n                        state |= 1 << i | 1 << j\n                        break\n                if update:\n                    break\n        if cnt <= 1:\n            res = 0\n        else:\n            res = cnt * (cnt - 1) // 2 + max((dfs(state, *e) for e in s))\n        memo[pstate, dx, dy] = res\n        return res\n    return max((dfs(0, *e) for e in s))"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "cnt = -1",
      "mutated_line": "cnt = --1",
      "code": "def max_parallel_line_pairs(points):\n    m = len(points)\n    s = set()\n    for i in range(m):\n        (xi, yi) = points[i]\n        for j in range(i + 1, m):\n            (xj, yj) = points[j]\n            u = xj - xi\n            v = yj - yi\n            for (x, y) in s:\n                if x * v == y * u:\n                    break\n            else:\n                s.add((u, v))\n    memo = {}\n\n    def dfs(state, dx, dy):\n        if (state, dx, dy) in memo:\n            return memo[state, dx, dy]\n        pstate = state\n        update = 1\n        cnt = --1\n        while update:\n            update = 0\n            cnt += 1\n            for i in range(m):\n                if state >> i & 1:\n                    continue\n                (xi, yi) = points[i]\n                for j in range(i + 1, m):\n                    if state >> j & 1:\n                        continue\n                    (xj, yj) = points[j]\n                    u = xj - xi\n                    v = yj - yi\n                    if dx * v == dy * u:\n                        update = 1\n                        state |= 1 << i | 1 << j\n                        break\n                if update:\n                    break\n        if cnt <= 1:\n            res = 0\n        else:\n            res = cnt * (cnt - 1) // 2 + max((dfs(state, *e) for e in s))\n        memo[pstate, dx, dy] = res\n        return res\n    return max((dfs(0, *e) for e in s))"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "update = 0",
      "mutated_line": "update = 1",
      "code": "def max_parallel_line_pairs(points):\n    m = len(points)\n    s = set()\n    for i in range(m):\n        (xi, yi) = points[i]\n        for j in range(i + 1, m):\n            (xj, yj) = points[j]\n            u = xj - xi\n            v = yj - yi\n            for (x, y) in s:\n                if x * v == y * u:\n                    break\n            else:\n                s.add((u, v))\n    memo = {}\n\n    def dfs(state, dx, dy):\n        if (state, dx, dy) in memo:\n            return memo[state, dx, dy]\n        pstate = state\n        update = 1\n        cnt = -1\n        while update:\n            update = 1\n            cnt += 1\n            for i in range(m):\n                if state >> i & 1:\n                    continue\n                (xi, yi) = points[i]\n                for j in range(i + 1, m):\n                    if state >> j & 1:\n                        continue\n                    (xj, yj) = points[j]\n                    u = xj - xi\n                    v = yj - yi\n                    if dx * v == dy * u:\n                        update = 1\n                        state |= 1 << i | 1 << j\n                        break\n                if update:\n                    break\n        if cnt <= 1:\n            res = 0\n        else:\n            res = cnt * (cnt - 1) // 2 + max((dfs(state, *e) for e in s))\n        memo[pstate, dx, dy] = res\n        return res\n    return max((dfs(0, *e) for e in s))"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "update = 0",
      "mutated_line": "update = -1",
      "code": "def max_parallel_line_pairs(points):\n    m = len(points)\n    s = set()\n    for i in range(m):\n        (xi, yi) = points[i]\n        for j in range(i + 1, m):\n            (xj, yj) = points[j]\n            u = xj - xi\n            v = yj - yi\n            for (x, y) in s:\n                if x * v == y * u:\n                    break\n            else:\n                s.add((u, v))\n    memo = {}\n\n    def dfs(state, dx, dy):\n        if (state, dx, dy) in memo:\n            return memo[state, dx, dy]\n        pstate = state\n        update = 1\n        cnt = -1\n        while update:\n            update = -1\n            cnt += 1\n            for i in range(m):\n                if state >> i & 1:\n                    continue\n                (xi, yi) = points[i]\n                for j in range(i + 1, m):\n                    if state >> j & 1:\n                        continue\n                    (xj, yj) = points[j]\n                    u = xj - xi\n                    v = yj - yi\n                    if dx * v == dy * u:\n                        update = 1\n                        state |= 1 << i | 1 << j\n                        break\n                if update:\n                    break\n        if cnt <= 1:\n            res = 0\n        else:\n            res = cnt * (cnt - 1) // 2 + max((dfs(state, *e) for e in s))\n        memo[pstate, dx, dy] = res\n        return res\n    return max((dfs(0, *e) for e in s))"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "update = 0",
      "mutated_line": "update = 1",
      "code": "def max_parallel_line_pairs(points):\n    m = len(points)\n    s = set()\n    for i in range(m):\n        (xi, yi) = points[i]\n        for j in range(i + 1, m):\n            (xj, yj) = points[j]\n            u = xj - xi\n            v = yj - yi\n            for (x, y) in s:\n                if x * v == y * u:\n                    break\n            else:\n                s.add((u, v))\n    memo = {}\n\n    def dfs(state, dx, dy):\n        if (state, dx, dy) in memo:\n            return memo[state, dx, dy]\n        pstate = state\n        update = 1\n        cnt = -1\n        while update:\n            update = 1\n            cnt += 1\n            for i in range(m):\n                if state >> i & 1:\n                    continue\n                (xi, yi) = points[i]\n                for j in range(i + 1, m):\n                    if state >> j & 1:\n                        continue\n                    (xj, yj) = points[j]\n                    u = xj - xi\n                    v = yj - yi\n                    if dx * v == dy * u:\n                        update = 1\n                        state |= 1 << i | 1 << j\n                        break\n                if update:\n                    break\n        if cnt <= 1:\n            res = 0\n        else:\n            res = cnt * (cnt - 1) // 2 + max((dfs(state, *e) for e in s))\n        memo[pstate, dx, dy] = res\n        return res\n    return max((dfs(0, *e) for e in s))"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "cnt += 1",
      "mutated_line": "cnt += 2",
      "code": "def max_parallel_line_pairs(points):\n    m = len(points)\n    s = set()\n    for i in range(m):\n        (xi, yi) = points[i]\n        for j in range(i + 1, m):\n            (xj, yj) = points[j]\n            u = xj - xi\n            v = yj - yi\n            for (x, y) in s:\n                if x * v == y * u:\n                    break\n            else:\n                s.add((u, v))\n    memo = {}\n\n    def dfs(state, dx, dy):\n        if (state, dx, dy) in memo:\n            return memo[state, dx, dy]\n        pstate = state\n        update = 1\n        cnt = -1\n        while update:\n            update = 0\n            cnt += 2\n            for i in range(m):\n                if state >> i & 1:\n                    continue\n                (xi, yi) = points[i]\n                for j in range(i + 1, m):\n                    if state >> j & 1:\n                        continue\n                    (xj, yj) = points[j]\n                    u = xj - xi\n                    v = yj - yi\n                    if dx * v == dy * u:\n                        update = 1\n                        state |= 1 << i | 1 << j\n                        break\n                if update:\n                    break\n        if cnt <= 1:\n            res = 0\n        else:\n            res = cnt * (cnt - 1) // 2 + max((dfs(state, *e) for e in s))\n        memo[pstate, dx, dy] = res\n        return res\n    return max((dfs(0, *e) for e in s))"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "cnt += 1",
      "mutated_line": "cnt += 0",
      "code": "def max_parallel_line_pairs(points):\n    m = len(points)\n    s = set()\n    for i in range(m):\n        (xi, yi) = points[i]\n        for j in range(i + 1, m):\n            (xj, yj) = points[j]\n            u = xj - xi\n            v = yj - yi\n            for (x, y) in s:\n                if x * v == y * u:\n                    break\n            else:\n                s.add((u, v))\n    memo = {}\n\n    def dfs(state, dx, dy):\n        if (state, dx, dy) in memo:\n            return memo[state, dx, dy]\n        pstate = state\n        update = 1\n        cnt = -1\n        while update:\n            update = 0\n            cnt += 0\n            for i in range(m):\n                if state >> i & 1:\n                    continue\n                (xi, yi) = points[i]\n                for j in range(i + 1, m):\n                    if state >> j & 1:\n                        continue\n                    (xj, yj) = points[j]\n                    u = xj - xi\n                    v = yj - yi\n                    if dx * v == dy * u:\n                        update = 1\n                        state |= 1 << i | 1 << j\n                        break\n                if update:\n                    break\n        if cnt <= 1:\n            res = 0\n        else:\n            res = cnt * (cnt - 1) // 2 + max((dfs(state, *e) for e in s))\n        memo[pstate, dx, dy] = res\n        return res\n    return max((dfs(0, *e) for e in s))"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "cnt += 1",
      "mutated_line": "cnt += 0",
      "code": "def max_parallel_line_pairs(points):\n    m = len(points)\n    s = set()\n    for i in range(m):\n        (xi, yi) = points[i]\n        for j in range(i + 1, m):\n            (xj, yj) = points[j]\n            u = xj - xi\n            v = yj - yi\n            for (x, y) in s:\n                if x * v == y * u:\n                    break\n            else:\n                s.add((u, v))\n    memo = {}\n\n    def dfs(state, dx, dy):\n        if (state, dx, dy) in memo:\n            return memo[state, dx, dy]\n        pstate = state\n        update = 1\n        cnt = -1\n        while update:\n            update = 0\n            cnt += 0\n            for i in range(m):\n                if state >> i & 1:\n                    continue\n                (xi, yi) = points[i]\n                for j in range(i + 1, m):\n                    if state >> j & 1:\n                        continue\n                    (xj, yj) = points[j]\n                    u = xj - xi\n                    v = yj - yi\n                    if dx * v == dy * u:\n                        update = 1\n                        state |= 1 << i | 1 << j\n                        break\n                if update:\n                    break\n        if cnt <= 1:\n            res = 0\n        else:\n            res = cnt * (cnt - 1) // 2 + max((dfs(state, *e) for e in s))\n        memo[pstate, dx, dy] = res\n        return res\n    return max((dfs(0, *e) for e in s))"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "cnt += 1",
      "mutated_line": "cnt += -1",
      "code": "def max_parallel_line_pairs(points):\n    m = len(points)\n    s = set()\n    for i in range(m):\n        (xi, yi) = points[i]\n        for j in range(i + 1, m):\n            (xj, yj) = points[j]\n            u = xj - xi\n            v = yj - yi\n            for (x, y) in s:\n                if x * v == y * u:\n                    break\n            else:\n                s.add((u, v))\n    memo = {}\n\n    def dfs(state, dx, dy):\n        if (state, dx, dy) in memo:\n            return memo[state, dx, dy]\n        pstate = state\n        update = 1\n        cnt = -1\n        while update:\n            update = 0\n            cnt += -1\n            for i in range(m):\n                if state >> i & 1:\n                    continue\n                (xi, yi) = points[i]\n                for j in range(i + 1, m):\n                    if state >> j & 1:\n                        continue\n                    (xj, yj) = points[j]\n                    u = xj - xi\n                    v = yj - yi\n                    if dx * v == dy * u:\n                        update = 1\n                        state |= 1 << i | 1 << j\n                        break\n                if update:\n                    break\n        if cnt <= 1:\n            res = 0\n        else:\n            res = cnt * (cnt - 1) // 2 + max((dfs(state, *e) for e in s))\n        memo[pstate, dx, dy] = res\n        return res\n    return max((dfs(0, *e) for e in s))"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if cnt <= 1:",
      "mutated_line": "if cnt <= 2:",
      "code": "def max_parallel_line_pairs(points):\n    m = len(points)\n    s = set()\n    for i in range(m):\n        (xi, yi) = points[i]\n        for j in range(i + 1, m):\n            (xj, yj) = points[j]\n            u = xj - xi\n            v = yj - yi\n            for (x, y) in s:\n                if x * v == y * u:\n                    break\n            else:\n                s.add((u, v))\n    memo = {}\n\n    def dfs(state, dx, dy):\n        if (state, dx, dy) in memo:\n            return memo[state, dx, dy]\n        pstate = state\n        update = 1\n        cnt = -1\n        while update:\n            update = 0\n            cnt += 1\n            for i in range(m):\n                if state >> i & 1:\n                    continue\n                (xi, yi) = points[i]\n                for j in range(i + 1, m):\n                    if state >> j & 1:\n                        continue\n                    (xj, yj) = points[j]\n                    u = xj - xi\n                    v = yj - yi\n                    if dx * v == dy * u:\n                        update = 1\n                        state |= 1 << i | 1 << j\n                        break\n                if update:\n                    break\n        if cnt <= 2:\n            res = 0\n        else:\n            res = cnt * (cnt - 1) // 2 + max((dfs(state, *e) for e in s))\n        memo[pstate, dx, dy] = res\n        return res\n    return max((dfs(0, *e) for e in s))"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if cnt <= 1:",
      "mutated_line": "if cnt <= 0:",
      "code": "def max_parallel_line_pairs(points):\n    m = len(points)\n    s = set()\n    for i in range(m):\n        (xi, yi) = points[i]\n        for j in range(i + 1, m):\n            (xj, yj) = points[j]\n            u = xj - xi\n            v = yj - yi\n            for (x, y) in s:\n                if x * v == y * u:\n                    break\n            else:\n                s.add((u, v))\n    memo = {}\n\n    def dfs(state, dx, dy):\n        if (state, dx, dy) in memo:\n            return memo[state, dx, dy]\n        pstate = state\n        update = 1\n        cnt = -1\n        while update:\n            update = 0\n            cnt += 1\n            for i in range(m):\n                if state >> i & 1:\n                    continue\n                (xi, yi) = points[i]\n                for j in range(i + 1, m):\n                    if state >> j & 1:\n                        continue\n                    (xj, yj) = points[j]\n                    u = xj - xi\n                    v = yj - yi\n                    if dx * v == dy * u:\n                        update = 1\n                        state |= 1 << i | 1 << j\n                        break\n                if update:\n                    break\n        if cnt <= 0:\n            res = 0\n        else:\n            res = cnt * (cnt - 1) // 2 + max((dfs(state, *e) for e in s))\n        memo[pstate, dx, dy] = res\n        return res\n    return max((dfs(0, *e) for e in s))"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if cnt <= 1:",
      "mutated_line": "if cnt <= 0:",
      "code": "def max_parallel_line_pairs(points):\n    m = len(points)\n    s = set()\n    for i in range(m):\n        (xi, yi) = points[i]\n        for j in range(i + 1, m):\n            (xj, yj) = points[j]\n            u = xj - xi\n            v = yj - yi\n            for (x, y) in s:\n                if x * v == y * u:\n                    break\n            else:\n                s.add((u, v))\n    memo = {}\n\n    def dfs(state, dx, dy):\n        if (state, dx, dy) in memo:\n            return memo[state, dx, dy]\n        pstate = state\n        update = 1\n        cnt = -1\n        while update:\n            update = 0\n            cnt += 1\n            for i in range(m):\n                if state >> i & 1:\n                    continue\n                (xi, yi) = points[i]\n                for j in range(i + 1, m):\n                    if state >> j & 1:\n                        continue\n                    (xj, yj) = points[j]\n                    u = xj - xi\n                    v = yj - yi\n                    if dx * v == dy * u:\n                        update = 1\n                        state |= 1 << i | 1 << j\n                        break\n                if update:\n                    break\n        if cnt <= 0:\n            res = 0\n        else:\n            res = cnt * (cnt - 1) // 2 + max((dfs(state, *e) for e in s))\n        memo[pstate, dx, dy] = res\n        return res\n    return max((dfs(0, *e) for e in s))"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if cnt <= 1:",
      "mutated_line": "if cnt <= -1:",
      "code": "def max_parallel_line_pairs(points):\n    m = len(points)\n    s = set()\n    for i in range(m):\n        (xi, yi) = points[i]\n        for j in range(i + 1, m):\n            (xj, yj) = points[j]\n            u = xj - xi\n            v = yj - yi\n            for (x, y) in s:\n                if x * v == y * u:\n                    break\n            else:\n                s.add((u, v))\n    memo = {}\n\n    def dfs(state, dx, dy):\n        if (state, dx, dy) in memo:\n            return memo[state, dx, dy]\n        pstate = state\n        update = 1\n        cnt = -1\n        while update:\n            update = 0\n            cnt += 1\n            for i in range(m):\n                if state >> i & 1:\n                    continue\n                (xi, yi) = points[i]\n                for j in range(i + 1, m):\n                    if state >> j & 1:\n                        continue\n                    (xj, yj) = points[j]\n                    u = xj - xi\n                    v = yj - yi\n                    if dx * v == dy * u:\n                        update = 1\n                        state |= 1 << i | 1 << j\n                        break\n                if update:\n                    break\n        if cnt <= -1:\n            res = 0\n        else:\n            res = cnt * (cnt - 1) // 2 + max((dfs(state, *e) for e in s))\n        memo[pstate, dx, dy] = res\n        return res\n    return max((dfs(0, *e) for e in s))"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "res = 0",
      "mutated_line": "res = 1",
      "code": "def max_parallel_line_pairs(points):\n    m = len(points)\n    s = set()\n    for i in range(m):\n        (xi, yi) = points[i]\n        for j in range(i + 1, m):\n            (xj, yj) = points[j]\n            u = xj - xi\n            v = yj - yi\n            for (x, y) in s:\n                if x * v == y * u:\n                    break\n            else:\n                s.add((u, v))\n    memo = {}\n\n    def dfs(state, dx, dy):\n        if (state, dx, dy) in memo:\n            return memo[state, dx, dy]\n        pstate = state\n        update = 1\n        cnt = -1\n        while update:\n            update = 0\n            cnt += 1\n            for i in range(m):\n                if state >> i & 1:\n                    continue\n                (xi, yi) = points[i]\n                for j in range(i + 1, m):\n                    if state >> j & 1:\n                        continue\n                    (xj, yj) = points[j]\n                    u = xj - xi\n                    v = yj - yi\n                    if dx * v == dy * u:\n                        update = 1\n                        state |= 1 << i | 1 << j\n                        break\n                if update:\n                    break\n        if cnt <= 1:\n            res = 1\n        else:\n            res = cnt * (cnt - 1) // 2 + max((dfs(state, *e) for e in s))\n        memo[pstate, dx, dy] = res\n        return res\n    return max((dfs(0, *e) for e in s))"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "res = 0",
      "mutated_line": "res = -1",
      "code": "def max_parallel_line_pairs(points):\n    m = len(points)\n    s = set()\n    for i in range(m):\n        (xi, yi) = points[i]\n        for j in range(i + 1, m):\n            (xj, yj) = points[j]\n            u = xj - xi\n            v = yj - yi\n            for (x, y) in s:\n                if x * v == y * u:\n                    break\n            else:\n                s.add((u, v))\n    memo = {}\n\n    def dfs(state, dx, dy):\n        if (state, dx, dy) in memo:\n            return memo[state, dx, dy]\n        pstate = state\n        update = 1\n        cnt = -1\n        while update:\n            update = 0\n            cnt += 1\n            for i in range(m):\n                if state >> i & 1:\n                    continue\n                (xi, yi) = points[i]\n                for j in range(i + 1, m):\n                    if state >> j & 1:\n                        continue\n                    (xj, yj) = points[j]\n                    u = xj - xi\n                    v = yj - yi\n                    if dx * v == dy * u:\n                        update = 1\n                        state |= 1 << i | 1 << j\n                        break\n                if update:\n                    break\n        if cnt <= 1:\n            res = -1\n        else:\n            res = cnt * (cnt - 1) // 2 + max((dfs(state, *e) for e in s))\n        memo[pstate, dx, dy] = res\n        return res\n    return max((dfs(0, *e) for e in s))"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "res = 0",
      "mutated_line": "res = 1",
      "code": "def max_parallel_line_pairs(points):\n    m = len(points)\n    s = set()\n    for i in range(m):\n        (xi, yi) = points[i]\n        for j in range(i + 1, m):\n            (xj, yj) = points[j]\n            u = xj - xi\n            v = yj - yi\n            for (x, y) in s:\n                if x * v == y * u:\n                    break\n            else:\n                s.add((u, v))\n    memo = {}\n\n    def dfs(state, dx, dy):\n        if (state, dx, dy) in memo:\n            return memo[state, dx, dy]\n        pstate = state\n        update = 1\n        cnt = -1\n        while update:\n            update = 0\n            cnt += 1\n            for i in range(m):\n                if state >> i & 1:\n                    continue\n                (xi, yi) = points[i]\n                for j in range(i + 1, m):\n                    if state >> j & 1:\n                        continue\n                    (xj, yj) = points[j]\n                    u = xj - xi\n                    v = yj - yi\n                    if dx * v == dy * u:\n                        update = 1\n                        state |= 1 << i | 1 << j\n                        break\n                if update:\n                    break\n        if cnt <= 1:\n            res = 1\n        else:\n            res = cnt * (cnt - 1) // 2 + max((dfs(state, *e) for e in s))\n        memo[pstate, dx, dy] = res\n        return res\n    return max((dfs(0, *e) for e in s))"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "res = cnt * (cnt - 1) // 2 + max((dfs(state, *e) for e in s))",
      "mutated_line": "res = cnt * (cnt - 1) // 2 - max((dfs(state, *e) for e in s))",
      "code": "def max_parallel_line_pairs(points):\n    m = len(points)\n    s = set()\n    for i in range(m):\n        (xi, yi) = points[i]\n        for j in range(i + 1, m):\n            (xj, yj) = points[j]\n            u = xj - xi\n            v = yj - yi\n            for (x, y) in s:\n                if x * v == y * u:\n                    break\n            else:\n                s.add((u, v))\n    memo = {}\n\n    def dfs(state, dx, dy):\n        if (state, dx, dy) in memo:\n            return memo[state, dx, dy]\n        pstate = state\n        update = 1\n        cnt = -1\n        while update:\n            update = 0\n            cnt += 1\n            for i in range(m):\n                if state >> i & 1:\n                    continue\n                (xi, yi) = points[i]\n                for j in range(i + 1, m):\n                    if state >> j & 1:\n                        continue\n                    (xj, yj) = points[j]\n                    u = xj - xi\n                    v = yj - yi\n                    if dx * v == dy * u:\n                        update = 1\n                        state |= 1 << i | 1 << j\n                        break\n                if update:\n                    break\n        if cnt <= 1:\n            res = 0\n        else:\n            res = cnt * (cnt - 1) // 2 - max((dfs(state, *e) for e in s))\n        memo[pstate, dx, dy] = res\n        return res\n    return max((dfs(0, *e) for e in s))"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "res = cnt * (cnt - 1) // 2 + max((dfs(state, *e) for e in s))",
      "mutated_line": "res = cnt * (cnt - 1) // 2 * max((dfs(state, *e) for e in s))",
      "code": "def max_parallel_line_pairs(points):\n    m = len(points)\n    s = set()\n    for i in range(m):\n        (xi, yi) = points[i]\n        for j in range(i + 1, m):\n            (xj, yj) = points[j]\n            u = xj - xi\n            v = yj - yi\n            for (x, y) in s:\n                if x * v == y * u:\n                    break\n            else:\n                s.add((u, v))\n    memo = {}\n\n    def dfs(state, dx, dy):\n        if (state, dx, dy) in memo:\n            return memo[state, dx, dy]\n        pstate = state\n        update = 1\n        cnt = -1\n        while update:\n            update = 0\n            cnt += 1\n            for i in range(m):\n                if state >> i & 1:\n                    continue\n                (xi, yi) = points[i]\n                for j in range(i + 1, m):\n                    if state >> j & 1:\n                        continue\n                    (xj, yj) = points[j]\n                    u = xj - xi\n                    v = yj - yi\n                    if dx * v == dy * u:\n                        update = 1\n                        state |= 1 << i | 1 << j\n                        break\n                if update:\n                    break\n        if cnt <= 1:\n            res = 0\n        else:\n            res = cnt * (cnt - 1) // 2 * max((dfs(state, *e) for e in s))\n        memo[pstate, dx, dy] = res\n        return res\n    return max((dfs(0, *e) for e in s))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for j in range(i + 1, m):",
      "mutated_line": "for j in range(i + 2, m):",
      "code": "def max_parallel_line_pairs(points):\n    m = len(points)\n    s = set()\n    for i in range(m):\n        (xi, yi) = points[i]\n        for j in range(i + 2, m):\n            (xj, yj) = points[j]\n            u = xj - xi\n            v = yj - yi\n            for (x, y) in s:\n                if x * v == y * u:\n                    break\n            else:\n                s.add((u, v))\n    memo = {}\n\n    def dfs(state, dx, dy):\n        if (state, dx, dy) in memo:\n            return memo[state, dx, dy]\n        pstate = state\n        update = 1\n        cnt = -1\n        while update:\n            update = 0\n            cnt += 1\n            for i in range(m):\n                if state >> i & 1:\n                    continue\n                (xi, yi) = points[i]\n                for j in range(i + 1, m):\n                    if state >> j & 1:\n                        continue\n                    (xj, yj) = points[j]\n                    u = xj - xi\n                    v = yj - yi\n                    if dx * v == dy * u:\n                        update = 1\n                        state |= 1 << i | 1 << j\n                        break\n                if update:\n                    break\n        if cnt <= 1:\n            res = 0\n        else:\n            res = cnt * (cnt - 1) // 2 + max((dfs(state, *e) for e in s))\n        memo[pstate, dx, dy] = res\n        return res\n    return max((dfs(0, *e) for e in s))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for j in range(i + 1, m):",
      "mutated_line": "for j in range(i + 0, m):",
      "code": "def max_parallel_line_pairs(points):\n    m = len(points)\n    s = set()\n    for i in range(m):\n        (xi, yi) = points[i]\n        for j in range(i + 0, m):\n            (xj, yj) = points[j]\n            u = xj - xi\n            v = yj - yi\n            for (x, y) in s:\n                if x * v == y * u:\n                    break\n            else:\n                s.add((u, v))\n    memo = {}\n\n    def dfs(state, dx, dy):\n        if (state, dx, dy) in memo:\n            return memo[state, dx, dy]\n        pstate = state\n        update = 1\n        cnt = -1\n        while update:\n            update = 0\n            cnt += 1\n            for i in range(m):\n                if state >> i & 1:\n                    continue\n                (xi, yi) = points[i]\n                for j in range(i + 1, m):\n                    if state >> j & 1:\n                        continue\n                    (xj, yj) = points[j]\n                    u = xj - xi\n                    v = yj - yi\n                    if dx * v == dy * u:\n                        update = 1\n                        state |= 1 << i | 1 << j\n                        break\n                if update:\n                    break\n        if cnt <= 1:\n            res = 0\n        else:\n            res = cnt * (cnt - 1) // 2 + max((dfs(state, *e) for e in s))\n        memo[pstate, dx, dy] = res\n        return res\n    return max((dfs(0, *e) for e in s))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for j in range(i + 1, m):",
      "mutated_line": "for j in range(i + 0, m):",
      "code": "def max_parallel_line_pairs(points):\n    m = len(points)\n    s = set()\n    for i in range(m):\n        (xi, yi) = points[i]\n        for j in range(i + 0, m):\n            (xj, yj) = points[j]\n            u = xj - xi\n            v = yj - yi\n            for (x, y) in s:\n                if x * v == y * u:\n                    break\n            else:\n                s.add((u, v))\n    memo = {}\n\n    def dfs(state, dx, dy):\n        if (state, dx, dy) in memo:\n            return memo[state, dx, dy]\n        pstate = state\n        update = 1\n        cnt = -1\n        while update:\n            update = 0\n            cnt += 1\n            for i in range(m):\n                if state >> i & 1:\n                    continue\n                (xi, yi) = points[i]\n                for j in range(i + 1, m):\n                    if state >> j & 1:\n                        continue\n                    (xj, yj) = points[j]\n                    u = xj - xi\n                    v = yj - yi\n                    if dx * v == dy * u:\n                        update = 1\n                        state |= 1 << i | 1 << j\n                        break\n                if update:\n                    break\n        if cnt <= 1:\n            res = 0\n        else:\n            res = cnt * (cnt - 1) // 2 + max((dfs(state, *e) for e in s))\n        memo[pstate, dx, dy] = res\n        return res\n    return max((dfs(0, *e) for e in s))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for j in range(i + 1, m):",
      "mutated_line": "for j in range(i + -1, m):",
      "code": "def max_parallel_line_pairs(points):\n    m = len(points)\n    s = set()\n    for i in range(m):\n        (xi, yi) = points[i]\n        for j in range(i + -1, m):\n            (xj, yj) = points[j]\n            u = xj - xi\n            v = yj - yi\n            for (x, y) in s:\n                if x * v == y * u:\n                    break\n            else:\n                s.add((u, v))\n    memo = {}\n\n    def dfs(state, dx, dy):\n        if (state, dx, dy) in memo:\n            return memo[state, dx, dy]\n        pstate = state\n        update = 1\n        cnt = -1\n        while update:\n            update = 0\n            cnt += 1\n            for i in range(m):\n                if state >> i & 1:\n                    continue\n                (xi, yi) = points[i]\n                for j in range(i + 1, m):\n                    if state >> j & 1:\n                        continue\n                    (xj, yj) = points[j]\n                    u = xj - xi\n                    v = yj - yi\n                    if dx * v == dy * u:\n                        update = 1\n                        state |= 1 << i | 1 << j\n                        break\n                if update:\n                    break\n        if cnt <= 1:\n            res = 0\n        else:\n            res = cnt * (cnt - 1) // 2 + max((dfs(state, *e) for e in s))\n        memo[pstate, dx, dy] = res\n        return res\n    return max((dfs(0, *e) for e in s))"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if x * v == y * u:",
      "mutated_line": "if x * v != y * u:",
      "code": "def max_parallel_line_pairs(points):\n    m = len(points)\n    s = set()\n    for i in range(m):\n        (xi, yi) = points[i]\n        for j in range(i + 1, m):\n            (xj, yj) = points[j]\n            u = xj - xi\n            v = yj - yi\n            for (x, y) in s:\n                if x * v != y * u:\n                    break\n            else:\n                s.add((u, v))\n    memo = {}\n\n    def dfs(state, dx, dy):\n        if (state, dx, dy) in memo:\n            return memo[state, dx, dy]\n        pstate = state\n        update = 1\n        cnt = -1\n        while update:\n            update = 0\n            cnt += 1\n            for i in range(m):\n                if state >> i & 1:\n                    continue\n                (xi, yi) = points[i]\n                for j in range(i + 1, m):\n                    if state >> j & 1:\n                        continue\n                    (xj, yj) = points[j]\n                    u = xj - xi\n                    v = yj - yi\n                    if dx * v == dy * u:\n                        update = 1\n                        state |= 1 << i | 1 << j\n                        break\n                if update:\n                    break\n        if cnt <= 1:\n            res = 0\n        else:\n            res = cnt * (cnt - 1) // 2 + max((dfs(state, *e) for e in s))\n        memo[pstate, dx, dy] = res\n        return res\n    return max((dfs(0, *e) for e in s))"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "if state >> i & 1:",
      "mutated_line": "if state >> i | 1:",
      "code": "def max_parallel_line_pairs(points):\n    m = len(points)\n    s = set()\n    for i in range(m):\n        (xi, yi) = points[i]\n        for j in range(i + 1, m):\n            (xj, yj) = points[j]\n            u = xj - xi\n            v = yj - yi\n            for (x, y) in s:\n                if x * v == y * u:\n                    break\n            else:\n                s.add((u, v))\n    memo = {}\n\n    def dfs(state, dx, dy):\n        if (state, dx, dy) in memo:\n            return memo[state, dx, dy]\n        pstate = state\n        update = 1\n        cnt = -1\n        while update:\n            update = 0\n            cnt += 1\n            for i in range(m):\n                if state >> i | 1:\n                    continue\n                (xi, yi) = points[i]\n                for j in range(i + 1, m):\n                    if state >> j & 1:\n                        continue\n                    (xj, yj) = points[j]\n                    u = xj - xi\n                    v = yj - yi\n                    if dx * v == dy * u:\n                        update = 1\n                        state |= 1 << i | 1 << j\n                        break\n                if update:\n                    break\n        if cnt <= 1:\n            res = 0\n        else:\n            res = cnt * (cnt - 1) // 2 + max((dfs(state, *e) for e in s))\n        memo[pstate, dx, dy] = res\n        return res\n    return max((dfs(0, *e) for e in s))"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "res = cnt * (cnt - 1) // 2 + max((dfs(state, *e) for e in s))",
      "mutated_line": "res = cnt * (cnt - 1) / 2 + max((dfs(state, *e) for e in s))",
      "code": "def max_parallel_line_pairs(points):\n    m = len(points)\n    s = set()\n    for i in range(m):\n        (xi, yi) = points[i]\n        for j in range(i + 1, m):\n            (xj, yj) = points[j]\n            u = xj - xi\n            v = yj - yi\n            for (x, y) in s:\n                if x * v == y * u:\n                    break\n            else:\n                s.add((u, v))\n    memo = {}\n\n    def dfs(state, dx, dy):\n        if (state, dx, dy) in memo:\n            return memo[state, dx, dy]\n        pstate = state\n        update = 1\n        cnt = -1\n        while update:\n            update = 0\n            cnt += 1\n            for i in range(m):\n                if state >> i & 1:\n                    continue\n                (xi, yi) = points[i]\n                for j in range(i + 1, m):\n                    if state >> j & 1:\n                        continue\n                    (xj, yj) = points[j]\n                    u = xj - xi\n                    v = yj - yi\n                    if dx * v == dy * u:\n                        update = 1\n                        state |= 1 << i | 1 << j\n                        break\n                if update:\n                    break\n        if cnt <= 1:\n            res = 0\n        else:\n            res = cnt * (cnt - 1) / 2 + max((dfs(state, *e) for e in s))\n        memo[pstate, dx, dy] = res\n        return res\n    return max((dfs(0, *e) for e in s))"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "res = cnt * (cnt - 1) // 2 + max((dfs(state, *e) for e in s))",
      "mutated_line": "res = cnt * (cnt - 1) * 2 + max((dfs(state, *e) for e in s))",
      "code": "def max_parallel_line_pairs(points):\n    m = len(points)\n    s = set()\n    for i in range(m):\n        (xi, yi) = points[i]\n        for j in range(i + 1, m):\n            (xj, yj) = points[j]\n            u = xj - xi\n            v = yj - yi\n            for (x, y) in s:\n                if x * v == y * u:\n                    break\n            else:\n                s.add((u, v))\n    memo = {}\n\n    def dfs(state, dx, dy):\n        if (state, dx, dy) in memo:\n            return memo[state, dx, dy]\n        pstate = state\n        update = 1\n        cnt = -1\n        while update:\n            update = 0\n            cnt += 1\n            for i in range(m):\n                if state >> i & 1:\n                    continue\n                (xi, yi) = points[i]\n                for j in range(i + 1, m):\n                    if state >> j & 1:\n                        continue\n                    (xj, yj) = points[j]\n                    u = xj - xi\n                    v = yj - yi\n                    if dx * v == dy * u:\n                        update = 1\n                        state |= 1 << i | 1 << j\n                        break\n                if update:\n                    break\n        if cnt <= 1:\n            res = 0\n        else:\n            res = cnt * (cnt - 1) * 2 + max((dfs(state, *e) for e in s))\n        memo[pstate, dx, dy] = res\n        return res\n    return max((dfs(0, *e) for e in s))"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "return max((dfs(0, *e) for e in s))",
      "mutated_line": "return max((dfs(1, *e) for e in s))",
      "code": "def max_parallel_line_pairs(points):\n    m = len(points)\n    s = set()\n    for i in range(m):\n        (xi, yi) = points[i]\n        for j in range(i + 1, m):\n            (xj, yj) = points[j]\n            u = xj - xi\n            v = yj - yi\n            for (x, y) in s:\n                if x * v == y * u:\n                    break\n            else:\n                s.add((u, v))\n    memo = {}\n\n    def dfs(state, dx, dy):\n        if (state, dx, dy) in memo:\n            return memo[state, dx, dy]\n        pstate = state\n        update = 1\n        cnt = -1\n        while update:\n            update = 0\n            cnt += 1\n            for i in range(m):\n                if state >> i & 1:\n                    continue\n                (xi, yi) = points[i]\n                for j in range(i + 1, m):\n                    if state >> j & 1:\n                        continue\n                    (xj, yj) = points[j]\n                    u = xj - xi\n                    v = yj - yi\n                    if dx * v == dy * u:\n                        update = 1\n                        state |= 1 << i | 1 << j\n                        break\n                if update:\n                    break\n        if cnt <= 1:\n            res = 0\n        else:\n            res = cnt * (cnt - 1) // 2 + max((dfs(state, *e) for e in s))\n        memo[pstate, dx, dy] = res\n        return res\n    return max((dfs(1, *e) for e in s))"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "return max((dfs(0, *e) for e in s))",
      "mutated_line": "return max((dfs(-1, *e) for e in s))",
      "code": "def max_parallel_line_pairs(points):\n    m = len(points)\n    s = set()\n    for i in range(m):\n        (xi, yi) = points[i]\n        for j in range(i + 1, m):\n            (xj, yj) = points[j]\n            u = xj - xi\n            v = yj - yi\n            for (x, y) in s:\n                if x * v == y * u:\n                    break\n            else:\n                s.add((u, v))\n    memo = {}\n\n    def dfs(state, dx, dy):\n        if (state, dx, dy) in memo:\n            return memo[state, dx, dy]\n        pstate = state\n        update = 1\n        cnt = -1\n        while update:\n            update = 0\n            cnt += 1\n            for i in range(m):\n                if state >> i & 1:\n                    continue\n                (xi, yi) = points[i]\n                for j in range(i + 1, m):\n                    if state >> j & 1:\n                        continue\n                    (xj, yj) = points[j]\n                    u = xj - xi\n                    v = yj - yi\n                    if dx * v == dy * u:\n                        update = 1\n                        state |= 1 << i | 1 << j\n                        break\n                if update:\n                    break\n        if cnt <= 1:\n            res = 0\n        else:\n            res = cnt * (cnt - 1) // 2 + max((dfs(state, *e) for e in s))\n        memo[pstate, dx, dy] = res\n        return res\n    return max((dfs(-1, *e) for e in s))"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "return max((dfs(0, *e) for e in s))",
      "mutated_line": "return max((dfs(1, *e) for e in s))",
      "code": "def max_parallel_line_pairs(points):\n    m = len(points)\n    s = set()\n    for i in range(m):\n        (xi, yi) = points[i]\n        for j in range(i + 1, m):\n            (xj, yj) = points[j]\n            u = xj - xi\n            v = yj - yi\n            for (x, y) in s:\n                if x * v == y * u:\n                    break\n            else:\n                s.add((u, v))\n    memo = {}\n\n    def dfs(state, dx, dy):\n        if (state, dx, dy) in memo:\n            return memo[state, dx, dy]\n        pstate = state\n        update = 1\n        cnt = -1\n        while update:\n            update = 0\n            cnt += 1\n            for i in range(m):\n                if state >> i & 1:\n                    continue\n                (xi, yi) = points[i]\n                for j in range(i + 1, m):\n                    if state >> j & 1:\n                        continue\n                    (xj, yj) = points[j]\n                    u = xj - xi\n                    v = yj - yi\n                    if dx * v == dy * u:\n                        update = 1\n                        state |= 1 << i | 1 << j\n                        break\n                if update:\n                    break\n        if cnt <= 1:\n            res = 0\n        else:\n            res = cnt * (cnt - 1) // 2 + max((dfs(state, *e) for e in s))\n        memo[pstate, dx, dy] = res\n        return res\n    return max((dfs(1, *e) for e in s))"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "if x * v == y * u:",
      "mutated_line": "if x / v == y * u:",
      "code": "def max_parallel_line_pairs(points):\n    m = len(points)\n    s = set()\n    for i in range(m):\n        (xi, yi) = points[i]\n        for j in range(i + 1, m):\n            (xj, yj) = points[j]\n            u = xj - xi\n            v = yj - yi\n            for (x, y) in s:\n                if x / v == y * u:\n                    break\n            else:\n                s.add((u, v))\n    memo = {}\n\n    def dfs(state, dx, dy):\n        if (state, dx, dy) in memo:\n            return memo[state, dx, dy]\n        pstate = state\n        update = 1\n        cnt = -1\n        while update:\n            update = 0\n            cnt += 1\n            for i in range(m):\n                if state >> i & 1:\n                    continue\n                (xi, yi) = points[i]\n                for j in range(i + 1, m):\n                    if state >> j & 1:\n                        continue\n                    (xj, yj) = points[j]\n                    u = xj - xi\n                    v = yj - yi\n                    if dx * v == dy * u:\n                        update = 1\n                        state |= 1 << i | 1 << j\n                        break\n                if update:\n                    break\n        if cnt <= 1:\n            res = 0\n        else:\n            res = cnt * (cnt - 1) // 2 + max((dfs(state, *e) for e in s))\n        memo[pstate, dx, dy] = res\n        return res\n    return max((dfs(0, *e) for e in s))"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "if x * v == y * u:",
      "mutated_line": "if x + v == y * u:",
      "code": "def max_parallel_line_pairs(points):\n    m = len(points)\n    s = set()\n    for i in range(m):\n        (xi, yi) = points[i]\n        for j in range(i + 1, m):\n            (xj, yj) = points[j]\n            u = xj - xi\n            v = yj - yi\n            for (x, y) in s:\n                if x + v == y * u:\n                    break\n            else:\n                s.add((u, v))\n    memo = {}\n\n    def dfs(state, dx, dy):\n        if (state, dx, dy) in memo:\n            return memo[state, dx, dy]\n        pstate = state\n        update = 1\n        cnt = -1\n        while update:\n            update = 0\n            cnt += 1\n            for i in range(m):\n                if state >> i & 1:\n                    continue\n                (xi, yi) = points[i]\n                for j in range(i + 1, m):\n                    if state >> j & 1:\n                        continue\n                    (xj, yj) = points[j]\n                    u = xj - xi\n                    v = yj - yi\n                    if dx * v == dy * u:\n                        update = 1\n                        state |= 1 << i | 1 << j\n                        break\n                if update:\n                    break\n        if cnt <= 1:\n            res = 0\n        else:\n            res = cnt * (cnt - 1) // 2 + max((dfs(state, *e) for e in s))\n        memo[pstate, dx, dy] = res\n        return res\n    return max((dfs(0, *e) for e in s))"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "if x * v == y * u:",
      "mutated_line": "if x ** v == y * u:",
      "code": "def max_parallel_line_pairs(points):\n    m = len(points)\n    s = set()\n    for i in range(m):\n        (xi, yi) = points[i]\n        for j in range(i + 1, m):\n            (xj, yj) = points[j]\n            u = xj - xi\n            v = yj - yi\n            for (x, y) in s:\n                if x ** v == y * u:\n                    break\n            else:\n                s.add((u, v))\n    memo = {}\n\n    def dfs(state, dx, dy):\n        if (state, dx, dy) in memo:\n            return memo[state, dx, dy]\n        pstate = state\n        update = 1\n        cnt = -1\n        while update:\n            update = 0\n            cnt += 1\n            for i in range(m):\n                if state >> i & 1:\n                    continue\n                (xi, yi) = points[i]\n                for j in range(i + 1, m):\n                    if state >> j & 1:\n                        continue\n                    (xj, yj) = points[j]\n                    u = xj - xi\n                    v = yj - yi\n                    if dx * v == dy * u:\n                        update = 1\n                        state |= 1 << i | 1 << j\n                        break\n                if update:\n                    break\n        if cnt <= 1:\n            res = 0\n        else:\n            res = cnt * (cnt - 1) // 2 + max((dfs(state, *e) for e in s))\n        memo[pstate, dx, dy] = res\n        return res\n    return max((dfs(0, *e) for e in s))"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "if x * v == y * u:",
      "mutated_line": "if x * v == y / u:",
      "code": "def max_parallel_line_pairs(points):\n    m = len(points)\n    s = set()\n    for i in range(m):\n        (xi, yi) = points[i]\n        for j in range(i + 1, m):\n            (xj, yj) = points[j]\n            u = xj - xi\n            v = yj - yi\n            for (x, y) in s:\n                if x * v == y / u:\n                    break\n            else:\n                s.add((u, v))\n    memo = {}\n\n    def dfs(state, dx, dy):\n        if (state, dx, dy) in memo:\n            return memo[state, dx, dy]\n        pstate = state\n        update = 1\n        cnt = -1\n        while update:\n            update = 0\n            cnt += 1\n            for i in range(m):\n                if state >> i & 1:\n                    continue\n                (xi, yi) = points[i]\n                for j in range(i + 1, m):\n                    if state >> j & 1:\n                        continue\n                    (xj, yj) = points[j]\n                    u = xj - xi\n                    v = yj - yi\n                    if dx * v == dy * u:\n                        update = 1\n                        state |= 1 << i | 1 << j\n                        break\n                if update:\n                    break\n        if cnt <= 1:\n            res = 0\n        else:\n            res = cnt * (cnt - 1) // 2 + max((dfs(state, *e) for e in s))\n        memo[pstate, dx, dy] = res\n        return res\n    return max((dfs(0, *e) for e in s))"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "if x * v == y * u:",
      "mutated_line": "if x * v == y + u:",
      "code": "def max_parallel_line_pairs(points):\n    m = len(points)\n    s = set()\n    for i in range(m):\n        (xi, yi) = points[i]\n        for j in range(i + 1, m):\n            (xj, yj) = points[j]\n            u = xj - xi\n            v = yj - yi\n            for (x, y) in s:\n                if x * v == y + u:\n                    break\n            else:\n                s.add((u, v))\n    memo = {}\n\n    def dfs(state, dx, dy):\n        if (state, dx, dy) in memo:\n            return memo[state, dx, dy]\n        pstate = state\n        update = 1\n        cnt = -1\n        while update:\n            update = 0\n            cnt += 1\n            for i in range(m):\n                if state >> i & 1:\n                    continue\n                (xi, yi) = points[i]\n                for j in range(i + 1, m):\n                    if state >> j & 1:\n                        continue\n                    (xj, yj) = points[j]\n                    u = xj - xi\n                    v = yj - yi\n                    if dx * v == dy * u:\n                        update = 1\n                        state |= 1 << i | 1 << j\n                        break\n                if update:\n                    break\n        if cnt <= 1:\n            res = 0\n        else:\n            res = cnt * (cnt - 1) // 2 + max((dfs(state, *e) for e in s))\n        memo[pstate, dx, dy] = res\n        return res\n    return max((dfs(0, *e) for e in s))"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "if x * v == y * u:",
      "mutated_line": "if x * v == y ** u:",
      "code": "def max_parallel_line_pairs(points):\n    m = len(points)\n    s = set()\n    for i in range(m):\n        (xi, yi) = points[i]\n        for j in range(i + 1, m):\n            (xj, yj) = points[j]\n            u = xj - xi\n            v = yj - yi\n            for (x, y) in s:\n                if x * v == y ** u:\n                    break\n            else:\n                s.add((u, v))\n    memo = {}\n\n    def dfs(state, dx, dy):\n        if (state, dx, dy) in memo:\n            return memo[state, dx, dy]\n        pstate = state\n        update = 1\n        cnt = -1\n        while update:\n            update = 0\n            cnt += 1\n            for i in range(m):\n                if state >> i & 1:\n                    continue\n                (xi, yi) = points[i]\n                for j in range(i + 1, m):\n                    if state >> j & 1:\n                        continue\n                    (xj, yj) = points[j]\n                    u = xj - xi\n                    v = yj - yi\n                    if dx * v == dy * u:\n                        update = 1\n                        state |= 1 << i | 1 << j\n                        break\n                if update:\n                    break\n        if cnt <= 1:\n            res = 0\n        else:\n            res = cnt * (cnt - 1) // 2 + max((dfs(state, *e) for e in s))\n        memo[pstate, dx, dy] = res\n        return res\n    return max((dfs(0, *e) for e in s))"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if state >> i & 1:",
      "mutated_line": "if state >> i & 2:",
      "code": "def max_parallel_line_pairs(points):\n    m = len(points)\n    s = set()\n    for i in range(m):\n        (xi, yi) = points[i]\n        for j in range(i + 1, m):\n            (xj, yj) = points[j]\n            u = xj - xi\n            v = yj - yi\n            for (x, y) in s:\n                if x * v == y * u:\n                    break\n            else:\n                s.add((u, v))\n    memo = {}\n\n    def dfs(state, dx, dy):\n        if (state, dx, dy) in memo:\n            return memo[state, dx, dy]\n        pstate = state\n        update = 1\n        cnt = -1\n        while update:\n            update = 0\n            cnt += 1\n            for i in range(m):\n                if state >> i & 2:\n                    continue\n                (xi, yi) = points[i]\n                for j in range(i + 1, m):\n                    if state >> j & 1:\n                        continue\n                    (xj, yj) = points[j]\n                    u = xj - xi\n                    v = yj - yi\n                    if dx * v == dy * u:\n                        update = 1\n                        state |= 1 << i | 1 << j\n                        break\n                if update:\n                    break\n        if cnt <= 1:\n            res = 0\n        else:\n            res = cnt * (cnt - 1) // 2 + max((dfs(state, *e) for e in s))\n        memo[pstate, dx, dy] = res\n        return res\n    return max((dfs(0, *e) for e in s))"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if state >> i & 1:",
      "mutated_line": "if state >> i & 0:",
      "code": "def max_parallel_line_pairs(points):\n    m = len(points)\n    s = set()\n    for i in range(m):\n        (xi, yi) = points[i]\n        for j in range(i + 1, m):\n            (xj, yj) = points[j]\n            u = xj - xi\n            v = yj - yi\n            for (x, y) in s:\n                if x * v == y * u:\n                    break\n            else:\n                s.add((u, v))\n    memo = {}\n\n    def dfs(state, dx, dy):\n        if (state, dx, dy) in memo:\n            return memo[state, dx, dy]\n        pstate = state\n        update = 1\n        cnt = -1\n        while update:\n            update = 0\n            cnt += 1\n            for i in range(m):\n                if state >> i & 0:\n                    continue\n                (xi, yi) = points[i]\n                for j in range(i + 1, m):\n                    if state >> j & 1:\n                        continue\n                    (xj, yj) = points[j]\n                    u = xj - xi\n                    v = yj - yi\n                    if dx * v == dy * u:\n                        update = 1\n                        state |= 1 << i | 1 << j\n                        break\n                if update:\n                    break\n        if cnt <= 1:\n            res = 0\n        else:\n            res = cnt * (cnt - 1) // 2 + max((dfs(state, *e) for e in s))\n        memo[pstate, dx, dy] = res\n        return res\n    return max((dfs(0, *e) for e in s))"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if state >> i & 1:",
      "mutated_line": "if state >> i & 0:",
      "code": "def max_parallel_line_pairs(points):\n    m = len(points)\n    s = set()\n    for i in range(m):\n        (xi, yi) = points[i]\n        for j in range(i + 1, m):\n            (xj, yj) = points[j]\n            u = xj - xi\n            v = yj - yi\n            for (x, y) in s:\n                if x * v == y * u:\n                    break\n            else:\n                s.add((u, v))\n    memo = {}\n\n    def dfs(state, dx, dy):\n        if (state, dx, dy) in memo:\n            return memo[state, dx, dy]\n        pstate = state\n        update = 1\n        cnt = -1\n        while update:\n            update = 0\n            cnt += 1\n            for i in range(m):\n                if state >> i & 0:\n                    continue\n                (xi, yi) = points[i]\n                for j in range(i + 1, m):\n                    if state >> j & 1:\n                        continue\n                    (xj, yj) = points[j]\n                    u = xj - xi\n                    v = yj - yi\n                    if dx * v == dy * u:\n                        update = 1\n                        state |= 1 << i | 1 << j\n                        break\n                if update:\n                    break\n        if cnt <= 1:\n            res = 0\n        else:\n            res = cnt * (cnt - 1) // 2 + max((dfs(state, *e) for e in s))\n        memo[pstate, dx, dy] = res\n        return res\n    return max((dfs(0, *e) for e in s))"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if state >> i & 1:",
      "mutated_line": "if state >> i & -1:",
      "code": "def max_parallel_line_pairs(points):\n    m = len(points)\n    s = set()\n    for i in range(m):\n        (xi, yi) = points[i]\n        for j in range(i + 1, m):\n            (xj, yj) = points[j]\n            u = xj - xi\n            v = yj - yi\n            for (x, y) in s:\n                if x * v == y * u:\n                    break\n            else:\n                s.add((u, v))\n    memo = {}\n\n    def dfs(state, dx, dy):\n        if (state, dx, dy) in memo:\n            return memo[state, dx, dy]\n        pstate = state\n        update = 1\n        cnt = -1\n        while update:\n            update = 0\n            cnt += 1\n            for i in range(m):\n                if state >> i & -1:\n                    continue\n                (xi, yi) = points[i]\n                for j in range(i + 1, m):\n                    if state >> j & 1:\n                        continue\n                    (xj, yj) = points[j]\n                    u = xj - xi\n                    v = yj - yi\n                    if dx * v == dy * u:\n                        update = 1\n                        state |= 1 << i | 1 << j\n                        break\n                if update:\n                    break\n        if cnt <= 1:\n            res = 0\n        else:\n            res = cnt * (cnt - 1) // 2 + max((dfs(state, *e) for e in s))\n        memo[pstate, dx, dy] = res\n        return res\n    return max((dfs(0, *e) for e in s))"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "for j in range(i + 1, m):",
      "mutated_line": "for j in range(i - 1, m):",
      "code": "def max_parallel_line_pairs(points):\n    m = len(points)\n    s = set()\n    for i in range(m):\n        (xi, yi) = points[i]\n        for j in range(i + 1, m):\n            (xj, yj) = points[j]\n            u = xj - xi\n            v = yj - yi\n            for (x, y) in s:\n                if x * v == y * u:\n                    break\n            else:\n                s.add((u, v))\n    memo = {}\n\n    def dfs(state, dx, dy):\n        if (state, dx, dy) in memo:\n            return memo[state, dx, dy]\n        pstate = state\n        update = 1\n        cnt = -1\n        while update:\n            update = 0\n            cnt += 1\n            for i in range(m):\n                if state >> i & 1:\n                    continue\n                (xi, yi) = points[i]\n                for j in range(i - 1, m):\n                    if state >> j & 1:\n                        continue\n                    (xj, yj) = points[j]\n                    u = xj - xi\n                    v = yj - yi\n                    if dx * v == dy * u:\n                        update = 1\n                        state |= 1 << i | 1 << j\n                        break\n                if update:\n                    break\n        if cnt <= 1:\n            res = 0\n        else:\n            res = cnt * (cnt - 1) // 2 + max((dfs(state, *e) for e in s))\n        memo[pstate, dx, dy] = res\n        return res\n    return max((dfs(0, *e) for e in s))"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "for j in range(i + 1, m):",
      "mutated_line": "for j in range(i * 1, m):",
      "code": "def max_parallel_line_pairs(points):\n    m = len(points)\n    s = set()\n    for i in range(m):\n        (xi, yi) = points[i]\n        for j in range(i + 1, m):\n            (xj, yj) = points[j]\n            u = xj - xi\n            v = yj - yi\n            for (x, y) in s:\n                if x * v == y * u:\n                    break\n            else:\n                s.add((u, v))\n    memo = {}\n\n    def dfs(state, dx, dy):\n        if (state, dx, dy) in memo:\n            return memo[state, dx, dy]\n        pstate = state\n        update = 1\n        cnt = -1\n        while update:\n            update = 0\n            cnt += 1\n            for i in range(m):\n                if state >> i & 1:\n                    continue\n                (xi, yi) = points[i]\n                for j in range(i * 1, m):\n                    if state >> j & 1:\n                        continue\n                    (xj, yj) = points[j]\n                    u = xj - xi\n                    v = yj - yi\n                    if dx * v == dy * u:\n                        update = 1\n                        state |= 1 << i | 1 << j\n                        break\n                if update:\n                    break\n        if cnt <= 1:\n            res = 0\n        else:\n            res = cnt * (cnt - 1) // 2 + max((dfs(state, *e) for e in s))\n        memo[pstate, dx, dy] = res\n        return res\n    return max((dfs(0, *e) for e in s))"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "if state >> j & 1:",
      "mutated_line": "if state >> j | 1:",
      "code": "def max_parallel_line_pairs(points):\n    m = len(points)\n    s = set()\n    for i in range(m):\n        (xi, yi) = points[i]\n        for j in range(i + 1, m):\n            (xj, yj) = points[j]\n            u = xj - xi\n            v = yj - yi\n            for (x, y) in s:\n                if x * v == y * u:\n                    break\n            else:\n                s.add((u, v))\n    memo = {}\n\n    def dfs(state, dx, dy):\n        if (state, dx, dy) in memo:\n            return memo[state, dx, dy]\n        pstate = state\n        update = 1\n        cnt = -1\n        while update:\n            update = 0\n            cnt += 1\n            for i in range(m):\n                if state >> i & 1:\n                    continue\n                (xi, yi) = points[i]\n                for j in range(i + 1, m):\n                    if state >> j | 1:\n                        continue\n                    (xj, yj) = points[j]\n                    u = xj - xi\n                    v = yj - yi\n                    if dx * v == dy * u:\n                        update = 1\n                        state |= 1 << i | 1 << j\n                        break\n                if update:\n                    break\n        if cnt <= 1:\n            res = 0\n        else:\n            res = cnt * (cnt - 1) // 2 + max((dfs(state, *e) for e in s))\n        memo[pstate, dx, dy] = res\n        return res\n    return max((dfs(0, *e) for e in s))"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "u = xj - xi",
      "mutated_line": "u = xj + xi",
      "code": "def max_parallel_line_pairs(points):\n    m = len(points)\n    s = set()\n    for i in range(m):\n        (xi, yi) = points[i]\n        for j in range(i + 1, m):\n            (xj, yj) = points[j]\n            u = xj - xi\n            v = yj - yi\n            for (x, y) in s:\n                if x * v == y * u:\n                    break\n            else:\n                s.add((u, v))\n    memo = {}\n\n    def dfs(state, dx, dy):\n        if (state, dx, dy) in memo:\n            return memo[state, dx, dy]\n        pstate = state\n        update = 1\n        cnt = -1\n        while update:\n            update = 0\n            cnt += 1\n            for i in range(m):\n                if state >> i & 1:\n                    continue\n                (xi, yi) = points[i]\n                for j in range(i + 1, m):\n                    if state >> j & 1:\n                        continue\n                    (xj, yj) = points[j]\n                    u = xj + xi\n                    v = yj - yi\n                    if dx * v == dy * u:\n                        update = 1\n                        state |= 1 << i | 1 << j\n                        break\n                if update:\n                    break\n        if cnt <= 1:\n            res = 0\n        else:\n            res = cnt * (cnt - 1) // 2 + max((dfs(state, *e) for e in s))\n        memo[pstate, dx, dy] = res\n        return res\n    return max((dfs(0, *e) for e in s))"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "u = xj - xi",
      "mutated_line": "u = xj * xi",
      "code": "def max_parallel_line_pairs(points):\n    m = len(points)\n    s = set()\n    for i in range(m):\n        (xi, yi) = points[i]\n        for j in range(i + 1, m):\n            (xj, yj) = points[j]\n            u = xj - xi\n            v = yj - yi\n            for (x, y) in s:\n                if x * v == y * u:\n                    break\n            else:\n                s.add((u, v))\n    memo = {}\n\n    def dfs(state, dx, dy):\n        if (state, dx, dy) in memo:\n            return memo[state, dx, dy]\n        pstate = state\n        update = 1\n        cnt = -1\n        while update:\n            update = 0\n            cnt += 1\n            for i in range(m):\n                if state >> i & 1:\n                    continue\n                (xi, yi) = points[i]\n                for j in range(i + 1, m):\n                    if state >> j & 1:\n                        continue\n                    (xj, yj) = points[j]\n                    u = xj * xi\n                    v = yj - yi\n                    if dx * v == dy * u:\n                        update = 1\n                        state |= 1 << i | 1 << j\n                        break\n                if update:\n                    break\n        if cnt <= 1:\n            res = 0\n        else:\n            res = cnt * (cnt - 1) // 2 + max((dfs(state, *e) for e in s))\n        memo[pstate, dx, dy] = res\n        return res\n    return max((dfs(0, *e) for e in s))"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "v = yj - yi",
      "mutated_line": "v = yj + yi",
      "code": "def max_parallel_line_pairs(points):\n    m = len(points)\n    s = set()\n    for i in range(m):\n        (xi, yi) = points[i]\n        for j in range(i + 1, m):\n            (xj, yj) = points[j]\n            u = xj - xi\n            v = yj - yi\n            for (x, y) in s:\n                if x * v == y * u:\n                    break\n            else:\n                s.add((u, v))\n    memo = {}\n\n    def dfs(state, dx, dy):\n        if (state, dx, dy) in memo:\n            return memo[state, dx, dy]\n        pstate = state\n        update = 1\n        cnt = -1\n        while update:\n            update = 0\n            cnt += 1\n            for i in range(m):\n                if state >> i & 1:\n                    continue\n                (xi, yi) = points[i]\n                for j in range(i + 1, m):\n                    if state >> j & 1:\n                        continue\n                    (xj, yj) = points[j]\n                    u = xj - xi\n                    v = yj + yi\n                    if dx * v == dy * u:\n                        update = 1\n                        state |= 1 << i | 1 << j\n                        break\n                if update:\n                    break\n        if cnt <= 1:\n            res = 0\n        else:\n            res = cnt * (cnt - 1) // 2 + max((dfs(state, *e) for e in s))\n        memo[pstate, dx, dy] = res\n        return res\n    return max((dfs(0, *e) for e in s))"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "v = yj - yi",
      "mutated_line": "v = yj * yi",
      "code": "def max_parallel_line_pairs(points):\n    m = len(points)\n    s = set()\n    for i in range(m):\n        (xi, yi) = points[i]\n        for j in range(i + 1, m):\n            (xj, yj) = points[j]\n            u = xj - xi\n            v = yj - yi\n            for (x, y) in s:\n                if x * v == y * u:\n                    break\n            else:\n                s.add((u, v))\n    memo = {}\n\n    def dfs(state, dx, dy):\n        if (state, dx, dy) in memo:\n            return memo[state, dx, dy]\n        pstate = state\n        update = 1\n        cnt = -1\n        while update:\n            update = 0\n            cnt += 1\n            for i in range(m):\n                if state >> i & 1:\n                    continue\n                (xi, yi) = points[i]\n                for j in range(i + 1, m):\n                    if state >> j & 1:\n                        continue\n                    (xj, yj) = points[j]\n                    u = xj - xi\n                    v = yj * yi\n                    if dx * v == dy * u:\n                        update = 1\n                        state |= 1 << i | 1 << j\n                        break\n                if update:\n                    break\n        if cnt <= 1:\n            res = 0\n        else:\n            res = cnt * (cnt - 1) // 2 + max((dfs(state, *e) for e in s))\n        memo[pstate, dx, dy] = res\n        return res\n    return max((dfs(0, *e) for e in s))"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if dx * v == dy * u:",
      "mutated_line": "if dx * v != dy * u:",
      "code": "def max_parallel_line_pairs(points):\n    m = len(points)\n    s = set()\n    for i in range(m):\n        (xi, yi) = points[i]\n        for j in range(i + 1, m):\n            (xj, yj) = points[j]\n            u = xj - xi\n            v = yj - yi\n            for (x, y) in s:\n                if x * v == y * u:\n                    break\n            else:\n                s.add((u, v))\n    memo = {}\n\n    def dfs(state, dx, dy):\n        if (state, dx, dy) in memo:\n            return memo[state, dx, dy]\n        pstate = state\n        update = 1\n        cnt = -1\n        while update:\n            update = 0\n            cnt += 1\n            for i in range(m):\n                if state >> i & 1:\n                    continue\n                (xi, yi) = points[i]\n                for j in range(i + 1, m):\n                    if state >> j & 1:\n                        continue\n                    (xj, yj) = points[j]\n                    u = xj - xi\n                    v = yj - yi\n                    if dx * v != dy * u:\n                        update = 1\n                        state |= 1 << i | 1 << j\n                        break\n                if update:\n                    break\n        if cnt <= 1:\n            res = 0\n        else:\n            res = cnt * (cnt - 1) // 2 + max((dfs(state, *e) for e in s))\n        memo[pstate, dx, dy] = res\n        return res\n    return max((dfs(0, *e) for e in s))"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "res = cnt * (cnt - 1) // 2 + max((dfs(state, *e) for e in s))",
      "mutated_line": "res = cnt / (cnt - 1) // 2 + max((dfs(state, *e) for e in s))",
      "code": "def max_parallel_line_pairs(points):\n    m = len(points)\n    s = set()\n    for i in range(m):\n        (xi, yi) = points[i]\n        for j in range(i + 1, m):\n            (xj, yj) = points[j]\n            u = xj - xi\n            v = yj - yi\n            for (x, y) in s:\n                if x * v == y * u:\n                    break\n            else:\n                s.add((u, v))\n    memo = {}\n\n    def dfs(state, dx, dy):\n        if (state, dx, dy) in memo:\n            return memo[state, dx, dy]\n        pstate = state\n        update = 1\n        cnt = -1\n        while update:\n            update = 0\n            cnt += 1\n            for i in range(m):\n                if state >> i & 1:\n                    continue\n                (xi, yi) = points[i]\n                for j in range(i + 1, m):\n                    if state >> j & 1:\n                        continue\n                    (xj, yj) = points[j]\n                    u = xj - xi\n                    v = yj - yi\n                    if dx * v == dy * u:\n                        update = 1\n                        state |= 1 << i | 1 << j\n                        break\n                if update:\n                    break\n        if cnt <= 1:\n            res = 0\n        else:\n            res = cnt / (cnt - 1) // 2 + max((dfs(state, *e) for e in s))\n        memo[pstate, dx, dy] = res\n        return res\n    return max((dfs(0, *e) for e in s))"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "res = cnt * (cnt - 1) // 2 + max((dfs(state, *e) for e in s))",
      "mutated_line": "res = (cnt + (cnt - 1)) // 2 + max((dfs(state, *e) for e in s))",
      "code": "def max_parallel_line_pairs(points):\n    m = len(points)\n    s = set()\n    for i in range(m):\n        (xi, yi) = points[i]\n        for j in range(i + 1, m):\n            (xj, yj) = points[j]\n            u = xj - xi\n            v = yj - yi\n            for (x, y) in s:\n                if x * v == y * u:\n                    break\n            else:\n                s.add((u, v))\n    memo = {}\n\n    def dfs(state, dx, dy):\n        if (state, dx, dy) in memo:\n            return memo[state, dx, dy]\n        pstate = state\n        update = 1\n        cnt = -1\n        while update:\n            update = 0\n            cnt += 1\n            for i in range(m):\n                if state >> i & 1:\n                    continue\n                (xi, yi) = points[i]\n                for j in range(i + 1, m):\n                    if state >> j & 1:\n                        continue\n                    (xj, yj) = points[j]\n                    u = xj - xi\n                    v = yj - yi\n                    if dx * v == dy * u:\n                        update = 1\n                        state |= 1 << i | 1 << j\n                        break\n                if update:\n                    break\n        if cnt <= 1:\n            res = 0\n        else:\n            res = (cnt + (cnt - 1)) // 2 + max((dfs(state, *e) for e in s))\n        memo[pstate, dx, dy] = res\n        return res\n    return max((dfs(0, *e) for e in s))"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "res = cnt * (cnt - 1) // 2 + max((dfs(state, *e) for e in s))",
      "mutated_line": "res = cnt ** (cnt - 1) // 2 + max((dfs(state, *e) for e in s))",
      "code": "def max_parallel_line_pairs(points):\n    m = len(points)\n    s = set()\n    for i in range(m):\n        (xi, yi) = points[i]\n        for j in range(i + 1, m):\n            (xj, yj) = points[j]\n            u = xj - xi\n            v = yj - yi\n            for (x, y) in s:\n                if x * v == y * u:\n                    break\n            else:\n                s.add((u, v))\n    memo = {}\n\n    def dfs(state, dx, dy):\n        if (state, dx, dy) in memo:\n            return memo[state, dx, dy]\n        pstate = state\n        update = 1\n        cnt = -1\n        while update:\n            update = 0\n            cnt += 1\n            for i in range(m):\n                if state >> i & 1:\n                    continue\n                (xi, yi) = points[i]\n                for j in range(i + 1, m):\n                    if state >> j & 1:\n                        continue\n                    (xj, yj) = points[j]\n                    u = xj - xi\n                    v = yj - yi\n                    if dx * v == dy * u:\n                        update = 1\n                        state |= 1 << i | 1 << j\n                        break\n                if update:\n                    break\n        if cnt <= 1:\n            res = 0\n        else:\n            res = cnt ** (cnt - 1) // 2 + max((dfs(state, *e) for e in s))\n        memo[pstate, dx, dy] = res\n        return res\n    return max((dfs(0, *e) for e in s))"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "res = cnt * (cnt - 1) // 2 + max((dfs(state, *e) for e in s))",
      "mutated_line": "res = cnt * (cnt - 1) // 3 + max((dfs(state, *e) for e in s))",
      "code": "def max_parallel_line_pairs(points):\n    m = len(points)\n    s = set()\n    for i in range(m):\n        (xi, yi) = points[i]\n        for j in range(i + 1, m):\n            (xj, yj) = points[j]\n            u = xj - xi\n            v = yj - yi\n            for (x, y) in s:\n                if x * v == y * u:\n                    break\n            else:\n                s.add((u, v))\n    memo = {}\n\n    def dfs(state, dx, dy):\n        if (state, dx, dy) in memo:\n            return memo[state, dx, dy]\n        pstate = state\n        update = 1\n        cnt = -1\n        while update:\n            update = 0\n            cnt += 1\n            for i in range(m):\n                if state >> i & 1:\n                    continue\n                (xi, yi) = points[i]\n                for j in range(i + 1, m):\n                    if state >> j & 1:\n                        continue\n                    (xj, yj) = points[j]\n                    u = xj - xi\n                    v = yj - yi\n                    if dx * v == dy * u:\n                        update = 1\n                        state |= 1 << i | 1 << j\n                        break\n                if update:\n                    break\n        if cnt <= 1:\n            res = 0\n        else:\n            res = cnt * (cnt - 1) // 3 + max((dfs(state, *e) for e in s))\n        memo[pstate, dx, dy] = res\n        return res\n    return max((dfs(0, *e) for e in s))"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "res = cnt * (cnt - 1) // 2 + max((dfs(state, *e) for e in s))",
      "mutated_line": "res = cnt * (cnt - 1) // 1 + max((dfs(state, *e) for e in s))",
      "code": "def max_parallel_line_pairs(points):\n    m = len(points)\n    s = set()\n    for i in range(m):\n        (xi, yi) = points[i]\n        for j in range(i + 1, m):\n            (xj, yj) = points[j]\n            u = xj - xi\n            v = yj - yi\n            for (x, y) in s:\n                if x * v == y * u:\n                    break\n            else:\n                s.add((u, v))\n    memo = {}\n\n    def dfs(state, dx, dy):\n        if (state, dx, dy) in memo:\n            return memo[state, dx, dy]\n        pstate = state\n        update = 1\n        cnt = -1\n        while update:\n            update = 0\n            cnt += 1\n            for i in range(m):\n                if state >> i & 1:\n                    continue\n                (xi, yi) = points[i]\n                for j in range(i + 1, m):\n                    if state >> j & 1:\n                        continue\n                    (xj, yj) = points[j]\n                    u = xj - xi\n                    v = yj - yi\n                    if dx * v == dy * u:\n                        update = 1\n                        state |= 1 << i | 1 << j\n                        break\n                if update:\n                    break\n        if cnt <= 1:\n            res = 0\n        else:\n            res = cnt * (cnt - 1) // 1 + max((dfs(state, *e) for e in s))\n        memo[pstate, dx, dy] = res\n        return res\n    return max((dfs(0, *e) for e in s))"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "res = cnt * (cnt - 1) // 2 + max((dfs(state, *e) for e in s))",
      "mutated_line": "res = cnt * (cnt - 1) // 0 + max((dfs(state, *e) for e in s))",
      "code": "def max_parallel_line_pairs(points):\n    m = len(points)\n    s = set()\n    for i in range(m):\n        (xi, yi) = points[i]\n        for j in range(i + 1, m):\n            (xj, yj) = points[j]\n            u = xj - xi\n            v = yj - yi\n            for (x, y) in s:\n                if x * v == y * u:\n                    break\n            else:\n                s.add((u, v))\n    memo = {}\n\n    def dfs(state, dx, dy):\n        if (state, dx, dy) in memo:\n            return memo[state, dx, dy]\n        pstate = state\n        update = 1\n        cnt = -1\n        while update:\n            update = 0\n            cnt += 1\n            for i in range(m):\n                if state >> i & 1:\n                    continue\n                (xi, yi) = points[i]\n                for j in range(i + 1, m):\n                    if state >> j & 1:\n                        continue\n                    (xj, yj) = points[j]\n                    u = xj - xi\n                    v = yj - yi\n                    if dx * v == dy * u:\n                        update = 1\n                        state |= 1 << i | 1 << j\n                        break\n                if update:\n                    break\n        if cnt <= 1:\n            res = 0\n        else:\n            res = cnt * (cnt - 1) // 0 + max((dfs(state, *e) for e in s))\n        memo[pstate, dx, dy] = res\n        return res\n    return max((dfs(0, *e) for e in s))"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "res = cnt * (cnt - 1) // 2 + max((dfs(state, *e) for e in s))",
      "mutated_line": "res = cnt * (cnt - 1) // 1 + max((dfs(state, *e) for e in s))",
      "code": "def max_parallel_line_pairs(points):\n    m = len(points)\n    s = set()\n    for i in range(m):\n        (xi, yi) = points[i]\n        for j in range(i + 1, m):\n            (xj, yj) = points[j]\n            u = xj - xi\n            v = yj - yi\n            for (x, y) in s:\n                if x * v == y * u:\n                    break\n            else:\n                s.add((u, v))\n    memo = {}\n\n    def dfs(state, dx, dy):\n        if (state, dx, dy) in memo:\n            return memo[state, dx, dy]\n        pstate = state\n        update = 1\n        cnt = -1\n        while update:\n            update = 0\n            cnt += 1\n            for i in range(m):\n                if state >> i & 1:\n                    continue\n                (xi, yi) = points[i]\n                for j in range(i + 1, m):\n                    if state >> j & 1:\n                        continue\n                    (xj, yj) = points[j]\n                    u = xj - xi\n                    v = yj - yi\n                    if dx * v == dy * u:\n                        update = 1\n                        state |= 1 << i | 1 << j\n                        break\n                if update:\n                    break\n        if cnt <= 1:\n            res = 0\n        else:\n            res = cnt * (cnt - 1) // 1 + max((dfs(state, *e) for e in s))\n        memo[pstate, dx, dy] = res\n        return res\n    return max((dfs(0, *e) for e in s))"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "res = cnt * (cnt - 1) // 2 + max((dfs(state, *e) for e in s))",
      "mutated_line": "res = cnt * (cnt - 1) // -2 + max((dfs(state, *e) for e in s))",
      "code": "def max_parallel_line_pairs(points):\n    m = len(points)\n    s = set()\n    for i in range(m):\n        (xi, yi) = points[i]\n        for j in range(i + 1, m):\n            (xj, yj) = points[j]\n            u = xj - xi\n            v = yj - yi\n            for (x, y) in s:\n                if x * v == y * u:\n                    break\n            else:\n                s.add((u, v))\n    memo = {}\n\n    def dfs(state, dx, dy):\n        if (state, dx, dy) in memo:\n            return memo[state, dx, dy]\n        pstate = state\n        update = 1\n        cnt = -1\n        while update:\n            update = 0\n            cnt += 1\n            for i in range(m):\n                if state >> i & 1:\n                    continue\n                (xi, yi) = points[i]\n                for j in range(i + 1, m):\n                    if state >> j & 1:\n                        continue\n                    (xj, yj) = points[j]\n                    u = xj - xi\n                    v = yj - yi\n                    if dx * v == dy * u:\n                        update = 1\n                        state |= 1 << i | 1 << j\n                        break\n                if update:\n                    break\n        if cnt <= 1:\n            res = 0\n        else:\n            res = cnt * (cnt - 1) // -2 + max((dfs(state, *e) for e in s))\n        memo[pstate, dx, dy] = res\n        return res\n    return max((dfs(0, *e) for e in s))"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for j in range(i + 1, m):",
      "mutated_line": "for j in range(i + 2, m):",
      "code": "def max_parallel_line_pairs(points):\n    m = len(points)\n    s = set()\n    for i in range(m):\n        (xi, yi) = points[i]\n        for j in range(i + 1, m):\n            (xj, yj) = points[j]\n            u = xj - xi\n            v = yj - yi\n            for (x, y) in s:\n                if x * v == y * u:\n                    break\n            else:\n                s.add((u, v))\n    memo = {}\n\n    def dfs(state, dx, dy):\n        if (state, dx, dy) in memo:\n            return memo[state, dx, dy]\n        pstate = state\n        update = 1\n        cnt = -1\n        while update:\n            update = 0\n            cnt += 1\n            for i in range(m):\n                if state >> i & 1:\n                    continue\n                (xi, yi) = points[i]\n                for j in range(i + 2, m):\n                    if state >> j & 1:\n                        continue\n                    (xj, yj) = points[j]\n                    u = xj - xi\n                    v = yj - yi\n                    if dx * v == dy * u:\n                        update = 1\n                        state |= 1 << i | 1 << j\n                        break\n                if update:\n                    break\n        if cnt <= 1:\n            res = 0\n        else:\n            res = cnt * (cnt - 1) // 2 + max((dfs(state, *e) for e in s))\n        memo[pstate, dx, dy] = res\n        return res\n    return max((dfs(0, *e) for e in s))"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for j in range(i + 1, m):",
      "mutated_line": "for j in range(i + 0, m):",
      "code": "def max_parallel_line_pairs(points):\n    m = len(points)\n    s = set()\n    for i in range(m):\n        (xi, yi) = points[i]\n        for j in range(i + 1, m):\n            (xj, yj) = points[j]\n            u = xj - xi\n            v = yj - yi\n            for (x, y) in s:\n                if x * v == y * u:\n                    break\n            else:\n                s.add((u, v))\n    memo = {}\n\n    def dfs(state, dx, dy):\n        if (state, dx, dy) in memo:\n            return memo[state, dx, dy]\n        pstate = state\n        update = 1\n        cnt = -1\n        while update:\n            update = 0\n            cnt += 1\n            for i in range(m):\n                if state >> i & 1:\n                    continue\n                (xi, yi) = points[i]\n                for j in range(i + 0, m):\n                    if state >> j & 1:\n                        continue\n                    (xj, yj) = points[j]\n                    u = xj - xi\n                    v = yj - yi\n                    if dx * v == dy * u:\n                        update = 1\n                        state |= 1 << i | 1 << j\n                        break\n                if update:\n                    break\n        if cnt <= 1:\n            res = 0\n        else:\n            res = cnt * (cnt - 1) // 2 + max((dfs(state, *e) for e in s))\n        memo[pstate, dx, dy] = res\n        return res\n    return max((dfs(0, *e) for e in s))"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for j in range(i + 1, m):",
      "mutated_line": "for j in range(i + 0, m):",
      "code": "def max_parallel_line_pairs(points):\n    m = len(points)\n    s = set()\n    for i in range(m):\n        (xi, yi) = points[i]\n        for j in range(i + 1, m):\n            (xj, yj) = points[j]\n            u = xj - xi\n            v = yj - yi\n            for (x, y) in s:\n                if x * v == y * u:\n                    break\n            else:\n                s.add((u, v))\n    memo = {}\n\n    def dfs(state, dx, dy):\n        if (state, dx, dy) in memo:\n            return memo[state, dx, dy]\n        pstate = state\n        update = 1\n        cnt = -1\n        while update:\n            update = 0\n            cnt += 1\n            for i in range(m):\n                if state >> i & 1:\n                    continue\n                (xi, yi) = points[i]\n                for j in range(i + 0, m):\n                    if state >> j & 1:\n                        continue\n                    (xj, yj) = points[j]\n                    u = xj - xi\n                    v = yj - yi\n                    if dx * v == dy * u:\n                        update = 1\n                        state |= 1 << i | 1 << j\n                        break\n                if update:\n                    break\n        if cnt <= 1:\n            res = 0\n        else:\n            res = cnt * (cnt - 1) // 2 + max((dfs(state, *e) for e in s))\n        memo[pstate, dx, dy] = res\n        return res\n    return max((dfs(0, *e) for e in s))"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for j in range(i + 1, m):",
      "mutated_line": "for j in range(i + -1, m):",
      "code": "def max_parallel_line_pairs(points):\n    m = len(points)\n    s = set()\n    for i in range(m):\n        (xi, yi) = points[i]\n        for j in range(i + 1, m):\n            (xj, yj) = points[j]\n            u = xj - xi\n            v = yj - yi\n            for (x, y) in s:\n                if x * v == y * u:\n                    break\n            else:\n                s.add((u, v))\n    memo = {}\n\n    def dfs(state, dx, dy):\n        if (state, dx, dy) in memo:\n            return memo[state, dx, dy]\n        pstate = state\n        update = 1\n        cnt = -1\n        while update:\n            update = 0\n            cnt += 1\n            for i in range(m):\n                if state >> i & 1:\n                    continue\n                (xi, yi) = points[i]\n                for j in range(i + -1, m):\n                    if state >> j & 1:\n                        continue\n                    (xj, yj) = points[j]\n                    u = xj - xi\n                    v = yj - yi\n                    if dx * v == dy * u:\n                        update = 1\n                        state |= 1 << i | 1 << j\n                        break\n                if update:\n                    break\n        if cnt <= 1:\n            res = 0\n        else:\n            res = cnt * (cnt - 1) // 2 + max((dfs(state, *e) for e in s))\n        memo[pstate, dx, dy] = res\n        return res\n    return max((dfs(0, *e) for e in s))"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if state >> j & 1:",
      "mutated_line": "if state >> j & 2:",
      "code": "def max_parallel_line_pairs(points):\n    m = len(points)\n    s = set()\n    for i in range(m):\n        (xi, yi) = points[i]\n        for j in range(i + 1, m):\n            (xj, yj) = points[j]\n            u = xj - xi\n            v = yj - yi\n            for (x, y) in s:\n                if x * v == y * u:\n                    break\n            else:\n                s.add((u, v))\n    memo = {}\n\n    def dfs(state, dx, dy):\n        if (state, dx, dy) in memo:\n            return memo[state, dx, dy]\n        pstate = state\n        update = 1\n        cnt = -1\n        while update:\n            update = 0\n            cnt += 1\n            for i in range(m):\n                if state >> i & 1:\n                    continue\n                (xi, yi) = points[i]\n                for j in range(i + 1, m):\n                    if state >> j & 2:\n                        continue\n                    (xj, yj) = points[j]\n                    u = xj - xi\n                    v = yj - yi\n                    if dx * v == dy * u:\n                        update = 1\n                        state |= 1 << i | 1 << j\n                        break\n                if update:\n                    break\n        if cnt <= 1:\n            res = 0\n        else:\n            res = cnt * (cnt - 1) // 2 + max((dfs(state, *e) for e in s))\n        memo[pstate, dx, dy] = res\n        return res\n    return max((dfs(0, *e) for e in s))"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if state >> j & 1:",
      "mutated_line": "if state >> j & 0:",
      "code": "def max_parallel_line_pairs(points):\n    m = len(points)\n    s = set()\n    for i in range(m):\n        (xi, yi) = points[i]\n        for j in range(i + 1, m):\n            (xj, yj) = points[j]\n            u = xj - xi\n            v = yj - yi\n            for (x, y) in s:\n                if x * v == y * u:\n                    break\n            else:\n                s.add((u, v))\n    memo = {}\n\n    def dfs(state, dx, dy):\n        if (state, dx, dy) in memo:\n            return memo[state, dx, dy]\n        pstate = state\n        update = 1\n        cnt = -1\n        while update:\n            update = 0\n            cnt += 1\n            for i in range(m):\n                if state >> i & 1:\n                    continue\n                (xi, yi) = points[i]\n                for j in range(i + 1, m):\n                    if state >> j & 0:\n                        continue\n                    (xj, yj) = points[j]\n                    u = xj - xi\n                    v = yj - yi\n                    if dx * v == dy * u:\n                        update = 1\n                        state |= 1 << i | 1 << j\n                        break\n                if update:\n                    break\n        if cnt <= 1:\n            res = 0\n        else:\n            res = cnt * (cnt - 1) // 2 + max((dfs(state, *e) for e in s))\n        memo[pstate, dx, dy] = res\n        return res\n    return max((dfs(0, *e) for e in s))"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if state >> j & 1:",
      "mutated_line": "if state >> j & 0:",
      "code": "def max_parallel_line_pairs(points):\n    m = len(points)\n    s = set()\n    for i in range(m):\n        (xi, yi) = points[i]\n        for j in range(i + 1, m):\n            (xj, yj) = points[j]\n            u = xj - xi\n            v = yj - yi\n            for (x, y) in s:\n                if x * v == y * u:\n                    break\n            else:\n                s.add((u, v))\n    memo = {}\n\n    def dfs(state, dx, dy):\n        if (state, dx, dy) in memo:\n            return memo[state, dx, dy]\n        pstate = state\n        update = 1\n        cnt = -1\n        while update:\n            update = 0\n            cnt += 1\n            for i in range(m):\n                if state >> i & 1:\n                    continue\n                (xi, yi) = points[i]\n                for j in range(i + 1, m):\n                    if state >> j & 0:\n                        continue\n                    (xj, yj) = points[j]\n                    u = xj - xi\n                    v = yj - yi\n                    if dx * v == dy * u:\n                        update = 1\n                        state |= 1 << i | 1 << j\n                        break\n                if update:\n                    break\n        if cnt <= 1:\n            res = 0\n        else:\n            res = cnt * (cnt - 1) // 2 + max((dfs(state, *e) for e in s))\n        memo[pstate, dx, dy] = res\n        return res\n    return max((dfs(0, *e) for e in s))"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if state >> j & 1:",
      "mutated_line": "if state >> j & -1:",
      "code": "def max_parallel_line_pairs(points):\n    m = len(points)\n    s = set()\n    for i in range(m):\n        (xi, yi) = points[i]\n        for j in range(i + 1, m):\n            (xj, yj) = points[j]\n            u = xj - xi\n            v = yj - yi\n            for (x, y) in s:\n                if x * v == y * u:\n                    break\n            else:\n                s.add((u, v))\n    memo = {}\n\n    def dfs(state, dx, dy):\n        if (state, dx, dy) in memo:\n            return memo[state, dx, dy]\n        pstate = state\n        update = 1\n        cnt = -1\n        while update:\n            update = 0\n            cnt += 1\n            for i in range(m):\n                if state >> i & 1:\n                    continue\n                (xi, yi) = points[i]\n                for j in range(i + 1, m):\n                    if state >> j & -1:\n                        continue\n                    (xj, yj) = points[j]\n                    u = xj - xi\n                    v = yj - yi\n                    if dx * v == dy * u:\n                        update = 1\n                        state |= 1 << i | 1 << j\n                        break\n                if update:\n                    break\n        if cnt <= 1:\n            res = 0\n        else:\n            res = cnt * (cnt - 1) // 2 + max((dfs(state, *e) for e in s))\n        memo[pstate, dx, dy] = res\n        return res\n    return max((dfs(0, *e) for e in s))"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "if dx * v == dy * u:",
      "mutated_line": "if dx / v == dy * u:",
      "code": "def max_parallel_line_pairs(points):\n    m = len(points)\n    s = set()\n    for i in range(m):\n        (xi, yi) = points[i]\n        for j in range(i + 1, m):\n            (xj, yj) = points[j]\n            u = xj - xi\n            v = yj - yi\n            for (x, y) in s:\n                if x * v == y * u:\n                    break\n            else:\n                s.add((u, v))\n    memo = {}\n\n    def dfs(state, dx, dy):\n        if (state, dx, dy) in memo:\n            return memo[state, dx, dy]\n        pstate = state\n        update = 1\n        cnt = -1\n        while update:\n            update = 0\n            cnt += 1\n            for i in range(m):\n                if state >> i & 1:\n                    continue\n                (xi, yi) = points[i]\n                for j in range(i + 1, m):\n                    if state >> j & 1:\n                        continue\n                    (xj, yj) = points[j]\n                    u = xj - xi\n                    v = yj - yi\n                    if dx / v == dy * u:\n                        update = 1\n                        state |= 1 << i | 1 << j\n                        break\n                if update:\n                    break\n        if cnt <= 1:\n            res = 0\n        else:\n            res = cnt * (cnt - 1) // 2 + max((dfs(state, *e) for e in s))\n        memo[pstate, dx, dy] = res\n        return res\n    return max((dfs(0, *e) for e in s))"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "if dx * v == dy * u:",
      "mutated_line": "if dx + v == dy * u:",
      "code": "def max_parallel_line_pairs(points):\n    m = len(points)\n    s = set()\n    for i in range(m):\n        (xi, yi) = points[i]\n        for j in range(i + 1, m):\n            (xj, yj) = points[j]\n            u = xj - xi\n            v = yj - yi\n            for (x, y) in s:\n                if x * v == y * u:\n                    break\n            else:\n                s.add((u, v))\n    memo = {}\n\n    def dfs(state, dx, dy):\n        if (state, dx, dy) in memo:\n            return memo[state, dx, dy]\n        pstate = state\n        update = 1\n        cnt = -1\n        while update:\n            update = 0\n            cnt += 1\n            for i in range(m):\n                if state >> i & 1:\n                    continue\n                (xi, yi) = points[i]\n                for j in range(i + 1, m):\n                    if state >> j & 1:\n                        continue\n                    (xj, yj) = points[j]\n                    u = xj - xi\n                    v = yj - yi\n                    if dx + v == dy * u:\n                        update = 1\n                        state |= 1 << i | 1 << j\n                        break\n                if update:\n                    break\n        if cnt <= 1:\n            res = 0\n        else:\n            res = cnt * (cnt - 1) // 2 + max((dfs(state, *e) for e in s))\n        memo[pstate, dx, dy] = res\n        return res\n    return max((dfs(0, *e) for e in s))"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "if dx * v == dy * u:",
      "mutated_line": "if dx ** v == dy * u:",
      "code": "def max_parallel_line_pairs(points):\n    m = len(points)\n    s = set()\n    for i in range(m):\n        (xi, yi) = points[i]\n        for j in range(i + 1, m):\n            (xj, yj) = points[j]\n            u = xj - xi\n            v = yj - yi\n            for (x, y) in s:\n                if x * v == y * u:\n                    break\n            else:\n                s.add((u, v))\n    memo = {}\n\n    def dfs(state, dx, dy):\n        if (state, dx, dy) in memo:\n            return memo[state, dx, dy]\n        pstate = state\n        update = 1\n        cnt = -1\n        while update:\n            update = 0\n            cnt += 1\n            for i in range(m):\n                if state >> i & 1:\n                    continue\n                (xi, yi) = points[i]\n                for j in range(i + 1, m):\n                    if state >> j & 1:\n                        continue\n                    (xj, yj) = points[j]\n                    u = xj - xi\n                    v = yj - yi\n                    if dx ** v == dy * u:\n                        update = 1\n                        state |= 1 << i | 1 << j\n                        break\n                if update:\n                    break\n        if cnt <= 1:\n            res = 0\n        else:\n            res = cnt * (cnt - 1) // 2 + max((dfs(state, *e) for e in s))\n        memo[pstate, dx, dy] = res\n        return res\n    return max((dfs(0, *e) for e in s))"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "if dx * v == dy * u:",
      "mutated_line": "if dx * v == dy / u:",
      "code": "def max_parallel_line_pairs(points):\n    m = len(points)\n    s = set()\n    for i in range(m):\n        (xi, yi) = points[i]\n        for j in range(i + 1, m):\n            (xj, yj) = points[j]\n            u = xj - xi\n            v = yj - yi\n            for (x, y) in s:\n                if x * v == y * u:\n                    break\n            else:\n                s.add((u, v))\n    memo = {}\n\n    def dfs(state, dx, dy):\n        if (state, dx, dy) in memo:\n            return memo[state, dx, dy]\n        pstate = state\n        update = 1\n        cnt = -1\n        while update:\n            update = 0\n            cnt += 1\n            for i in range(m):\n                if state >> i & 1:\n                    continue\n                (xi, yi) = points[i]\n                for j in range(i + 1, m):\n                    if state >> j & 1:\n                        continue\n                    (xj, yj) = points[j]\n                    u = xj - xi\n                    v = yj - yi\n                    if dx * v == dy / u:\n                        update = 1\n                        state |= 1 << i | 1 << j\n                        break\n                if update:\n                    break\n        if cnt <= 1:\n            res = 0\n        else:\n            res = cnt * (cnt - 1) // 2 + max((dfs(state, *e) for e in s))\n        memo[pstate, dx, dy] = res\n        return res\n    return max((dfs(0, *e) for e in s))"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "if dx * v == dy * u:",
      "mutated_line": "if dx * v == dy + u:",
      "code": "def max_parallel_line_pairs(points):\n    m = len(points)\n    s = set()\n    for i in range(m):\n        (xi, yi) = points[i]\n        for j in range(i + 1, m):\n            (xj, yj) = points[j]\n            u = xj - xi\n            v = yj - yi\n            for (x, y) in s:\n                if x * v == y * u:\n                    break\n            else:\n                s.add((u, v))\n    memo = {}\n\n    def dfs(state, dx, dy):\n        if (state, dx, dy) in memo:\n            return memo[state, dx, dy]\n        pstate = state\n        update = 1\n        cnt = -1\n        while update:\n            update = 0\n            cnt += 1\n            for i in range(m):\n                if state >> i & 1:\n                    continue\n                (xi, yi) = points[i]\n                for j in range(i + 1, m):\n                    if state >> j & 1:\n                        continue\n                    (xj, yj) = points[j]\n                    u = xj - xi\n                    v = yj - yi\n                    if dx * v == dy + u:\n                        update = 1\n                        state |= 1 << i | 1 << j\n                        break\n                if update:\n                    break\n        if cnt <= 1:\n            res = 0\n        else:\n            res = cnt * (cnt - 1) // 2 + max((dfs(state, *e) for e in s))\n        memo[pstate, dx, dy] = res\n        return res\n    return max((dfs(0, *e) for e in s))"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "if dx * v == dy * u:",
      "mutated_line": "if dx * v == dy ** u:",
      "code": "def max_parallel_line_pairs(points):\n    m = len(points)\n    s = set()\n    for i in range(m):\n        (xi, yi) = points[i]\n        for j in range(i + 1, m):\n            (xj, yj) = points[j]\n            u = xj - xi\n            v = yj - yi\n            for (x, y) in s:\n                if x * v == y * u:\n                    break\n            else:\n                s.add((u, v))\n    memo = {}\n\n    def dfs(state, dx, dy):\n        if (state, dx, dy) in memo:\n            return memo[state, dx, dy]\n        pstate = state\n        update = 1\n        cnt = -1\n        while update:\n            update = 0\n            cnt += 1\n            for i in range(m):\n                if state >> i & 1:\n                    continue\n                (xi, yi) = points[i]\n                for j in range(i + 1, m):\n                    if state >> j & 1:\n                        continue\n                    (xj, yj) = points[j]\n                    u = xj - xi\n                    v = yj - yi\n                    if dx * v == dy ** u:\n                        update = 1\n                        state |= 1 << i | 1 << j\n                        break\n                if update:\n                    break\n        if cnt <= 1:\n            res = 0\n        else:\n            res = cnt * (cnt - 1) // 2 + max((dfs(state, *e) for e in s))\n        memo[pstate, dx, dy] = res\n        return res\n    return max((dfs(0, *e) for e in s))"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "update = 1",
      "mutated_line": "update = 2",
      "code": "def max_parallel_line_pairs(points):\n    m = len(points)\n    s = set()\n    for i in range(m):\n        (xi, yi) = points[i]\n        for j in range(i + 1, m):\n            (xj, yj) = points[j]\n            u = xj - xi\n            v = yj - yi\n            for (x, y) in s:\n                if x * v == y * u:\n                    break\n            else:\n                s.add((u, v))\n    memo = {}\n\n    def dfs(state, dx, dy):\n        if (state, dx, dy) in memo:\n            return memo[state, dx, dy]\n        pstate = state\n        update = 1\n        cnt = -1\n        while update:\n            update = 0\n            cnt += 1\n            for i in range(m):\n                if state >> i & 1:\n                    continue\n                (xi, yi) = points[i]\n                for j in range(i + 1, m):\n                    if state >> j & 1:\n                        continue\n                    (xj, yj) = points[j]\n                    u = xj - xi\n                    v = yj - yi\n                    if dx * v == dy * u:\n                        update = 2\n                        state |= 1 << i | 1 << j\n                        break\n                if update:\n                    break\n        if cnt <= 1:\n            res = 0\n        else:\n            res = cnt * (cnt - 1) // 2 + max((dfs(state, *e) for e in s))\n        memo[pstate, dx, dy] = res\n        return res\n    return max((dfs(0, *e) for e in s))"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "update = 1",
      "mutated_line": "update = 0",
      "code": "def max_parallel_line_pairs(points):\n    m = len(points)\n    s = set()\n    for i in range(m):\n        (xi, yi) = points[i]\n        for j in range(i + 1, m):\n            (xj, yj) = points[j]\n            u = xj - xi\n            v = yj - yi\n            for (x, y) in s:\n                if x * v == y * u:\n                    break\n            else:\n                s.add((u, v))\n    memo = {}\n\n    def dfs(state, dx, dy):\n        if (state, dx, dy) in memo:\n            return memo[state, dx, dy]\n        pstate = state\n        update = 1\n        cnt = -1\n        while update:\n            update = 0\n            cnt += 1\n            for i in range(m):\n                if state >> i & 1:\n                    continue\n                (xi, yi) = points[i]\n                for j in range(i + 1, m):\n                    if state >> j & 1:\n                        continue\n                    (xj, yj) = points[j]\n                    u = xj - xi\n                    v = yj - yi\n                    if dx * v == dy * u:\n                        update = 0\n                        state |= 1 << i | 1 << j\n                        break\n                if update:\n                    break\n        if cnt <= 1:\n            res = 0\n        else:\n            res = cnt * (cnt - 1) // 2 + max((dfs(state, *e) for e in s))\n        memo[pstate, dx, dy] = res\n        return res\n    return max((dfs(0, *e) for e in s))"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "update = 1",
      "mutated_line": "update = 0",
      "code": "def max_parallel_line_pairs(points):\n    m = len(points)\n    s = set()\n    for i in range(m):\n        (xi, yi) = points[i]\n        for j in range(i + 1, m):\n            (xj, yj) = points[j]\n            u = xj - xi\n            v = yj - yi\n            for (x, y) in s:\n                if x * v == y * u:\n                    break\n            else:\n                s.add((u, v))\n    memo = {}\n\n    def dfs(state, dx, dy):\n        if (state, dx, dy) in memo:\n            return memo[state, dx, dy]\n        pstate = state\n        update = 1\n        cnt = -1\n        while update:\n            update = 0\n            cnt += 1\n            for i in range(m):\n                if state >> i & 1:\n                    continue\n                (xi, yi) = points[i]\n                for j in range(i + 1, m):\n                    if state >> j & 1:\n                        continue\n                    (xj, yj) = points[j]\n                    u = xj - xi\n                    v = yj - yi\n                    if dx * v == dy * u:\n                        update = 0\n                        state |= 1 << i | 1 << j\n                        break\n                if update:\n                    break\n        if cnt <= 1:\n            res = 0\n        else:\n            res = cnt * (cnt - 1) // 2 + max((dfs(state, *e) for e in s))\n        memo[pstate, dx, dy] = res\n        return res\n    return max((dfs(0, *e) for e in s))"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "update = 1",
      "mutated_line": "update = -1",
      "code": "def max_parallel_line_pairs(points):\n    m = len(points)\n    s = set()\n    for i in range(m):\n        (xi, yi) = points[i]\n        for j in range(i + 1, m):\n            (xj, yj) = points[j]\n            u = xj - xi\n            v = yj - yi\n            for (x, y) in s:\n                if x * v == y * u:\n                    break\n            else:\n                s.add((u, v))\n    memo = {}\n\n    def dfs(state, dx, dy):\n        if (state, dx, dy) in memo:\n            return memo[state, dx, dy]\n        pstate = state\n        update = 1\n        cnt = -1\n        while update:\n            update = 0\n            cnt += 1\n            for i in range(m):\n                if state >> i & 1:\n                    continue\n                (xi, yi) = points[i]\n                for j in range(i + 1, m):\n                    if state >> j & 1:\n                        continue\n                    (xj, yj) = points[j]\n                    u = xj - xi\n                    v = yj - yi\n                    if dx * v == dy * u:\n                        update = -1\n                        state |= 1 << i | 1 << j\n                        break\n                if update:\n                    break\n        if cnt <= 1:\n            res = 0\n        else:\n            res = cnt * (cnt - 1) // 2 + max((dfs(state, *e) for e in s))\n        memo[pstate, dx, dy] = res\n        return res\n    return max((dfs(0, *e) for e in s))"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "state |= 1 << i | 1 << j",
      "mutated_line": "state |= 1 << i & 1 << j",
      "code": "def max_parallel_line_pairs(points):\n    m = len(points)\n    s = set()\n    for i in range(m):\n        (xi, yi) = points[i]\n        for j in range(i + 1, m):\n            (xj, yj) = points[j]\n            u = xj - xi\n            v = yj - yi\n            for (x, y) in s:\n                if x * v == y * u:\n                    break\n            else:\n                s.add((u, v))\n    memo = {}\n\n    def dfs(state, dx, dy):\n        if (state, dx, dy) in memo:\n            return memo[state, dx, dy]\n        pstate = state\n        update = 1\n        cnt = -1\n        while update:\n            update = 0\n            cnt += 1\n            for i in range(m):\n                if state >> i & 1:\n                    continue\n                (xi, yi) = points[i]\n                for j in range(i + 1, m):\n                    if state >> j & 1:\n                        continue\n                    (xj, yj) = points[j]\n                    u = xj - xi\n                    v = yj - yi\n                    if dx * v == dy * u:\n                        update = 1\n                        state |= 1 << i & 1 << j\n                        break\n                if update:\n                    break\n        if cnt <= 1:\n            res = 0\n        else:\n            res = cnt * (cnt - 1) // 2 + max((dfs(state, *e) for e in s))\n        memo[pstate, dx, dy] = res\n        return res\n    return max((dfs(0, *e) for e in s))"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "state |= 1 << i | 1 << j",
      "mutated_line": "state |= 1 << i ^ 1 << j",
      "code": "def max_parallel_line_pairs(points):\n    m = len(points)\n    s = set()\n    for i in range(m):\n        (xi, yi) = points[i]\n        for j in range(i + 1, m):\n            (xj, yj) = points[j]\n            u = xj - xi\n            v = yj - yi\n            for (x, y) in s:\n                if x * v == y * u:\n                    break\n            else:\n                s.add((u, v))\n    memo = {}\n\n    def dfs(state, dx, dy):\n        if (state, dx, dy) in memo:\n            return memo[state, dx, dy]\n        pstate = state\n        update = 1\n        cnt = -1\n        while update:\n            update = 0\n            cnt += 1\n            for i in range(m):\n                if state >> i & 1:\n                    continue\n                (xi, yi) = points[i]\n                for j in range(i + 1, m):\n                    if state >> j & 1:\n                        continue\n                    (xj, yj) = points[j]\n                    u = xj - xi\n                    v = yj - yi\n                    if dx * v == dy * u:\n                        update = 1\n                        state |= 1 << i ^ 1 << j\n                        break\n                if update:\n                    break\n        if cnt <= 1:\n            res = 0\n        else:\n            res = cnt * (cnt - 1) // 2 + max((dfs(state, *e) for e in s))\n        memo[pstate, dx, dy] = res\n        return res\n    return max((dfs(0, *e) for e in s))"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "res = cnt * (cnt - 1) // 2 + max((dfs(state, *e) for e in s))",
      "mutated_line": "res = cnt * (cnt + 1) // 2 + max((dfs(state, *e) for e in s))",
      "code": "def max_parallel_line_pairs(points):\n    m = len(points)\n    s = set()\n    for i in range(m):\n        (xi, yi) = points[i]\n        for j in range(i + 1, m):\n            (xj, yj) = points[j]\n            u = xj - xi\n            v = yj - yi\n            for (x, y) in s:\n                if x * v == y * u:\n                    break\n            else:\n                s.add((u, v))\n    memo = {}\n\n    def dfs(state, dx, dy):\n        if (state, dx, dy) in memo:\n            return memo[state, dx, dy]\n        pstate = state\n        update = 1\n        cnt = -1\n        while update:\n            update = 0\n            cnt += 1\n            for i in range(m):\n                if state >> i & 1:\n                    continue\n                (xi, yi) = points[i]\n                for j in range(i + 1, m):\n                    if state >> j & 1:\n                        continue\n                    (xj, yj) = points[j]\n                    u = xj - xi\n                    v = yj - yi\n                    if dx * v == dy * u:\n                        update = 1\n                        state |= 1 << i | 1 << j\n                        break\n                if update:\n                    break\n        if cnt <= 1:\n            res = 0\n        else:\n            res = cnt * (cnt + 1) // 2 + max((dfs(state, *e) for e in s))\n        memo[pstate, dx, dy] = res\n        return res\n    return max((dfs(0, *e) for e in s))"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "res = cnt * (cnt - 1) // 2 + max((dfs(state, *e) for e in s))",
      "mutated_line": "res = cnt * (cnt * 1) // 2 + max((dfs(state, *e) for e in s))",
      "code": "def max_parallel_line_pairs(points):\n    m = len(points)\n    s = set()\n    for i in range(m):\n        (xi, yi) = points[i]\n        for j in range(i + 1, m):\n            (xj, yj) = points[j]\n            u = xj - xi\n            v = yj - yi\n            for (x, y) in s:\n                if x * v == y * u:\n                    break\n            else:\n                s.add((u, v))\n    memo = {}\n\n    def dfs(state, dx, dy):\n        if (state, dx, dy) in memo:\n            return memo[state, dx, dy]\n        pstate = state\n        update = 1\n        cnt = -1\n        while update:\n            update = 0\n            cnt += 1\n            for i in range(m):\n                if state >> i & 1:\n                    continue\n                (xi, yi) = points[i]\n                for j in range(i + 1, m):\n                    if state >> j & 1:\n                        continue\n                    (xj, yj) = points[j]\n                    u = xj - xi\n                    v = yj - yi\n                    if dx * v == dy * u:\n                        update = 1\n                        state |= 1 << i | 1 << j\n                        break\n                if update:\n                    break\n        if cnt <= 1:\n            res = 0\n        else:\n            res = cnt * (cnt * 1) // 2 + max((dfs(state, *e) for e in s))\n        memo[pstate, dx, dy] = res\n        return res\n    return max((dfs(0, *e) for e in s))"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "res = cnt * (cnt - 1) // 2 + max((dfs(state, *e) for e in s))",
      "mutated_line": "res = cnt * (cnt - 2) // 2 + max((dfs(state, *e) for e in s))",
      "code": "def max_parallel_line_pairs(points):\n    m = len(points)\n    s = set()\n    for i in range(m):\n        (xi, yi) = points[i]\n        for j in range(i + 1, m):\n            (xj, yj) = points[j]\n            u = xj - xi\n            v = yj - yi\n            for (x, y) in s:\n                if x * v == y * u:\n                    break\n            else:\n                s.add((u, v))\n    memo = {}\n\n    def dfs(state, dx, dy):\n        if (state, dx, dy) in memo:\n            return memo[state, dx, dy]\n        pstate = state\n        update = 1\n        cnt = -1\n        while update:\n            update = 0\n            cnt += 1\n            for i in range(m):\n                if state >> i & 1:\n                    continue\n                (xi, yi) = points[i]\n                for j in range(i + 1, m):\n                    if state >> j & 1:\n                        continue\n                    (xj, yj) = points[j]\n                    u = xj - xi\n                    v = yj - yi\n                    if dx * v == dy * u:\n                        update = 1\n                        state |= 1 << i | 1 << j\n                        break\n                if update:\n                    break\n        if cnt <= 1:\n            res = 0\n        else:\n            res = cnt * (cnt - 2) // 2 + max((dfs(state, *e) for e in s))\n        memo[pstate, dx, dy] = res\n        return res\n    return max((dfs(0, *e) for e in s))"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "res = cnt * (cnt - 1) // 2 + max((dfs(state, *e) for e in s))",
      "mutated_line": "res = cnt * (cnt - 0) // 2 + max((dfs(state, *e) for e in s))",
      "code": "def max_parallel_line_pairs(points):\n    m = len(points)\n    s = set()\n    for i in range(m):\n        (xi, yi) = points[i]\n        for j in range(i + 1, m):\n            (xj, yj) = points[j]\n            u = xj - xi\n            v = yj - yi\n            for (x, y) in s:\n                if x * v == y * u:\n                    break\n            else:\n                s.add((u, v))\n    memo = {}\n\n    def dfs(state, dx, dy):\n        if (state, dx, dy) in memo:\n            return memo[state, dx, dy]\n        pstate = state\n        update = 1\n        cnt = -1\n        while update:\n            update = 0\n            cnt += 1\n            for i in range(m):\n                if state >> i & 1:\n                    continue\n                (xi, yi) = points[i]\n                for j in range(i + 1, m):\n                    if state >> j & 1:\n                        continue\n                    (xj, yj) = points[j]\n                    u = xj - xi\n                    v = yj - yi\n                    if dx * v == dy * u:\n                        update = 1\n                        state |= 1 << i | 1 << j\n                        break\n                if update:\n                    break\n        if cnt <= 1:\n            res = 0\n        else:\n            res = cnt * (cnt - 0) // 2 + max((dfs(state, *e) for e in s))\n        memo[pstate, dx, dy] = res\n        return res\n    return max((dfs(0, *e) for e in s))"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "res = cnt * (cnt - 1) // 2 + max((dfs(state, *e) for e in s))",
      "mutated_line": "res = cnt * (cnt - 0) // 2 + max((dfs(state, *e) for e in s))",
      "code": "def max_parallel_line_pairs(points):\n    m = len(points)\n    s = set()\n    for i in range(m):\n        (xi, yi) = points[i]\n        for j in range(i + 1, m):\n            (xj, yj) = points[j]\n            u = xj - xi\n            v = yj - yi\n            for (x, y) in s:\n                if x * v == y * u:\n                    break\n            else:\n                s.add((u, v))\n    memo = {}\n\n    def dfs(state, dx, dy):\n        if (state, dx, dy) in memo:\n            return memo[state, dx, dy]\n        pstate = state\n        update = 1\n        cnt = -1\n        while update:\n            update = 0\n            cnt += 1\n            for i in range(m):\n                if state >> i & 1:\n                    continue\n                (xi, yi) = points[i]\n                for j in range(i + 1, m):\n                    if state >> j & 1:\n                        continue\n                    (xj, yj) = points[j]\n                    u = xj - xi\n                    v = yj - yi\n                    if dx * v == dy * u:\n                        update = 1\n                        state |= 1 << i | 1 << j\n                        break\n                if update:\n                    break\n        if cnt <= 1:\n            res = 0\n        else:\n            res = cnt * (cnt - 0) // 2 + max((dfs(state, *e) for e in s))\n        memo[pstate, dx, dy] = res\n        return res\n    return max((dfs(0, *e) for e in s))"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "res = cnt * (cnt - 1) // 2 + max((dfs(state, *e) for e in s))",
      "mutated_line": "res = cnt * (cnt - -1) // 2 + max((dfs(state, *e) for e in s))",
      "code": "def max_parallel_line_pairs(points):\n    m = len(points)\n    s = set()\n    for i in range(m):\n        (xi, yi) = points[i]\n        for j in range(i + 1, m):\n            (xj, yj) = points[j]\n            u = xj - xi\n            v = yj - yi\n            for (x, y) in s:\n                if x * v == y * u:\n                    break\n            else:\n                s.add((u, v))\n    memo = {}\n\n    def dfs(state, dx, dy):\n        if (state, dx, dy) in memo:\n            return memo[state, dx, dy]\n        pstate = state\n        update = 1\n        cnt = -1\n        while update:\n            update = 0\n            cnt += 1\n            for i in range(m):\n                if state >> i & 1:\n                    continue\n                (xi, yi) = points[i]\n                for j in range(i + 1, m):\n                    if state >> j & 1:\n                        continue\n                    (xj, yj) = points[j]\n                    u = xj - xi\n                    v = yj - yi\n                    if dx * v == dy * u:\n                        update = 1\n                        state |= 1 << i | 1 << j\n                        break\n                if update:\n                    break\n        if cnt <= 1:\n            res = 0\n        else:\n            res = cnt * (cnt - -1) // 2 + max((dfs(state, *e) for e in s))\n        memo[pstate, dx, dy] = res\n        return res\n    return max((dfs(0, *e) for e in s))"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "state |= 1 << i | 1 << j",
      "mutated_line": "state |= 2 << i | 1 << j",
      "code": "def max_parallel_line_pairs(points):\n    m = len(points)\n    s = set()\n    for i in range(m):\n        (xi, yi) = points[i]\n        for j in range(i + 1, m):\n            (xj, yj) = points[j]\n            u = xj - xi\n            v = yj - yi\n            for (x, y) in s:\n                if x * v == y * u:\n                    break\n            else:\n                s.add((u, v))\n    memo = {}\n\n    def dfs(state, dx, dy):\n        if (state, dx, dy) in memo:\n            return memo[state, dx, dy]\n        pstate = state\n        update = 1\n        cnt = -1\n        while update:\n            update = 0\n            cnt += 1\n            for i in range(m):\n                if state >> i & 1:\n                    continue\n                (xi, yi) = points[i]\n                for j in range(i + 1, m):\n                    if state >> j & 1:\n                        continue\n                    (xj, yj) = points[j]\n                    u = xj - xi\n                    v = yj - yi\n                    if dx * v == dy * u:\n                        update = 1\n                        state |= 2 << i | 1 << j\n                        break\n                if update:\n                    break\n        if cnt <= 1:\n            res = 0\n        else:\n            res = cnt * (cnt - 1) // 2 + max((dfs(state, *e) for e in s))\n        memo[pstate, dx, dy] = res\n        return res\n    return max((dfs(0, *e) for e in s))"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "state |= 1 << i | 1 << j",
      "mutated_line": "state |= 0 << i | 1 << j",
      "code": "def max_parallel_line_pairs(points):\n    m = len(points)\n    s = set()\n    for i in range(m):\n        (xi, yi) = points[i]\n        for j in range(i + 1, m):\n            (xj, yj) = points[j]\n            u = xj - xi\n            v = yj - yi\n            for (x, y) in s:\n                if x * v == y * u:\n                    break\n            else:\n                s.add((u, v))\n    memo = {}\n\n    def dfs(state, dx, dy):\n        if (state, dx, dy) in memo:\n            return memo[state, dx, dy]\n        pstate = state\n        update = 1\n        cnt = -1\n        while update:\n            update = 0\n            cnt += 1\n            for i in range(m):\n                if state >> i & 1:\n                    continue\n                (xi, yi) = points[i]\n                for j in range(i + 1, m):\n                    if state >> j & 1:\n                        continue\n                    (xj, yj) = points[j]\n                    u = xj - xi\n                    v = yj - yi\n                    if dx * v == dy * u:\n                        update = 1\n                        state |= 0 << i | 1 << j\n                        break\n                if update:\n                    break\n        if cnt <= 1:\n            res = 0\n        else:\n            res = cnt * (cnt - 1) // 2 + max((dfs(state, *e) for e in s))\n        memo[pstate, dx, dy] = res\n        return res\n    return max((dfs(0, *e) for e in s))"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "state |= 1 << i | 1 << j",
      "mutated_line": "state |= 0 << i | 1 << j",
      "code": "def max_parallel_line_pairs(points):\n    m = len(points)\n    s = set()\n    for i in range(m):\n        (xi, yi) = points[i]\n        for j in range(i + 1, m):\n            (xj, yj) = points[j]\n            u = xj - xi\n            v = yj - yi\n            for (x, y) in s:\n                if x * v == y * u:\n                    break\n            else:\n                s.add((u, v))\n    memo = {}\n\n    def dfs(state, dx, dy):\n        if (state, dx, dy) in memo:\n            return memo[state, dx, dy]\n        pstate = state\n        update = 1\n        cnt = -1\n        while update:\n            update = 0\n            cnt += 1\n            for i in range(m):\n                if state >> i & 1:\n                    continue\n                (xi, yi) = points[i]\n                for j in range(i + 1, m):\n                    if state >> j & 1:\n                        continue\n                    (xj, yj) = points[j]\n                    u = xj - xi\n                    v = yj - yi\n                    if dx * v == dy * u:\n                        update = 1\n                        state |= 0 << i | 1 << j\n                        break\n                if update:\n                    break\n        if cnt <= 1:\n            res = 0\n        else:\n            res = cnt * (cnt - 1) // 2 + max((dfs(state, *e) for e in s))\n        memo[pstate, dx, dy] = res\n        return res\n    return max((dfs(0, *e) for e in s))"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "state |= 1 << i | 1 << j",
      "mutated_line": "state |= -1 << i | 1 << j",
      "code": "def max_parallel_line_pairs(points):\n    m = len(points)\n    s = set()\n    for i in range(m):\n        (xi, yi) = points[i]\n        for j in range(i + 1, m):\n            (xj, yj) = points[j]\n            u = xj - xi\n            v = yj - yi\n            for (x, y) in s:\n                if x * v == y * u:\n                    break\n            else:\n                s.add((u, v))\n    memo = {}\n\n    def dfs(state, dx, dy):\n        if (state, dx, dy) in memo:\n            return memo[state, dx, dy]\n        pstate = state\n        update = 1\n        cnt = -1\n        while update:\n            update = 0\n            cnt += 1\n            for i in range(m):\n                if state >> i & 1:\n                    continue\n                (xi, yi) = points[i]\n                for j in range(i + 1, m):\n                    if state >> j & 1:\n                        continue\n                    (xj, yj) = points[j]\n                    u = xj - xi\n                    v = yj - yi\n                    if dx * v == dy * u:\n                        update = 1\n                        state |= -1 << i | 1 << j\n                        break\n                if update:\n                    break\n        if cnt <= 1:\n            res = 0\n        else:\n            res = cnt * (cnt - 1) // 2 + max((dfs(state, *e) for e in s))\n        memo[pstate, dx, dy] = res\n        return res\n    return max((dfs(0, *e) for e in s))"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "state |= 1 << i | 1 << j",
      "mutated_line": "state |= 1 << i | 2 << j",
      "code": "def max_parallel_line_pairs(points):\n    m = len(points)\n    s = set()\n    for i in range(m):\n        (xi, yi) = points[i]\n        for j in range(i + 1, m):\n            (xj, yj) = points[j]\n            u = xj - xi\n            v = yj - yi\n            for (x, y) in s:\n                if x * v == y * u:\n                    break\n            else:\n                s.add((u, v))\n    memo = {}\n\n    def dfs(state, dx, dy):\n        if (state, dx, dy) in memo:\n            return memo[state, dx, dy]\n        pstate = state\n        update = 1\n        cnt = -1\n        while update:\n            update = 0\n            cnt += 1\n            for i in range(m):\n                if state >> i & 1:\n                    continue\n                (xi, yi) = points[i]\n                for j in range(i + 1, m):\n                    if state >> j & 1:\n                        continue\n                    (xj, yj) = points[j]\n                    u = xj - xi\n                    v = yj - yi\n                    if dx * v == dy * u:\n                        update = 1\n                        state |= 1 << i | 2 << j\n                        break\n                if update:\n                    break\n        if cnt <= 1:\n            res = 0\n        else:\n            res = cnt * (cnt - 1) // 2 + max((dfs(state, *e) for e in s))\n        memo[pstate, dx, dy] = res\n        return res\n    return max((dfs(0, *e) for e in s))"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "state |= 1 << i | 1 << j",
      "mutated_line": "state |= 1 << i | 0 << j",
      "code": "def max_parallel_line_pairs(points):\n    m = len(points)\n    s = set()\n    for i in range(m):\n        (xi, yi) = points[i]\n        for j in range(i + 1, m):\n            (xj, yj) = points[j]\n            u = xj - xi\n            v = yj - yi\n            for (x, y) in s:\n                if x * v == y * u:\n                    break\n            else:\n                s.add((u, v))\n    memo = {}\n\n    def dfs(state, dx, dy):\n        if (state, dx, dy) in memo:\n            return memo[state, dx, dy]\n        pstate = state\n        update = 1\n        cnt = -1\n        while update:\n            update = 0\n            cnt += 1\n            for i in range(m):\n                if state >> i & 1:\n                    continue\n                (xi, yi) = points[i]\n                for j in range(i + 1, m):\n                    if state >> j & 1:\n                        continue\n                    (xj, yj) = points[j]\n                    u = xj - xi\n                    v = yj - yi\n                    if dx * v == dy * u:\n                        update = 1\n                        state |= 1 << i | 0 << j\n                        break\n                if update:\n                    break\n        if cnt <= 1:\n            res = 0\n        else:\n            res = cnt * (cnt - 1) // 2 + max((dfs(state, *e) for e in s))\n        memo[pstate, dx, dy] = res\n        return res\n    return max((dfs(0, *e) for e in s))"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "state |= 1 << i | 1 << j",
      "mutated_line": "state |= 1 << i | 0 << j",
      "code": "def max_parallel_line_pairs(points):\n    m = len(points)\n    s = set()\n    for i in range(m):\n        (xi, yi) = points[i]\n        for j in range(i + 1, m):\n            (xj, yj) = points[j]\n            u = xj - xi\n            v = yj - yi\n            for (x, y) in s:\n                if x * v == y * u:\n                    break\n            else:\n                s.add((u, v))\n    memo = {}\n\n    def dfs(state, dx, dy):\n        if (state, dx, dy) in memo:\n            return memo[state, dx, dy]\n        pstate = state\n        update = 1\n        cnt = -1\n        while update:\n            update = 0\n            cnt += 1\n            for i in range(m):\n                if state >> i & 1:\n                    continue\n                (xi, yi) = points[i]\n                for j in range(i + 1, m):\n                    if state >> j & 1:\n                        continue\n                    (xj, yj) = points[j]\n                    u = xj - xi\n                    v = yj - yi\n                    if dx * v == dy * u:\n                        update = 1\n                        state |= 1 << i | 0 << j\n                        break\n                if update:\n                    break\n        if cnt <= 1:\n            res = 0\n        else:\n            res = cnt * (cnt - 1) // 2 + max((dfs(state, *e) for e in s))\n        memo[pstate, dx, dy] = res\n        return res\n    return max((dfs(0, *e) for e in s))"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "state |= 1 << i | 1 << j",
      "mutated_line": "state |= 1 << i | -1 << j",
      "code": "def max_parallel_line_pairs(points):\n    m = len(points)\n    s = set()\n    for i in range(m):\n        (xi, yi) = points[i]\n        for j in range(i + 1, m):\n            (xj, yj) = points[j]\n            u = xj - xi\n            v = yj - yi\n            for (x, y) in s:\n                if x * v == y * u:\n                    break\n            else:\n                s.add((u, v))\n    memo = {}\n\n    def dfs(state, dx, dy):\n        if (state, dx, dy) in memo:\n            return memo[state, dx, dy]\n        pstate = state\n        update = 1\n        cnt = -1\n        while update:\n            update = 0\n            cnt += 1\n            for i in range(m):\n                if state >> i & 1:\n                    continue\n                (xi, yi) = points[i]\n                for j in range(i + 1, m):\n                    if state >> j & 1:\n                        continue\n                    (xj, yj) = points[j]\n                    u = xj - xi\n                    v = yj - yi\n                    if dx * v == dy * u:\n                        update = 1\n                        state |= 1 << i | -1 << j\n                        break\n                if update:\n                    break\n        if cnt <= 1:\n            res = 0\n        else:\n            res = cnt * (cnt - 1) // 2 + max((dfs(state, *e) for e in s))\n        memo[pstate, dx, dy] = res\n        return res\n    return max((dfs(0, *e) for e in s))"
    }
  ]
}