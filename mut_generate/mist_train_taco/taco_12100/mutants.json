{
  "task_id": "taco_12100",
  "entry_point": "find_possible_k_values",
  "mutant_count": 75,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "counts = {i: 0 for i in range(32)}",
      "mutated_line": "counts = {i: 1 for i in range(32)}",
      "code": "import math\n\ndef find_possible_k_values(n, a):\n    counts = {i: 1 for i in range(32)}\n    for ai in a:\n        bin_ai = '{:032b}'.format(ai)\n        for i in range(32):\n            if bin_ai[i] == '1':\n                counts[i] += 1\n    groups = [counts[i] for i in range(32) if counts[i] > 0]\n    if not groups:\n        return list(range(1, n + 1))\n    counts_by_divisor = {}\n    for group_size in groups:\n        for divisor in get_divisors(group_size):\n            if divisor in counts_by_divisor:\n                counts_by_divisor[divisor] += 1\n            else:\n                counts_by_divisor[divisor] = 1\n    k_values = [divisor for divisor in counts_by_divisor if counts_by_divisor[divisor] == len(groups)]\n    return sorted(k_values)\n\ndef get_divisors(value):\n    m = int(math.ceil(math.sqrt(value)))\n    for d in range(1, m + 1):\n        if value % d == 0:\n            e = value // d\n            if d < e:\n                yield d\n                yield e\n            elif d == e:\n                yield d"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "counts = {i: 0 for i in range(32)}",
      "mutated_line": "counts = {i: -1 for i in range(32)}",
      "code": "import math\n\ndef find_possible_k_values(n, a):\n    counts = {i: -1 for i in range(32)}\n    for ai in a:\n        bin_ai = '{:032b}'.format(ai)\n        for i in range(32):\n            if bin_ai[i] == '1':\n                counts[i] += 1\n    groups = [counts[i] for i in range(32) if counts[i] > 0]\n    if not groups:\n        return list(range(1, n + 1))\n    counts_by_divisor = {}\n    for group_size in groups:\n        for divisor in get_divisors(group_size):\n            if divisor in counts_by_divisor:\n                counts_by_divisor[divisor] += 1\n            else:\n                counts_by_divisor[divisor] = 1\n    k_values = [divisor for divisor in counts_by_divisor if counts_by_divisor[divisor] == len(groups)]\n    return sorted(k_values)\n\ndef get_divisors(value):\n    m = int(math.ceil(math.sqrt(value)))\n    for d in range(1, m + 1):\n        if value % d == 0:\n            e = value // d\n            if d < e:\n                yield d\n                yield e\n            elif d == e:\n                yield d"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "counts = {i: 0 for i in range(32)}",
      "mutated_line": "counts = {i: 1 for i in range(32)}",
      "code": "import math\n\ndef find_possible_k_values(n, a):\n    counts = {i: 1 for i in range(32)}\n    for ai in a:\n        bin_ai = '{:032b}'.format(ai)\n        for i in range(32):\n            if bin_ai[i] == '1':\n                counts[i] += 1\n    groups = [counts[i] for i in range(32) if counts[i] > 0]\n    if not groups:\n        return list(range(1, n + 1))\n    counts_by_divisor = {}\n    for group_size in groups:\n        for divisor in get_divisors(group_size):\n            if divisor in counts_by_divisor:\n                counts_by_divisor[divisor] += 1\n            else:\n                counts_by_divisor[divisor] = 1\n    k_values = [divisor for divisor in counts_by_divisor if counts_by_divisor[divisor] == len(groups)]\n    return sorted(k_values)\n\ndef get_divisors(value):\n    m = int(math.ceil(math.sqrt(value)))\n    for d in range(1, m + 1):\n        if value % d == 0:\n            e = value // d\n            if d < e:\n                yield d\n                yield e\n            elif d == e:\n                yield d"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for d in range(1, m + 1):",
      "mutated_line": "for d in range(2, m + 1):",
      "code": "import math\n\ndef find_possible_k_values(n, a):\n    counts = {i: 0 for i in range(32)}\n    for ai in a:\n        bin_ai = '{:032b}'.format(ai)\n        for i in range(32):\n            if bin_ai[i] == '1':\n                counts[i] += 1\n    groups = [counts[i] for i in range(32) if counts[i] > 0]\n    if not groups:\n        return list(range(1, n + 1))\n    counts_by_divisor = {}\n    for group_size in groups:\n        for divisor in get_divisors(group_size):\n            if divisor in counts_by_divisor:\n                counts_by_divisor[divisor] += 1\n            else:\n                counts_by_divisor[divisor] = 1\n    k_values = [divisor for divisor in counts_by_divisor if counts_by_divisor[divisor] == len(groups)]\n    return sorted(k_values)\n\ndef get_divisors(value):\n    m = int(math.ceil(math.sqrt(value)))\n    for d in range(2, m + 1):\n        if value % d == 0:\n            e = value // d\n            if d < e:\n                yield d\n                yield e\n            elif d == e:\n                yield d"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for d in range(1, m + 1):",
      "mutated_line": "for d in range(0, m + 1):",
      "code": "import math\n\ndef find_possible_k_values(n, a):\n    counts = {i: 0 for i in range(32)}\n    for ai in a:\n        bin_ai = '{:032b}'.format(ai)\n        for i in range(32):\n            if bin_ai[i] == '1':\n                counts[i] += 1\n    groups = [counts[i] for i in range(32) if counts[i] > 0]\n    if not groups:\n        return list(range(1, n + 1))\n    counts_by_divisor = {}\n    for group_size in groups:\n        for divisor in get_divisors(group_size):\n            if divisor in counts_by_divisor:\n                counts_by_divisor[divisor] += 1\n            else:\n                counts_by_divisor[divisor] = 1\n    k_values = [divisor for divisor in counts_by_divisor if counts_by_divisor[divisor] == len(groups)]\n    return sorted(k_values)\n\ndef get_divisors(value):\n    m = int(math.ceil(math.sqrt(value)))\n    for d in range(0, m + 1):\n        if value % d == 0:\n            e = value // d\n            if d < e:\n                yield d\n                yield e\n            elif d == e:\n                yield d"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for d in range(1, m + 1):",
      "mutated_line": "for d in range(0, m + 1):",
      "code": "import math\n\ndef find_possible_k_values(n, a):\n    counts = {i: 0 for i in range(32)}\n    for ai in a:\n        bin_ai = '{:032b}'.format(ai)\n        for i in range(32):\n            if bin_ai[i] == '1':\n                counts[i] += 1\n    groups = [counts[i] for i in range(32) if counts[i] > 0]\n    if not groups:\n        return list(range(1, n + 1))\n    counts_by_divisor = {}\n    for group_size in groups:\n        for divisor in get_divisors(group_size):\n            if divisor in counts_by_divisor:\n                counts_by_divisor[divisor] += 1\n            else:\n                counts_by_divisor[divisor] = 1\n    k_values = [divisor for divisor in counts_by_divisor if counts_by_divisor[divisor] == len(groups)]\n    return sorted(k_values)\n\ndef get_divisors(value):\n    m = int(math.ceil(math.sqrt(value)))\n    for d in range(0, m + 1):\n        if value % d == 0:\n            e = value // d\n            if d < e:\n                yield d\n                yield e\n            elif d == e:\n                yield d"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for d in range(1, m + 1):",
      "mutated_line": "for d in range(-1, m + 1):",
      "code": "import math\n\ndef find_possible_k_values(n, a):\n    counts = {i: 0 for i in range(32)}\n    for ai in a:\n        bin_ai = '{:032b}'.format(ai)\n        for i in range(32):\n            if bin_ai[i] == '1':\n                counts[i] += 1\n    groups = [counts[i] for i in range(32) if counts[i] > 0]\n    if not groups:\n        return list(range(1, n + 1))\n    counts_by_divisor = {}\n    for group_size in groups:\n        for divisor in get_divisors(group_size):\n            if divisor in counts_by_divisor:\n                counts_by_divisor[divisor] += 1\n            else:\n                counts_by_divisor[divisor] = 1\n    k_values = [divisor for divisor in counts_by_divisor if counts_by_divisor[divisor] == len(groups)]\n    return sorted(k_values)\n\ndef get_divisors(value):\n    m = int(math.ceil(math.sqrt(value)))\n    for d in range(-1, m + 1):\n        if value % d == 0:\n            e = value // d\n            if d < e:\n                yield d\n                yield e\n            elif d == e:\n                yield d"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "for d in range(1, m + 1):",
      "mutated_line": "for d in range(1, m - 1):",
      "code": "import math\n\ndef find_possible_k_values(n, a):\n    counts = {i: 0 for i in range(32)}\n    for ai in a:\n        bin_ai = '{:032b}'.format(ai)\n        for i in range(32):\n            if bin_ai[i] == '1':\n                counts[i] += 1\n    groups = [counts[i] for i in range(32) if counts[i] > 0]\n    if not groups:\n        return list(range(1, n + 1))\n    counts_by_divisor = {}\n    for group_size in groups:\n        for divisor in get_divisors(group_size):\n            if divisor in counts_by_divisor:\n                counts_by_divisor[divisor] += 1\n            else:\n                counts_by_divisor[divisor] = 1\n    k_values = [divisor for divisor in counts_by_divisor if counts_by_divisor[divisor] == len(groups)]\n    return sorted(k_values)\n\ndef get_divisors(value):\n    m = int(math.ceil(math.sqrt(value)))\n    for d in range(1, m - 1):\n        if value % d == 0:\n            e = value // d\n            if d < e:\n                yield d\n                yield e\n            elif d == e:\n                yield d"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "for d in range(1, m + 1):",
      "mutated_line": "for d in range(1, m * 1):",
      "code": "import math\n\ndef find_possible_k_values(n, a):\n    counts = {i: 0 for i in range(32)}\n    for ai in a:\n        bin_ai = '{:032b}'.format(ai)\n        for i in range(32):\n            if bin_ai[i] == '1':\n                counts[i] += 1\n    groups = [counts[i] for i in range(32) if counts[i] > 0]\n    if not groups:\n        return list(range(1, n + 1))\n    counts_by_divisor = {}\n    for group_size in groups:\n        for divisor in get_divisors(group_size):\n            if divisor in counts_by_divisor:\n                counts_by_divisor[divisor] += 1\n            else:\n                counts_by_divisor[divisor] = 1\n    k_values = [divisor for divisor in counts_by_divisor if counts_by_divisor[divisor] == len(groups)]\n    return sorted(k_values)\n\ndef get_divisors(value):\n    m = int(math.ceil(math.sqrt(value)))\n    for d in range(1, m * 1):\n        if value % d == 0:\n            e = value // d\n            if d < e:\n                yield d\n                yield e\n            elif d == e:\n                yield d"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if value % d == 0:",
      "mutated_line": "if value % d != 0:",
      "code": "import math\n\ndef find_possible_k_values(n, a):\n    counts = {i: 0 for i in range(32)}\n    for ai in a:\n        bin_ai = '{:032b}'.format(ai)\n        for i in range(32):\n            if bin_ai[i] == '1':\n                counts[i] += 1\n    groups = [counts[i] for i in range(32) if counts[i] > 0]\n    if not groups:\n        return list(range(1, n + 1))\n    counts_by_divisor = {}\n    for group_size in groups:\n        for divisor in get_divisors(group_size):\n            if divisor in counts_by_divisor:\n                counts_by_divisor[divisor] += 1\n            else:\n                counts_by_divisor[divisor] = 1\n    k_values = [divisor for divisor in counts_by_divisor if counts_by_divisor[divisor] == len(groups)]\n    return sorted(k_values)\n\ndef get_divisors(value):\n    m = int(math.ceil(math.sqrt(value)))\n    for d in range(1, m + 1):\n        if value % d != 0:\n            e = value // d\n            if d < e:\n                yield d\n                yield e\n            elif d == e:\n                yield d"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(32):",
      "mutated_line": "for i in range(33):",
      "code": "import math\n\ndef find_possible_k_values(n, a):\n    counts = {i: 0 for i in range(32)}\n    for ai in a:\n        bin_ai = '{:032b}'.format(ai)\n        for i in range(33):\n            if bin_ai[i] == '1':\n                counts[i] += 1\n    groups = [counts[i] for i in range(32) if counts[i] > 0]\n    if not groups:\n        return list(range(1, n + 1))\n    counts_by_divisor = {}\n    for group_size in groups:\n        for divisor in get_divisors(group_size):\n            if divisor in counts_by_divisor:\n                counts_by_divisor[divisor] += 1\n            else:\n                counts_by_divisor[divisor] = 1\n    k_values = [divisor for divisor in counts_by_divisor if counts_by_divisor[divisor] == len(groups)]\n    return sorted(k_values)\n\ndef get_divisors(value):\n    m = int(math.ceil(math.sqrt(value)))\n    for d in range(1, m + 1):\n        if value % d == 0:\n            e = value // d\n            if d < e:\n                yield d\n                yield e\n            elif d == e:\n                yield d"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(32):",
      "mutated_line": "for i in range(31):",
      "code": "import math\n\ndef find_possible_k_values(n, a):\n    counts = {i: 0 for i in range(32)}\n    for ai in a:\n        bin_ai = '{:032b}'.format(ai)\n        for i in range(31):\n            if bin_ai[i] == '1':\n                counts[i] += 1\n    groups = [counts[i] for i in range(32) if counts[i] > 0]\n    if not groups:\n        return list(range(1, n + 1))\n    counts_by_divisor = {}\n    for group_size in groups:\n        for divisor in get_divisors(group_size):\n            if divisor in counts_by_divisor:\n                counts_by_divisor[divisor] += 1\n            else:\n                counts_by_divisor[divisor] = 1\n    k_values = [divisor for divisor in counts_by_divisor if counts_by_divisor[divisor] == len(groups)]\n    return sorted(k_values)\n\ndef get_divisors(value):\n    m = int(math.ceil(math.sqrt(value)))\n    for d in range(1, m + 1):\n        if value % d == 0:\n            e = value // d\n            if d < e:\n                yield d\n                yield e\n            elif d == e:\n                yield d"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(32):",
      "mutated_line": "for i in range(0):",
      "code": "import math\n\ndef find_possible_k_values(n, a):\n    counts = {i: 0 for i in range(32)}\n    for ai in a:\n        bin_ai = '{:032b}'.format(ai)\n        for i in range(0):\n            if bin_ai[i] == '1':\n                counts[i] += 1\n    groups = [counts[i] for i in range(32) if counts[i] > 0]\n    if not groups:\n        return list(range(1, n + 1))\n    counts_by_divisor = {}\n    for group_size in groups:\n        for divisor in get_divisors(group_size):\n            if divisor in counts_by_divisor:\n                counts_by_divisor[divisor] += 1\n            else:\n                counts_by_divisor[divisor] = 1\n    k_values = [divisor for divisor in counts_by_divisor if counts_by_divisor[divisor] == len(groups)]\n    return sorted(k_values)\n\ndef get_divisors(value):\n    m = int(math.ceil(math.sqrt(value)))\n    for d in range(1, m + 1):\n        if value % d == 0:\n            e = value // d\n            if d < e:\n                yield d\n                yield e\n            elif d == e:\n                yield d"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(32):",
      "mutated_line": "for i in range(1):",
      "code": "import math\n\ndef find_possible_k_values(n, a):\n    counts = {i: 0 for i in range(32)}\n    for ai in a:\n        bin_ai = '{:032b}'.format(ai)\n        for i in range(1):\n            if bin_ai[i] == '1':\n                counts[i] += 1\n    groups = [counts[i] for i in range(32) if counts[i] > 0]\n    if not groups:\n        return list(range(1, n + 1))\n    counts_by_divisor = {}\n    for group_size in groups:\n        for divisor in get_divisors(group_size):\n            if divisor in counts_by_divisor:\n                counts_by_divisor[divisor] += 1\n            else:\n                counts_by_divisor[divisor] = 1\n    k_values = [divisor for divisor in counts_by_divisor if counts_by_divisor[divisor] == len(groups)]\n    return sorted(k_values)\n\ndef get_divisors(value):\n    m = int(math.ceil(math.sqrt(value)))\n    for d in range(1, m + 1):\n        if value % d == 0:\n            e = value // d\n            if d < e:\n                yield d\n                yield e\n            elif d == e:\n                yield d"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(32):",
      "mutated_line": "for i in range(-32):",
      "code": "import math\n\ndef find_possible_k_values(n, a):\n    counts = {i: 0 for i in range(32)}\n    for ai in a:\n        bin_ai = '{:032b}'.format(ai)\n        for i in range(-32):\n            if bin_ai[i] == '1':\n                counts[i] += 1\n    groups = [counts[i] for i in range(32) if counts[i] > 0]\n    if not groups:\n        return list(range(1, n + 1))\n    counts_by_divisor = {}\n    for group_size in groups:\n        for divisor in get_divisors(group_size):\n            if divisor in counts_by_divisor:\n                counts_by_divisor[divisor] += 1\n            else:\n                counts_by_divisor[divisor] = 1\n    k_values = [divisor for divisor in counts_by_divisor if counts_by_divisor[divisor] == len(groups)]\n    return sorted(k_values)\n\ndef get_divisors(value):\n    m = int(math.ceil(math.sqrt(value)))\n    for d in range(1, m + 1):\n        if value % d == 0:\n            e = value // d\n            if d < e:\n                yield d\n                yield e\n            elif d == e:\n                yield d"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if bin_ai[i] == '1':",
      "mutated_line": "if bin_ai[i] != '1':",
      "code": "import math\n\ndef find_possible_k_values(n, a):\n    counts = {i: 0 for i in range(32)}\n    for ai in a:\n        bin_ai = '{:032b}'.format(ai)\n        for i in range(32):\n            if bin_ai[i] != '1':\n                counts[i] += 1\n    groups = [counts[i] for i in range(32) if counts[i] > 0]\n    if not groups:\n        return list(range(1, n + 1))\n    counts_by_divisor = {}\n    for group_size in groups:\n        for divisor in get_divisors(group_size):\n            if divisor in counts_by_divisor:\n                counts_by_divisor[divisor] += 1\n            else:\n                counts_by_divisor[divisor] = 1\n    k_values = [divisor for divisor in counts_by_divisor if counts_by_divisor[divisor] == len(groups)]\n    return sorted(k_values)\n\ndef get_divisors(value):\n    m = int(math.ceil(math.sqrt(value)))\n    for d in range(1, m + 1):\n        if value % d == 0:\n            e = value // d\n            if d < e:\n                yield d\n                yield e\n            elif d == e:\n                yield d"
    },
    {
      "operator": "ASR",
      "lineno": 9,
      "original_line": "counts[i] += 1",
      "mutated_line": "counts[i] -= 1",
      "code": "import math\n\ndef find_possible_k_values(n, a):\n    counts = {i: 0 for i in range(32)}\n    for ai in a:\n        bin_ai = '{:032b}'.format(ai)\n        for i in range(32):\n            if bin_ai[i] == '1':\n                counts[i] -= 1\n    groups = [counts[i] for i in range(32) if counts[i] > 0]\n    if not groups:\n        return list(range(1, n + 1))\n    counts_by_divisor = {}\n    for group_size in groups:\n        for divisor in get_divisors(group_size):\n            if divisor in counts_by_divisor:\n                counts_by_divisor[divisor] += 1\n            else:\n                counts_by_divisor[divisor] = 1\n    k_values = [divisor for divisor in counts_by_divisor if counts_by_divisor[divisor] == len(groups)]\n    return sorted(k_values)\n\ndef get_divisors(value):\n    m = int(math.ceil(math.sqrt(value)))\n    for d in range(1, m + 1):\n        if value % d == 0:\n            e = value // d\n            if d < e:\n                yield d\n                yield e\n            elif d == e:\n                yield d"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "groups = [counts[i] for i in range(32) if counts[i] > 0]",
      "mutated_line": "groups = [counts[i] for i in range(32) if counts[i] >= 0]",
      "code": "import math\n\ndef find_possible_k_values(n, a):\n    counts = {i: 0 for i in range(32)}\n    for ai in a:\n        bin_ai = '{:032b}'.format(ai)\n        for i in range(32):\n            if bin_ai[i] == '1':\n                counts[i] += 1\n    groups = [counts[i] for i in range(32) if counts[i] >= 0]\n    if not groups:\n        return list(range(1, n + 1))\n    counts_by_divisor = {}\n    for group_size in groups:\n        for divisor in get_divisors(group_size):\n            if divisor in counts_by_divisor:\n                counts_by_divisor[divisor] += 1\n            else:\n                counts_by_divisor[divisor] = 1\n    k_values = [divisor for divisor in counts_by_divisor if counts_by_divisor[divisor] == len(groups)]\n    return sorted(k_values)\n\ndef get_divisors(value):\n    m = int(math.ceil(math.sqrt(value)))\n    for d in range(1, m + 1):\n        if value % d == 0:\n            e = value // d\n            if d < e:\n                yield d\n                yield e\n            elif d == e:\n                yield d"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "groups = [counts[i] for i in range(32) if counts[i] > 0]",
      "mutated_line": "groups = [counts[i] for i in range(32) if counts[i] <= 0]",
      "code": "import math\n\ndef find_possible_k_values(n, a):\n    counts = {i: 0 for i in range(32)}\n    for ai in a:\n        bin_ai = '{:032b}'.format(ai)\n        for i in range(32):\n            if bin_ai[i] == '1':\n                counts[i] += 1\n    groups = [counts[i] for i in range(32) if counts[i] <= 0]\n    if not groups:\n        return list(range(1, n + 1))\n    counts_by_divisor = {}\n    for group_size in groups:\n        for divisor in get_divisors(group_size):\n            if divisor in counts_by_divisor:\n                counts_by_divisor[divisor] += 1\n            else:\n                counts_by_divisor[divisor] = 1\n    k_values = [divisor for divisor in counts_by_divisor if counts_by_divisor[divisor] == len(groups)]\n    return sorted(k_values)\n\ndef get_divisors(value):\n    m = int(math.ceil(math.sqrt(value)))\n    for d in range(1, m + 1):\n        if value % d == 0:\n            e = value // d\n            if d < e:\n                yield d\n                yield e\n            elif d == e:\n                yield d"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "groups = [counts[i] for i in range(32) if counts[i] > 0]",
      "mutated_line": "groups = [counts[i] for i in range(32) if counts[i] != 0]",
      "code": "import math\n\ndef find_possible_k_values(n, a):\n    counts = {i: 0 for i in range(32)}\n    for ai in a:\n        bin_ai = '{:032b}'.format(ai)\n        for i in range(32):\n            if bin_ai[i] == '1':\n                counts[i] += 1\n    groups = [counts[i] for i in range(32) if counts[i] != 0]\n    if not groups:\n        return list(range(1, n + 1))\n    counts_by_divisor = {}\n    for group_size in groups:\n        for divisor in get_divisors(group_size):\n            if divisor in counts_by_divisor:\n                counts_by_divisor[divisor] += 1\n            else:\n                counts_by_divisor[divisor] = 1\n    k_values = [divisor for divisor in counts_by_divisor if counts_by_divisor[divisor] == len(groups)]\n    return sorted(k_values)\n\ndef get_divisors(value):\n    m = int(math.ceil(math.sqrt(value)))\n    for d in range(1, m + 1):\n        if value % d == 0:\n            e = value // d\n            if d < e:\n                yield d\n                yield e\n            elif d == e:\n                yield d"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if divisor in counts_by_divisor:",
      "mutated_line": "if divisor not in counts_by_divisor:",
      "code": "import math\n\ndef find_possible_k_values(n, a):\n    counts = {i: 0 for i in range(32)}\n    for ai in a:\n        bin_ai = '{:032b}'.format(ai)\n        for i in range(32):\n            if bin_ai[i] == '1':\n                counts[i] += 1\n    groups = [counts[i] for i in range(32) if counts[i] > 0]\n    if not groups:\n        return list(range(1, n + 1))\n    counts_by_divisor = {}\n    for group_size in groups:\n        for divisor in get_divisors(group_size):\n            if divisor not in counts_by_divisor:\n                counts_by_divisor[divisor] += 1\n            else:\n                counts_by_divisor[divisor] = 1\n    k_values = [divisor for divisor in counts_by_divisor if counts_by_divisor[divisor] == len(groups)]\n    return sorted(k_values)\n\ndef get_divisors(value):\n    m = int(math.ceil(math.sqrt(value)))\n    for d in range(1, m + 1):\n        if value % d == 0:\n            e = value // d\n            if d < e:\n                yield d\n                yield e\n            elif d == e:\n                yield d"
    },
    {
      "operator": "ASR",
      "lineno": 20,
      "original_line": "counts_by_divisor[divisor] += 1",
      "mutated_line": "counts_by_divisor[divisor] -= 1",
      "code": "import math\n\ndef find_possible_k_values(n, a):\n    counts = {i: 0 for i in range(32)}\n    for ai in a:\n        bin_ai = '{:032b}'.format(ai)\n        for i in range(32):\n            if bin_ai[i] == '1':\n                counts[i] += 1\n    groups = [counts[i] for i in range(32) if counts[i] > 0]\n    if not groups:\n        return list(range(1, n + 1))\n    counts_by_divisor = {}\n    for group_size in groups:\n        for divisor in get_divisors(group_size):\n            if divisor in counts_by_divisor:\n                counts_by_divisor[divisor] -= 1\n            else:\n                counts_by_divisor[divisor] = 1\n    k_values = [divisor for divisor in counts_by_divisor if counts_by_divisor[divisor] == len(groups)]\n    return sorted(k_values)\n\ndef get_divisors(value):\n    m = int(math.ceil(math.sqrt(value)))\n    for d in range(1, m + 1):\n        if value % d == 0:\n            e = value // d\n            if d < e:\n                yield d\n                yield e\n            elif d == e:\n                yield d"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "k_values = [divisor for divisor in counts_by_divisor if counts_by_divisor[divisor] == len(groups)]",
      "mutated_line": "k_values = [divisor for divisor in counts_by_divisor if counts_by_divisor[divisor] != len(groups)]",
      "code": "import math\n\ndef find_possible_k_values(n, a):\n    counts = {i: 0 for i in range(32)}\n    for ai in a:\n        bin_ai = '{:032b}'.format(ai)\n        for i in range(32):\n            if bin_ai[i] == '1':\n                counts[i] += 1\n    groups = [counts[i] for i in range(32) if counts[i] > 0]\n    if not groups:\n        return list(range(1, n + 1))\n    counts_by_divisor = {}\n    for group_size in groups:\n        for divisor in get_divisors(group_size):\n            if divisor in counts_by_divisor:\n                counts_by_divisor[divisor] += 1\n            else:\n                counts_by_divisor[divisor] = 1\n    k_values = [divisor for divisor in counts_by_divisor if counts_by_divisor[divisor] != len(groups)]\n    return sorted(k_values)\n\ndef get_divisors(value):\n    m = int(math.ceil(math.sqrt(value)))\n    for d in range(1, m + 1):\n        if value % d == 0:\n            e = value // d\n            if d < e:\n                yield d\n                yield e\n            elif d == e:\n                yield d"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for d in range(1, m + 1):",
      "mutated_line": "for d in range(1, m + 2):",
      "code": "import math\n\ndef find_possible_k_values(n, a):\n    counts = {i: 0 for i in range(32)}\n    for ai in a:\n        bin_ai = '{:032b}'.format(ai)\n        for i in range(32):\n            if bin_ai[i] == '1':\n                counts[i] += 1\n    groups = [counts[i] for i in range(32) if counts[i] > 0]\n    if not groups:\n        return list(range(1, n + 1))\n    counts_by_divisor = {}\n    for group_size in groups:\n        for divisor in get_divisors(group_size):\n            if divisor in counts_by_divisor:\n                counts_by_divisor[divisor] += 1\n            else:\n                counts_by_divisor[divisor] = 1\n    k_values = [divisor for divisor in counts_by_divisor if counts_by_divisor[divisor] == len(groups)]\n    return sorted(k_values)\n\ndef get_divisors(value):\n    m = int(math.ceil(math.sqrt(value)))\n    for d in range(1, m + 2):\n        if value % d == 0:\n            e = value // d\n            if d < e:\n                yield d\n                yield e\n            elif d == e:\n                yield d"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for d in range(1, m + 1):",
      "mutated_line": "for d in range(1, m + 0):",
      "code": "import math\n\ndef find_possible_k_values(n, a):\n    counts = {i: 0 for i in range(32)}\n    for ai in a:\n        bin_ai = '{:032b}'.format(ai)\n        for i in range(32):\n            if bin_ai[i] == '1':\n                counts[i] += 1\n    groups = [counts[i] for i in range(32) if counts[i] > 0]\n    if not groups:\n        return list(range(1, n + 1))\n    counts_by_divisor = {}\n    for group_size in groups:\n        for divisor in get_divisors(group_size):\n            if divisor in counts_by_divisor:\n                counts_by_divisor[divisor] += 1\n            else:\n                counts_by_divisor[divisor] = 1\n    k_values = [divisor for divisor in counts_by_divisor if counts_by_divisor[divisor] == len(groups)]\n    return sorted(k_values)\n\ndef get_divisors(value):\n    m = int(math.ceil(math.sqrt(value)))\n    for d in range(1, m + 0):\n        if value % d == 0:\n            e = value // d\n            if d < e:\n                yield d\n                yield e\n            elif d == e:\n                yield d"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for d in range(1, m + 1):",
      "mutated_line": "for d in range(1, m + 0):",
      "code": "import math\n\ndef find_possible_k_values(n, a):\n    counts = {i: 0 for i in range(32)}\n    for ai in a:\n        bin_ai = '{:032b}'.format(ai)\n        for i in range(32):\n            if bin_ai[i] == '1':\n                counts[i] += 1\n    groups = [counts[i] for i in range(32) if counts[i] > 0]\n    if not groups:\n        return list(range(1, n + 1))\n    counts_by_divisor = {}\n    for group_size in groups:\n        for divisor in get_divisors(group_size):\n            if divisor in counts_by_divisor:\n                counts_by_divisor[divisor] += 1\n            else:\n                counts_by_divisor[divisor] = 1\n    k_values = [divisor for divisor in counts_by_divisor if counts_by_divisor[divisor] == len(groups)]\n    return sorted(k_values)\n\ndef get_divisors(value):\n    m = int(math.ceil(math.sqrt(value)))\n    for d in range(1, m + 0):\n        if value % d == 0:\n            e = value // d\n            if d < e:\n                yield d\n                yield e\n            elif d == e:\n                yield d"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for d in range(1, m + 1):",
      "mutated_line": "for d in range(1, m + -1):",
      "code": "import math\n\ndef find_possible_k_values(n, a):\n    counts = {i: 0 for i in range(32)}\n    for ai in a:\n        bin_ai = '{:032b}'.format(ai)\n        for i in range(32):\n            if bin_ai[i] == '1':\n                counts[i] += 1\n    groups = [counts[i] for i in range(32) if counts[i] > 0]\n    if not groups:\n        return list(range(1, n + 1))\n    counts_by_divisor = {}\n    for group_size in groups:\n        for divisor in get_divisors(group_size):\n            if divisor in counts_by_divisor:\n                counts_by_divisor[divisor] += 1\n            else:\n                counts_by_divisor[divisor] = 1\n    k_values = [divisor for divisor in counts_by_divisor if counts_by_divisor[divisor] == len(groups)]\n    return sorted(k_values)\n\ndef get_divisors(value):\n    m = int(math.ceil(math.sqrt(value)))\n    for d in range(1, m + -1):\n        if value % d == 0:\n            e = value // d\n            if d < e:\n                yield d\n                yield e\n            elif d == e:\n                yield d"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "if value % d == 0:",
      "mutated_line": "if value * d == 0:",
      "code": "import math\n\ndef find_possible_k_values(n, a):\n    counts = {i: 0 for i in range(32)}\n    for ai in a:\n        bin_ai = '{:032b}'.format(ai)\n        for i in range(32):\n            if bin_ai[i] == '1':\n                counts[i] += 1\n    groups = [counts[i] for i in range(32) if counts[i] > 0]\n    if not groups:\n        return list(range(1, n + 1))\n    counts_by_divisor = {}\n    for group_size in groups:\n        for divisor in get_divisors(group_size):\n            if divisor in counts_by_divisor:\n                counts_by_divisor[divisor] += 1\n            else:\n                counts_by_divisor[divisor] = 1\n    k_values = [divisor for divisor in counts_by_divisor if counts_by_divisor[divisor] == len(groups)]\n    return sorted(k_values)\n\ndef get_divisors(value):\n    m = int(math.ceil(math.sqrt(value)))\n    for d in range(1, m + 1):\n        if value * d == 0:\n            e = value // d\n            if d < e:\n                yield d\n                yield e\n            elif d == e:\n                yield d"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "if value % d == 0:",
      "mutated_line": "if value + d == 0:",
      "code": "import math\n\ndef find_possible_k_values(n, a):\n    counts = {i: 0 for i in range(32)}\n    for ai in a:\n        bin_ai = '{:032b}'.format(ai)\n        for i in range(32):\n            if bin_ai[i] == '1':\n                counts[i] += 1\n    groups = [counts[i] for i in range(32) if counts[i] > 0]\n    if not groups:\n        return list(range(1, n + 1))\n    counts_by_divisor = {}\n    for group_size in groups:\n        for divisor in get_divisors(group_size):\n            if divisor in counts_by_divisor:\n                counts_by_divisor[divisor] += 1\n            else:\n                counts_by_divisor[divisor] = 1\n    k_values = [divisor for divisor in counts_by_divisor if counts_by_divisor[divisor] == len(groups)]\n    return sorted(k_values)\n\ndef get_divisors(value):\n    m = int(math.ceil(math.sqrt(value)))\n    for d in range(1, m + 1):\n        if value + d == 0:\n            e = value // d\n            if d < e:\n                yield d\n                yield e\n            elif d == e:\n                yield d"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if value % d == 0:",
      "mutated_line": "if value % d == 1:",
      "code": "import math\n\ndef find_possible_k_values(n, a):\n    counts = {i: 0 for i in range(32)}\n    for ai in a:\n        bin_ai = '{:032b}'.format(ai)\n        for i in range(32):\n            if bin_ai[i] == '1':\n                counts[i] += 1\n    groups = [counts[i] for i in range(32) if counts[i] > 0]\n    if not groups:\n        return list(range(1, n + 1))\n    counts_by_divisor = {}\n    for group_size in groups:\n        for divisor in get_divisors(group_size):\n            if divisor in counts_by_divisor:\n                counts_by_divisor[divisor] += 1\n            else:\n                counts_by_divisor[divisor] = 1\n    k_values = [divisor for divisor in counts_by_divisor if counts_by_divisor[divisor] == len(groups)]\n    return sorted(k_values)\n\ndef get_divisors(value):\n    m = int(math.ceil(math.sqrt(value)))\n    for d in range(1, m + 1):\n        if value % d == 1:\n            e = value // d\n            if d < e:\n                yield d\n                yield e\n            elif d == e:\n                yield d"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if value % d == 0:",
      "mutated_line": "if value % d == -1:",
      "code": "import math\n\ndef find_possible_k_values(n, a):\n    counts = {i: 0 for i in range(32)}\n    for ai in a:\n        bin_ai = '{:032b}'.format(ai)\n        for i in range(32):\n            if bin_ai[i] == '1':\n                counts[i] += 1\n    groups = [counts[i] for i in range(32) if counts[i] > 0]\n    if not groups:\n        return list(range(1, n + 1))\n    counts_by_divisor = {}\n    for group_size in groups:\n        for divisor in get_divisors(group_size):\n            if divisor in counts_by_divisor:\n                counts_by_divisor[divisor] += 1\n            else:\n                counts_by_divisor[divisor] = 1\n    k_values = [divisor for divisor in counts_by_divisor if counts_by_divisor[divisor] == len(groups)]\n    return sorted(k_values)\n\ndef get_divisors(value):\n    m = int(math.ceil(math.sqrt(value)))\n    for d in range(1, m + 1):\n        if value % d == -1:\n            e = value // d\n            if d < e:\n                yield d\n                yield e\n            elif d == e:\n                yield d"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if value % d == 0:",
      "mutated_line": "if value % d == 1:",
      "code": "import math\n\ndef find_possible_k_values(n, a):\n    counts = {i: 0 for i in range(32)}\n    for ai in a:\n        bin_ai = '{:032b}'.format(ai)\n        for i in range(32):\n            if bin_ai[i] == '1':\n                counts[i] += 1\n    groups = [counts[i] for i in range(32) if counts[i] > 0]\n    if not groups:\n        return list(range(1, n + 1))\n    counts_by_divisor = {}\n    for group_size in groups:\n        for divisor in get_divisors(group_size):\n            if divisor in counts_by_divisor:\n                counts_by_divisor[divisor] += 1\n            else:\n                counts_by_divisor[divisor] = 1\n    k_values = [divisor for divisor in counts_by_divisor if counts_by_divisor[divisor] == len(groups)]\n    return sorted(k_values)\n\ndef get_divisors(value):\n    m = int(math.ceil(math.sqrt(value)))\n    for d in range(1, m + 1):\n        if value % d == 1:\n            e = value // d\n            if d < e:\n                yield d\n                yield e\n            elif d == e:\n                yield d"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "e = value // d",
      "mutated_line": "e = value / d",
      "code": "import math\n\ndef find_possible_k_values(n, a):\n    counts = {i: 0 for i in range(32)}\n    for ai in a:\n        bin_ai = '{:032b}'.format(ai)\n        for i in range(32):\n            if bin_ai[i] == '1':\n                counts[i] += 1\n    groups = [counts[i] for i in range(32) if counts[i] > 0]\n    if not groups:\n        return list(range(1, n + 1))\n    counts_by_divisor = {}\n    for group_size in groups:\n        for divisor in get_divisors(group_size):\n            if divisor in counts_by_divisor:\n                counts_by_divisor[divisor] += 1\n            else:\n                counts_by_divisor[divisor] = 1\n    k_values = [divisor for divisor in counts_by_divisor if counts_by_divisor[divisor] == len(groups)]\n    return sorted(k_values)\n\ndef get_divisors(value):\n    m = int(math.ceil(math.sqrt(value)))\n    for d in range(1, m + 1):\n        if value % d == 0:\n            e = value / d\n            if d < e:\n                yield d\n                yield e\n            elif d == e:\n                yield d"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "e = value // d",
      "mutated_line": "e = value * d",
      "code": "import math\n\ndef find_possible_k_values(n, a):\n    counts = {i: 0 for i in range(32)}\n    for ai in a:\n        bin_ai = '{:032b}'.format(ai)\n        for i in range(32):\n            if bin_ai[i] == '1':\n                counts[i] += 1\n    groups = [counts[i] for i in range(32) if counts[i] > 0]\n    if not groups:\n        return list(range(1, n + 1))\n    counts_by_divisor = {}\n    for group_size in groups:\n        for divisor in get_divisors(group_size):\n            if divisor in counts_by_divisor:\n                counts_by_divisor[divisor] += 1\n            else:\n                counts_by_divisor[divisor] = 1\n    k_values = [divisor for divisor in counts_by_divisor if counts_by_divisor[divisor] == len(groups)]\n    return sorted(k_values)\n\ndef get_divisors(value):\n    m = int(math.ceil(math.sqrt(value)))\n    for d in range(1, m + 1):\n        if value % d == 0:\n            e = value * d\n            if d < e:\n                yield d\n                yield e\n            elif d == e:\n                yield d"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if d < e:",
      "mutated_line": "if d <= e:",
      "code": "import math\n\ndef find_possible_k_values(n, a):\n    counts = {i: 0 for i in range(32)}\n    for ai in a:\n        bin_ai = '{:032b}'.format(ai)\n        for i in range(32):\n            if bin_ai[i] == '1':\n                counts[i] += 1\n    groups = [counts[i] for i in range(32) if counts[i] > 0]\n    if not groups:\n        return list(range(1, n + 1))\n    counts_by_divisor = {}\n    for group_size in groups:\n        for divisor in get_divisors(group_size):\n            if divisor in counts_by_divisor:\n                counts_by_divisor[divisor] += 1\n            else:\n                counts_by_divisor[divisor] = 1\n    k_values = [divisor for divisor in counts_by_divisor if counts_by_divisor[divisor] == len(groups)]\n    return sorted(k_values)\n\ndef get_divisors(value):\n    m = int(math.ceil(math.sqrt(value)))\n    for d in range(1, m + 1):\n        if value % d == 0:\n            e = value // d\n            if d <= e:\n                yield d\n                yield e\n            elif d == e:\n                yield d"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if d < e:",
      "mutated_line": "if d >= e:",
      "code": "import math\n\ndef find_possible_k_values(n, a):\n    counts = {i: 0 for i in range(32)}\n    for ai in a:\n        bin_ai = '{:032b}'.format(ai)\n        for i in range(32):\n            if bin_ai[i] == '1':\n                counts[i] += 1\n    groups = [counts[i] for i in range(32) if counts[i] > 0]\n    if not groups:\n        return list(range(1, n + 1))\n    counts_by_divisor = {}\n    for group_size in groups:\n        for divisor in get_divisors(group_size):\n            if divisor in counts_by_divisor:\n                counts_by_divisor[divisor] += 1\n            else:\n                counts_by_divisor[divisor] = 1\n    k_values = [divisor for divisor in counts_by_divisor if counts_by_divisor[divisor] == len(groups)]\n    return sorted(k_values)\n\ndef get_divisors(value):\n    m = int(math.ceil(math.sqrt(value)))\n    for d in range(1, m + 1):\n        if value % d == 0:\n            e = value // d\n            if d >= e:\n                yield d\n                yield e\n            elif d == e:\n                yield d"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if d < e:",
      "mutated_line": "if d != e:",
      "code": "import math\n\ndef find_possible_k_values(n, a):\n    counts = {i: 0 for i in range(32)}\n    for ai in a:\n        bin_ai = '{:032b}'.format(ai)\n        for i in range(32):\n            if bin_ai[i] == '1':\n                counts[i] += 1\n    groups = [counts[i] for i in range(32) if counts[i] > 0]\n    if not groups:\n        return list(range(1, n + 1))\n    counts_by_divisor = {}\n    for group_size in groups:\n        for divisor in get_divisors(group_size):\n            if divisor in counts_by_divisor:\n                counts_by_divisor[divisor] += 1\n            else:\n                counts_by_divisor[divisor] = 1\n    k_values = [divisor for divisor in counts_by_divisor if counts_by_divisor[divisor] == len(groups)]\n    return sorted(k_values)\n\ndef get_divisors(value):\n    m = int(math.ceil(math.sqrt(value)))\n    for d in range(1, m + 1):\n        if value % d == 0:\n            e = value // d\n            if d != e:\n                yield d\n                yield e\n            elif d == e:\n                yield d"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "counts = {i: 0 for i in range(32)}",
      "mutated_line": "counts = {i: 0 for i in range(33)}",
      "code": "import math\n\ndef find_possible_k_values(n, a):\n    counts = {i: 0 for i in range(33)}\n    for ai in a:\n        bin_ai = '{:032b}'.format(ai)\n        for i in range(32):\n            if bin_ai[i] == '1':\n                counts[i] += 1\n    groups = [counts[i] for i in range(32) if counts[i] > 0]\n    if not groups:\n        return list(range(1, n + 1))\n    counts_by_divisor = {}\n    for group_size in groups:\n        for divisor in get_divisors(group_size):\n            if divisor in counts_by_divisor:\n                counts_by_divisor[divisor] += 1\n            else:\n                counts_by_divisor[divisor] = 1\n    k_values = [divisor for divisor in counts_by_divisor if counts_by_divisor[divisor] == len(groups)]\n    return sorted(k_values)\n\ndef get_divisors(value):\n    m = int(math.ceil(math.sqrt(value)))\n    for d in range(1, m + 1):\n        if value % d == 0:\n            e = value // d\n            if d < e:\n                yield d\n                yield e\n            elif d == e:\n                yield d"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "counts = {i: 0 for i in range(32)}",
      "mutated_line": "counts = {i: 0 for i in range(31)}",
      "code": "import math\n\ndef find_possible_k_values(n, a):\n    counts = {i: 0 for i in range(31)}\n    for ai in a:\n        bin_ai = '{:032b}'.format(ai)\n        for i in range(32):\n            if bin_ai[i] == '1':\n                counts[i] += 1\n    groups = [counts[i] for i in range(32) if counts[i] > 0]\n    if not groups:\n        return list(range(1, n + 1))\n    counts_by_divisor = {}\n    for group_size in groups:\n        for divisor in get_divisors(group_size):\n            if divisor in counts_by_divisor:\n                counts_by_divisor[divisor] += 1\n            else:\n                counts_by_divisor[divisor] = 1\n    k_values = [divisor for divisor in counts_by_divisor if counts_by_divisor[divisor] == len(groups)]\n    return sorted(k_values)\n\ndef get_divisors(value):\n    m = int(math.ceil(math.sqrt(value)))\n    for d in range(1, m + 1):\n        if value % d == 0:\n            e = value // d\n            if d < e:\n                yield d\n                yield e\n            elif d == e:\n                yield d"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "counts = {i: 0 for i in range(32)}",
      "mutated_line": "counts = {i: 0 for i in range(0)}",
      "code": "import math\n\ndef find_possible_k_values(n, a):\n    counts = {i: 0 for i in range(0)}\n    for ai in a:\n        bin_ai = '{:032b}'.format(ai)\n        for i in range(32):\n            if bin_ai[i] == '1':\n                counts[i] += 1\n    groups = [counts[i] for i in range(32) if counts[i] > 0]\n    if not groups:\n        return list(range(1, n + 1))\n    counts_by_divisor = {}\n    for group_size in groups:\n        for divisor in get_divisors(group_size):\n            if divisor in counts_by_divisor:\n                counts_by_divisor[divisor] += 1\n            else:\n                counts_by_divisor[divisor] = 1\n    k_values = [divisor for divisor in counts_by_divisor if counts_by_divisor[divisor] == len(groups)]\n    return sorted(k_values)\n\ndef get_divisors(value):\n    m = int(math.ceil(math.sqrt(value)))\n    for d in range(1, m + 1):\n        if value % d == 0:\n            e = value // d\n            if d < e:\n                yield d\n                yield e\n            elif d == e:\n                yield d"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "counts = {i: 0 for i in range(32)}",
      "mutated_line": "counts = {i: 0 for i in range(1)}",
      "code": "import math\n\ndef find_possible_k_values(n, a):\n    counts = {i: 0 for i in range(1)}\n    for ai in a:\n        bin_ai = '{:032b}'.format(ai)\n        for i in range(32):\n            if bin_ai[i] == '1':\n                counts[i] += 1\n    groups = [counts[i] for i in range(32) if counts[i] > 0]\n    if not groups:\n        return list(range(1, n + 1))\n    counts_by_divisor = {}\n    for group_size in groups:\n        for divisor in get_divisors(group_size):\n            if divisor in counts_by_divisor:\n                counts_by_divisor[divisor] += 1\n            else:\n                counts_by_divisor[divisor] = 1\n    k_values = [divisor for divisor in counts_by_divisor if counts_by_divisor[divisor] == len(groups)]\n    return sorted(k_values)\n\ndef get_divisors(value):\n    m = int(math.ceil(math.sqrt(value)))\n    for d in range(1, m + 1):\n        if value % d == 0:\n            e = value // d\n            if d < e:\n                yield d\n                yield e\n            elif d == e:\n                yield d"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "counts = {i: 0 for i in range(32)}",
      "mutated_line": "counts = {i: 0 for i in range(-32)}",
      "code": "import math\n\ndef find_possible_k_values(n, a):\n    counts = {i: 0 for i in range(-32)}\n    for ai in a:\n        bin_ai = '{:032b}'.format(ai)\n        for i in range(32):\n            if bin_ai[i] == '1':\n                counts[i] += 1\n    groups = [counts[i] for i in range(32) if counts[i] > 0]\n    if not groups:\n        return list(range(1, n + 1))\n    counts_by_divisor = {}\n    for group_size in groups:\n        for divisor in get_divisors(group_size):\n            if divisor in counts_by_divisor:\n                counts_by_divisor[divisor] += 1\n            else:\n                counts_by_divisor[divisor] = 1\n    k_values = [divisor for divisor in counts_by_divisor if counts_by_divisor[divisor] == len(groups)]\n    return sorted(k_values)\n\ndef get_divisors(value):\n    m = int(math.ceil(math.sqrt(value)))\n    for d in range(1, m + 1):\n        if value % d == 0:\n            e = value // d\n            if d < e:\n                yield d\n                yield e\n            elif d == e:\n                yield d"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "bin_ai = '{:032b}'.format(ai)",
      "mutated_line": "bin_ai = ''.format(ai)",
      "code": "import math\n\ndef find_possible_k_values(n, a):\n    counts = {i: 0 for i in range(32)}\n    for ai in a:\n        bin_ai = ''.format(ai)\n        for i in range(32):\n            if bin_ai[i] == '1':\n                counts[i] += 1\n    groups = [counts[i] for i in range(32) if counts[i] > 0]\n    if not groups:\n        return list(range(1, n + 1))\n    counts_by_divisor = {}\n    for group_size in groups:\n        for divisor in get_divisors(group_size):\n            if divisor in counts_by_divisor:\n                counts_by_divisor[divisor] += 1\n            else:\n                counts_by_divisor[divisor] = 1\n    k_values = [divisor for divisor in counts_by_divisor if counts_by_divisor[divisor] == len(groups)]\n    return sorted(k_values)\n\ndef get_divisors(value):\n    m = int(math.ceil(math.sqrt(value)))\n    for d in range(1, m + 1):\n        if value % d == 0:\n            e = value // d\n            if d < e:\n                yield d\n                yield e\n            elif d == e:\n                yield d"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if bin_ai[i] == '1':",
      "mutated_line": "if bin_ai[i] == '':",
      "code": "import math\n\ndef find_possible_k_values(n, a):\n    counts = {i: 0 for i in range(32)}\n    for ai in a:\n        bin_ai = '{:032b}'.format(ai)\n        for i in range(32):\n            if bin_ai[i] == '':\n                counts[i] += 1\n    groups = [counts[i] for i in range(32) if counts[i] > 0]\n    if not groups:\n        return list(range(1, n + 1))\n    counts_by_divisor = {}\n    for group_size in groups:\n        for divisor in get_divisors(group_size):\n            if divisor in counts_by_divisor:\n                counts_by_divisor[divisor] += 1\n            else:\n                counts_by_divisor[divisor] = 1\n    k_values = [divisor for divisor in counts_by_divisor if counts_by_divisor[divisor] == len(groups)]\n    return sorted(k_values)\n\ndef get_divisors(value):\n    m = int(math.ceil(math.sqrt(value)))\n    for d in range(1, m + 1):\n        if value % d == 0:\n            e = value // d\n            if d < e:\n                yield d\n                yield e\n            elif d == e:\n                yield d"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "counts[i] += 1",
      "mutated_line": "counts[i] += 2",
      "code": "import math\n\ndef find_possible_k_values(n, a):\n    counts = {i: 0 for i in range(32)}\n    for ai in a:\n        bin_ai = '{:032b}'.format(ai)\n        for i in range(32):\n            if bin_ai[i] == '1':\n                counts[i] += 2\n    groups = [counts[i] for i in range(32) if counts[i] > 0]\n    if not groups:\n        return list(range(1, n + 1))\n    counts_by_divisor = {}\n    for group_size in groups:\n        for divisor in get_divisors(group_size):\n            if divisor in counts_by_divisor:\n                counts_by_divisor[divisor] += 1\n            else:\n                counts_by_divisor[divisor] = 1\n    k_values = [divisor for divisor in counts_by_divisor if counts_by_divisor[divisor] == len(groups)]\n    return sorted(k_values)\n\ndef get_divisors(value):\n    m = int(math.ceil(math.sqrt(value)))\n    for d in range(1, m + 1):\n        if value % d == 0:\n            e = value // d\n            if d < e:\n                yield d\n                yield e\n            elif d == e:\n                yield d"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "counts[i] += 1",
      "mutated_line": "counts[i] += 0",
      "code": "import math\n\ndef find_possible_k_values(n, a):\n    counts = {i: 0 for i in range(32)}\n    for ai in a:\n        bin_ai = '{:032b}'.format(ai)\n        for i in range(32):\n            if bin_ai[i] == '1':\n                counts[i] += 0\n    groups = [counts[i] for i in range(32) if counts[i] > 0]\n    if not groups:\n        return list(range(1, n + 1))\n    counts_by_divisor = {}\n    for group_size in groups:\n        for divisor in get_divisors(group_size):\n            if divisor in counts_by_divisor:\n                counts_by_divisor[divisor] += 1\n            else:\n                counts_by_divisor[divisor] = 1\n    k_values = [divisor for divisor in counts_by_divisor if counts_by_divisor[divisor] == len(groups)]\n    return sorted(k_values)\n\ndef get_divisors(value):\n    m = int(math.ceil(math.sqrt(value)))\n    for d in range(1, m + 1):\n        if value % d == 0:\n            e = value // d\n            if d < e:\n                yield d\n                yield e\n            elif d == e:\n                yield d"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "counts[i] += 1",
      "mutated_line": "counts[i] += 0",
      "code": "import math\n\ndef find_possible_k_values(n, a):\n    counts = {i: 0 for i in range(32)}\n    for ai in a:\n        bin_ai = '{:032b}'.format(ai)\n        for i in range(32):\n            if bin_ai[i] == '1':\n                counts[i] += 0\n    groups = [counts[i] for i in range(32) if counts[i] > 0]\n    if not groups:\n        return list(range(1, n + 1))\n    counts_by_divisor = {}\n    for group_size in groups:\n        for divisor in get_divisors(group_size):\n            if divisor in counts_by_divisor:\n                counts_by_divisor[divisor] += 1\n            else:\n                counts_by_divisor[divisor] = 1\n    k_values = [divisor for divisor in counts_by_divisor if counts_by_divisor[divisor] == len(groups)]\n    return sorted(k_values)\n\ndef get_divisors(value):\n    m = int(math.ceil(math.sqrt(value)))\n    for d in range(1, m + 1):\n        if value % d == 0:\n            e = value // d\n            if d < e:\n                yield d\n                yield e\n            elif d == e:\n                yield d"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "counts[i] += 1",
      "mutated_line": "counts[i] += -1",
      "code": "import math\n\ndef find_possible_k_values(n, a):\n    counts = {i: 0 for i in range(32)}\n    for ai in a:\n        bin_ai = '{:032b}'.format(ai)\n        for i in range(32):\n            if bin_ai[i] == '1':\n                counts[i] += -1\n    groups = [counts[i] for i in range(32) if counts[i] > 0]\n    if not groups:\n        return list(range(1, n + 1))\n    counts_by_divisor = {}\n    for group_size in groups:\n        for divisor in get_divisors(group_size):\n            if divisor in counts_by_divisor:\n                counts_by_divisor[divisor] += 1\n            else:\n                counts_by_divisor[divisor] = 1\n    k_values = [divisor for divisor in counts_by_divisor if counts_by_divisor[divisor] == len(groups)]\n    return sorted(k_values)\n\ndef get_divisors(value):\n    m = int(math.ceil(math.sqrt(value)))\n    for d in range(1, m + 1):\n        if value % d == 0:\n            e = value // d\n            if d < e:\n                yield d\n                yield e\n            elif d == e:\n                yield d"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "groups = [counts[i] for i in range(32) if counts[i] > 0]",
      "mutated_line": "groups = [counts[i] for i in range(33) if counts[i] > 0]",
      "code": "import math\n\ndef find_possible_k_values(n, a):\n    counts = {i: 0 for i in range(32)}\n    for ai in a:\n        bin_ai = '{:032b}'.format(ai)\n        for i in range(32):\n            if bin_ai[i] == '1':\n                counts[i] += 1\n    groups = [counts[i] for i in range(33) if counts[i] > 0]\n    if not groups:\n        return list(range(1, n + 1))\n    counts_by_divisor = {}\n    for group_size in groups:\n        for divisor in get_divisors(group_size):\n            if divisor in counts_by_divisor:\n                counts_by_divisor[divisor] += 1\n            else:\n                counts_by_divisor[divisor] = 1\n    k_values = [divisor for divisor in counts_by_divisor if counts_by_divisor[divisor] == len(groups)]\n    return sorted(k_values)\n\ndef get_divisors(value):\n    m = int(math.ceil(math.sqrt(value)))\n    for d in range(1, m + 1):\n        if value % d == 0:\n            e = value // d\n            if d < e:\n                yield d\n                yield e\n            elif d == e:\n                yield d"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "groups = [counts[i] for i in range(32) if counts[i] > 0]",
      "mutated_line": "groups = [counts[i] for i in range(31) if counts[i] > 0]",
      "code": "import math\n\ndef find_possible_k_values(n, a):\n    counts = {i: 0 for i in range(32)}\n    for ai in a:\n        bin_ai = '{:032b}'.format(ai)\n        for i in range(32):\n            if bin_ai[i] == '1':\n                counts[i] += 1\n    groups = [counts[i] for i in range(31) if counts[i] > 0]\n    if not groups:\n        return list(range(1, n + 1))\n    counts_by_divisor = {}\n    for group_size in groups:\n        for divisor in get_divisors(group_size):\n            if divisor in counts_by_divisor:\n                counts_by_divisor[divisor] += 1\n            else:\n                counts_by_divisor[divisor] = 1\n    k_values = [divisor for divisor in counts_by_divisor if counts_by_divisor[divisor] == len(groups)]\n    return sorted(k_values)\n\ndef get_divisors(value):\n    m = int(math.ceil(math.sqrt(value)))\n    for d in range(1, m + 1):\n        if value % d == 0:\n            e = value // d\n            if d < e:\n                yield d\n                yield e\n            elif d == e:\n                yield d"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "groups = [counts[i] for i in range(32) if counts[i] > 0]",
      "mutated_line": "groups = [counts[i] for i in range(0) if counts[i] > 0]",
      "code": "import math\n\ndef find_possible_k_values(n, a):\n    counts = {i: 0 for i in range(32)}\n    for ai in a:\n        bin_ai = '{:032b}'.format(ai)\n        for i in range(32):\n            if bin_ai[i] == '1':\n                counts[i] += 1\n    groups = [counts[i] for i in range(0) if counts[i] > 0]\n    if not groups:\n        return list(range(1, n + 1))\n    counts_by_divisor = {}\n    for group_size in groups:\n        for divisor in get_divisors(group_size):\n            if divisor in counts_by_divisor:\n                counts_by_divisor[divisor] += 1\n            else:\n                counts_by_divisor[divisor] = 1\n    k_values = [divisor for divisor in counts_by_divisor if counts_by_divisor[divisor] == len(groups)]\n    return sorted(k_values)\n\ndef get_divisors(value):\n    m = int(math.ceil(math.sqrt(value)))\n    for d in range(1, m + 1):\n        if value % d == 0:\n            e = value // d\n            if d < e:\n                yield d\n                yield e\n            elif d == e:\n                yield d"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "groups = [counts[i] for i in range(32) if counts[i] > 0]",
      "mutated_line": "groups = [counts[i] for i in range(1) if counts[i] > 0]",
      "code": "import math\n\ndef find_possible_k_values(n, a):\n    counts = {i: 0 for i in range(32)}\n    for ai in a:\n        bin_ai = '{:032b}'.format(ai)\n        for i in range(32):\n            if bin_ai[i] == '1':\n                counts[i] += 1\n    groups = [counts[i] for i in range(1) if counts[i] > 0]\n    if not groups:\n        return list(range(1, n + 1))\n    counts_by_divisor = {}\n    for group_size in groups:\n        for divisor in get_divisors(group_size):\n            if divisor in counts_by_divisor:\n                counts_by_divisor[divisor] += 1\n            else:\n                counts_by_divisor[divisor] = 1\n    k_values = [divisor for divisor in counts_by_divisor if counts_by_divisor[divisor] == len(groups)]\n    return sorted(k_values)\n\ndef get_divisors(value):\n    m = int(math.ceil(math.sqrt(value)))\n    for d in range(1, m + 1):\n        if value % d == 0:\n            e = value // d\n            if d < e:\n                yield d\n                yield e\n            elif d == e:\n                yield d"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "groups = [counts[i] for i in range(32) if counts[i] > 0]",
      "mutated_line": "groups = [counts[i] for i in range(-32) if counts[i] > 0]",
      "code": "import math\n\ndef find_possible_k_values(n, a):\n    counts = {i: 0 for i in range(32)}\n    for ai in a:\n        bin_ai = '{:032b}'.format(ai)\n        for i in range(32):\n            if bin_ai[i] == '1':\n                counts[i] += 1\n    groups = [counts[i] for i in range(-32) if counts[i] > 0]\n    if not groups:\n        return list(range(1, n + 1))\n    counts_by_divisor = {}\n    for group_size in groups:\n        for divisor in get_divisors(group_size):\n            if divisor in counts_by_divisor:\n                counts_by_divisor[divisor] += 1\n            else:\n                counts_by_divisor[divisor] = 1\n    k_values = [divisor for divisor in counts_by_divisor if counts_by_divisor[divisor] == len(groups)]\n    return sorted(k_values)\n\ndef get_divisors(value):\n    m = int(math.ceil(math.sqrt(value)))\n    for d in range(1, m + 1):\n        if value % d == 0:\n            e = value // d\n            if d < e:\n                yield d\n                yield e\n            elif d == e:\n                yield d"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "groups = [counts[i] for i in range(32) if counts[i] > 0]",
      "mutated_line": "groups = [counts[i] for i in range(32) if counts[i] > 1]",
      "code": "import math\n\ndef find_possible_k_values(n, a):\n    counts = {i: 0 for i in range(32)}\n    for ai in a:\n        bin_ai = '{:032b}'.format(ai)\n        for i in range(32):\n            if bin_ai[i] == '1':\n                counts[i] += 1\n    groups = [counts[i] for i in range(32) if counts[i] > 1]\n    if not groups:\n        return list(range(1, n + 1))\n    counts_by_divisor = {}\n    for group_size in groups:\n        for divisor in get_divisors(group_size):\n            if divisor in counts_by_divisor:\n                counts_by_divisor[divisor] += 1\n            else:\n                counts_by_divisor[divisor] = 1\n    k_values = [divisor for divisor in counts_by_divisor if counts_by_divisor[divisor] == len(groups)]\n    return sorted(k_values)\n\ndef get_divisors(value):\n    m = int(math.ceil(math.sqrt(value)))\n    for d in range(1, m + 1):\n        if value % d == 0:\n            e = value // d\n            if d < e:\n                yield d\n                yield e\n            elif d == e:\n                yield d"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "groups = [counts[i] for i in range(32) if counts[i] > 0]",
      "mutated_line": "groups = [counts[i] for i in range(32) if counts[i] > -1]",
      "code": "import math\n\ndef find_possible_k_values(n, a):\n    counts = {i: 0 for i in range(32)}\n    for ai in a:\n        bin_ai = '{:032b}'.format(ai)\n        for i in range(32):\n            if bin_ai[i] == '1':\n                counts[i] += 1\n    groups = [counts[i] for i in range(32) if counts[i] > -1]\n    if not groups:\n        return list(range(1, n + 1))\n    counts_by_divisor = {}\n    for group_size in groups:\n        for divisor in get_divisors(group_size):\n            if divisor in counts_by_divisor:\n                counts_by_divisor[divisor] += 1\n            else:\n                counts_by_divisor[divisor] = 1\n    k_values = [divisor for divisor in counts_by_divisor if counts_by_divisor[divisor] == len(groups)]\n    return sorted(k_values)\n\ndef get_divisors(value):\n    m = int(math.ceil(math.sqrt(value)))\n    for d in range(1, m + 1):\n        if value % d == 0:\n            e = value // d\n            if d < e:\n                yield d\n                yield e\n            elif d == e:\n                yield d"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "groups = [counts[i] for i in range(32) if counts[i] > 0]",
      "mutated_line": "groups = [counts[i] for i in range(32) if counts[i] > 1]",
      "code": "import math\n\ndef find_possible_k_values(n, a):\n    counts = {i: 0 for i in range(32)}\n    for ai in a:\n        bin_ai = '{:032b}'.format(ai)\n        for i in range(32):\n            if bin_ai[i] == '1':\n                counts[i] += 1\n    groups = [counts[i] for i in range(32) if counts[i] > 1]\n    if not groups:\n        return list(range(1, n + 1))\n    counts_by_divisor = {}\n    for group_size in groups:\n        for divisor in get_divisors(group_size):\n            if divisor in counts_by_divisor:\n                counts_by_divisor[divisor] += 1\n            else:\n                counts_by_divisor[divisor] = 1\n    k_values = [divisor for divisor in counts_by_divisor if counts_by_divisor[divisor] == len(groups)]\n    return sorted(k_values)\n\ndef get_divisors(value):\n    m = int(math.ceil(math.sqrt(value)))\n    for d in range(1, m + 1):\n        if value % d == 0:\n            e = value // d\n            if d < e:\n                yield d\n                yield e\n            elif d == e:\n                yield d"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return list(range(1, n + 1))",
      "mutated_line": "return list(range(2, n + 1))",
      "code": "import math\n\ndef find_possible_k_values(n, a):\n    counts = {i: 0 for i in range(32)}\n    for ai in a:\n        bin_ai = '{:032b}'.format(ai)\n        for i in range(32):\n            if bin_ai[i] == '1':\n                counts[i] += 1\n    groups = [counts[i] for i in range(32) if counts[i] > 0]\n    if not groups:\n        return list(range(2, n + 1))\n    counts_by_divisor = {}\n    for group_size in groups:\n        for divisor in get_divisors(group_size):\n            if divisor in counts_by_divisor:\n                counts_by_divisor[divisor] += 1\n            else:\n                counts_by_divisor[divisor] = 1\n    k_values = [divisor for divisor in counts_by_divisor if counts_by_divisor[divisor] == len(groups)]\n    return sorted(k_values)\n\ndef get_divisors(value):\n    m = int(math.ceil(math.sqrt(value)))\n    for d in range(1, m + 1):\n        if value % d == 0:\n            e = value // d\n            if d < e:\n                yield d\n                yield e\n            elif d == e:\n                yield d"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return list(range(1, n + 1))",
      "mutated_line": "return list(range(0, n + 1))",
      "code": "import math\n\ndef find_possible_k_values(n, a):\n    counts = {i: 0 for i in range(32)}\n    for ai in a:\n        bin_ai = '{:032b}'.format(ai)\n        for i in range(32):\n            if bin_ai[i] == '1':\n                counts[i] += 1\n    groups = [counts[i] for i in range(32) if counts[i] > 0]\n    if not groups:\n        return list(range(0, n + 1))\n    counts_by_divisor = {}\n    for group_size in groups:\n        for divisor in get_divisors(group_size):\n            if divisor in counts_by_divisor:\n                counts_by_divisor[divisor] += 1\n            else:\n                counts_by_divisor[divisor] = 1\n    k_values = [divisor for divisor in counts_by_divisor if counts_by_divisor[divisor] == len(groups)]\n    return sorted(k_values)\n\ndef get_divisors(value):\n    m = int(math.ceil(math.sqrt(value)))\n    for d in range(1, m + 1):\n        if value % d == 0:\n            e = value // d\n            if d < e:\n                yield d\n                yield e\n            elif d == e:\n                yield d"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return list(range(1, n + 1))",
      "mutated_line": "return list(range(0, n + 1))",
      "code": "import math\n\ndef find_possible_k_values(n, a):\n    counts = {i: 0 for i in range(32)}\n    for ai in a:\n        bin_ai = '{:032b}'.format(ai)\n        for i in range(32):\n            if bin_ai[i] == '1':\n                counts[i] += 1\n    groups = [counts[i] for i in range(32) if counts[i] > 0]\n    if not groups:\n        return list(range(0, n + 1))\n    counts_by_divisor = {}\n    for group_size in groups:\n        for divisor in get_divisors(group_size):\n            if divisor in counts_by_divisor:\n                counts_by_divisor[divisor] += 1\n            else:\n                counts_by_divisor[divisor] = 1\n    k_values = [divisor for divisor in counts_by_divisor if counts_by_divisor[divisor] == len(groups)]\n    return sorted(k_values)\n\ndef get_divisors(value):\n    m = int(math.ceil(math.sqrt(value)))\n    for d in range(1, m + 1):\n        if value % d == 0:\n            e = value // d\n            if d < e:\n                yield d\n                yield e\n            elif d == e:\n                yield d"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return list(range(1, n + 1))",
      "mutated_line": "return list(range(-1, n + 1))",
      "code": "import math\n\ndef find_possible_k_values(n, a):\n    counts = {i: 0 for i in range(32)}\n    for ai in a:\n        bin_ai = '{:032b}'.format(ai)\n        for i in range(32):\n            if bin_ai[i] == '1':\n                counts[i] += 1\n    groups = [counts[i] for i in range(32) if counts[i] > 0]\n    if not groups:\n        return list(range(-1, n + 1))\n    counts_by_divisor = {}\n    for group_size in groups:\n        for divisor in get_divisors(group_size):\n            if divisor in counts_by_divisor:\n                counts_by_divisor[divisor] += 1\n            else:\n                counts_by_divisor[divisor] = 1\n    k_values = [divisor for divisor in counts_by_divisor if counts_by_divisor[divisor] == len(groups)]\n    return sorted(k_values)\n\ndef get_divisors(value):\n    m = int(math.ceil(math.sqrt(value)))\n    for d in range(1, m + 1):\n        if value % d == 0:\n            e = value // d\n            if d < e:\n                yield d\n                yield e\n            elif d == e:\n                yield d"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return list(range(1, n + 1))",
      "mutated_line": "return list(range(1, n - 1))",
      "code": "import math\n\ndef find_possible_k_values(n, a):\n    counts = {i: 0 for i in range(32)}\n    for ai in a:\n        bin_ai = '{:032b}'.format(ai)\n        for i in range(32):\n            if bin_ai[i] == '1':\n                counts[i] += 1\n    groups = [counts[i] for i in range(32) if counts[i] > 0]\n    if not groups:\n        return list(range(1, n - 1))\n    counts_by_divisor = {}\n    for group_size in groups:\n        for divisor in get_divisors(group_size):\n            if divisor in counts_by_divisor:\n                counts_by_divisor[divisor] += 1\n            else:\n                counts_by_divisor[divisor] = 1\n    k_values = [divisor for divisor in counts_by_divisor if counts_by_divisor[divisor] == len(groups)]\n    return sorted(k_values)\n\ndef get_divisors(value):\n    m = int(math.ceil(math.sqrt(value)))\n    for d in range(1, m + 1):\n        if value % d == 0:\n            e = value // d\n            if d < e:\n                yield d\n                yield e\n            elif d == e:\n                yield d"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return list(range(1, n + 1))",
      "mutated_line": "return list(range(1, n * 1))",
      "code": "import math\n\ndef find_possible_k_values(n, a):\n    counts = {i: 0 for i in range(32)}\n    for ai in a:\n        bin_ai = '{:032b}'.format(ai)\n        for i in range(32):\n            if bin_ai[i] == '1':\n                counts[i] += 1\n    groups = [counts[i] for i in range(32) if counts[i] > 0]\n    if not groups:\n        return list(range(1, n * 1))\n    counts_by_divisor = {}\n    for group_size in groups:\n        for divisor in get_divisors(group_size):\n            if divisor in counts_by_divisor:\n                counts_by_divisor[divisor] += 1\n            else:\n                counts_by_divisor[divisor] = 1\n    k_values = [divisor for divisor in counts_by_divisor if counts_by_divisor[divisor] == len(groups)]\n    return sorted(k_values)\n\ndef get_divisors(value):\n    m = int(math.ceil(math.sqrt(value)))\n    for d in range(1, m + 1):\n        if value % d == 0:\n            e = value // d\n            if d < e:\n                yield d\n                yield e\n            elif d == e:\n                yield d"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "counts_by_divisor[divisor] += 1",
      "mutated_line": "counts_by_divisor[divisor] += 2",
      "code": "import math\n\ndef find_possible_k_values(n, a):\n    counts = {i: 0 for i in range(32)}\n    for ai in a:\n        bin_ai = '{:032b}'.format(ai)\n        for i in range(32):\n            if bin_ai[i] == '1':\n                counts[i] += 1\n    groups = [counts[i] for i in range(32) if counts[i] > 0]\n    if not groups:\n        return list(range(1, n + 1))\n    counts_by_divisor = {}\n    for group_size in groups:\n        for divisor in get_divisors(group_size):\n            if divisor in counts_by_divisor:\n                counts_by_divisor[divisor] += 2\n            else:\n                counts_by_divisor[divisor] = 1\n    k_values = [divisor for divisor in counts_by_divisor if counts_by_divisor[divisor] == len(groups)]\n    return sorted(k_values)\n\ndef get_divisors(value):\n    m = int(math.ceil(math.sqrt(value)))\n    for d in range(1, m + 1):\n        if value % d == 0:\n            e = value // d\n            if d < e:\n                yield d\n                yield e\n            elif d == e:\n                yield d"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "counts_by_divisor[divisor] += 1",
      "mutated_line": "counts_by_divisor[divisor] += 0",
      "code": "import math\n\ndef find_possible_k_values(n, a):\n    counts = {i: 0 for i in range(32)}\n    for ai in a:\n        bin_ai = '{:032b}'.format(ai)\n        for i in range(32):\n            if bin_ai[i] == '1':\n                counts[i] += 1\n    groups = [counts[i] for i in range(32) if counts[i] > 0]\n    if not groups:\n        return list(range(1, n + 1))\n    counts_by_divisor = {}\n    for group_size in groups:\n        for divisor in get_divisors(group_size):\n            if divisor in counts_by_divisor:\n                counts_by_divisor[divisor] += 0\n            else:\n                counts_by_divisor[divisor] = 1\n    k_values = [divisor for divisor in counts_by_divisor if counts_by_divisor[divisor] == len(groups)]\n    return sorted(k_values)\n\ndef get_divisors(value):\n    m = int(math.ceil(math.sqrt(value)))\n    for d in range(1, m + 1):\n        if value % d == 0:\n            e = value // d\n            if d < e:\n                yield d\n                yield e\n            elif d == e:\n                yield d"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "counts_by_divisor[divisor] += 1",
      "mutated_line": "counts_by_divisor[divisor] += 0",
      "code": "import math\n\ndef find_possible_k_values(n, a):\n    counts = {i: 0 for i in range(32)}\n    for ai in a:\n        bin_ai = '{:032b}'.format(ai)\n        for i in range(32):\n            if bin_ai[i] == '1':\n                counts[i] += 1\n    groups = [counts[i] for i in range(32) if counts[i] > 0]\n    if not groups:\n        return list(range(1, n + 1))\n    counts_by_divisor = {}\n    for group_size in groups:\n        for divisor in get_divisors(group_size):\n            if divisor in counts_by_divisor:\n                counts_by_divisor[divisor] += 0\n            else:\n                counts_by_divisor[divisor] = 1\n    k_values = [divisor for divisor in counts_by_divisor if counts_by_divisor[divisor] == len(groups)]\n    return sorted(k_values)\n\ndef get_divisors(value):\n    m = int(math.ceil(math.sqrt(value)))\n    for d in range(1, m + 1):\n        if value % d == 0:\n            e = value // d\n            if d < e:\n                yield d\n                yield e\n            elif d == e:\n                yield d"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "counts_by_divisor[divisor] += 1",
      "mutated_line": "counts_by_divisor[divisor] += -1",
      "code": "import math\n\ndef find_possible_k_values(n, a):\n    counts = {i: 0 for i in range(32)}\n    for ai in a:\n        bin_ai = '{:032b}'.format(ai)\n        for i in range(32):\n            if bin_ai[i] == '1':\n                counts[i] += 1\n    groups = [counts[i] for i in range(32) if counts[i] > 0]\n    if not groups:\n        return list(range(1, n + 1))\n    counts_by_divisor = {}\n    for group_size in groups:\n        for divisor in get_divisors(group_size):\n            if divisor in counts_by_divisor:\n                counts_by_divisor[divisor] += -1\n            else:\n                counts_by_divisor[divisor] = 1\n    k_values = [divisor for divisor in counts_by_divisor if counts_by_divisor[divisor] == len(groups)]\n    return sorted(k_values)\n\ndef get_divisors(value):\n    m = int(math.ceil(math.sqrt(value)))\n    for d in range(1, m + 1):\n        if value % d == 0:\n            e = value // d\n            if d < e:\n                yield d\n                yield e\n            elif d == e:\n                yield d"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "counts_by_divisor[divisor] = 1",
      "mutated_line": "counts_by_divisor[divisor] = 2",
      "code": "import math\n\ndef find_possible_k_values(n, a):\n    counts = {i: 0 for i in range(32)}\n    for ai in a:\n        bin_ai = '{:032b}'.format(ai)\n        for i in range(32):\n            if bin_ai[i] == '1':\n                counts[i] += 1\n    groups = [counts[i] for i in range(32) if counts[i] > 0]\n    if not groups:\n        return list(range(1, n + 1))\n    counts_by_divisor = {}\n    for group_size in groups:\n        for divisor in get_divisors(group_size):\n            if divisor in counts_by_divisor:\n                counts_by_divisor[divisor] += 1\n            else:\n                counts_by_divisor[divisor] = 2\n    k_values = [divisor for divisor in counts_by_divisor if counts_by_divisor[divisor] == len(groups)]\n    return sorted(k_values)\n\ndef get_divisors(value):\n    m = int(math.ceil(math.sqrt(value)))\n    for d in range(1, m + 1):\n        if value % d == 0:\n            e = value // d\n            if d < e:\n                yield d\n                yield e\n            elif d == e:\n                yield d"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "counts_by_divisor[divisor] = 1",
      "mutated_line": "counts_by_divisor[divisor] = 0",
      "code": "import math\n\ndef find_possible_k_values(n, a):\n    counts = {i: 0 for i in range(32)}\n    for ai in a:\n        bin_ai = '{:032b}'.format(ai)\n        for i in range(32):\n            if bin_ai[i] == '1':\n                counts[i] += 1\n    groups = [counts[i] for i in range(32) if counts[i] > 0]\n    if not groups:\n        return list(range(1, n + 1))\n    counts_by_divisor = {}\n    for group_size in groups:\n        for divisor in get_divisors(group_size):\n            if divisor in counts_by_divisor:\n                counts_by_divisor[divisor] += 1\n            else:\n                counts_by_divisor[divisor] = 0\n    k_values = [divisor for divisor in counts_by_divisor if counts_by_divisor[divisor] == len(groups)]\n    return sorted(k_values)\n\ndef get_divisors(value):\n    m = int(math.ceil(math.sqrt(value)))\n    for d in range(1, m + 1):\n        if value % d == 0:\n            e = value // d\n            if d < e:\n                yield d\n                yield e\n            elif d == e:\n                yield d"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "counts_by_divisor[divisor] = 1",
      "mutated_line": "counts_by_divisor[divisor] = 0",
      "code": "import math\n\ndef find_possible_k_values(n, a):\n    counts = {i: 0 for i in range(32)}\n    for ai in a:\n        bin_ai = '{:032b}'.format(ai)\n        for i in range(32):\n            if bin_ai[i] == '1':\n                counts[i] += 1\n    groups = [counts[i] for i in range(32) if counts[i] > 0]\n    if not groups:\n        return list(range(1, n + 1))\n    counts_by_divisor = {}\n    for group_size in groups:\n        for divisor in get_divisors(group_size):\n            if divisor in counts_by_divisor:\n                counts_by_divisor[divisor] += 1\n            else:\n                counts_by_divisor[divisor] = 0\n    k_values = [divisor for divisor in counts_by_divisor if counts_by_divisor[divisor] == len(groups)]\n    return sorted(k_values)\n\ndef get_divisors(value):\n    m = int(math.ceil(math.sqrt(value)))\n    for d in range(1, m + 1):\n        if value % d == 0:\n            e = value // d\n            if d < e:\n                yield d\n                yield e\n            elif d == e:\n                yield d"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "counts_by_divisor[divisor] = 1",
      "mutated_line": "counts_by_divisor[divisor] = -1",
      "code": "import math\n\ndef find_possible_k_values(n, a):\n    counts = {i: 0 for i in range(32)}\n    for ai in a:\n        bin_ai = '{:032b}'.format(ai)\n        for i in range(32):\n            if bin_ai[i] == '1':\n                counts[i] += 1\n    groups = [counts[i] for i in range(32) if counts[i] > 0]\n    if not groups:\n        return list(range(1, n + 1))\n    counts_by_divisor = {}\n    for group_size in groups:\n        for divisor in get_divisors(group_size):\n            if divisor in counts_by_divisor:\n                counts_by_divisor[divisor] += 1\n            else:\n                counts_by_divisor[divisor] = -1\n    k_values = [divisor for divisor in counts_by_divisor if counts_by_divisor[divisor] == len(groups)]\n    return sorted(k_values)\n\ndef get_divisors(value):\n    m = int(math.ceil(math.sqrt(value)))\n    for d in range(1, m + 1):\n        if value % d == 0:\n            e = value // d\n            if d < e:\n                yield d\n                yield e\n            elif d == e:\n                yield d"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "elif d == e:",
      "mutated_line": "elif d != e:",
      "code": "import math\n\ndef find_possible_k_values(n, a):\n    counts = {i: 0 for i in range(32)}\n    for ai in a:\n        bin_ai = '{:032b}'.format(ai)\n        for i in range(32):\n            if bin_ai[i] == '1':\n                counts[i] += 1\n    groups = [counts[i] for i in range(32) if counts[i] > 0]\n    if not groups:\n        return list(range(1, n + 1))\n    counts_by_divisor = {}\n    for group_size in groups:\n        for divisor in get_divisors(group_size):\n            if divisor in counts_by_divisor:\n                counts_by_divisor[divisor] += 1\n            else:\n                counts_by_divisor[divisor] = 1\n    k_values = [divisor for divisor in counts_by_divisor if counts_by_divisor[divisor] == len(groups)]\n    return sorted(k_values)\n\ndef get_divisors(value):\n    m = int(math.ceil(math.sqrt(value)))\n    for d in range(1, m + 1):\n        if value % d == 0:\n            e = value // d\n            if d < e:\n                yield d\n                yield e\n            elif d != e:\n                yield d"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return list(range(1, n + 1))",
      "mutated_line": "return list(range(1, n + 2))",
      "code": "import math\n\ndef find_possible_k_values(n, a):\n    counts = {i: 0 for i in range(32)}\n    for ai in a:\n        bin_ai = '{:032b}'.format(ai)\n        for i in range(32):\n            if bin_ai[i] == '1':\n                counts[i] += 1\n    groups = [counts[i] for i in range(32) if counts[i] > 0]\n    if not groups:\n        return list(range(1, n + 2))\n    counts_by_divisor = {}\n    for group_size in groups:\n        for divisor in get_divisors(group_size):\n            if divisor in counts_by_divisor:\n                counts_by_divisor[divisor] += 1\n            else:\n                counts_by_divisor[divisor] = 1\n    k_values = [divisor for divisor in counts_by_divisor if counts_by_divisor[divisor] == len(groups)]\n    return sorted(k_values)\n\ndef get_divisors(value):\n    m = int(math.ceil(math.sqrt(value)))\n    for d in range(1, m + 1):\n        if value % d == 0:\n            e = value // d\n            if d < e:\n                yield d\n                yield e\n            elif d == e:\n                yield d"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return list(range(1, n + 1))",
      "mutated_line": "return list(range(1, n + 0))",
      "code": "import math\n\ndef find_possible_k_values(n, a):\n    counts = {i: 0 for i in range(32)}\n    for ai in a:\n        bin_ai = '{:032b}'.format(ai)\n        for i in range(32):\n            if bin_ai[i] == '1':\n                counts[i] += 1\n    groups = [counts[i] for i in range(32) if counts[i] > 0]\n    if not groups:\n        return list(range(1, n + 0))\n    counts_by_divisor = {}\n    for group_size in groups:\n        for divisor in get_divisors(group_size):\n            if divisor in counts_by_divisor:\n                counts_by_divisor[divisor] += 1\n            else:\n                counts_by_divisor[divisor] = 1\n    k_values = [divisor for divisor in counts_by_divisor if counts_by_divisor[divisor] == len(groups)]\n    return sorted(k_values)\n\ndef get_divisors(value):\n    m = int(math.ceil(math.sqrt(value)))\n    for d in range(1, m + 1):\n        if value % d == 0:\n            e = value // d\n            if d < e:\n                yield d\n                yield e\n            elif d == e:\n                yield d"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return list(range(1, n + 1))",
      "mutated_line": "return list(range(1, n + 0))",
      "code": "import math\n\ndef find_possible_k_values(n, a):\n    counts = {i: 0 for i in range(32)}\n    for ai in a:\n        bin_ai = '{:032b}'.format(ai)\n        for i in range(32):\n            if bin_ai[i] == '1':\n                counts[i] += 1\n    groups = [counts[i] for i in range(32) if counts[i] > 0]\n    if not groups:\n        return list(range(1, n + 0))\n    counts_by_divisor = {}\n    for group_size in groups:\n        for divisor in get_divisors(group_size):\n            if divisor in counts_by_divisor:\n                counts_by_divisor[divisor] += 1\n            else:\n                counts_by_divisor[divisor] = 1\n    k_values = [divisor for divisor in counts_by_divisor if counts_by_divisor[divisor] == len(groups)]\n    return sorted(k_values)\n\ndef get_divisors(value):\n    m = int(math.ceil(math.sqrt(value)))\n    for d in range(1, m + 1):\n        if value % d == 0:\n            e = value // d\n            if d < e:\n                yield d\n                yield e\n            elif d == e:\n                yield d"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return list(range(1, n + 1))",
      "mutated_line": "return list(range(1, n + -1))",
      "code": "import math\n\ndef find_possible_k_values(n, a):\n    counts = {i: 0 for i in range(32)}\n    for ai in a:\n        bin_ai = '{:032b}'.format(ai)\n        for i in range(32):\n            if bin_ai[i] == '1':\n                counts[i] += 1\n    groups = [counts[i] for i in range(32) if counts[i] > 0]\n    if not groups:\n        return list(range(1, n + -1))\n    counts_by_divisor = {}\n    for group_size in groups:\n        for divisor in get_divisors(group_size):\n            if divisor in counts_by_divisor:\n                counts_by_divisor[divisor] += 1\n            else:\n                counts_by_divisor[divisor] = 1\n    k_values = [divisor for divisor in counts_by_divisor if counts_by_divisor[divisor] == len(groups)]\n    return sorted(k_values)\n\ndef get_divisors(value):\n    m = int(math.ceil(math.sqrt(value)))\n    for d in range(1, m + 1):\n        if value % d == 0:\n            e = value // d\n            if d < e:\n                yield d\n                yield e\n            elif d == e:\n                yield d"
    }
  ]
}